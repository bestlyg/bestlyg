---
title: 676. 实现一个魔法字典
order: 676
nav:
  title: 力扣题解
  path: /leetcode
  order: 4
group:
  title: 601-700
  path: /601-700
  order: 601
---

# 676. 实现一个魔法字典

> 链接：[676. 实现一个魔法字典](https://leetcode-cn.com/problems/implement-magic-dictionary/)  
> 难度：中等  
> 标签：设计、字典树、哈希表、字符串  
> 简介：设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。

## 题解 1 - typescript

- 编辑时间：2021.11.05
- 执行用时：132ms
- 内存消耗：45.9MB
- 编程语言：typescript
- 解法介绍：trie。

```typescript
const getIdx = (ch: string) => ch.codePointAt(0)! - 'a'.codePointAt(0)!;
class TrieNode {
  end = false;
  children: TrieNode[] = [];
  constructor(public val: string) {}
}
class Trie {
  root = new TrieNode('');
  insert(word: string): void {
    let node = this.root;
    for (const ch of word) {
      const idx = getIdx(ch);
      if (!node.children[idx]) node.children[idx] = new TrieNode(ch);
      node = node.children[idx];
    }
    node.end = true;
  }
  search(word: string): boolean {
    return this._search(word);
  }
  _search(word: string, node = this.root, idx = 0, err = 1): boolean {
    if (idx === word.length) return node.end && err === 0;
    const ch = word[idx];
    const chIdx = getIdx(ch);
    if (node.children[chIdx] && this._search(word, node.children[chIdx], idx + 1, err)) return true;
    if (err === 0) return false;
    for (const child of node.children) {
      if (child === node.children[chIdx]) continue;
      if (this._search(word, child, idx + 1, err - 1)) return true;
    }
    return false;
  }
}

class MagicDictionary {
  trie = new Trie();
  buildDict(dictionary: string[]): void {
    dictionary.forEach(word => this.trie.insert(word));
  }
  search(searchWord: string): boolean {
    return this.trie.search(searchWord);
  }
}
```
## 题解 2 - cpp
- 编辑时间：2022.07.11
- 执行用时：712ms
- 内存消耗：101.6MB
- 编程语言：cpp
- 解法介绍：trie, 对于每种可能出现1个替换，进行递归考虑。
```cpp
#define CHILD_SIZE 26
class TrieNode {
   public:
    int key;
    bool end;
    TrieNode **children;
    TrieNode(int key) {
        this->key = key;
        this->end = false;
        this->children = (TrieNode **)malloc(sizeof(TrieNode *) * CHILD_SIZE);
        for (int i = 0; i < CHILD_SIZE; i++) children[i] = nullptr;
    }
};
class Trie {
   public:
    TrieNode *root;
    Trie() { this->root = new TrieNode(0); }
    void insert(string words) {
        TrieNode *node = root;
        for (auto &w : words) {
            if (node->children[w - 'a'] == nullptr)
                node->children[w - 'a'] = new TrieNode(w);
            node = node->children[w - 'a'];
        }
        node->end = true;
    }
    bool search(string words) { return _search(words, 0, root, 0); }
    bool _search(string &words, int idx, TrieNode *node, int replaceCnt) {
        int w = words[idx];
        if (idx == words.size() - 1) {
            if (replaceCnt > 1)
                return false;
            else if (replaceCnt == 1)
                return node->children[w - 'a'] != nullptr &&
                       node->children[w - 'a']->end;
            else {
                for (int i = 0; i < CHILD_SIZE; i++) {
                    if (node->children[i] == nullptr || w - 'a' == i) continue;
                    if (node->children[i]->end) return true;
                }
            }
            return false;
        }
        int nextw = words[idx + 1];
        for (int i = 0; i < CHILD_SIZE; i++) {
            if (node->children[i] == nullptr) continue;
            if (w - 'a' == i &&
                _search(words, idx + 1, node->children[i], replaceCnt))
                return true;
            if (w - 'a' != i &&
                _search(words, idx + 1, node->children[i], replaceCnt + 1))
                return true;
        }
        return false;
    }
};

class MagicDictionary {
   public:
    Trie *trie;
    MagicDictionary() { trie = new Trie(); }
    void buildDict(vector<string> dictionary) {
        for (auto &words : dictionary) trie->insert(words);
    }
    bool search(string searchWord) { return trie->search(searchWord); }
};

```
