# 队列(Queue)

特殊线性表，就有先进先出的特性，一般使用一个数组实现。

## 常用队列

- 普通队列
  - 尾部进，头部出
- 双端队列(Deque)
  - 可在尾部进，头部出
  - 可在头部进，尾部出
- 循环队列
  - 由于数组一般初始化时会固定长度，当使用完后，存在前在的多个下标所对应的值为空
  - 利用取余进行循环利用空间
- 循环双端队列
  - 具有循环队列和双端队列的性质

## 类型定义

```ts
import { StructConstructor, IStruct, AbstractStruct } from '@/types';
import { hashCode, formatToString, commonToString, ErrorEnum, throwError } from '@/utils';

export interface IQueueConstructor<T> extends StructConstructor {
  new (capacity: number): IQueue<T>;
  readonly [Symbol.species]: IQueueConstructor<T>;
  readonly prototype: IQueue<T>;
  of<T>(...datas: T[]): IQueue<T>;
  from<T>(datas: T[]): IQueue<T>;
}
/**
 * 队列，
 * 先进先出
 */
export interface IQueue<T> extends IStruct {
  /**
   * 队列容量
   */
  capacity: number;
  /**
   * 获取对头元素
   */
  front: T;
  /**
   * 在队尾入队
   * @param element 元素
   */
  enQueue(element: T): void;
  /**
   * 在对头出队
   */
  deQueue(): T;
  [Symbol.iterator](): IterableIterator<T>;
  entries(): IterableIterator<[number, T]>;
  keys(): IterableIterator<number>;
  values(): IterableIterator<T>;
}
/**
 * 队列抽象类
 */
export abstract class AbstractQueue<T> extends AbstractStruct implements IQueue<T> {
  protected _list: T[] = [];
  abstract enQueue(element: T): void;
  abstract deQueue(): T;
  get size(): number {
    return this._list.length;
  }
  get capacity(): number {
    return this._capacity;
  }
  get hash(): number {
    let res = 0;
    for (const el of this) res += hashCode(el);
    return res;
  }
  get front(): T {
    this.empty && this.structError();
    return this._list[0];
  }
  constructor(private _capacity: number) {
    super();
    this._capacity <= 0 && this.capacityError();
  }
  clear(): void {
    this._list.length = 0;
    super.clear();
  }
  *[Symbol.iterator](): IterableIterator<T> {
    for (const v of this.values()) yield v;
  }
  *keys(): IterableIterator<number> {
    for (const [k] of this.entries()) yield k;
  }
  *values(): IterableIterator<T> {
    for (const [, v] of this.entries()) yield v;
  }
  *entries(): IterableIterator<[number, T]> {
    for (let i = 0; i < this.size; i++) yield [i, this._list[i]];
  }
  toString(): string {
    let s = formatToString(
      this[Symbol.toStringTag],
      ['Capacity', this._capacity],
      ['Size', this.size]
    );
    if (this.size !== 0) {
      s += ',Elements=[';
      for (const val of this) s += commonToString(val) + ',';
      s = s.substr(0, s.length - 1) + ']';
    }
    return s;
  }
  protected checkEnQueue(): void {
    if (this.size >= this._capacity) this.structError();
  }
  protected checkDeQueue(): void {
    if (this.size <= 0) this.structError();
  }
  protected structError(): never {
    this.thorwError(
      formatToString(this[Symbol.toStringTag], ['Capacity', this._capacity], ['Size', this._size])
    );
  }
  protected capacityError(): never {
    this.thorwError(`capacity must greater than 0`);
  }
  /**
   * 抛出越界异常
   * @param index 下标
   */
  protected thorwError(s: string): never {
    return throwError(s, ErrorEnum.range);
  }
}
```

## 实现

```ts
/**
 * 队列构造器
 */
export interface QueueConstructor<T> extends IQueueConstructor<T> {
  new (size: number): Queue<T>;
  readonly [Symbol.species]: QueueConstructor<T>;
  readonly prototype: Queue<T>;
  isQueue<T>(obj: unknown): obj is Queue<T>;
  of<T>(...datas: T[]): Queue<T>;
  from<T>(datas: T[]): Queue<T>;
}
/**
 * 判断是否是队列
 * @param obj 任意对象
 */
export function isQueue<T>(obj: unknown): obj is Queue<T> {
  return obj instanceof Queue;
}
/**
 * 队列
 */
export class Queue<T> extends AbstractQueue<T> {
  static [Symbol.hasInstance](instance): boolean {
    return objectToString(instance) === objectToStringFormat(QUEUE);
  }
  static from<T>(datas: T[]): Queue<T> {
    const queue: Queue<T> = new Queue<T>(datas.length);
    for (const data of datas) queue.enQueue(data);
    return queue;
  }
  static of<T>(...datas: T[]): Queue<T> {
    return this.from(datas);
  }
  static isQueue<T>(obj: unknown): obj is Queue<T> {
    return isQueue(obj);
  }
  static get [Symbol.species](): QueueConstructor<any> {
    return Queue;
  }
  [Symbol.toStringTag] = QUEUE;
  constructor(capacity: number) {
    super(capacity);
  }
  enQueue(element: T): void {
    this.checkEnQueue();
    this._list.push(element);
  }
  deQueue(): T {
    this.checkDeQueue();
    return this._list.shift() as T;
  }
}
```
