{
    "id": "2603",
    "name": "2512.奖励最顶尖的K名学生",
    "url": "https://leetcode.cn/problems/reward-top-k-students",
    "difficulty": "中等",
    "tag": [
        "数组",
        "哈希表",
        "字符串",
        "排序",
        "堆（优先队列）"
    ],
    "desc": "给你一个整数 k ，请你返回按照得分 从高到低 最顶尖的 k 名学生。",
    "solutions": [
        {
            "script": "cpp",
            "time": 264,
            "memory": 54.2,
            "desc": "哈希后排序。",
            "code": "class Solution {\npublic:\n    vector<int> topStudents(vector<string>& positive_feedback, vector<string>& negative_feedback, vector<string>& report, vector<int>& student_id, int k) {\n        unordered_set<string> pset(positive_feedback.begin(), positive_feedback.end()), nset(negative_feedback.begin(), negative_feedback.end());\n        int n = report.size();\n        vector<int> arr;\n        for (int i = 0; i < n; i++) {\n            istringstream iss(report[i]);\n            string tmp;\n            int res = 0;\n            while (getline(iss, tmp, ' ')) {\n                if (pset.count(tmp)) res += 3;\n                else if (nset.count(tmp)) res -= 1;\n            }\n            arr.push_back(res);\n        }\n        vector<int> idxs;\n        for (int i = 0; i < n; i++) idxs.push_back(i);\n        sort(idxs.begin(), idxs.end(), [&](auto &a, auto &b) {\n            if (arr[a] != arr[b]) return arr[b] < arr[a];\n            return student_id[a] < student_id[b];\n        });\n        vector<int> res;\n        for (int i = 0; i < k; i++) res.push_back(student_id[idxs[i]]);\n        return res;\n    }\n};",
            "date": 1696953600000
        },
        {
            "script": "python",
            "time": 172,
            "memory": 23.4,
            "desc": "同上。",
            "code": "class Solution:\n    def topStudents(self, positive_feedback: List[str], negative_feedback: List[str], report: List[str], student_id: List[int], k: int) -> List[int]:\n        pset = set(positive_feedback)\n        nset = set(negative_feedback)\n        n = len(report)\n        arr = [sum(3 if s in pset else -1 for s in filter(lambda o: o in pset or o in nset, report[i].split(' '))) for i in range(n)]\n        idxs = [i for i in range(n)]\n        idxs.sort(key = lambda i: (arr[i], -student_id[i]), reverse = True)\n        return [student_id[i] for i in idxs[:k]]",
            "date": 1696953600000
        },
        {
            "script": "rust",
            "time": 48,
            "memory": 5.72,
            "desc": "同上。",
            "code": "impl Solution {\n    pub fn top_students(\n        positive_feedback: Vec<String>,\n        negative_feedback: Vec<String>,\n        report: Vec<String>,\n        student_id: Vec<i32>,\n        k: i32,\n    ) -> Vec<i32> {\n        use std::collections::HashSet;\n        use std::cmp::Ordering;\n        let pset = positive_feedback.into_iter().collect::<HashSet<_>>();\n        let nset = negative_feedback.into_iter().collect::<HashSet<_>>();\n        let n = report.len();\n        let arr = (0..n)\n            .map(|i| {\n                report[i]\n                    .split(' ')\n                    .map(|s| {\n                        if pset.contains(s) {\n                            3\n                        } else if nset.contains(s) {\n                            -1\n                        } else {\n                            0\n                        }\n                    })\n                    .sum()\n            })\n            .collect::<Vec<i32>>();\n        let mut idxs = (0..n).collect::<Vec<usize>>();\n        idxs.sort_by(|i1, i2| {\n            let res = arr[*i2].cmp(&arr[*i1]);\n            if res == Ordering::Equal {\n                student_id[*i1].cmp(&student_id[*i2])\n            } else {\n                res\n            }\n        });\n        idxs.into_iter()\n            .enumerate()\n            .filter(|(i, _)| *i < k as usize)\n            .map(|(_, i)| student_id[i])\n            .collect()\n    }\n}",
            "date": 1696953600000
        }
    ]
}