{
  "name": "547. 省份数量",
  "url": "https://leetcode-cn.com/problems/number-of-provinces/",
  "difficulty": "中等",
  "tag": ["并查集", "深度优先搜索"],
  "desc": "在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。返回矩阵中 省份 的数量。",
  "solutions": [
    {
      "date": 1609948800000,
      "time": 92,
      "memory": 41.1,
      "script": "typescript",
      "desc": "深度优先搜索。",
      "code": "function findCircleNum(isConnected: number[][]): number {\n  const set = new Set<number>();\n  let ans = 0;\n  const len = isConnected.length;\n  const find = (index: number): void => {\n    for (let i = 0; i < len; i++) {\n      if (isConnected[i][index] === 1 && !set.has(i)) {\n        set.add(i);\n        find(i);\n      }\n    }\n  };\n  for (let i = 0; i < len; i++) {\n    if (!set.has(i)) {\n      ans++;\n      find(i);\n    }\n  }\n  return ans;\n}"
    },
    {
      "date": 1619712000000,
      "time": 92,
      "memory": 40.7,
      "script": "typescript",
      "desc": "并查集。",
      "code": "class UnionFind {\n  elements: number[];\n  constructor(public size: number) {\n    this.elements = new Array(size).fill(0).map((_, i) => i);\n  }\n  same(v1: number, v2: number): boolean {\n    return this.find(v1) === this.find(v2);\n  }\n  find(v: number): number {\n    return v === this.elements[v] ? v : (this.elements[v] = this.find(this.elements[v]));\n  }\n  union(v1: number, v2: number): void {\n    const e1 = this.find(v1);\n    const e2 = this.find(v2);\n    if (e1 !== e2) {\n      this.elements[e1] = e2;\n      this.size--;\n    }\n  }\n}\n\nfunction findCircleNum(isConnected: number[][]): number {\n  const len = isConnected.length;\n  const uf = new UnionFind(len);\n  for (let i = 0; i < len; i++) {\n    const connect = isConnected[i];\n    for (let j = 0; j < len; j++) {\n      connect[j] === 1 && uf.union(i, j);\n    }\n  }\n  return uf.size;\n}"
    }
  ]
}
