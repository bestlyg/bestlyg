{
    "name": "591.标签验证器",
    "url": "https://leetcode-cn.com/problems/tag-validator/",
    "difficulty": "困难",
    "tag": [
        "栈",
        "字符串"
    ],
    "desc": "给定一个表示代码片段的字符串，你需要实现一个验证器来解析这段代码，并返回它是否合法。",
    "solutions": [
        {
            "date": 1651420800000,
            "time": 0,
            "memory": 6.5,
            "script": "cpp",
            "desc": "栈存每一层，再遍历字符串。",
            "code": "#ifdef DEBUG\n#define log(fmt, args...) \\\n    { printf(fmt, ##args); }\n#else\n#define log(fmt, args...)\n#endif\nclass Solution {\n   public:\n    int i = 0, n;\n    bool check = true;\n    stack<string> s;\n    string code;\n    bool isValid(string code) {\n        this->code = code;\n        n = code.size();\n        log(\"n = %d\\n\", n);\n        // 最外层一定要是tag\n        if (code[0] != '<' || code[n - 1] != '>') return false;\n        while (i < n) {\n            // 检测tag开始\n            if (code[i] == '<') {\n                // 检测CDATA\n                if (i + 1 < n && code[i + 1] == '!') {\n                    // CDATA一定要在tag里\n                    if (s.empty()) return false;\n                    analysisCDATATag();\n                    log(\"end analysisCDATATag : i = %d\\n\", i);\n                    if (!check) return false;\n                } else {\n                    // 检测tag\n                    analysisTag();\n                    log(\"end analysisTag : i = %d\\n\", i);\n                    // 如果栈空了，但检测没结束，就有问题\n                    if (!check || s.empty() && i != n) return false;\n                }\n            }\n            // 直接到下一个<\n            while (i < n && code[i] != '<') i++;\n        }\n        log(\"end check\");\n        // 最后看看是不是栈空\n        return s.empty();\n    }\n    void analysisTag() {\n        // 先拿到结尾下标\n        int end = i;\n        while (end < n && code[end] != '>') end++;\n        // 没结尾就不对了\n        if (end == n) {\n            check = false;\n            return;\n        }\n        // 看看是endTag还是startTag\n        if (i + 1 < n && code[i + 1] == '/') {\n            // endTag先过滤斜线\n            i += 1;\n            string tag = analysisCommonTag(end);\n            // 跳跃\n            i = end + 1;\n            // 如果tag解析不出来就不对了\n            if (tag != \"\") {\n                log(\"find end  tag : %s\\n\", tag.data());\n                // 如果endTag解析出来了但栈空或栈顶没匹配的也不对\n                if (s.empty() || s.top() != tag) check = false;\n                // 对了就出栈\n                else\n                    s.pop();\n                return;\n            } else\n                check = false;\n        } else {\n            // 解析startTag\n            string tag = analysisCommonTag(end);\n            i = end + 1;\n            if (tag != \"\") {\n                log(\"find start tag : %s\\n\", tag.data());\n                // 对了就入栈\n                s.push(tag);\n                return;\n            } else\n                check = false;\n        }\n    }\n    string analysisCommonTag(int end) {\n        string ans = \"\";\n        // 长度 [1, 9]\n        if (end == i + 1 || end - i - 1 > 9) return \"\";\n        // 都是大写字符\n        for (int start = i + 1; start < end; start++) {\n            if (!isupper(code[start])) return \"\";\n            ans += code[start];\n        }\n        return ans;\n    }\n    string startWith_cdata = \"<![CDATA[\";\n    string endWith_cdata = \"]]>\";\n    void analysisCDATATag() {\n        log(\"anasysisCDATATAG, i = %d\\n\", i);\n        // 先看看能不能匹配开始标记\n        int start = i, startMatchCnt = 0;\n        while (start < n && startMatchCnt != startWith_cdata.size()) {\n            if (code[start] == startWith_cdata[startMatchCnt])\n                startMatchCnt++;\n            else\n                break;\n            start++;\n        }\n        // 匹配不上就错了\n        if (start == n || startMatchCnt != startWith_cdata.size()) {\n            check = false;\n            return;\n        }\n        // 再看看能不能匹配结束标记\n        log(\"find start = %d\\n\", start);\n        int end = start, endMatchCnt = 0;\n        // 一直循环找]开头的进行尝试\n        while (true) {\n            endMatchCnt = 0;\n            while (end < n && code[end] != endWith_cdata[0]) end++;\n            while (end < n && endMatchCnt != endWith_cdata.size()) {\n                if (code[end] == endWith_cdata[endMatchCnt])\n                    endMatchCnt++;\n                else\n                    break;\n                end++;\n            }\n            log(\"end = %d\\n\", end);\n            if (end == n || endMatchCnt == endWith_cdata.size()) break;\n        }\n        // 匹配不上就错了\n        // 匹配上就跳跃了\n        if (end == n) {\n            check = false;\n        } else {\n            log(\"find cdata tag : start = %d, end = %d\\n\", start, end);\n            i = end;\n        }\n    }\n};"
        }
    ]
}