{
    "id": "1389",
    "name": "1263.推箱子",
    "url": "https://leetcode.cn/problems/minimum-moves-to-move-a-box-to-their-target-location",
    "difficulty": "困难",
    "tag": [
        "广度优先搜索",
        "数组",
        "矩阵",
        "堆（优先队列）"
    ],
    "desc": "返回将箱子推到目标位置的最小 推动 次数，如果无法做到，请返回 -1。",
    "solutions": [
        {
            "script": "cpp",
            "time": 72,
            "memory": 15.4,
            "desc": "dfs每次统计左右子树的差值。",
            "code": "#define X first\n#define Y second\n#define pii pair<int, int>\n\nclass UnionFind {\n    public:\n    int n;\n    vector<int> data, cnt;\n    UnionFind(int n) : n(n), data(vector<int>(n, 0)), cnt(vector<int>(n, 1)) {\n        iota(data.begin(), data.end(), 0);\n    }\n    int size(int v) { return cnt[find(v)]; }\n    int find(int v) {\n        if (data[v] == v) return v;\n        return data[v] = find(data[v]);\n    }\n    void uni(int v1, int v2) {\n        int p1 = find(v1), p2 = find(v2);\n        if (p1 != p2) cnt[p1] += cnt[p2], data[p2] = p1;\n    }\n    bool same(int v1, int v2) { return find(v1) == find(v2); }\n};\nint pos2Idx(int x, int y, int size) { return x * size + y; }\nvoid idx2Pos(int idx, int size, int &x, int &y) {\n    x = idx / size;\n    y = idx % size;\n}\nvector<vector<int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n// 记录箱子和人的位置\nstruct Node {\n    pii p, b;\n    Node(pii p, pii b): p(p), b(b) {}\n};\nclass Solution {\npublic:\n    int minPushBox(vector<vector<char>>& grid) {\n        pii t, p, b;\n        int n = grid.size(), m = grid[0].size();\n        // 统计箱子和人的位置放置重复计算\n        unordered_map<int, unordered_map<int, bool>> used;\n        // 判断两个坐标是否相等\n        auto is_same = [&](pii a, pii b) -> bool {\n            return a.X == b.X && a.Y == b.Y;\n        };\n        // 针对当前Node值，计算并查集，计算时要排除箱子位置，用于后面判断人是不是能到这个点\n        auto get_uf = [&](Node cur) -> UnionFind {\n            UnionFind uf(n * m);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    if (grid[i][j] == '.' && !is_same(cur.b, make_pair(i, j))) {\n                        for (int k = 0; k < 4; k++) {\n                            int ni = i + dirs[k][0], nj = j + dirs[k][1];\n                            if (0 <= ni && ni < n && 0 <= nj && nj < m && grid[ni][nj] == '.' && !is_same(cur.b, make_pair(ni, nj))) {\n                                uf.uni(pos2Idx(i, j, m), pos2Idx(ni, nj, m));\n                            }\n                        }\n                    }\n                }\n            }\n            return uf;\n        };\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 'T') t = make_pair(i, j), grid[i][j] = '.';\n                else if (grid[i][j] == 'B') b = make_pair(i, j), grid[i][j] = '.';\n                else if (grid[i][j] == 'S') p = make_pair(i, j), grid[i][j] = '.';\n            }\n        }\n        queue<Node> q;\n        q.push(Node(p, b));\n        int size = 1, step = 0;\n        while (q.size()) {\n            auto cur = q.front();\n            q.pop();\n            if (is_same(cur.b, t)) return step;\n            auto uf = get_uf(cur);\n            for (int k = 0; k < 4; k++) {\n                int ni = cur.b.X + dirs[k][0], nj = cur.b.Y + dirs[k][1],\n                    bi = cur.b.X - dirs[k][0], bj = cur.b.Y - dirs[k][1];\n                // 如果箱子要推到(ni, nj), 那么人要在(bi, bj)位置上推，所以这两个位置都要空，且这个位置没有被统计过\n                if (0 <= ni && ni < n && 0 <= nj && nj < m && grid[ni][nj] == '.' &&\n                    0 <= bi && bi < n && 0 <= bj && bj < m && grid[bi][bj] == '.' &&\n                    uf.same(pos2Idx(cur.p.X, cur.p.Y, m), pos2Idx(bi, bj, m)) &&\n                    !used[pos2Idx(cur.b.X, cur.b.Y, m)][pos2Idx(ni, nj, m)]) {\n                    q.push(Node(make_pair(cur.b.X, cur.b.Y), make_pair(ni, nj)));\n                    used[pos2Idx(cur.b.X, cur.b.Y, m)][pos2Idx(ni, nj, m)] = true;\n                }\n            }\n            if (--size == 0) {\n                size = q.size();\n                step++;\n            }\n        }\n\n        return -1;\n    }\n};",
            "date": 1683475200000
        },
        {
            "script": "python3",
            "time": 2080,
            "memory": 16.5,
            "desc": "同上。",
            "code": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\nclass UnionFind:\n    def __init__(self, n) -> None:\n        self.n = n\n        self.data = [i for i in range(0, n)]\n        self.cnt = [1] * n\n\n    def size(self, v: int) -> int:\n        return self.cnt[self.find(v)]\n\n    def find(self, v: int) -> int:\n        if self.data[v] != v:\n            self.data[v] = self.find(self.data[v])\n        return self.data[v]\n\n    def uni(self, v1: int, v2: int):\n        p1 = self.find(v1)\n        p2 = self.find(v2)\n        if p1 != p2:\n            self.cnt[p1] += self.cnt[p2]\n            self.data[p2] = p1\n\n    def same(self, v1: int, v2: int):\n        return self.find(v1) == self.find(v2)\n\n\ndef pos2Idx(x: int, y: int, size: int):\n    return x * size + y\n\n\ndef idx2pox(idx: int, size: int) -> Tuple[int,  int]:\n    return (idx // size, idx % size)\n\nclass Node:\n    def __init__(self, p: Tuple[int, int], b: Tuple[int, int]) -> None:\n        self.p = p\n        self.b = b\n\nclass Solution:\n    def minPushBox(self, grid: List[List[str]]) -> int:\n        t, p, b = (0, 0), (0, 0), (0, 0)\n        n = len(grid)\n        m = len(grid[0])\n        used = defaultdict(dict)\n\n        def is_valid(v: Tuple[int, int]) -> bool:\n            return 0 <= v[0] < n and 0 <= v[1] < m\n\n        def is_same(a: Tuple[int, int], b: Tuple[int, int]):\n            return a[0] == b[0] and a[1] == b[1]\n\n        def get_uf(cur: Node) -> UnionFind:\n            uf = UnionFind(n * m)\n            for i in range(n):\n                for j in range(m):\n                    if grid[i][j] == '.' and not is_same(cur.b, (i, j)):\n                        for k in range(4):\n                            ni = i + dirs[k][0]\n                            nj = j + dirs[k][1]\n                            if is_valid((ni, nj)) and grid[ni][nj] == '.' and not is_same(cur.b, (ni, nj)):\n                                uf.uni(pos2Idx(i, j, m), pos2Idx(ni, nj, m))\n            return uf\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'T':\n                    t = (i, j)\n                    grid[i][j] = '.'\n                elif grid[i][j] == 'B':\n                    b = (i, j)\n                    grid[i][j] = '.'\n                elif grid[i][j] == 'S':\n                    p = (i, j)\n                    grid[i][j] = '.'\n        q = deque()\n        q.append(Node(p, b))\n        size = 1\n        step = 0\n        while len(q):\n            cur: Node = q.popleft()\n            if is_same(cur.b, t):\n                return step\n            uf = get_uf(cur)\n            for k in range(4):\n                ni = cur.b[0] + dirs[k][0]\n                nj = cur.b[1] + dirs[k][1]\n                bi = cur.b[0] - dirs[k][0]\n                bj = cur.b[1] - dirs[k][1]\n                pidx = pos2Idx(cur.p[0], cur.p[1], m)\n                bidx = pos2Idx(cur.b[0], cur.b[1], m)\n                if is_valid((ni, nj)) and grid[ni][nj] == '.' and is_valid((bi, bj)) and grid[bi][bj] == '.' and uf.same(pidx, pos2Idx(bi, bj, m)) and pos2Idx(ni, nj, m) not in used[bidx]:\n                    q.append(Node(cur.b, (ni, nj)))\n                    used[bidx][pos2Idx(ni, nj, m)] = True\n            size -= 1\n            if size == 0:\n                size = len(q)\n                step += 1\n        return -1",
            "date": 1683561600000
        },
        {
            "script": "rust",
            "time": 16,
            "memory": 2.2,
            "desc": "同上。",
            "code": "pub use std::collections::HashMap;\npub use std::collections::VecDeque;\npub const dirs: [[i32; 2]; 4] = [[0, 1], [0, -1], [1, 0], [-1, 0]];\npub struct UnionFind {\n    n: usize,\n    data: Vec<usize>,\n    cnt: Vec<usize>,\n}\nimpl UnionFind {\n    pub fn new(n: usize) -> Self {\n        let mut data = vec![0; n];\n        for i in 0..data.len() {\n            data[i] = i;\n        }\n        Self {\n            n,\n            data,\n            cnt: vec![0; n],\n        }\n    }\n    pub fn size(&mut self, v: usize) -> usize {\n        let idx = self.find(v);\n        self.cnt[idx]\n    }\n    pub fn find(&mut self, v: usize) -> usize {\n        if self.data[v] != v {\n            self.data[v] = self.find(self.data[v]);\n        }\n        self.data[v]\n    }\n    pub fn uni(&mut self, v1: usize, v2: usize) {\n        let p1 = self.find(v1);\n        let p2 = self.find(v2);\n        if p1 != p2 {\n            self.cnt[p1] += self.cnt[p2];\n            self.data[p2] = p1;\n        }\n    }\n    pub fn same(&mut self, v1: usize, v2: usize) -> bool {\n        self.find(v1) == self.find(v2)\n    }\n}\npub fn pos2Idx(x: usize, y: usize, size: usize) -> usize {\n    x * size + y\n}\npub fn idx2Pos(idx: usize, size: usize) -> (usize, usize) {\n    (idx / size, idx % size)\n}\n\ntype Position = (usize, usize);\n\n#[derive(Clone, Copy, Debug)]\nstruct Node {\n    p: Position,\n    b: Position,\n}\nimpl Node {\n    fn new(p: Position, b: Position) -> Self {\n        Self { p, b }\n    }\n}\n\nimpl Solution {\n    pub fn min_push_box(mut grid: Vec<Vec<char>>) -> i32 {\n        let mut p: Position = (0, 0);\n        let mut b: Position = (0, 0);\n        let mut t: Position = (0, 0);\n        let n = grid.len();\n        let m = grid[0].len();\n        let mut used = HashMap::<usize, HashMap<usize, bool>>::new();\n        let is_same = |a: Position, b: Position| a.0 == b.0 && a.1 == b.1;\n        let is_valid = |v: (i32, i32)| 0 <= v.0 && v.0 < n as i32 && 0 <= v.1 && v.1 < m as i32;\n        let get_uf = |grid: &Vec<Vec<char>>, cur: Node| {\n            let mut uf = UnionFind::new(n * m);\n            for i in 0..n {\n                for j in 0..m {\n                    if grid[i][j] == '.' && !is_same(cur.b, (i, j)) {\n                        for k in 0..4 {\n                            let ni = i as i32 + dirs[k][0];\n                            let nj = j as i32 + dirs[k][1];\n                            if is_valid((ni, nj))\n                                && grid[ni as usize][nj as usize] == '.'\n                                && !is_same(cur.b, (ni as usize, nj as usize))\n                            {\n                                uf.uni(pos2Idx(i, j, m), pos2Idx(ni as usize, nj as usize, m));\n                            }\n                        }\n                    }\n                }\n            }\n            uf\n        };\n        for i in 0..n {\n            for j in 0..m {\n                let t1 = grid[i][j] == 'T';\n                let t2 = grid[i][j] == 'B';\n                let t3 = grid[i][j] == 'S';\n                if t1 {\n                    t = (i, j);\n                    grid[i][j] = '.';\n                } else if t2 {\n                    b = (i, j);\n                    grid[i][j] = '.';\n                } else if t3 {\n                    p = (i, j);\n                    grid[i][j] = '.';\n                }\n            }\n        }\n        let mut q = VecDeque::<Node>::new();\n        q.push_back(Node::new(p, b));\n        let mut size = 1;\n        let mut step = 0;\n        while let Some(cur) = q.pop_front() {\n            if is_same(cur.b, t) {\n                return step;\n            }\n            let mut uf = get_uf(&grid, cur);\n            for k in 0..4 {\n                let ni = cur.b.0 as i32 + dirs[k][0];\n                let nj = cur.b.1 as i32 + dirs[k][1];\n                let bi = cur.b.0 as i32 - dirs[k][0];\n                let bj = cur.b.1 as i32 - dirs[k][1];\n                let pidx = pos2Idx(cur.p.0, cur.p.1, m);\n                let bidx = pos2Idx(cur.b.0, cur.b.1, m);\n                if is_valid((ni, nj))\n                    && grid[ni as usize][nj as usize] == '.'\n                    && is_valid((bi, bj))\n                    && grid[bi as usize][bj as usize] == '.'\n                    && uf.same(pidx, pos2Idx(bi as usize, bj as usize, m))\n                {\n                    if used.contains_key(&bidx)\n                        && used.get(&bidx).unwrap().contains_key(&pos2Idx(\n                            ni as usize,\n                            nj as usize,\n                            m,\n                        ))\n                    {\n                        continue;\n                    }\n                    let ni = ni as usize;\n                    let nj = nj as usize;\n                    q.push_back(Node::new(cur.b, (ni, nj)));\n                    let item = used.entry(bidx).or_insert(HashMap::new());\n                    *item.entry(pos2Idx(ni, nj, m)).or_insert(false) = true;\n                }\n            }\n            size -= 1;\n            if size == 0 {\n                size = q.len();\n                step += 1;\n            }\n        }\n        -1\n    }\n}",
            "date": 1683561600000
        }
    ]
}