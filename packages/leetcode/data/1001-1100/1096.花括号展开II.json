{
    "id": "1188",
    "name": "1096.花括号展开II",
    "url": "https://leetcode.cn/problems/brace-expansion-ii",
    "desc": "给出表示基于给定语法规则的表达式 expression，返回它所表示的所有字符串组成的有序列表。",
    "solutions": [
        {
            "script": "cpp",
            "time": 12,
            "memory": 10.9,
            "desc": "递归遍历。",
            "code": "class Solution {\npublic:\n    vector<string> braceExpansionII(string expression) {\n        if (checkSingal(expression)) expression = expression.substr(1, expression.size() - 2);\n        set<string> s;\n        vector<string> items = split(expression);\n        if (items.size() > 1) {\n            for (auto &item : items) {\n                for (auto &res : braceExpansionII(item)) {\n                    s.insert(res);\n                }\n            }\n        } else {\n            string item = items[0];\n            vector<vector<string>> res = analysis(item);\n            dfs(s, res, 0, \"\");\n        }\n        return vector<string>(s.begin(), s.end());\n    }\n    bool checkSingal(string &expression) {\n        if (expression[0] != '{' || expression[expression.size() - 1] != '}') return false;\n        int level = 0, i = 0;\n        for (; i < expression.size(); i++) {\n            if (expression[i] == '{') level++;\n            else if (expression[i] == '}') level--;\n            if (i != expression.size() - 1 && level == 0) return false;\n        }\n        return true;\n    }\n    vector<string> split(string &expression) {\n        vector<string> items;\n        int level = 0, prev = 0, i = 0;\n        for (; i < expression.size(); i++) {\n            if (expression[i] == '{') level++;\n            else if (expression[i] == '}') level--;\n            else if (expression[i] == ',' && level == 0) {\n                items.push_back(expression.substr(prev, i - prev));\n                prev = i + 1;\n            }\n        }\n        items.push_back(expression.substr(prev, i - prev));\n        return items;\n    }\n    vector<vector<string>> analysis(string &item) {\n        vector<vector<string>> res;\n        for (int i = 0; i < item.size(); i++) {\n            if (item[i] != '{') {\n                string s = \"\";\n                s += item[i];\n                vector<string> v;\n                v.push_back(s);\n                res.push_back(v);\n            } else {\n                int prev = i, level = 0;\n                do {\n                    if (item[i] == '{') level++;\n                    else if (item[i] == '}') level--;\n                    if (level != 0) i++;\n                } while (level != 0);\n                res.push_back(braceExpansionII(item.substr(prev, i - prev + 1)));\n            }\n        }\n        return res;\n    }\n    void dfs(set<string> &s, vector<vector<string>> &res, int start, string cur) {\n        if (start == res.size()) {\n            s.insert(cur);\n        } else {\n            for (int i = 0; i < res[start].size(); i++) {\n                dfs(s, res, start + 1, cur + res[start][i]);\n            }\n        }\n    }\n};",
            "date": "2023-03-07"
        },
        {
            "script": "python",
            "time": 60,
            "memory": 15.7,
            "desc": "同上。",
            "code": "from sortedcontainers import SortedSet\nclass Solution:\n\n    def checkSingal(self, expression: str):\n        if expression[0] != '{' or expression[-1] != '}':\n            return False\n        level, i = 0, 0\n        while i < len(expression):\n            if expression[i] == '{':\n                level += 1\n            elif expression[i] == '}':\n                level -= 1\n            if i != len(expression) - 1 and level == 0:\n                return False\n            i += 1\n        return True\n\n    def split(self, expression: str):\n        items = []\n        level = prev = i = 0\n        while i < len(expression):\n            if expression[i] == '{':\n                level += 1\n            elif expression[i] == '}':\n                level -= 1\n            elif expression[i] == ',' and level == 0:\n                items.append(expression[prev:i])\n                prev = i + 1\n            i += 1\n        items.append(expression[prev:])\n        return items\n\n    def analysis(self, item: str):\n        res = []\n        i = 0\n        while i < len(item):\n            if item[i] != '{':\n                res.append([str(item[i])])\n            else:\n                prev, level = i, 0\n                while True:\n                    if item[i] == '{':\n                        level += 1\n                    elif item[i] == '}':\n                        level -= 1\n                    if level == 0:\n                        break\n                    else:\n                        i += 1\n                res.append(self.braceExpansionII(item[prev:i+1]))\n            i += 1\n        return res\n\n    def dfs(self, s: SortedSet, res: List[List[str]], start: int, cur: str):\n        if start == len(res):\n            s.add(cur)\n        else:\n            for i in range(len(res[start])):\n                self.dfs(s, res, start+1, cur+res[start][i])\n\n    def braceExpansionII(self, expression: str) -> List[str]:\n        s = SortedSet()\n        if self.checkSingal(expression):\n            expression = expression[1:-1]\n        items = self.split(expression)\n        if len(items) > 1:\n            for item in items:\n                for res in self.braceExpansionII(item):\n                    s.add(res)\n        else:\n            item = items[0]\n            res = self.analysis(item)\n            self.dfs(s, res, 0, '')\n        return list(s)",
            "date": "2023-03-07"
        },
        {
            "script": "rust",
            "time": 4,
            "memory": 2.3,
            "desc": "同上。",
            "code": "use std::collections::BTreeSet;\nimpl Solution {\n    fn check_signal(expression: &Vec<char>) -> bool {\n        if *expression.first().unwrap() != '{' || *expression.last().unwrap() != '}' {\n            false\n        } else {\n            let mut level = 0;\n            for i in 0..expression.len() {\n                if expression[i] == '{' {\n                    level += 1\n                } else if expression[i] == '}' {\n                    level -= 1\n                }\n                if i != expression.len() - 1 && level == 0 {\n                    return false;\n                }\n            }\n            true\n        }\n    }\n    fn split(expression: &Vec<char>) -> Vec<Vec<char>> {\n        let mut items: Vec<Vec<char>> = vec![];\n        let mut level = 0;\n        let mut prev = 0;\n        let mut i = 0;\n        while i < expression.len() {\n            if expression[i] == '{' {\n                level += 1;\n            } else if expression[i] == '}' {\n                level -= 1;\n            } else if expression[i] == ',' && level == 0 {\n                items.push(\n                    expression[prev..i]\n                        .iter()\n                        .map(|v| *v)\n                        .collect::<Vec<char>>(),\n                );\n                prev = i + 1;\n            }\n            i += 1;\n        }\n        items.push(expression[prev..].iter().map(|v| *v).collect::<Vec<char>>());\n        items\n    }\n    fn analysis(item: &Vec<char>) -> Vec<Vec<Vec<char>>> {\n        let mut res = vec![];\n        let mut i = 0;\n        while i < item.len() {\n            if item[i] != '{' {\n                res.push(vec![vec![item[i]]])\n            } else {\n                let prev = i;\n                let mut level = 0;\n                loop {\n                    if item[i] == '{' {\n                        level += 1;\n                    } else if item[i] == '}' {\n                        level -= 1;\n                    }\n                    if level == 0 {\n                        break;\n                    } else {\n                        i += 1;\n                    }\n                }\n                res.push(Solution::_brace_expansion_ii(\n                    item[prev..i + 1].iter().map(|v| *v).collect::<Vec<char>>(),\n                ))\n            }\n            i += 1;\n        }\n        res\n    }\n    fn dfs(s: &mut BTreeSet<Vec<char>>, res: &Vec<Vec<Vec<char>>>, start: usize, cur: Vec<char>) {\n        if start == res.len() {\n            s.insert(cur);\n        } else {\n            for item in res[start].iter() {\n                let mut next = cur.clone();\n                let mut other = item.clone();\n                next.append(&mut other);\n                Solution::dfs(s, res, start + 1, next);\n            }\n        }\n    }\n    pub fn brace_expansion_ii(expression: String) -> Vec<String> {\n        let expression = expression.chars().collect::<Vec<char>>();\n        Solution::_brace_expansion_ii(expression)\n            .into_iter()\n            .map(|v| {\n                String::from_utf8(v.into_iter().map(|v| v as u8).collect::<Vec<u8>>()).unwrap()\n            })\n            .collect()\n    }\n    fn _brace_expansion_ii(expression: Vec<char>) -> Vec<Vec<char>> {\n        let mut expression = expression;\n        if Solution::check_signal(&expression) {\n            expression.remove(expression.len() - 1);\n            expression.remove(0);\n        }\n        let mut s = BTreeSet::<Vec<char>>::new();\n        let items = Solution::split(&expression);\n        if items.len() > 1 {\n            for item in items {\n                for res in Solution::_brace_expansion_ii(item) {\n                    s.insert(res);\n                }\n            }\n        } else {\n            let res = Solution::analysis(&items[0]);\n            Solution::dfs(&mut s, &res, 0, vec![]);\n        }\n        s.into_iter().collect::<Vec<Vec<char>>>()\n    }\n}",
            "date": "2023-03-07"
        }
    ],
    "tagList": ["栈", "广度优先搜索", "字符串", "回溯"],
    "level": "Hard"
}
