{
    "id": "460",
    "name": "460.LFU缓存",
    "url": "https://leetcode.cn/problems/lfu-cache",
    "desc": "请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。它应该支持以下操作：get 和 put。",
    "solutions": [
        {
            "date": "2020-04-09",
            "time": 1136,
            "memory": 78.2,
            "script": "javascript",
            "desc": "使用 Node 储存次数和值，进行判断，难点没有就是细节需要考虑。",
            "code": "class Node {\n  count = 0;\n  value;\n  constructor(value) {\n    this.value = value;\n  }\n}\nclass LFUCache {\n  _capacity;\n  _cache = new Map();\n  newest = [];\n  constructor(capacity) {\n    this._capacity = capacity;\n  }\n  get(key) {\n    // console.log('====GET-' + key);\n    // console.log(this._cache);\n    if (this._capacity === 0 || !this._cache.has(key)) return -1;\n    const node = this._cache.get(key);\n    node.count++;\n    this.setNewest(key);\n    return node.value;\n  }\n  setNewest(key) {\n    if (this.newest[this.newest.length - 1] === key) return;\n    this.newest = this.newest.filter(v => v !== key);\n    this.newest.push(key);\n  }\n  getMinKey() {\n    const arr = [];\n    let minValue = Number.MAX_VALUE;\n    for (let [_, node] of this._cache) {\n      if (node.count < minValue) {\n        minValue = node.count;\n      }\n    }\n    for (let [key, node] of this._cache) {\n      if (node.count === minValue) arr.push(key);\n    }\n    return arr;\n  }\n  put(key, value) {\n    // console.log('====PUT-' + key + '-' + value);\n    // console.log(key, value);\n    if (this._capacity === 0) return;\n    if (this._cache.has(key)) {\n      const node = this._cache.get(key);\n      node.value = value;\n      node.count++;\n      this.setNewest(key);\n      return;\n    }\n    const node = new Node(value);\n    if (this._cache.size < this._capacity) {\n      this._cache.set(key, node);\n      this.setNewest(key);\n      return;\n    }\n    const mins = this.getMinKey();\n    if (mins.length === 1) {\n      this._cache.delete(mins[0]);\n      this._cache.set(key, node);\n      this.setNewest(key);\n      return;\n    }\n    // console.log('mins:' + mins);\n    // console.log('newest:' + this.newest);\n    for (let item of this.newest) {\n      if (mins.includes(item)) {\n        this._cache.delete(item);\n        this._cache.set(key, node);\n        this.setNewest(key);\n        return;\n      }\n    }\n  }\n}"
        },
        {
            "script": "python",
            "time": 720,
            "memory": 77.2,
            "desc": "链表。",
            "code": "class NodeBase:\n    def __init__(self, prev, next):\n        self.prev = prev\n        self.next = next\n\n    def append(self, prev):\n        next = prev.next\n        prev.next, next.prev, self.prev, self.next = self, self, prev, next\n        return self\n\n    def remove(self):\n        if self.prev:\n            self.prev.next, self.next.prev, self.next, self.prev = self.next, self.prev, None, None\n\nclass ListBase:\n    def __init__(self, cstr):\n        self.cstr = cstr\n        self.head = cstr()\n        self.tail = cstr()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n    \n    def is_empty(self):\n        return self.head.next == self.tail\n\n\nclass Node(NodeBase):\n    def __init__(self, key=0, val=0, cnt=0, cntNode=None, prev=None, next=None):\n        self.key = key\n        self.val = val\n        self.cnt = cnt\n        self.cntNode = cntNode\n        NodeBase.__init__(self, prev, next)\n\n\nclass CntNode(NodeBase, ListBase):\n    def __init__(self, cnt = 0, prev=None, next=None):\n        self.cnt = cnt\n        ListBase.__init__(self, Node)\n        NodeBase.__init__(self, prev, next)\n\nclass LFUCache(ListBase):\n\n    def __init__(self, capacity: int):\n        self.cntCache = {}\n        self.cache = {}\n        self.capacity = capacity\n        self.size = 0\n        ListBase.__init__(self, CntNode)\n\n    def get_next_cntnode(self, node):\n        if node.next.cnt == node.cnt + 1:\n            return node.next\n        next = CntNode(node.cnt + 1)\n        next.append(node)\n        self.cntCache[next.cnt] = next\n        return next\n\n    def check_cntnode_empty(self, node):\n        if node.is_empty():\n            node.remove()\n            del self.cntCache[node.cnt]\n    \n    def upgrade_node(self, key: int, update):\n        node = self.cache[key]\n        update(node)\n        node.cnt += 1\n        nextCntNode = self.get_next_cntnode(node.cntNode)\n        node.remove()\n        if node.cntNode != self.head: self.check_cntnode_empty(node.cntNode)\n        node.append(nextCntNode.head)\n        node.cntNode = nextCntNode\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self.upgrade_node(key, lambda node: node)\n        return self.cache[key].val\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            self.cache[key] = Node(key, value, 0, self.head)\n            self.size += 1\n            if self.size > self.capacity:\n                self.size -= 1\n                firstCntNode = self.head.next\n                removeNode = firstCntNode.tail.prev\n                removeNode.remove()\n                del self.cache[removeNode.key]\n                self.check_cntnode_empty(firstCntNode)\n            if self.head.next.cnt != 1:\n                self.cntCache[1] = CntNode(1).append(self.head)\n        def update(node): node.val = value\n        self.upgrade_node(key, update)",
            "date": "2023-09-25"
        }
    ],
    "tagList": ["设计", "哈希表", "链表", "双向链表"],
    "level": "Hard"
}
