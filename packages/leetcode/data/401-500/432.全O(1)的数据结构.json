{
    "id": "432",
    "name": "432.全O(1)的数据结构",
    "url": "https://leetcode.cn/problems/all-oone-data-structure",
    "desc": "请你设计一个用于存储字符串计数的数据结构，并能够返回计数最小和最大的字符串。",
    "solutions": [
        {
            "date": "2022-03-16",
            "time": 136,
            "memory": 55.9,
            "script": "cpp",
            "desc": "利用哈希删查 O1，链表增删 O1 来维护结构。",
            "code": "class VNode {\n   public:\n    int cnt;\n    string value;\n    VNode(string _value) {\n        value = _value;\n        cnt = 1;\n    }\n};\nclass CNode {\n   public:\n    int value;\n    CNode *prev, *next;\n    unordered_set<VNode *> children;\n    CNode(int _value, CNode *_prev = NULL) {\n        value = _value;\n        prev = _prev;\n        next = NULL;\n        if (prev) {\n            insert(prev);\n        }\n    }\n    void insert(CNode *prev) {\n        CNode *next = prev->next;\n        prev->next = this;\n        next->prev = this;\n        this->next = next;\n        this->prev = prev;\n    };\n    void remove() {\n        if (prev) prev->next = next;\n        if (next) next->prev = prev;\n        prev = NULL;\n        next = NULL;\n    };\n};\nclass AllOne {\n   public:\n    unordered_map<string, VNode *> vmap;\n    unordered_map<int, CNode *> cmap;\n    // first min | last max\n    CNode *first = new CNode(-1), *last = new CNode(-1);\n    void\n    log() { /*\n    cout << \"======START LOG=====\" << endl;\n    cout << \"CNode : first -> \";\n    CNode *p = first->next;\n    while (p != last) {\n        cout << \"(\" << p->prev->value << \", \" << p->value << \", \"\n             << p->next->value << \") -> \";\n        p = p->next;\n    }\n    cout << \"last\" << endl;\n\n    cout << \"VMap\" << endl;\n    for (auto &it : vmap) {\n        cout << \"(\" << it.first << \", \" << it.second->cnt << \")\" << endl;\n    }\n\n    cout << \"CMap\" << endl;\n    for (auto &it : cmap) {\n        cout << \"(\" << it.first << \", \" << it.second->children.size() << \")\"\n             << endl;\n    }\n    cout << \"======END LOG=====\" << endl;*/\n    }\n    AllOne() {\n        first->next = last;\n        last->prev = first;\n    }\n    /*\n    ~AllOne() {\n        last = NULL;\n        CNode *p = first;\n        while (p) {\n            CNode *cur = p;\n            p = p->next;\n            cur->remove();\n            delete cur;\n        }\n    }\n    */\n    void inc(string key) {\n        // cout << \"inc \" << key << endl;\n        if (vmap.count(key))\n            inc_key(key);\n        else\n            inc_nokey(key);\n        log();\n    }\n    // 增加key且当前存在\n    void inc_key(string key) {\n        VNode *vnode = vmap[key];\n        CNode *cnode = cmap[vnode->cnt];\n        cnode->children.erase(vnode);\n        if (cnode->children.size() == 0) {\n            CNode *prev = cnode->prev;\n            cnode->remove();\n            cmap.erase(cnode->value);\n            delete cnode;\n            cnode = prev;\n        }\n        vnode->cnt += 1;\n        if (cnode->next->value == vnode->cnt) {\n            cnode->next->children.insert(vnode);\n        } else {\n            CNode *cnode_next = new CNode(vnode->cnt, cnode);\n            cnode_next->children.insert(vnode);\n            cmap[vnode->cnt] = cnode_next;\n        }\n    }\n    // 增加key且当前不存在\n    void inc_nokey(string key) {\n        VNode *vnode = new VNode(key);\n        vmap[key] = vnode;\n        CNode *cnode =\n            first->next->value == 1 ? cmap[1] : (cmap[1] = new CNode(1, first));\n        cnode->children.insert(vnode);\n    }\n    void dec(string key) {\n        // cout << \"dec \" << key << endl;\n        if (vmap[key]->cnt == 1) {\n            dec_nokey(key);\n        } else {\n            dec_key(key);\n        }\n        log();\n    }\n    // 减少key且当前存在\n    void dec_key(string key) {\n        VNode *vnode = vmap[key];\n        CNode *cnode = cmap[vnode->cnt], *prev = cnode->prev;\n        cnode->children.erase(vnode);\n        if (cnode->children.size() == 0) {\n            cnode->remove();\n            cmap.erase(vnode->cnt);\n            delete cnode;\n        }\n        if (prev != first && prev->value == vnode->cnt - 1) {\n            prev->children.insert(vnode);\n        } else {\n            CNode *cnode_new = new CNode(vnode->cnt - 1, prev);\n            cmap[vnode->cnt - 1] = cnode_new;\n            cnode_new->children.insert(vnode);\n        }\n        vnode->cnt -= 1;\n    }\n    // 减少key且当前不存在\n    void dec_nokey(string key) {\n        VNode *vnode = vmap[key];\n        CNode *cnode = cmap[vnode->cnt];\n        cnode->children.erase(vnode);\n        if (cnode->children.size() == 0) {\n            cnode->remove();\n            cmap.erase(vnode->cnt);\n            delete cnode;\n        }\n        vmap.erase(vnode->value);\n        delete vnode;\n    }\n    string getMaxKey() {\n        if (first->next == last) return \"\";\n        auto it = last->prev->children.begin();\n        return (*it)->value;\n    }\n\n    string getMinKey() {\n        if (first->next == last) return \"\";\n        auto it = first->next->children.begin();\n        return (*it)->value;\n    }\n};"
        }
    ],
    "tagList": [
        "设计",
        "哈希表",
        "链表",
        "双向链表"
    ],
    "level": "Hard"
}