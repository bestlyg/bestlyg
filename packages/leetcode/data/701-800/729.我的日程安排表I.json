{
  "name": "729. 我的日程安排表 I",
  "url": "https://leetcode.cn/problems/my-calendar-i/",
  "difficulty": "中等",
  "tag": ["设计", "线段树", "二分查找", "有序集合"],
  "desc": "实现一个 MyCalendar 类来存放你的日程安排。如果要添加的日程安排不会造成 重复预订 ，则可以存储这个新的日程安排。",
  "solutions": [
    {
      "date": 1656950400000,
      "time": 188,
      "memory": 50.3,
      "script": "typescript",
      "desc": "构建 rbtree，每次通过 start、end 查找他最近的值然后进行比较。",
      "code": "let NIL: RBNode<any>;\nclass RBNode<T> {\n  constructor(public key: T, public color = 0, public lchild = NIL, public rchild = NIL) {}\n  hasRedChild() {\n    return this.lchild.color === 0 || this.rchild.color === 0;\n  }\n}\nNIL = new RBNode(0, 1);\n\nclass RBTree<T extends Array<any>> {\n  root: RBNode<T> = NIL;\n  constructor(public compare: (v1: T, v2: T) => number) {}\n  print(node = this.root, init = true) {\n    if (node == NIL) return;\n    if (init) console.log('===[RBTree Print]===');\n    console.log(`${node.key}, (${node.lchild.key}, ${node.rchild.key})`);\n    this.print(node.lchild, false);\n    this.print(node.rchild, false);\n  }\n  rotateLeft(node: RBNode<T>) {\n    const newNode = node.rchild;\n    node.rchild = newNode.lchild;\n    newNode.lchild = node;\n    return newNode;\n  }\n  rotateRight(node: RBNode<T>) {\n    const newNode = node.lchild;\n    node.lchild = newNode.rchild;\n    newNode.rchild = node;\n    return newNode;\n  }\n  insert(key: T) {\n    this.root = this._insert(this.root, key);\n    this.root.color = 1;\n  }\n  _insert(node: RBNode<T>, key: T) {\n    if (node === NIL) return new RBNode(key);\n    const compare = this.compare(key, node.key);\n    if (compare === 0) {\n      node.key = key;\n      return node;\n    }\n    if (compare > 0) node.rchild = this._insert(node.rchild, key);\n    else node.lchild = this._insert(node.lchild, key);\n    return this._insertMaintain(node);\n  }\n  _insertMaintain(node: RBNode<T>) {\n    if (!node.hasRedChild()) return node;\n    if (\n      !(node.lchild.color === 0 && node.lchild.hasRedChild()) &&\n      !(node.rchild.color === 0 && node.rchild.hasRedChild())\n    )\n      return node;\n    if (node.lchild.color === 1) {\n      if (node.rchild.lchild.color === 0) node.rchild = this.rotateRight(node.rchild);\n      node = this.rotateLeft(node);\n    } else if (node.rchild.color === 1) {\n      if (node.lchild.rchild.color === 0) node.lchild = this.rotateLeft(node.lchild);\n      node = this.rotateRight(node);\n    }\n    node.color = 0;\n    node.lchild.color = node.rchild.color = 1;\n    return node;\n  }\n\n  remove(key: T) {\n    this.root = this._remove(this.root, key);\n    this.root.color = 1;\n  }\n  _remove(node: RBNode<T>, key: T) {\n    if (node == NIL) return node;\n    const compare = this.compare(key, node.key);\n    if (compare > 0) node.rchild = this._remove(node.rchild, key);\n    else if (compare < 0) node.lchild = this._remove(node.lchild, key);\n    else {\n      if (node.lchild === NIL || node.rchild === NIL) {\n        const tmp = node.lchild === NIL ? node.rchild : node.lchild;\n        tmp.color += node.color;\n        return tmp;\n      } else {\n        let tmp = node.lchild;\n        while (tmp.rchild !== NIL) tmp = tmp.rchild;\n        node.key = tmp.key;\n        node.lchild = this._remove(node.lchild, tmp.key);\n      }\n    }\n    return this._removeMaintain(node);\n  }\n  _removeMaintain(node: RBNode<T>) {\n    if (node.lchild.color !== 2 && node.rchild.color !== 2) return node;\n    if (node.hasRedChild()) {\n      let type = 0;\n      node.color = 0;\n      if (node.lchild.color === 0) node = this.rotateRight(node);\n      else (node = this.rotateLeft(node)), (type = 1);\n      node.color = 1;\n      if (type === 1) node.lchild = this._removeMaintain(node.lchild);\n      else node.rchild = this._removeMaintain(node.rchild);\n      return node;\n    }\n    if (\n      (node.lchild.color === 1 && !node.lchild.hasRedChild()) ||\n      (node.rchild.color === 1 && !node.rchild.hasRedChild())\n    ) {\n      node.color += 1;\n      node.lchild.color -= 1;\n      node.rchild.color -= 1;\n      return node;\n    }\n    if (node.lchild.color === 1) {\n      if (node.lchild.lchild.color !== 0) {\n        node.lchild.color = 0;\n        node.lchild = this.rotateLeft(node.lchild);\n        node.lchild.color = 1;\n      }\n      node.lchild.color = node.color;\n      node.rchild.color = 1;\n      node = this.rotateRight(node);\n    } else {\n      if (node.rchild.rchild.color !== 0) {\n        node.rchild.color = 0;\n        node.rchild = this.rotateRight(node.rchild);\n        node.rchild.color = 1;\n      }\n      node.rchild.color = node.color;\n      node.lchild.color = 1;\n      node = this.rotateLeft(node);\n    }\n    node.lchild.color = node.rchild.color = 1;\n    return node;\n  }\n  successor(node: RBNode<T>) {\n    let successor = NIL;\n    if (node.rchild) {\n      successor = node.rchild;\n      while (successor.lchild) successor = successor!.lchild;\n      return successor;\n    }\n    let tmp = this.root;\n    while (tmp) {\n      if (tmp.key > node.key) {\n        successor = tmp;\n        tmp = tmp.lchild;\n      } else {\n        tmp = tmp.rchild;\n      }\n    }\n    return tmp;\n  }\n  check([start, end]: T): boolean {\n    let node = this.root;\n    while (node !== NIL) {\n      if (node.key[0] >= end) node = node.lchild;\n      else if (node.key[1] <= start) node = node.rchild;\n      else break;\n    }\n    if (node === NIL) return true;\n    let tmp = node;\n    while (tmp !== NIL && tmp.key[1] >= start) {\n      const [tstart, tend] = tmp.key;\n      if (\n        (start > tstart && start < tend) ||\n        (end > tstart && end < tend) ||\n        (start <= tstart && end >= tend)\n      )\n        return false;\n      tmp = this.successor(tmp);\n    }\n    return true;\n  }\n}\nclass MyCalendar {\n  tree = new RBTree<number[]>((v1, v2) => v1[0] - v2[0]);\n  book(start: number, end: number): boolean {\n    const ans = this.tree.check([start, end]);\n    if (ans) this.tree.insert([start, end]);\n    return ans;\n  }\n}"
    }
  ]
}
