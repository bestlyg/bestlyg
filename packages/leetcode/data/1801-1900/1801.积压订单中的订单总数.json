{
    "id": "1928",
    "name": "1801.积压订单中的订单总数",
    "url": "https://leetcode.cn/problems/number-of-orders-in-the-backlog",
    "desc": "给你一个二维整数数组 orders ，输入所有订单后，返回积压订单中的 订单总数 。由于数字可能很大，所以需要返回对 109 + 7 取余的结果。",
    "solutions": [
        {
            "date": "2021-04-11",
            "time": 332,
            "memory": 59.5,
            "script": "typescript",
            "desc": "利用买大顶堆和卖小顶堆维护最值。",
            "code": "class Heap<T = number> {\n  private arr: T[] = [];\n  get isEmpty() {\n    return this.size === 0;\n  }\n  get size() {\n    return this.arr.length;\n  }\n  get top() {\n    return this.arr[0];\n  }\n  constructor(private compare: (t1: T, t2: T) => number) {}\n  add(num: T): void {\n    this.arr.push(num);\n    this.shiftUp(this.size - 1);\n  }\n  remove(): T {\n    const num = this.arr.shift()!;\n    if (this.size) {\n      this.arr.unshift(this.arr.pop()!);\n      this.shiftDown(0);\n    }\n    return num;\n  }\n  private shiftUp(index: number): void {\n    if (index === 0) return;\n    const parentIndex = (index - 1) >> 1;\n    if (this.compare(this.arr[index], this.arr[parentIndex]) > 0) {\n      [this.arr[index], this.arr[parentIndex]] = [this.arr[parentIndex], this.arr[index]];\n      this.shiftUp(parentIndex);\n    }\n  }\n  private shiftDown(index: number): void {\n    let childrenIndex = index * 2 + 1;\n    if (childrenIndex > this.size - 1) return;\n    if (\n      childrenIndex + 1 <= this.size - 1 &&\n      this.compare(this.arr[childrenIndex + 1], this.arr[childrenIndex]) > 0\n    ) {\n      childrenIndex++;\n    }\n    if (this.compare(this.arr[childrenIndex], this.arr[index]) > 0) {\n      [this.arr[childrenIndex], this.arr[index]] = [this.arr[index], this.arr[childrenIndex]];\n      this.shiftDown(childrenIndex);\n    }\n  }\n  *[Symbol.iterator](): IterableIterator<T> {\n    for (const t of this.arr) {\n      yield t;\n    }\n  }\n}\nfunction getNumberOfBacklogOrders(orders: number[][]): number {\n  const buyHeap = new Heap<number[]>(([t1], [t2]) => t1 - t2);\n  const sellHeap = new Heap<number[]>(([t1], [t2]) => t2 - t1);\n  const add = (order: number[]) => {\n    (order[2] === 0 ? buyHeap : sellHeap).add(order);\n    while (buyHeap.size > 0 && sellHeap.size > 0 && buyHeap.top[0] >= sellHeap.top[0]) {\n      const buyTop = buyHeap.top;\n      const sellTop = sellHeap.top;\n      if (buyTop[1] > sellTop[1]) {\n        sellHeap.remove();\n        buyTop[1] -= sellTop[1];\n      } else if (buyTop[1] < sellTop[1]) {\n        buyHeap.remove();\n        sellTop[1] -= buyTop[1];\n      } else {\n        sellHeap.remove();\n        buyHeap.remove();\n      }\n    }\n  };\n  orders.forEach(order => add(order));\n  let ans = 0;\n  for (const [, c] of buyHeap) ans += c;\n  for (const [, c] of sellHeap) ans += c;\n  return ans % (10 ** 9 + 7);\n}"
        },
        {
            "date": "2023-01-02",
            "time": 188,
            "memory": 57.2,
            "script": "cpp",
            "desc": "模拟。",
            "code": "typedef pair<int, int> node;\n#define X              first\n#define Y              second\nstruct cmp {\n    int type;\n    cmp(int type): type(type) {}\n    bool operator()(node &a, node &b) {\n        if (type) return a.X < b.X;\n        else return a.X > b.X;\n    }\n};\nint mod = 1e9 + 7;\nclass Solution {\npublic:\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\n        priority_queue<node, vector<node>, cmp> buyq(cmp(1));\n        priority_queue<node, vector<node>, cmp> sellq(cmp(0));\n        for (auto &order : orders) {\n            if (order[2] == 0) {\n                node cur = make_pair(order[0], order[1]);\n                while (cur.Y && sellq.size() && sellq.top().X <= cur.X) {\n                    if (sellq.top().Y > cur.Y) {\n                        auto v = sellq.top();\n                        sellq.pop();\n                        v.Y -= cur.Y;\n                        sellq.push(v);\n                        cur.Y = 0;\n                    } else if (sellq.top().Y < cur.Y) {\n                        cur.Y -= sellq.top().Y;\n                        sellq.pop();\n                    } else {\n                        cur.Y = 0;\n                        sellq.pop();\n                    }\n                }\n                if (cur.Y) buyq.push(cur);\n            } else {\n                node cur = make_pair(order[0], order[1]);\n                while (cur.Y && buyq.size() && buyq.top().X >= cur.X) {\n                    if (buyq.top().Y > cur.Y) {\n                        auto v = buyq.top();\n                        buyq.pop();\n                        v.Y -= cur.Y;\n                        buyq.push(v);\n                        cur.Y = 0;\n                    } else if (buyq.top().Y < cur.Y) {\n                        cur.Y -= buyq.top().Y;\n                        buyq.pop();\n                    } else {\n                        cur.Y = 0;\n                        buyq.pop();\n                    }\n                }\n                if (cur.Y) sellq.push(cur);\n            }\n        }\n        int ans = 0;\n        while (buyq.size()) ans = (ans + buyq.top().Y) % mod, buyq.pop();\n        while (sellq.size()) ans = (ans + sellq.top().Y) % mod, sellq.pop();\n        return ans;\n    }\n};"
        },
        {
            "date": "2023-01-02",
            "time": 200,
            "memory": 57.2,
            "script": "cpp",
            "desc": "同上。",
            "code": "typedef pair<int, int> node;\n#define X              first\n#define Y              second\nstruct cmp {\n    int type;\n    cmp(int type): type(type) {}\n    bool operator()(node &a, node &b) {\n        if (type) return a.X < b.X;\n        else return a.X > b.X;\n    }\n};\nint mod = 1e9 + 7;\nclass Solution {\npublic:\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\n        priority_queue<node, vector<node>, cmp> buyq(cmp(1));\n        priority_queue<node, vector<node>, cmp> sellq(cmp(0));\n        for (auto &order : orders) {\n            auto &q1 = order[2] == 0 ? sellq : buyq,\n                 &q2 = order[2] == 0 ? buyq  : sellq;\n            node cur = make_pair(order[0], order[1]);\n            while (cur.Y && q1.size() && (order[2] == 0 ? q1.top().X <= cur.X : q1.top().X >= cur.X)) {\n                if (q1.top().Y > cur.Y) {\n                    auto v = q1.top();\n                    q1.pop();\n                    v.Y -= cur.Y;\n                    q1.push(v);\n                    cur.Y = 0;\n                } else if (q1.top().Y < cur.Y) {\n                    cur.Y -= q1.top().Y;\n                    q1.pop();\n                } else {\n                    cur.Y = 0;\n                    q1.pop();\n                }\n            }\n            if (cur.Y) q2.push(cur);/\n        }\n        int ans = 0;\n        while (buyq.size()) ans = (ans + buyq.top().Y) % mod, buyq.pop();\n        while (sellq.size()) ans = (ans + sellq.top().Y) % mod, sellq.pop();\n        return ans;\n    }\n};"
        },
        {
            "date": "2023-01-02",
            "time": 24,
            "memory": 9.5,
            "script": "rust",
            "desc": "同上。",
            "code": "use std::{cmp::Ordering, collections::BinaryHeap};\nstruct Node(i32, i32, bool);\nimpl PartialEq for Node {\n    fn eq(&self, other: &Self) -> bool {\n        self.0 == other.0\n    }\n}\nimpl Eq for Node {}\nimpl Ord for Node {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        if self.2 {\n            self.0.cmp(&other.0)\n        } else {\n            other.0.cmp(&self.0)\n        }\n    }\n}\nimpl PartialOrd for Node {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        if self.2 {\n            self.0.partial_cmp(&other.0)\n        } else {\n            other.0.partial_cmp(&self.0)\n        }\n    }\n}\nconst mode: i32 = 1000000000 + 7;\nimpl Solution {\n    pub fn get_number_of_backlog_orders(orders: Vec<Vec<i32>>) -> i32 {\n        let mut buy_heap = BinaryHeap::<Node>::new();\n        let mut sell_heap = BinaryHeap::<Node>::new();\n        for order in orders {\n            if order[2] == 0 {\n                let mut cur = Node(order[0], order[1], order[2] == 0);\n                while cur.1 > 0 && !buy_heap.is_empty() && buy_heap.peek().unwrap().0 <= cur.0 {\n                    if buy_heap.peek().unwrap().1 > cur.1 {\n                        let mut node = buy_heap.pop().unwrap();\n                        node.1 -= cur.1;\n                        buy_heap.push(node);\n                        cur.1 = 0;\n                    } else if buy_heap.peek().unwrap().1 < cur.1 {\n                        cur.1 -= buy_heap.pop().unwrap().1;\n                    } else {\n                        cur.1 = 0;\n                        buy_heap.pop();\n                    }\n                }\n                if cur.1 > 0 {\n                    sell_heap.push(cur);\n                };\n            } else {\n                let mut cur = Node(order[0], order[1], order[2] == 0);\n                while cur.1 > 0 && !sell_heap.is_empty() && sell_heap.peek().unwrap().0 >= cur.0 {\n                    if sell_heap.peek().unwrap().1 > cur.1 {\n                        let mut node = sell_heap.pop().unwrap();\n                        node.1 -= cur.1;\n                        sell_heap.push(node);\n                        cur.1 = 0;\n                    } else if sell_heap.peek().unwrap().1 < cur.1 {\n                        cur.1 -= sell_heap.pop().unwrap().1;\n                    } else {\n                        cur.1 = 0;\n                        sell_heap.pop();\n                    }\n                }\n                if cur.1 > 0 {\n                    buy_heap.push(cur);\n                };\n            }\n        }\n        let mut ans = 0;\n        while !buy_heap.is_empty() {\n            ans = (ans + buy_heap.pop().unwrap().1) % mode;\n        }\n        while !sell_heap.is_empty() {\n            ans = (ans + sell_heap.pop().unwrap().1) % mode;\n        }\n        ans\n    }\n}"
        }
    ],
    "tagList": [
        "数组",
        "模拟",
        "堆（优先队列）"
    ],
    "level": "Medium"
}