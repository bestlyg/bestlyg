{
    "name": "1825.求出MK平均值",
    "url": "https://leetcode.cn/problems/finding-mk-average/",
    "difficulty": "困难",
    "tag": [
        "设计",
        "队列",
        "数据流",
        "有序合集",
        "堆(优先队列)"
    ],
    "desc": "请你实现 MKAverage 类。",
    "solutions": [
        {
            "script": "cpp",
            "time": 796,
            "memory": 144.8,
            "desc": "有序集合，维护有序性,s1表示前k个，s3表示后k个，s2表示中间m-2k个。",
            "code": "class MKAverage {\npublic:\n    multiset<int> s1, s2, s3;\n    queue<int> q;\n    long long sum = 0, m, k;\n    MKAverage(int m, int k) {\n        this->m = m;\n        this->k = k;\n    }\n \n    int calculateMKAverage() {\n        if (q.size() < m) return -1;\n        return sum / (m - 2 * k);\n    }\n \n    void addElement(int num) {\n        q.push(num);\n        if (q.size() <= m) {\n            s2.insert(num);\n            sum += num;\n            if (q.size() == m) {\n                while (s2.size() > m - 2 * k && s3.size() < k) {\n                    s3.insert(*s2.rbegin());\n                    sum -= *s2.rbegin();\n                    s2.erase(prev(s2.end()));\n                }\n                while (s2.size() > m - 2 * k && s1.size() < k) {\n                    s1.insert(*s2.begin());\n                    sum -= *s2.begin();\n                    s2.erase(s2.begin());\n                }\n            }\n        } else {\n            if (num < *s2.begin()) {\n                s2.insert(*s1.rbegin());\n                sum += *s1.rbegin();\n                s1.insert(num);\n                s1.erase(prev(s1.end()));\n            } else if (num >= *s3.begin()) {\n                s2.insert(*s3.begin());\n                sum += *s3.begin();\n                s3.insert(num);\n                s3.erase(s3.begin());\n            } else {\n                s2.insert(num);\n                sum += num;\n            }\n            int eraseVal = q.front();\n            q.pop();\n            if (s1.count(eraseVal)) {\n                s1.erase(s1.find(eraseVal));\n                s1.insert(*s2.begin());\n                sum -= *s2.begin();\n                s2.erase(s2.begin());\n            } else if (s3.count(eraseVal)) {\n                s3.erase(s3.find(eraseVal));\n                s3.insert(*s2.rbegin());\n                sum -= *s2.rbegin();\n                s2.erase(prev(s2.end()));\n            } else {\n                s2.erase(s2.find(eraseVal));\n                sum -= eraseVal;\n            }\n        }\n    }\n    void print(string title) {\n        cout << \"===\" << title << \"===\" << endl;\n        cout << \"sum = \" << sum << endl;\n        cout << \"s1 : \";\n        for (auto &num : s1) cout << num << \", \";\n        cout << endl;\n        cout << \"s2 : \";\n        for (auto &num : s2) cout << num << \", \";\n        cout << endl;\n        cout << \"s3 : \";\n        for (auto &num : s3) cout << num << \", \";\n        cout << endl;\n    }\n};",
            "date": 1673971200000
        },
        {
            "script": "rust",
            "time": 64,
            "memory": 35.1,
            "desc": "同上。",
            "code": "use std::collections::BTreeMap;\nuse std::collections::VecDeque;\n\nstruct MulitSet<T: Ord + Copy + Clone> {\n    length: usize,\n    tree: BTreeMap<T, usize>,\n}\nimpl<T: Ord + Copy + Clone> MulitSet<T> {\n    fn new() -> Self {\n        MulitSet {\n            length: 0,\n            tree: BTreeMap::new(),\n        }\n    }\n    fn contains(&self, k: &T) -> bool {\n        self.tree.contains_key(k)\n    }\n    fn len(&self) -> usize {\n        self.length\n    }\n    fn insert(&mut self, key: T) {\n        *self.tree.entry(key).or_insert(0) += 1;\n        self.length += 1;\n    }\n    fn remove(&mut self, key: &T) {\n        let item = self.tree.get_mut(&key).unwrap();\n        if *item > 1 {\n            *item -= 1;\n        } else {\n            self.tree.remove(key);\n        }\n        self.length -= 1;\n    }\n    fn peek_first(&mut self) -> T {\n        *self.tree.iter().next().unwrap().0\n    }\n    fn peek_last(&mut self) -> T {\n        *self.tree.iter().rev().next().unwrap().0\n    }\n    fn pop_first(&mut self) -> T {\n        let key = self.peek_first();\n        self.remove(&key);\n        key\n    }\n    fn pop_last(&mut self) -> T {\n        let key = self.peek_last();\n        self.remove(&key);\n        key\n    }\n}\nstruct MKAverage {\n    m: i32,\n    k: i32,\n    sum: i64,\n    q: VecDeque<i32>,\n    s1: MulitSet<i32>,\n    s2: MulitSet<i32>,\n    s3: MulitSet<i32>,\n}\nimpl MKAverage {\n    fn new(m: i32, k: i32) -> Self {\n        Self {\n            m,\n            k,\n            sum: 0,\n            q: VecDeque::new(),\n            s1: MulitSet::<i32>::new(),\n            s2: MulitSet::<i32>::new(),\n            s3: MulitSet::<i32>::new(),\n        }\n    }\n\n    fn calculate_mk_average(&self) -> i32 {\n        if (self.q.len() as i32) < self.m {\n            -1\n        } else {\n            (self.sum / (self.m - 2 * self.k) as i64) as i32\n        }\n    }\n\n    fn add_element(&mut self, num: i32) {\n        let m = self.m as usize;\n        let k = self.k as usize;\n        self.q.push_back(num);\n        if self.q.len() <= m {\n            self.s2.insert(num);\n            self.sum += num as i64;\n            if self.q.len() == m {\n                for _ in 0..k {\n                    let num = self.s2.pop_last();\n                    self.sum -= num as i64;\n                    self.s3.insert(num);\n\n                    let num = self.s2.pop_first();\n                    self.sum -= num as i64;\n                    self.s1.insert(num);\n                }\n            }\n        } else {\n            if num < self.s2.peek_first() {\n                self.s1.insert(num);\n                self.sum += self.s1.peek_last() as i64;\n                self.s2.insert(self.s1.pop_last());\n            } else if num >= self.s3.peek_first() {\n                self.s3.insert(num);\n                self.sum += self.s3.peek_first() as i64;\n                self.s2.insert(self.s3.pop_first());\n            } else {\n                self.sum += num as i64;\n                self.s2.insert(num);\n            }\n            let pop_value = self.q.pop_front().unwrap();\n            if self.s1.contains(&pop_value) {\n                self.s1.remove(&pop_value);\n                self.sum -= self.s2.peek_first() as i64;\n                self.s1.insert(self.s2.pop_first());\n            } else if self.s3.contains(&pop_value) {\n                self.s3.remove(&pop_value);\n                self.sum -= self.s2.peek_last() as i64;\n                self.s3.insert(self.s2.pop_last());\n            } else {\n                self.sum -= pop_value as i64;\n                self.s2.remove(&pop_value);\n            }\n        }\n    }\n}",
            "date": 1673971200000
        },
        {
            "script": "python3",
            "time": 1748,
            "memory": 45.4,
            "desc": "同上。",
            "code": "from queue import Queue\nfrom sortedcontainers import SortedList\nclass MKAverage:\n    def __init__(self, m: int, k: int):\n        self.m = m\n        self.k = k\n        self.sum = 0\n        self.q = Queue()\n        self.s1 = SortedList()\n        self.s2 = SortedList()\n        self.s3 = SortedList()\n\n    def calculateMKAverage(self) -> int:\n        if self.q.qsize() < self.m:\n            return -1\n        else:\n            return self.sum // (self.m - self.k * 2)\n\n    def addElement(self, num: int) -> None:\n        self.q.put(num)\n        if self.q.qsize() <= self.m:\n            self.s2.add(num)\n            self.sum += num\n            if self.q.qsize() == self.m:\n                for _ in range(self.k):\n                    self.sum -= self.s2[-1]\n                    self.s3.add(self.s2.pop())\n\n                    self.sum -= self.s2[0]\n                    self.s1.add(self.s2.pop(0))\n        else:\n            if num < self.s2[0]:\n                self.s1.add(num)\n                self.sum += self.s1[-1]\n                self.s2.add(self.s1.pop())\n            elif num >= self.s3[0]:\n                self.s3.add(num)\n                self.sum += self.s3[0]\n                self.s2.add(self.s3.pop(0))\n            else:\n                self.sum += num\n                self.s2.add(num)\n            removeVal = self.q.get()\n            if self.s1.count(removeVal):\n                self.s1.discard(removeVal)\n                self.sum -= self.s2[0]\n                self.s1.add(self.s2.pop(0))\n            elif self.s3.count(removeVal):\n                self.s3.discard(removeVal)\n                self.sum -= self.s2[-1]\n                self.s3.add(self.s2.pop())\n            else:\n                self.sum -= removeVal\n                self.s2.discard(removeVal)",
            "date": 1673971200000
        }
    ]
}