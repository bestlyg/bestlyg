{
    "id": "1799",
    "name": "1681.最小不兼容性",
    "url": "https://leetcode.cn/problems/minimum-incompatibility",
    "desc": "给你一个整数数组 nums​​​ 和一个整数 k 。你需要将这个数组划分到 k 个相同大小的子集中，使得同一个子集里面没有两个相同的元素。一个子集的 不兼容性 是该子集里面最大值和最小值的差。请你返回将数组分成 k 个子集后，各子集 不兼容性 的 和 的 最小值 ，如果无法分成分成 k 个子集，返回 -1 。",
    "solutions": [
        {
            "script": "cpp",
            "time": 1852,
            "memory": 303.8,
            "desc": "状态压缩+记忆化搜索。",
            "code": "#define MAX 8\nclass Solution {\npublic:\n    int minimumIncompatibility(vector<int>& nums, int k) {\n        int n = nums.size(), m[17] = {0};\n        for (auto &num : nums) {\n            m[num]++;\n            if (m[num] > k) return -1;\n        }\n        if (k == n) return 0;\n        sort(nums.begin(), nums.end());\n\n        // cout << \"nums : \";\n        // for (auto &num : nums) cout << num << \", \";\n        // cout << endl;\n\n        // int dp[k + 1][1 << n];\n        // memset(dp, 0, sizeof(dp));\n        // for (int i = 1; i <= k; i++) {\n        //     int res = 0x3f3f3f3f;\n        // }\n\n        // return dp[k][1 << n];\n\n        unordered_map<int, unordered_map<int, int>> cache;\n        function<int(int, int)> dfs = [&](int cur, int used) {\n            // cout << \"==> cur = \" << cur << \", used = \" << bitset<MAX>(used).to_string() << endl;\n            if (cur == k) return 0;\n            if (cache[cur][used]) return cache[cur][used];\n            // cout << \"in\" << endl;\n            int res = 0x3f3f3f3f;\n            auto lists = comp(n / k, n, used, nums);\n\n            // cout << \"lists = \";\n            // for (auto &list : lists) {\n            //     cout << \"[\";\n            //     for (auto &num : list) {\n            //         cout << num << \", \";\n            //     }\n            //     cout << \"], \";\n            // }\n            // cout << endl;\n\n            for (auto &list : lists) {\n                int next_used = used, nmin = INT_MAX, nmax = INT_MIN;\n                for (auto &i : list) {\n                    nmin = min(nmin, nums[i]);\n                    nmax = max(nmax, nums[i]);\n                    next_used |= 1 << i;\n                }\n                auto next = dfs(cur + 1, next_used);\n                // cout << \"nmin = \" << nmin << \", nmax = \" << nmax << endl;\n                // cout << \"res = \" << res << \", dfs = \" << next << endl;\n                res = min(res,  next + nmax - nmin);\n            }\n\n            // cout << \"==> cur = \" << cur << \", used = \" << bitset<MAX>(used).to_string() << \", res = \" << res << endl;\n\n            return cache[cur][used] = res;\n        };\n        return dfs(0, 0);\n    }\n    vector<vector<int>> comp(int cnt, int total, int used, vector<int>& nums) {\n        // cout << \"comp \" << cnt << \", \" << total << \", \" << bitset<MAX>(used).to_string() << endl;\n\n        vector<vector<int>> res;\n        vector<int> list;\n        function<void(int, int)> dfs = [&](int idx, int sum) {\n\n            // cout << \"dfs \" << idx << \", \" << sum << \", list = \";\n            // for (auto &item : list) cout << item << \", \";\n            // cout << endl;\n\n            if (total - idx < sum) return;\n            else if (sum == 0) res.push_back(list);\n            else {\n                int cur_num = nums[idx];\n                bool is_used = used & (1 << idx);\n                if (!is_used) {\n                    list.push_back(idx);\n\n                    int next_idx = idx + 1;\n                    while (next_idx < total && nums[next_idx] == nums[idx]) next_idx++;\n                    dfs(next_idx, sum - 1);\n\n                    list.pop_back();\n                }\n\n                int next_idx = idx + 1;\n                while (next_idx < total && nums[idx] == nums[next_idx] && !is_used) next_idx++;\n                dfs(next_idx, sum);\n            }\n        };\n        dfs(0, cnt);\n        return res;\n    }\n};",
            "date": "2023-06-28"
        }
    ],
    "tagList": ["位运算", "数组", "动态规划", "状态压缩"],
    "level": "Hard"
}
