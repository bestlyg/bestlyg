{
    "id": "1753",
    "name": "1631.最小体力消耗路径",
    "url": "https://leetcode.cn/problems/path-with-minimum-effort",
    "difficulty": "中等",
    "tag": [
        "深度优先搜索",
        "广度优先搜索",
        "并查集",
        "数组",
        "二分查找",
        "矩阵",
        "堆（优先队列）"
    ],
    "desc": "一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。请你返回从左上角走到右下角的最小 体力消耗值 。",
    "solutions": [
        {
            "date": 1611849600000,
            "script": "typescript",
            "time": 352,
            "memory": 46.7,
            "desc": "二分。",
            "code": "var minimumEffortPath = function(heights) {\nconst dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n\nconst m = heights.length, n = heights[0].length;\nlet left = 0, right = 999999, ans = 0;\nwhile (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    const queue = [[0, 0]];\n    const seen = new Array(m * n).fill(0);\n    seen[0] = 1;\n    while (queue.length) {\n        const [x, y] = queue.shift();\n        for (let i = 0; i < 4; i++) {\n            const nx = x + dirs[i][0];\n            const ny = y + dirs[i][1];\n            if (nx >= 0 && nx < m && ny >= 0 && ny < n && !seen[nx * n + ny] && Math.abs(heights[x][y] - heights[nx][ny]) <= mid) {\n                queue.push([nx, ny]);\n                seen[nx * n + ny] = 1;\n            }\n        }\n    }\n    if (seen[m * n - 1]) {\n        ans = mid;\n        right = mid - 1;\n    } else {\n        left = mid + 1;\n    }\n}\nreturn ans;\n};"
        },
        {
            "script": "python",
            "time": 36,
            "memory": 16.67,
            "desc": "二分。",
            "code": "dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\nclass Solution:\n    def minimumEffortPath(self, heights: List[List[int]]) -> int:\n        n, m = len(heights), len(heights[0])\n        def check(val: int) -> bool:\n            q = deque([(0, 0)])\n            used = [[False] * m for _ in range(n)]\n            used[0][0] = True\n            while q:\n                i, j = q.popleft()\n                if i == n - 1 and j == m - 1: return True\n                for dir in dirs:\n                    ni = i + dir[0]\n                    nj = j + dir[1]\n                    if 0 <= ni < n and 0 <= nj < m and not used[ni][nj] and abs(heights[ni][nj] - heights[i][j]) <= val:\n                        q.append((ni, nj))\n                        used[ni][nj] = True\n            return False\n\n        l, r = 0, 10 ** 6\n        while l < r:\n            mid = (l + r) // 2\n            if check(mid): r = mid\n            else: l = mid + 1\n        return l",
            "date": 1702224000000
        }
    ]
}