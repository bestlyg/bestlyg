{
    "name": "935.骑士拨号器",
    "url": "https://leetcode.cn/problems/knight-dialer",
    "level": "Medium",
    "tagList": [
        "动态规划"
    ],
    "desc": "你可以将骑士放置在任何数字单元格上，然后你应该执行 n - 1 次移动来获得长度为 n 的号码。所有的跳跃应该是有效的骑士跳跃。",
    "solutions": [
        {
            "time": 59,
            "memory": 27.67,
            "desc": "dfs",
            "code": "dirs = [[1, -2], [1, 2], [2, -1], [2, 1], [-1, -2], [-1, 2], [-2, -1], [-2, 1]]\nget_pos = lambda num: ((num - 1) // 3, (num - 1) % 3) if num != 0 else (3, 1)\nget_num = lambda x, y: 0 if x == 3 and y == 1 else x * 3 + y + 1\nmod = 10 ** 9 + 7\n@cache\ndef baseKnightDialer(num: int, cnt: int) -> int:\n    if cnt == 0: return 1\n    x, y = get_pos(num)\n    res = 0\n    for dir in dirs:\n        nx = x + dir[0]\n        ny = y + dir[1]\n        if 0 <= nx < 3 and 0 <= ny < 3 or nx == 3 and ny == 1:\n            res += baseKnightDialer(get_num(nx, ny), cnt - 1)\n    return res % mod\nclass Solution:\n    def knightDialer(self, n: int) -> int:\n        return sum(baseKnightDialer(i, n - 1) for i in range(10)) % mod",
            "date": "2024-12-10"
        }
    ],
    "id": "972"
}