{
    "name": "907.子数组的最小值之和",
    "url": "https://leetcode.cn/problems/sum-of-subarray-minimums/",
    "difficulty": "中等",
    "tag": [
        "栈",
        "数组",
        "动态规划",
        "单调栈"
    ],
    "desc": "给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。",
    "solutions": [
        {
            "date": 1666886400000,
            "time": 104,
            "memory": 41.3,
            "script": "cpp",
            "desc": "单调栈，统计每个点第一个左边大的数，和第二个右边大的数，统计左边数量+右边数量+左右交叉数量。",
            "code": "class Solution {\npublic:\n    const int mod = 1e9 + 7;\n    int sumSubarrayMins(vector<int>& arr) {\n        int n = arr.size();\n        long long ans = 0;\n        vector<int> l(n, -1), r(n, n);\n        stack<int> s;\n        for (int i = 0; i < n; i++) {\n            while (s.size() && arr[s.top()] > arr[i]) r[s.top()] = i, s.pop();\n            if (s.size()) l[i] = s.top();\n            s.push(i);\n        }\n        for (int i = 0; i < n; i++) {\n            int left = i - l[i] - 1, right = r[i] - i - 1;\n            ans = (ans +(static_cast<long long>(left) + right + left * right + 1) * arr[i]) % mod;\n        }\n        return ans;\n    }\n};"
        }
    ]
}