---
title: 310. 最小高度树
order: 310
nav:
  title: 力扣题解
  path: /leetcode
  order: 4
group:
  title: 301-400
  path: /301-400
  order: 301
---

# 310. 最小高度树
    
> 链接：[310. 最小高度树](https://leetcode-cn.com/problems/minimum-height-trees/)  
> 难度：中等  
> 标签：深度优先搜索、广度优先搜索、图、拓扑排序  
> 简介：请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。
      
## 题解 1 - c++
- 编辑时间：2022.03.14
- 执行用时：180ms
- 内存消耗：77.6MB
- 编程语言：c++
- 解法介绍：从所有叶子节点开始遍历，由外到内。
```c++
class Solution {
   public:
    struct node {
        int idx, cnt;
        unordered_set<int> chilren;
    };
    vector<int> findMinHeightTrees(int n, vector<vector<int>> &edges) {
        if (n == 1) return vector(1, 0);
        vector<node> list(n);
        for (int i = 0; i < n; i++) {
            list[i].idx = i;
            list[i].cnt = 0;
        }
        for (auto &edge : edges) {
            int n1 = edge[0], n2 = edge[1];
            list[n1].cnt++;
            list[n2].cnt++;
            list[n1].chilren.insert(n2);
            list[n2].chilren.insert(n1);
        }
        queue<int> q;
        for (int i = 0; i < n; i++) {
            if (list[i].cnt == 1) q.push(i);
        }
        vector<int> ans;
        while (q.size()) {
            ans.clear();
            int size = q.size();
            for (int i = 0; i < size; i++) {
                int node = q.front();
                q.pop();
                ans.push_back(node);
                list[node].cnt--;
                for (auto &child : list[node].chilren) {
                    list[child].cnt--;
                    if (list[child].cnt == 1) q.push(child);
                }
            }
        }
        return ans;
    }
};
```

      