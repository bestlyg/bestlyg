---
title: 432. 全 O(1) 的数据结构
order: 432
nav:
  title: 力扣题解
  path: /leetcode
  order: 4
group:
  title: 401-500
  path: /401-500
  order: 401
---

# 432. 全 O(1) 的数据结构
    
> 链接：[432. 全 O(1) 的数据结构](https://leetcode-cn.com/problems/all-oone-data-structure/)  
> 难度：困难  
> 标签：设计、哈希表、链表、双向链表  
> 简介：请你设计一个用于存储字符串计数的数据结构，并能够返回计数最小和最大的字符串。
      
## 题解 1 - c++
- 编辑时间：2022.03.16
- 执行用时：136ms
- 内存消耗：55.9MB
- 编程语言：c++
- 解法介绍：利用哈希删查O1，链表增删O1来维护结构。
```c++
class VNode {
   public:
    int cnt;
    string value;
    VNode(string _value) {
        value = _value;
        cnt = 1;
    }
};
class CNode {
   public:
    int value;
    CNode *prev, *next;
    unordered_set<VNode *> children;
    CNode(int _value, CNode *_prev = NULL) {
        value = _value;
        prev = _prev;
        next = NULL;
        if (prev) {
            insert(prev);
        }
    }
    void insert(CNode *prev) {
        CNode *next = prev->next;
        prev->next = this;
        next->prev = this;
        this->next = next;
        this->prev = prev;
    };
    void remove() {
        if (prev) prev->next = next;
        if (next) next->prev = prev;
        prev = NULL;
        next = NULL;
    };
};
class AllOne {
   public:
    unordered_map<string, VNode *> vmap;
    unordered_map<int, CNode *> cmap;
    // first min | last max
    CNode *first = new CNode(-1), *last = new CNode(-1);
    void
    log() { /*
    cout << "======START LOG=====" << endl;
    cout << "CNode : first -> ";
    CNode *p = first->next;
    while (p != last) {
        cout << "(" << p->prev->value << ", " << p->value << ", "
             << p->next->value << ") -> ";
        p = p->next;
    }
    cout << "last" << endl;

    cout << "VMap" << endl;
    for (auto &it : vmap) {
        cout << "(" << it.first << ", " << it.second->cnt << ")" << endl;
    }

    cout << "CMap" << endl;
    for (auto &it : cmap) {
        cout << "(" << it.first << ", " << it.second->children.size() << ")"
             << endl;
    }
    cout << "======END LOG=====" << endl;*/
    }
    AllOne() {
        first->next = last;
        last->prev = first;
    }
    /*
    ~AllOne() {
        last = NULL;
        CNode *p = first;
        while (p) {
            CNode *cur = p;
            p = p->next;
            cur->remove();
            delete cur;
        }
    }
    */
    void inc(string key) {
        // cout << "inc " << key << endl;
        if (vmap.count(key))
            inc_key(key);
        else
            inc_nokey(key);
        log();
    }
    // 增加key且当前存在
    void inc_key(string key) {
        VNode *vnode = vmap[key];
        CNode *cnode = cmap[vnode->cnt];
        cnode->children.erase(vnode);
        if (cnode->children.size() == 0) {
            CNode *prev = cnode->prev;
            cnode->remove();
            cmap.erase(cnode->value);
            delete cnode;
            cnode = prev;
        }
        vnode->cnt += 1;
        if (cnode->next->value == vnode->cnt) {
            cnode->next->children.insert(vnode);
        } else {
            CNode *cnode_next = new CNode(vnode->cnt, cnode);
            cnode_next->children.insert(vnode);
            cmap[vnode->cnt] = cnode_next;
        }
    }
    // 增加key且当前不存在
    void inc_nokey(string key) {
        VNode *vnode = new VNode(key);
        vmap[key] = vnode;
        CNode *cnode =
            first->next->value == 1 ? cmap[1] : (cmap[1] = new CNode(1, first));
        cnode->children.insert(vnode);
    }
    void dec(string key) {
        // cout << "dec " << key << endl;
        if (vmap[key]->cnt == 1) {
            dec_nokey(key);
        } else {
            dec_key(key);
        }
        log();
    }
    // 减少key且当前存在
    void dec_key(string key) {
        VNode *vnode = vmap[key];
        CNode *cnode = cmap[vnode->cnt], *prev = cnode->prev;
        cnode->children.erase(vnode);
        if (cnode->children.size() == 0) {
            cnode->remove();
            cmap.erase(vnode->cnt);
            delete cnode;
        }
        if (prev != first && prev->value == vnode->cnt - 1) {
            prev->children.insert(vnode);
        } else {
            CNode *cnode_new = new CNode(vnode->cnt - 1, prev);
            cmap[vnode->cnt - 1] = cnode_new;
            cnode_new->children.insert(vnode);
        }
        vnode->cnt -= 1;
    }
    // 减少key且当前不存在
    void dec_nokey(string key) {
        VNode *vnode = vmap[key];
        CNode *cnode = cmap[vnode->cnt];
        cnode->children.erase(vnode);
        if (cnode->children.size() == 0) {
            cnode->remove();
            cmap.erase(vnode->cnt);
            delete cnode;
        }
        vmap.erase(vnode->value);
        delete vnode;
    }
    string getMaxKey() {
        if (first->next == last) return "";
        auto it = last->prev->children.begin();
        return (*it)->value;
    }

    string getMinKey() {
        if (first->next == last) return "";
        auto it = first->next->children.begin();
        return (*it)->value;
    }
};
```

      