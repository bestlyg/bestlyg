---
title: 427. 建立四叉树
order: 427
nav:
  title: 力扣题解
  path: /leetcode
  order: 4
group:
  title: 401-500
  path: /401-500
  order: 401
---

# 427. 建立四叉树
    
> 链接：[427. 建立四叉树](https://leetcode-cn.com/problems/construct-quad-tree/)  
> 难度：中等  
> 标签：树、数组、分治、矩阵  
> 简介：你需要返回能表示矩阵的 四叉树 的根结点。
      
## 题解 1 - cpp
- 编辑时间：2022.04.29
- 执行用时：24ms
- 内存消耗：23.7MB
- 编程语言：cpp
- 解法介绍：dfs。
```cpp
class Solution {
   public:
    Node *construct(vector<vector<int>> &grid) {
        int n = grid.size(), check;
        return dfs(grid, 0, n - 1, 0, n - 1, &check);
    }
    Node *dfs(vector<vector<int>> &grid, int srow, int erow, int scol, int ecol,
              int *check) {
        if (srow == erow && scol == ecol) {
            *check = 1;
            return getNode(grid[srow][scol], true);
        }
        int mrow = (erow + srow) >> 1, mcol = (ecol + scol) >> 1;
        int checkTL, checkTR, checkBL, checkBR;
        Node *tl = dfs(grid, srow, mrow, scol, mcol, &checkTL),
             *tr = dfs(grid, srow, mrow, mcol + 1, ecol, &checkTR),
             *bl = dfs(grid, mrow + 1, erow, scol, mcol, &checkBL),
             *br = dfs(grid, mrow + 1, erow, mcol + 1, ecol, &checkBR);
        if (tl->val == tr->val && tl->val == bl->val && tl->val == br->val &&
            checkTL & checkTR & checkBL & checkBR) {
            *check = 1;
            int val = tl->val;
            free(tl);
            free(tr);
            free(bl);
            free(br);
            return getNode(val, true);
        }
        Node *node = getNode(tl->val ^ tr->val ^ bl->val ^ br->val, false);
        *check = 0;
        node->topLeft = tl;
        node->topRight = tr;
        node->bottomLeft = bl;
        node->bottomRight = br;
        return node;
    }
    Node *getNode(bool val, bool isLeaf) {
        Node *node = (Node *)malloc(sizeof(Node));
        node->isLeaf = isLeaf;
        node->val = val;
        node->topLeft = node->topRight = node->bottomLeft = node->bottomRight =
            nullptr;
        return node;
    }
};
```

      