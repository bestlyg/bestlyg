---
title: 449. 序列化和反序列化二叉搜索树
order: 449
nav:
  title: 力扣题解
  path: /leetcode
  order: 4
group:
  title: 401-500
  path: /401-500
  order: 401
---

# 449. 序列化和反序列化二叉搜索树

> 链接：[449. 序列化和反序列化二叉搜索树](https://leetcode-cn.com/problems/serialize-and-deserialize-bst/)  
> 难度：中等  
> 标签：树、深度优先搜索、广度优先搜索、设计、二叉搜索树、字符串、二叉树  
> 简介：给你一棵二叉树，它的根为 root 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。 。

## 题解 1 - typescript

- 编辑时间：2021.08.14
- 执行用时：108ms
- 内存消耗：46.1MB
- 编程语言：typescript
- 解法介绍：JSON 序列化。

```typescript
function serialize(root: TreeNode | null): string {
  return JSON.stringify(root);
}
function deserialize(data: string): TreeNode | null {
  return JSON.parse(data);
}
```
## 题解 2 - cpp
- 编辑时间：2022.05.11
- 执行用时：64ms
- 内存消耗：45.7MB
- 编程语言：cpp
- 解法介绍：递归。
```cpp
class Codec {
   public:
    string serialize(TreeNode *root) {
        if (root == nullptr) return "(-1)";
        return "(" + to_string(root->val) + "," + serialize(root->left) + "," +
               serialize(root->right) + ")";
    }
    TreeNode *deserialize(string data) {
        if (data == "(-1)") return nullptr;
        string l, r;
        int val = analysis(data, l, r);
        TreeNode *ans = new TreeNode(val);
        ans->left = deserialize(l);
        ans->right = deserialize(r);
        return ans;
    }
    int analysis(string &data, string &l, string &r) {
        int level = 0, n = data.size(), val;
        int i = 0, prev = 1, cnt = 0;
        for (; i < n; i++) {
            int ch = data[i];
            if (ch == '(') {
                level++;
            } else if (ch == ')') {
                level--;
            } else if (ch == ',' && level == 1) {
                string substr = data.substr(prev, i - prev);
                if (cnt == 0)
                    val = stoi(substr);
                else if (cnt == 1)
                    l = substr;
                cnt++;
                prev = i + 1;
            }
        }
        r = data.substr(prev, i - prev - 1);
        return val;
    }
};
```
