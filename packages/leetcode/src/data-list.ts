export const DATA_LIST = [{"dirName":"1-100","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\1-100","problems":[{"problemName":"1.两数之和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/1.两数之和.json","problemData":{"id":"1","name":"1.两数之和","url":"https://leetcode.cn/problems/two-sum","desc":"给定一个整数数组 nums  和一个目标值 target，请你在该数组中找出和为目标值的那   两个   整数，并返回他们的数组下标。","solutions":[{"date":"2019-09-15","time":232,"memory":34.8,"script":"javascript","desc":"获取第一个 num 值后，用 target 减去求出对应值，使用 indexOf 判断该对应值是否在数组里。","code":"var twoSum = function (nums, target) {\n  for (let i = 0; i < nums.length; i++) {\n    num1 = nums[i];\n    num2 = target - nums[i];\n    result = nums.indexOf(num2);\n    if (result > -1 && result !== i) {\n      return [i, result];\n    }\n  }\n};"},{"date":"2019-09-15","time":68,"memory":35.2,"script":"javascript","desc":"获取第一个 num 值后，判断该值是否存在 map 表中，若存在则说明有匹配项直接返回，若不存在则储存。","code":"var twoSum = function (nums, target) {\n  let map = new Map();\n  for (let i = 0; i < nums.length; i++) {\n    if (map.has(nums[i])) {\n      return [i, map.get(nums[i])];\n    }\n    map.set(target - nums[i], i);\n  }\n};"},{"date":"2020-10-03","time":84,"memory":40.2,"script":"typescript","desc":"哈希储存下一值。","code":"function twoSum(nums: number[], target: number): number[] {\n  const cache = new Map<number, number>();\n  for (let i = 0, l = nums.length; i < l; i++) {\n    const num = nums[i];\n    const nextI = cache.get(num);\n    if (nextI !== undefined) return [nextI, i];\n    const nextNum = target - num;\n    cache.set(nextNum, i);\n  }\n  return [];\n}"},{"date":"2021-07-22","time":84,"memory":40.2,"script":"typescript","desc":"二分查找。","code":"function twoSum(nums: number[], target: number): number[] {\n  const list = new Array(nums.length)\n    .fill(0)\n    .map((_, i) => i)\n    .sort((a, b) => nums[a] - nums[b]);\n  for (let i = 0; i < nums.length; i++) {\n    const num = nums[list[i]];\n    const i2 = search(target - num, i + 1);\n    if (i2 !== -1) return [list[i], list[i2]];\n  }\n  return [];\n  function search(target: number, l: number): number {\n    let r = nums.length - 1;\n    while (l <= r) {\n      const mid = (l + r) >> 1;\n      const midNum = nums[list[mid]];\n      if (midNum < target) l = mid + 1;\n      else if (midNum > target) r = mid - 1;\n      else return mid;\n    }\n    return -1;\n  }\n}"},{"date":"2021-11-30","time":8,"memory":6.3,"script":"c","desc":"创建下标数组后排序后二分。","code":"int *gnums;\nint comp(const void *a, const void *b){\n    return gnums[(*(int *)a)] - gnums[(*(int *)b)];\n}\nint bs(int *arr, int numsSize, int start, int num){\n    int m, l = start, r = numsSize - 1;\n    if (gnums[arr[l]] > num || gnums[arr[r]] < num) return -1;\n    while (l < r) {\n        m = (l + r) >> 1;\n        if (gnums[arr[m]] == num) {\n            l = m;\n            break;\n        }\n        if (gnums[arr[m]] > num) r = m - 1;\n        else l = m + 1;\n    }\n    return gnums[arr[l]] == num ? l : -1;\n}\nint* twoSum(int* nums, int numsSize, int target, int* returnSize){\n    gnums = nums;\n    *returnSize = 2;\n    int *ans = (int *)malloc(sizeof(int) * 2);\n    int arr[numsSize];\n    for(int i = 0; i < numsSize; i++) arr[i] = i;\n    qsort(arr, numsSize, sizeof(int), comp);\n    for(int i = 0; i < numsSize; i++) {\n        int num1 = nums[arr[i]], num2 = target - num1;\n        int num2idx = bs(arr, numsSize, i + 1, num2);\n        if (num2idx == -1) continue;\n        if (arr[i] > num2idx) {\n            ans[0] = arr[num2idx];\n            ans[1] = arr[i];\n        } else {\n            ans[1] = arr[num2idx];\n            ans[0] = arr[i];\n        }\n        break;\n    }\n    return ans;\n}"},{"date":"2021-12-20","time":4,"memory":10.4,"script":"cpp","desc":"哈希存储。","code":"class Solution {\n   public:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> m;\n        vector<int> ans;\n        for (int i = 0; i < nums.size(); i++) {\n            int num = nums[i];\n            if (m.count(target - num)) {\n                ans.push_back(m[target - num]);\n                ans.push_back(i);\n                return ans;\n            } else {\n                m[num] = i;\n            }\n        }\n        return ans;\n    }\n};"},{"script":"python","time":32,"memory":16,"desc":"哈希。","code":"class Solution:\ndef twoSum(self, nums: List[int], target: int) -> List[int]:\n    m = defaultdict()\n    for i, num in enumerate(nums):\n        if target - num in m:\n            return [m[target- num], i]\n        m[num] = i\n    return []","date":"2023-01-21"},{"script":"rust","time":0,"memory":2.4,"desc":"同上。","code":"impl Solution {\n    pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {\n        let mut m = std::collections::HashMap::<i32, usize>::new();\n        for i in 0..nums.len() {\n            match m.get_mut(&(target - nums[i])) {\n                Some(prev) => return vec![*prev as i32, i as i32],\n                None => {\n                    m.insert(nums[i], i);\n                }\n            }\n        }\n        vec![]\n    }\n}","date":"2023-07-01"}],"tagList":["数组","哈希表"],"level":"Easy"}},{"problemName":"10.正则表达式匹配.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/10.正则表达式匹配.json","problemData":{"id":"10","name":"10.正则表达式匹配","url":"https://leetcode.cn/problems/regular-expression-matching","desc":"给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '\\*' 的正则表达式匹配。","solutions":[{"date":"2020-04-12","time":92,"memory":34.5,"script":"javascript","desc":"直接偷懒用新建正则判断。","code":"/**\n * @param {string} s\n * @param {string} p\n * @return {boolean}\n */\nvar isMatch = (s, p) => new RegExp(`^${p}$`).test(s);"}],"tagList":["递归","字符串","动态规划"],"level":"Hard"}},{"problemName":"100.相同的树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/100.相同的树.json","problemData":{"id":"100","name":"100.相同的树","url":"https://leetcode.cn/problems/same-tree","desc":"给定两个二叉树，编写一个函数来检验它们是否相同。","solutions":[{"date":"2020-08-07","time":88,"memory":38.1,"script":"typescript","desc":"序列化后比较字符串即可。","code":"function isSameTree(p: TreeNode | null, q: TreeNode | null): boolean {\n  return serialize(p) === serialize(q);\n  function serialize(node: TreeNode | null): string {\n    const queue = [node];\n    const hasNum = () => queue.some(v => v !== null);\n    let str = '';\n    while (hasNum()) {\n      const node = queue.shift() as TreeNode | null;\n      if (node === null) {\n        str += 'null,';\n        continue;\n      } else {\n        str += node.val + ',';\n      }\n      if (node.left !== null) queue.push(node.left);\n      else queue.push(null);\n      if (node.right !== null) queue.push(node.right);\n      else queue.push(null);\n    }\n    return `[${str.substr(0, str.length - 1)}]`;\n  }\n}"},{"date":"2021-11-27","time":0,"memory":5.7,"script":"c","desc":"递归。","code":"bool isSameTree(struct TreeNode* p, struct TreeNode* q){\n    // 同为NULL则相同\n    if (p == NULL && q == NULL) return 1;\n    // 若其中一个为NULL或者值不一样就不同,\n    if (p == NULL || q == NULL || p->val != q->val) return 0;\n    // 否则递归子树\n    return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n}"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉树"],"level":"Easy"}},{"problemName":"11.盛最多水的容器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/11.盛最多水的容器.json","problemData":{"id":"11","name":"11.盛最多水的容器","url":"https://leetcode.cn/problems/container-with-most-water","desc":"给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点  (i, ai) 。在坐标内画 n 条垂直线，垂直线 i  的两个端点分别为  (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与  x  轴共同构成的容器可以容纳最多的水。","solutions":[{"date":"2020-04-12","time":956,"memory":35.8,"script":"javascript","desc":"双重循环。","code":"/**\n * @param {number[]} height\n * @return {number}\n */\nvar maxArea = function (height) {\n  let res;\n  for (let i = 0; i < height.length; i++) {\n    for (let j = height.length - 1; j > i; j--) {\n      const area = (j - i) * Math.min(height[i], height[j]);\n      // console.log(`i=${i},j=${j},area=${area}`);\n      if (res === undefined || res < area) res = area;\n    }\n  }\n  return res;\n};"},{"date":"2021-05-07","time":96,"memory":47.2,"script":"typescript","desc":"双指针，向内移动。","code":"function maxArea(height: number[]): number {\n  let left = 0;\n  let right = height.length - 1;\n  let ans = 0;\n  while (left < right) {\n    const rightH = height[right];\n    const leftH = height[left];\n    ans = Math.max(ans, Math.min(rightH, leftH) * (right - left));\n    if (rightH > leftH) left++;\n    else right--;\n  }\n  return ans;\n}"}],"tagList":["贪心","数组","双指针"],"level":"Medium"}},{"problemName":"12.整数转罗马数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/12.整数转罗马数字.json","problemData":{"id":"12","name":"12.整数转罗马数字","url":"https://leetcode.cn/problems/integer-to-roman","desc":"给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。","solutions":[{"date":"2020-06-02","time":144,"memory":41.3,"script":"typescript","desc":"递归判断每一位。","code":"function intToRoman(num: number): string {\n  const len = (num + '').length;\n  let s = '';\n  switch (len) {\n    case 4: {\n      const n = ~~(num / 1000);\n      for (let i = 0; i < n; i++) s += 'M';\n      s += intToRoman(num % 1000);\n      break;\n    }\n    case 3: {\n      const n = ~~(num / 100);\n      switch (n) {\n        case 9: {\n          s += 'CM';\n          break;\n        }\n        case 8: {\n          s += 'DCCC';\n          break;\n        }\n        case 7: {\n          s += 'DCC';\n          break;\n        }\n        case 6: {\n          s += 'DC';\n          break;\n        }\n        case 5: {\n          s += 'D';\n          break;\n        }\n        case 4: {\n          s += 'CD';\n          break;\n        }\n        case 3: {\n          s += 'CCC';\n          break;\n        }\n        case 2: {\n          s += 'CC';\n          break;\n        }\n        case 1: {\n          s += 'C';\n          break;\n        }\n      }\n      s += intToRoman(num % 100);\n      break;\n    }\n    case 2: {\n      const n = ~~(num / 10);\n      switch (n) {\n        case 9: {\n          s += 'XC';\n          break;\n        }\n        case 8: {\n          s += 'LXXX';\n          break;\n        }\n        case 7: {\n          s += 'LXX';\n          break;\n        }\n        case 6: {\n          s += 'LX';\n          break;\n        }\n        case 5: {\n          s += 'L';\n          break;\n        }\n        case 4: {\n          s += 'XL';\n          break;\n        }\n        case 3: {\n          s += 'XXX';\n          break;\n        }\n        case 2: {\n          s += 'XX';\n          break;\n        }\n        case 1: {\n          s += 'X';\n          break;\n        }\n      }\n      s += intToRoman(num % 10);\n      break;\n    }\n    case 1: {\n      switch (num) {\n        case 9: {\n          s += 'IX';\n          break;\n        }\n        case 8: {\n          s += 'VIII';\n          break;\n        }\n        case 7: {\n          s += 'VII';\n          break;\n        }\n        case 6: {\n          s += 'VI';\n          break;\n        }\n        case 5: {\n          s += 'V';\n          break;\n        }\n        case 4: {\n          s += 'IV';\n          break;\n        }\n        case 3: {\n          s += 'III';\n          break;\n        }\n        case 2: {\n          s += 'II';\n          break;\n        }\n        case 1: {\n          s += 'I';\n          break;\n        }\n      }\n      break;\n    }\n  }\n  return s;\n}"},{"date":"2021-05-14","time":212,"memory":44.3,"script":"typescript","desc":"分节处理。","code":"const config: Map<number, Map<number, string>> = new Map([\n  [\n    100,\n    new Map([\n      [1, 'C'],\n      [5, 'D'],\n      [10, 'M'],\n    ]),\n  ],\n  [\n    10,\n    new Map([\n      [1, 'X'],\n      [5, 'L'],\n      [10, 'C'],\n    ]),\n  ],\n  [\n    1,\n    new Map([\n      [1, 'I'],\n      [5, 'V'],\n      [10, 'X'],\n    ]),\n  ],\n]);\nfunction intToRoman(num: number): string {\n  let ans = '';\n  if (num >= 1000) {\n    ans += 'M'.repeat(~~(num / 1000));\n    num = num % 1000;\n  }\n  for (const [val, map] of config) {\n    if (num < val) continue;\n    const c1 = map.get(1)!;\n    const c5 = map.get(5)!;\n    const c10 = map.get(10)!;\n    const c = ~~(num / val);\n    num = num % val;\n    if (c === 9) ans += c1 + c10;\n    else if (c >= 5) ans += c5 + c1.repeat(c - 5);\n    else if (c === 4) ans += c1 + c5;\n    else ans += c1.repeat(c);\n  }\n  return ans;\n}"},{"date":"2021-10-16","time":148,"memory":44.2,"script":"typescript","desc":"模拟。","code":"function intToRoman(num: number): string {\n  let ans = '';\n  const list: { val: number; template: [string, string, string] }[] = [\n    {\n      val: 1000,\n      template: ['M', 'M', 'M'],\n    },\n    {\n      val: 100,\n      template: ['M', 'D', 'C'],\n    },\n    {\n      val: 10,\n      template: ['C', 'L', 'X'],\n    },\n    {\n      val: 1,\n      template: ['X', 'V', 'I'],\n    },\n  ];\n  for (const { val, template } of list) {\n    if (num >= val) {\n      ans += createStr(Math.floor(num / val), ...template);\n      num %= val;\n    }\n  }\n  return ans;\n  function createStr(num: number, hight: string, mid: string, low: string) {\n    if (num <= 3) return low.repeat(num);\n    else if (num <= 5) return low.repeat(5 - num) + mid;\n    else if (num <= 8) return mid + low.repeat(num - 5);\n    else return low + hight;\n  }\n}"}],"tagList":["哈希表","数学","字符串"],"level":"Medium"}},{"problemName":"13.罗马数字转整数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/13.罗马数字转整数.json","problemData":{"id":"13","name":"13.罗马数字转整数","url":"https://leetcode.cn/problems/roman-to-integer","desc":"给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。","solutions":[{"date":"2020-06-02","time":192,"memory":42,"script":"typescript","desc":"特殊值进行特殊情况处理，为防止超标，在最后一位增加 0。","code":"function romanToInt(s: string): number {\n  const len = s.length;\n  const romans: {\n    [index: string]: number;\n  } = {\n    I: 1,\n    V: 5,\n    X: 10,\n    L: 50,\n    C: 100,\n    D: 500,\n    M: 1000,\n    N: 0,\n  };\n  s += 'N';\n  let num = 0;\n  let tempNum = 0;\n  let preRoman = '';\n  for (let i = 0; i < len; i++) {\n    const c = s[i];\n    switch (c) {\n      case 'C': {\n        if (preRoman === 'X') {\n          num += romans[(preRoman = c)] - tempNum;\n          tempNum = 0;\n        } else {\n          const n = romans[(preRoman = c)];\n          tempNum += n;\n          while (s[i + 1] === 'C') {\n            tempNum += n;\n            i++;\n          }\n          if (s[i + 1] !== 'D' && s[i + 1] !== 'M') {\n            num += tempNum;\n            tempNum = 0;\n          }\n        }\n        break;\n      }\n      case 'X': {\n        if (preRoman === 'I') {\n          num += romans[(preRoman = c)] - tempNum;\n          tempNum = 0;\n        } else {\n          const n = romans[(preRoman = c)];\n          tempNum += n;\n          while (s[i + 1] === 'X') {\n            tempNum += n;\n            i++;\n          }\n          if (s[i + 1] !== 'L' && s[i + 1] !== 'C') {\n            num += tempNum;\n            tempNum = 0;\n          }\n        }\n        break;\n      }\n      case 'I': {\n        const n = romans[(preRoman = c)];\n        tempNum += n;\n        while (s[i + 1] === 'I') {\n          tempNum += n;\n          i++;\n        }\n        if (s[i + 1] !== 'V' && s[i + 1] !== 'X') {\n          num += tempNum;\n          tempNum = 0;\n        }\n        break;\n      }\n      default: {\n        num += romans[(preRoman = c)] - tempNum;\n        tempNum = 0;\n      }\n    }\n  }\n  return num;\n}"},{"date":"2021-05-15","time":160,"memory":46.2,"script":"typescript","desc":"遍历。","code":"function romanToInt(s: string): number {\n  let ans = 0;\n  const scoreCache: Record<string, number> = {\n    M: 1000,\n    D: 500,\n    L: 50,\n    V: 5,\n  };\n  const specCache: Record<string, [string, string, number]> = {\n    C: ['D', 'M', 100],\n    X: ['L', 'C', 10],\n    I: ['V', 'X', 1],\n  };\n  for (let i = 0, l = s.length; i < l; i++) {\n    const c = s[i];\n    const data = specCache[c];\n    if (data) {\n      const [c1, c2, num] = data;\n      if (s[i + 1] === c1) {\n        i++;\n        ans += 4 * num;\n      } else if (s[i + 1] === c2) {\n        i++;\n        ans += 9 * num;\n      } else {\n        ans += 1 * num;\n      }\n    } else ans += scoreCache[c];\n  }\n  return ans;\n}"},{"date":"2021-12-20","time":4,"memory":5.9,"script":"cpp","desc":"遍历模拟。","code":"class Solution {\n   public:\n    int romanToInt(string s) {\n        int ans = 0;\n        for (int i = 0; i < s.size(); i++) {\n            char ch = s[i];\n            if (ch == 'M')\n                ans += 1000;\n            else if (ch == 'D')\n                ans += 500;\n            else if (ch == 'C') {\n                if (s[i + 1] == 'M') {\n                    ans += 900;\n                    i++;\n                } else if (s[i + 1] == 'D') {\n                    ans += 400;\n                    i++;\n                } else\n                    ans += 100;\n            } else if (ch == 'L')\n                ans += 50;\n            else if (ch == 'X') {\n                if (s[i + 1] == 'C') {\n                    ans += 90;\n                    i++;\n                } else if (s[i + 1] == 'L') {\n                    ans += 40;\n                    i++;\n                } else\n                    ans += 10;\n            } else if (ch == 'V')\n                ans += 5;\n            else if (ch == 'I') {\n                if (s[i + 1] == 'X') {\n                    ans += 9;\n                    i++;\n                } else if (s[i + 1] == 'V') {\n                    ans += 4;\n                    i++;\n                } else\n                    ans += 1;\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["哈希表","数学","字符串"],"level":"Easy"}},{"problemName":"14.最长公共前缀.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/14.最长公共前缀.json","problemData":{"id":"14","name":"14.最长公共前缀","url":"https://leetcode.cn/problems/longest-common-prefix","desc":"编写一个函数来查找字符串数组中的最长公共前缀。","solutions":[{"date":"2020-06-03","time":80,"memory":36.4,"script":"typescript","desc":"内部用函数判断头部重复字符数。","code":"function longestCommonPrefix(strs: string[]): string {\n  const len = strs.length;\n  if (len === 0) return '';\n  let commonS = strs[0];\n  for (let i = 1; i < len; i++) if ((commonS = comp(strs[i], commonS)) === '') return commonS;\n  return commonS;\n  function comp(s: string, commonS: string): string {\n    for (let i = 0, minLen = Math.min(s.length, commonS.length); i <= minLen; i++)\n      if (s[i] !== commonS[i]) return commonS.substring(0, i);\n    return commonS;\n  }\n}"},{"date":"2020-06-15","time":84,"memory":37,"script":"typescript","desc":"纵向判断。","code":"function longestCommonPrefix(strs: string[]): string {\n  const len = strs.length;\n  if (len === 0) return '';\n  const commonPrefix = strs[0];\n  for (let i = 0, cl = commonPrefix.length; i < cl; i++)\n    for (const str of strs) if (commonPrefix[i] !== str[i]) return commonPrefix.substring(0, i);\n  return commonPrefix;\n}"},{"date":"2021-10-16","time":80,"memory":40.4,"script":"typescript","desc":"字典树。","code":"class TrieNode {\n  end = false;\n  children: Map<string, TrieNode> = new Map();\n  constructor(public val: string) {}\n}\nclass Trie {\n  private _size = 0;\n  get size() {\n    return this._size;\n  }\n  get empty() {\n    return this._size === 0;\n  }\n  private _root = new TrieNode('');\n  get root() {\n    return this._root;\n  }\n  clear() {\n    this._root = new TrieNode('');\n    this._size = 0;\n  }\n  add(str: string) {\n    return this._add(str);\n  }\n  private _add(str: string, node = this._root) {\n    if (str.length === 0) {\n      this._root.end = true;\n      this._size++;\n      return;\n    }\n    if (str.length === 1) {\n      let endNode = node.children.get(str);\n      if (!endNode) node.children.set(str, (endNode = new TrieNode(str)));\n      if (!endNode.end) {\n        endNode.end = true;\n        this._size++;\n      }\n      return;\n    }\n    const first = str[0];\n    let nextNode = node.children.get(first);\n    if (!nextNode) node.children.set(first, (nextNode = new TrieNode(first)));\n    const nextStr = str.substr(1);\n    this._add(nextStr, nextNode);\n  }\n  contains(str: string) {\n    const endNode = this.findEndNode(str);\n    return endNode ? endNode.end : false;\n  }\n  remove(str: string) {\n    const endNode = this.findEndNode(str);\n    if (endNode && endNode.end) {\n      endNode.end = false;\n      this._size--;\n    }\n  }\n  starsWith(str: string) {\n    return this.findEndNode(str) !== null;\n  }\n  private findEndNode(str: string, node = this._root): TrieNode | null {\n    if (str.length === 0) return this._root;\n    if (str.length === 1) return node.children.get(str) ?? null;\n    const first = str[0];\n    let nextNode = node.children.get(first);\n    if (!nextNode) return null;\n    const nextStr = str.substr(1);\n    return this.findEndNode(nextStr, nextNode);\n  }\n}\nfunction longestCommonPrefix(strs: string[]): string {\n  const trie = new Trie();\n  for (const str of strs) {\n    if (str === '') return '';\n    trie.add(str);\n  }\n  let node = trie.root;\n  let ans = '';\n  while (node.children.size === 1 && !node.end) {\n    ans += node.val;\n    node = [...node.children.values()][0];\n  }\n  ans += node.val;\n  return ans;\n}"},{"date":"2021-12-20","time":4,"memory":9,"script":"cpp","desc":"遍历每一位。","code":"class Solution {\n   public:\n    string longestCommonPrefix(vector<string>& strs) {\n        int n = strs.size();\n        int maxn = 200;\n        for (int i = 0; i < n; i++) {\n            if (strs[i].size() < maxn) maxn = strs[i].size();\n        }\n        string ans = \"\";\n        if (maxn == 0) return ans;\n        for (int i = 0; i < maxn; i++) {\n            char ch = strs[0][i];\n            for (int j = 1; j < n; j++) {\n                if (strs[j][i] != ch) return ans;\n            }\n            ans += ch;\n        }\n        return ans;\n    }\n};"}],"tagList":["字典树","字符串"],"level":"Easy"}},{"problemName":"15.三数之和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/15.三数之和.json","problemData":{"id":"15","name":"15.三数之和","url":"https://leetcode.cn/problems/3sum","desc":"给你一个包含 n 个整数的数组  nums，判断  nums  中是否存在三个元素 a，b，c ，使得  a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。","solutions":[{"date":"2020-06-03","time":148,"memory":46.1,"script":"typescript","desc":"排序后将每个点作为中心位，增加左右指针。","code":"function threeSum(nums: number[]): number[][] {\n  const len = nums.length;\n  if (len < 3) return [];\n  const res = [];\n  nums.sort((a, b) => a - b);\n  for (let i = 0; i < len || nums[i] > 0; i++) {\n    if (nums[i] == nums[i - 1]) continue; // 去重\n    let L = i + 1;\n    let R = len - 1;\n    while (L < R) {\n      const sum = nums[i] + nums[L] + nums[R];\n      if (sum == 0) {\n        res.push([nums[i], nums[L], nums[R]]);\n        while (L < R && nums[L] == nums[L + 1]) L++; // 去重\n        while (L < R && nums[R] == nums[R - 1]) R--; // 去重\n        L++;\n        R--;\n      } else if (sum < 0) L++;\n      else if (sum > 0) R--;\n    }\n  }\n  return res;\n}"},{"date":"2020-06-12","time":144,"memory":45.9,"script":"typescript","desc":"双指针判断。","code":"function threeSum(nums: number[]): number[][] {\n  const len = nums.length;\n  nums = nums.sort((a, b) => a - b);\n  const ans: number[][] = [];\n  for (let i = 0; nums[i] <= 0; i++) {\n    let l = i + 1;\n    let r = len - 1;\n    while (l < r) {\n      const num = nums[i] + nums[l] + nums[r];\n      if (num < 0) l++;\n      else if (num > 0) r--;\n      else {\n        ans.push([nums[i], nums[l], nums[r]]);\n        l++;\n        while (nums[l] === nums[l - 1]) l++;\n        r--;\n        while (nums[r] === nums[r + 1]) r--;\n      }\n    }\n    while (nums[i] === nums[i + 1]) i++;\n  }\n  return ans;\n}"},{"date":"2022-02-18","time":60,"memory":19.3,"script":"cpp","desc":"循环双指针。","code":"class Solution {\n   public:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        vector<vector<int>> ans;\n        sort(nums.begin(), nums.end());\n        for (int i = 0; i < nums.size() && nums[i] <= 0; i++) {\n            if (i != 0 && nums[i] == nums[i - 1]) continue;\n            int sum, l = i + 1, r = nums.size() - 1;\n            while (l < r) {\n                sum = nums[l] + nums[r] + nums[i];\n                if (sum == 0) {\n                    ans.push_back(vector<int>{nums[i], nums[l], nums[r]});\n                    while (l < r && nums[l] == nums[l + 1]) l++;\n                    l++;\n                } else if (sum > 0)\n                    r--;\n                else\n                    l++;\n            }\n        }\n        return ans;\n    }\n};"},{"script":"cpp","date":"2023-07-09","time":336,"memory":23.3,"desc":"二分。","code":"class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        nums.push_back(INT_MAX);\n        int n = nums.size();\n        vector<vector<int>> res;\n        int prev1 = INT_MIN;\n        for (auto it1 = nums.begin(); it1 != nums.end() && *it1 <= 0; prev1 = *it1, it1++) {\n            if (prev1 == *it1) continue;\n            auto it2 = it1;\n            it2++;\n            int prev2 = INT_MIN;\n            for (; it2 != nums.end(); prev2 = *it2, it2++) {\n                if (prev2 == *it2) continue;\n                int val = 0 - *it1 - *it2;\n                if (val < *it2) continue;\n                auto it3 = it2;\n                it3++;\n                it3 = lower_bound(it3, nums.end(), val);\n                if (*it3 == val) {\n                    res.push_back({ *it1, *it2, *it3 });\n                }\n            }\n        }\n        return res;\n    }\n};"}],"tagList":["数组","双指针","排序"],"level":"Medium"}},{"problemName":"16.最接近的三数之和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/16.最接近的三数之和.json","problemData":{"id":"16","name":"16.最接近的三数之和","url":"https://leetcode.cn/problems/3sum-closest","desc":"给定一个包括  n 个整数的数组  nums  和 一个目标值  target。找出  nums  中的三个整数，使得它们的和与  target  最接近。返回这三个数的和。假定每组输入只存在唯一答案。","solutions":[{"date":"2020-06-10","time":80,"memory":35.9,"script":"typescript","desc":"如题 15。","code":"function threeSumClosest(nums: number[], target: number): number {\n  const len = nums.length;\n  nums = nums.sort((a, b) => a - b);\n  let min = Infinity;\n  let minNum = 0;\n  let maxI = target <= 0 ? 0 : target;\n  for (let i = 0; i === 0 || nums[i] < maxI; i++) {\n    let l = i + 1;\n    let r = len - 1;\n    while (l < r) {\n      const num = nums[i] + nums[l] + nums[r];\n      const comp = num - target;\n      if (min > Math.abs(comp)) {\n        min = Math.abs(comp);\n        minNum = num;\n      }\n      if (comp < 0) l++;\n      else if (comp > 0) r--;\n      else if (comp === 0) return num;\n    }\n  }\n  return minNum;\n}"},{"script":"cpp","time":136,"memory":9.9,"desc":"二分。","code":"class Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        nums.push_back(0x3f3f3f3f);\n        nums.push_back(-0x3f3f3f3f);\n        sort(nums.begin(), nums.end());\n        int n = nums.size(), res = -0x3f3f3f3f;\n        for (int i = 1; i + 2 < n; i++) {\n            for (int j = i + 1; j + 1 < n; j++) {\n                int l = j + 1, r = n, sum = nums[i] + nums[j];\n                while (l < r) {\n                    int m = (l + r) / 2;\n                    if (nums[m] >= target - sum) r = m;\n                    else l = m + 1;\n                }\n                if (sum + nums[l] == target) return target;\n                if (nums[l] != INT_MAX && abs(target - sum - nums[l]) < abs(target - res)) {\n                    res = sum + nums[l];\n                }\n                if (l != j + 1 && nums[l - 1] != INT_MIN && abs(target - sum - nums[l - 1]) < abs(target - res)) {\n                    res = sum + nums[l - 1];\n                }                \n            }\n        }\n        return res;\n    }\n};","date":"2023-07-10"}],"tagList":["数组","双指针","排序"],"level":"Medium"}},{"problemName":"17.电话号码的字母组合.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/17.电话号码的字母组合.json","problemData":{"id":"17","name":"17.电话号码的字母组合","url":"https://leetcode.cn/problems/letter-combinations-of-a-phone-number","desc":"给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。","solutions":[{"date":"2020-06-12","time":64,"memory":32.4,"script":"typescript","desc":"理由哈希表储存值进行递归。","code":"const tel: Record<string, string[]> = {\n  2: ['a', 'b', 'c'],\n  3: ['d', 'e', 'f'],\n  4: ['g', 'h', 'i'],\n  5: ['j', 'k', 'l'],\n  6: ['m', 'n', 'o'],\n  7: ['p', 'q', 'r', 's'],\n  8: ['t', 'u', 'v'],\n  9: ['w', 'x', 'y', 'z'],\n};\nfunction letterCombinations(digits: string): string[] {\n  const len = digits.length;\n  const ans: string[] = [];\n  if (len === 0) return ans;\n  const s = digits[0];\n  const letters = tel[s];\n  const nextLetter = letterCombinations(digits.substr(1));\n  if (nextLetter.length === 0) return letters;\n  for (const letter of letters) for (const nl of nextLetter) ans.push(letter + nl);\n  return ans;\n}"},{"date":"2020-08-26","time":84,"memory":37.6,"script":"typescript","desc":"深度遍历","code":"const phoneToLetter: Record<string, string> = {\n  '2': 'abc',\n  '3': 'def',\n  '4': 'ghi',\n  '5': 'jkl',\n  '6': 'mno',\n  '7': 'pqrs',\n  '8': 'tuv',\n  '9': 'wxyz',\n};\nfunction letterCombinations(digits: string): string[] {\n  const len = digits.length;\n  if (len === 0) return [];\n  else if (len === 1) return phoneToLetter[digits].split('');\n  const arr = phoneToLetter[digits[0]].split('');\n  const nextArr = letterCombinations(digits.substr(1));\n  const ans = [];\n  for (const c of arr) ans.push(...nextArr.map(v => c + v));\n  return ans;\n}"}],"tagList":["哈希表","字符串","回溯"],"level":"Medium"}},{"problemName":"18.四数之和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/18.四数之和.json","problemData":{"id":"18","name":"18.四数之和","url":"https://leetcode.cn/problems/4sum","desc":"给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] 。","solutions":[{"script":"javascript","time":92,"memory":39.7,"desc":"双指针。","code":"/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number[][]}\n*/\nvar fourSum = function(nums, target) {\n    const quadruplets = [];\n    if (nums.length < 4) {\n        return quadruplets;\n    }\n    nums.sort((x, y) => x - y);\n    const length = nums.length;\n    for (let i = 0; i < length - 3; i++) {\n        if (i > 0 && nums[i] === nums[i - 1]) {\n            continue;\n        }\n        if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) {\n            break;\n        }\n        if (nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] < target) {\n            continue;\n        }\n        for (let j = i + 1; j < length - 2; j++) {\n            if (j > i + 1 && nums[j] === nums[j - 1]) {\n                continue;\n            }\n            if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) {\n                break;\n            }\n            if (nums[i] + nums[j] + nums[length - 2] + nums[length - 1] < target) {\n                continue;\n            }\n            let left = j + 1, right = length - 1;\n            while (left < right) {\n                const sum = nums[i] + nums[j] + nums[left] + nums[right];\n                if (sum === target) {\n                    quadruplets.push([nums[i], nums[j], nums[left], nums[right]]);\n                    while (left < right && nums[left] === nums[left + 1]) {\n                        left++;\n                    }\n                    left++;\n                    while (left < right && nums[right] === nums[right - 1]) {\n                        right--;\n                    }\n                    right--;\n                } else if (sum < target) {\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n    }\n    return quadruplets;\n};","date":"2020-10-05"},{"script":"cpp","time":44,"memory":12.8,"desc":"双指针。","code":"class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        int n = nums.size();\n        vector<vector<int>> res;\n        sort(nums.begin(), nums.end());\n        for (int i = 0; i + 3 < n && (nums[i] <= target || nums[i] < 0); i++) {\n            if (i > 0 && nums[i] == nums[i - 1]) continue;\n            for (int j = i + 1; j + 2 < n && (nums[i] + nums[j] <= target || nums[j] < 0); j++) {\n                if (j > i + 1 && nums[j] == nums[j - 1]) continue;\n                long long num = nums[i] + nums[j];\n                int l = j + 1, r = n - 1;\n                while (l < r) {\n                    if (num + nums[l] + nums[r] > target) r--;\n                    else if (num + nums[l] + nums[r] < target)  l++;\n                    else {\n                        res.push_back({ nums[i], nums[j], nums[l], nums[r] });\n                        while (l + 1 < r && nums[l + 1] == nums[l]) l++;\n                        while (r - 1 > l && nums[r - 1] == nums[r]) r--;\n                        l++;\n                        r--;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n};","date":"2023-07-15"},{"script":"python","time":500,"memory":16.1,"desc":"同上。","code":"class Solution:\n    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:\n        n = len(nums)\n        res = []\n        nums.sort()\n        i = 0\n        while i + 3 < n and (nums[i] <= target or nums[i] < 0):\n            if i > 0 and nums[i] == nums[i - 1]:\n                i += 1\n                continue\n            j = i + 1\n            while j + 2 < n and (nums[i] + nums[j] <= target or nums[j] < 0):\n                if j > i + 1 and nums[j] == nums[j-1]:\n                    j += 1\n                    continue\n                num = nums[i] + nums[j]\n                l = j + 1\n                r = n-1\n                while l < r:\n                    if num + nums[l] + nums[r] > target:\n                        r -= 1\n                    elif num + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        while l + 1 < r and nums[l + 1] == nums[l]:\n                            l += 1\n                        while r - 1 > l and nums[r - 1] == nums[r]:\n                            r -= 1\n                        l += 1\n                        r -= 1\n                j += 1\n            i += 1\n        return res","date":"2023-07-15"},{"script":"rust","time":4,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn four_sum(mut nums: Vec<i32>, target: i32) -> Vec<Vec<i32>> {\n        let n = nums.len();\n        let mut res = vec![];\n        nums.sort();\n        let mut i = 0;\n        while i + 3 < n && (nums[i] <= target || nums[i] < 0) {\n            if i > 0 && nums[i] == nums[i - 1] {\n                i += 1;\n                continue;\n            }\n            let mut j = i + 1;\n            while j + 2 < n && (nums[i] + nums[j] <= target || nums[j] < 0) {\n                if j > i + 1 && nums[j] == nums[j - 1] {\n                    j += 1;\n                    continue;\n                }\n                let num = (nums[i] + nums[j]) as i64;\n                let mut l = j + 1;\n                let mut r = n - 1;\n                while l < r {\n                    let num = num + nums[l] as i64 + nums[r] as i64;\n                    let target = target as i64;\n                    if num > target {\n                        r -= 1;\n                    } else if num < target {\n                        l += 1;\n                    } else {\n                        res.push(vec![nums[i], nums[j], nums[l], nums[r]]);\n                        while l + 1 < r && nums[l + 1] == nums[l] {\n                            l += 1;\n                        }\n                        while r - 1 > l && nums[r - 1] == nums[r] {\n                            r -= 1;\n                        }\n                        l += 1;\n                        r -= 1;\n                    }\n                }\n                j += 1;\n            }\n            i += 1;\n        }\n        res\n    }\n}","date":"2023-07-15"}],"tagList":["数组","双指针","排序"],"level":"Medium"}},{"problemName":"19.删除链表的倒数第N个结点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/19.删除链表的倒数第N个结点.json","problemData":{"id":"19","name":"19.删除链表的倒数第N个结点","url":"https://leetcode.cn/problems/remove-nth-node-from-end-of-list","desc":"给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。","solutions":[{"date":"2020-05-22","time":64,"memory":33.5,"script":"javascript","desc":"压栈后出栈。","code":"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} n\n * @return {ListNode}\n */\nvar removeNthFromEnd = function (head, n) {\n  if (head === null || head.next === null) return null;\n  let temp = head;\n  const stack = [];\n  while (temp !== null) {\n    stack.push(temp);\n    temp = temp.next;\n  }\n  if (n === stack.length) return head.next;\n  stack.pop();\n  let c = 0;\n  while (++c !== n) {\n    stack.pop();\n  }\n  const node = stack.pop();\n  node.next = node.next.next;\n  return head;\n};"},{"date":"2020-10-18","time":96,"memory":40.1,"script":"typescript","desc":"利用栈排序。","code":"function removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\n  if (head === null) return null;\n  const stack: ListNode[] = [];\n  let temp: ListNode | null = head;\n  while (temp !== null) {\n    stack.push(temp);\n    temp = temp.next;\n  }\n  if (stack.length === n) return head.next;\n  while (n-- !== 0) {\n    stack.pop();\n  }\n  const node = stack.pop()!;\n  node.next = node.next!.next;\n  return head;\n}"},{"date":"2020-10-18","time":92,"memory":40.2,"script":"typescript","desc":"快慢指针，快指针先走 n 个节点。","code":"function removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\n  const dummy = new ListNode(0, head);\n  let first: ListNode | null = head;\n  let second: ListNode = dummy;\n  for (let i = 0; i < n; i++) first = first?.next!;\n  while (first !== null) {\n    first = first.next;\n    second = second?.next!;\n  }\n  second.next = second.next?.next!;\n  return dummy.next;\n}"},{"date":"2021-03-06","time":108,"memory":39.2,"script":"typescript","desc":"假设总长 len,q 先走 n 步,还剩 len-n 步,p 从头开始和 q 一起走,走到 q 为 null 的时候,p 就是要删除的节点。","code":"function removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {\n  const dummyHead = new ListNode(0, head);\n  let q = head;\n  while (n--) q = q!.next!;\n  let p = dummyHead;\n  while (q !== null) {\n    q = q.next!;\n    p = p.next!;\n  }\n  p.next = p.next!.next;\n  return dummyHead.next;\n}"},{"date":"2021-11-19","time":0,"memory":5.8,"script":"c","desc":"遍历。","code":"struct ListNode* removeNthFromEnd(struct ListNode* head, int n){\n        int sum = 0;\n        struct ListNode* p = head;\n        while (p) p = p->next, sum++;\n        if (sum == 1 && n == 1) return NULL;\n        int del_idx = sum - n;\n        p = head;\n        if (del_idx == 0) return p->next;\n        while (--del_idx) p = p->next;\n        p->next = p->next->next;\n        return head;\n}"}],"tagList":["链表","双指针"],"level":"Medium"}},{"problemName":"2.两数相加.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/2.两数相加.json","problemData":{"id":"2","name":"2.两数相加","url":"https://leetcode.cn/problems/add-two-numbers","desc":"给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照   逆序   的方式存储的，并且它们的每个节点只能存储   一位   数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0  开头。","solutions":[{"date":"2019-09-20","time":144,"memory":38.4,"script":"javascript","desc":"创建第三个链表，其中每个值为前两个链表相加，然后再次循环判断是否有一个节点值大于等于 10，若存在则-10 且下一个节点值+1。","code":"var addTwoNumbers = function (l1, l2) {\n  let node1 = l1,\n    node2 = l2;\n  let tempNode = new ListNode(node1.val + node2.val);\n  let node3 = tempNode;\n  while (node1.next !== null && node2.next !== null) {\n    node1 = node1.next;\n    node2 = node2.next;\n    tempNode.next = new ListNode(node1.val + node2.val);\n    tempNode = tempNode.next;\n  }\n  if (node1.next !== null) {\n    tempNode.next = node1.next;\n  }\n  if (node2.next !== null) {\n    tempNode.next = node2.next;\n  }\n  tempNode = node3;\n  while (tempNode !== null) {\n    if (tempNode.val >= 10) {\n      tempNode.val -= 10;\n      if (tempNode.next !== null) {\n        tempNode.next.val += 1;\n      } else {\n        tempNode.next = new ListNode(1);\n      }\n    }\n    tempNode = tempNode.next;\n  }\n  return node3;\n};"},{"date":"2019-09-20","time":248,"memory":46.2,"script":"javascript","desc":"创建待返回链表 node3，创建进位参数 carry，遍历 l1 和 l2，如果节点 1+节点 2+carry 没有大于 10 则直接储存，若相加大于 10 则存入 carry，余数部分直接储存。","code":"var addTwoNumbers = function (l1, l2) {\n  let tempNode = new ListNode(0);\n  let node3 = tempNode;\n  let carry = 0;\n  while (l1 !== null || l2 !== null) {\n    let x = l1 === null ? 0 : l1.val;\n    let y = l2 === null ? 0 : l2.val;\n    let sum = x + y + carry;\n    carry = Math.floor(sum / 10);\n    sum = Math.floor(sum % 10);\n    console.log(carry, sum);\n    tempNode.next = new ListNode(sum);\n    tempNode = tempNode.next;\n    if (l1 !== null) {\n      l1 = l1.next;\n    }\n    if (l2 !== null) {\n      l2 = l2.next;\n    }\n  }\n  if (carry === 1) {\n    tempNode.next = new ListNode(1);\n  }\n  return node3.next;\n};"},{"date":"2020-10-04","time":144,"memory":43.6,"script":"typescript","desc":"遍历所有节点。","code":"function addTwoNumbers(l1: ListNode | null, l2: ListNode | null): ListNode | null {\n  const list = new ListNode(0);\n  let temp = list;\n  let add = 0;\n  while (l1 !== null || l2 !== null) {\n    let sum = (l1?.val ?? 0) + (l2?.val ?? 0) + add;\n    add = 0;\n    if (sum >= 10) {\n      sum -= 10;\n      add++;\n    }\n    temp.next = new ListNode(sum);\n    temp = temp.next;\n    l1 = l1 === null ? null : l1.next;\n    l2 = l2 === null ? null : l2.next;\n  }\n  if (add !== 0) temp.next = new ListNode(add);\n  return list.next;\n}"},{"script":"cpp","time":20,"memory":69.8,"desc":"遍历。","code":"class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode *head = new ListNode(), *p = head;\n        int add = 0;\n        while (l1 || l2) {\n            int val = (l1 ? l1->val : 0) + \n                      (l2 ? l2->val : 0) +\n                      add;\n            if (val >= 10) val -= 10, add = 1;\n            else add = 0;\n            p->next = new ListNode(val);\n            p = p->next;\n            if (l1) l1 = l1->next;\n            if (l2) l2 = l2->next;\n        }\n        if (add) p->next = new ListNode(1);\n        return head->next;\n    }\n};","date":"2023-07-02"},{"script":"python","time":68,"memory":16.2,"desc":"同上。","code":"class Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        head = ListNode()\n        p = head\n        add = 0\n        while l1 or l2:\n            val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + add\n            if val >= 10:\n                val -= 10\n                add = 1\n            else:\n                add = 0\n            p.next = ListNode(val)\n            p = p.next\n            if l1:\n                l1 = l1.next\n            if l2:\n                l2 = l2.next\n        if add:\n            p.next = ListNode(1)\n        return head.next","date":"2023-07-02"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn add_two_numbers(\n        mut l1: Option<Box<ListNode>>,\n        mut l2: Option<Box<ListNode>>,\n    ) -> Option<Box<ListNode>> {\n        let mut head = Box::new(ListNode::new(0));\n        let mut p = &mut head;\n        let mut p1 = &mut l1;\n        let mut p2 = &mut l2;\n        let mut add = 0;\n        while p1.is_some() || p2.is_some() {\n            let mut val = match p1 {\n                Some(ref mut node) => {\n                    p1 = &mut node.next;\n                    node.val\n                }\n                None => 0,\n            } + match p2 {\n                Some(ref mut node) => {\n                    p2 = &mut node.next;\n                    node.val\n                }\n                None => 0,\n            } + add;\n            if val >= 10 {\n                val -= 10;\n                add = 1;\n            } else {\n                add = 0;\n            }\n            p.next = Some(Box::new(ListNode::new(val)));\n            p = p.next.as_mut().unwrap();\n        }\n        if add != 0 {\n            p.next = Some(Box::new(ListNode::new(1)));\n        }\n        head.next\n    }\n}","date":"2023-07-02"}],"tagList":["递归","链表","数学"],"level":"Medium"}},{"problemName":"20.有效的括号.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/20.有效的括号.json","problemData":{"id":"20","name":"20.有效的括号","url":"https://leetcode.cn/problems/valid-parentheses","desc":"给定一个只包括 '('，')'，'{'，'}'，'['，']'  的字符串，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。","solutions":[{"date":"2020-02-16","time":2,"memory":40.8,"script":"java","desc":"遍历，左括号压栈，右括号判断。","code":"class Solution {\n    public boolean isValid(String s) {\n\t    \tStack<Character> stack= new Stack<Character>();\n\t    \tint len=s.length();\n\t    \tfor(int i =0;i<len;i++) {\n\t    \t\tchar c=s.charAt(i);\n\t    \t\tif(c=='('||c=='{'||c=='[') {\n\t    \t\t\tstack.push(c);\n\t    \t\t}else {\n\t    \t\t\tif(stack.isEmpty())\treturn false;\n\t    \t\t\tchar left=stack.pop();\n\t    \t\t\tif(left=='('&&c!=')')return false;\n\t    \t\t\tif(left=='{'&&c!='}')return false;\n\t    \t\t\tif(left=='['&&c!=']')return false;\n\t    \t\t}\n\t    \t}\n\t        return stack.isEmpty();\n    }\n}"},{"date":"2020-02-16","time":4,"memory":41.4,"script":"java","desc":"与 1 思路相似，用 map 储存三对大括号。","code":"class Solution {\n    public boolean isValid(String s) {\n\t    \tStack<Character> stack= new Stack<Character>();\n\t    \tint len=s.length();\n\t    \tfor(int i =0;i<len;i++) {\n\t    \t\tchar c=s.charAt(i);\n\t    \t\tif(c=='('||c=='{'||c=='[') {\n\t    \t\t\tstack.push(c);\n\t    \t\t}else {\n\t    \t\t\tif(stack.isEmpty())\treturn false;\n\t    \t\t\tchar left=stack.pop();\n\t    \t\t\tif(left=='('&&c!=')')return false;\n\t    \t\t\tif(left=='{'&&c!='}')return false;\n\t    \t\t\tif(left=='['&&c!=']')return false;\n\t    \t\t}\n\t    \t}\n\t        return stack.isEmpty();\n    }\n}"},{"date":"2020-08-14","time":92,"memory":38.5,"script":"typescript","desc":"利用栈进行判断。","code":"function isValid(s: string): boolean {\n  const stack: string[] = [];\n  for (const c of s) {\n    if (c === '(' || c === '[' || c === '{') {\n      stack.push(c);\n    } else {\n      const left = stack.pop();\n      if (\n        !left ||\n        (left === '(' && c !== ')') ||\n        (left === '[' && c !== ']') ||\n        (left === '{' && c !== '}')\n      )\n        return false;\n    }\n  }\n  return stack.length === 0;\n}"},{"date":"2021-03-19","time":84,"memory":41,"script":"typescript","desc":"栈维护。","code":"const leftSet = new Set(['(', '[', '{']);\nfunction isValid(s: string): boolean {\n  if (s.length === 0) return true;\n  const stack: string[] = [];\n  for (const c of s) {\n    if (leftSet.has(c)) {\n      stack.push(c);\n    } else if (c === ')') {\n      let str = '';\n      while (stack.length > 0 && stack[stack.length - 1] !== '(') str = stack.pop()! + str;\n      if (stack.length === 0 || stack[stack.length - 1] !== '(') return false;\n      stack.pop();\n      if (!isValid(str)) return false;\n    } else if (c === ']') {\n      let str = '';\n      while (stack.length > 0 && stack[stack.length - 1] !== '[') str = stack.pop()! + str;\n      if (stack.length === 0 || stack[stack.length - 1] !== '[') return false;\n      stack.pop();\n      if (!isValid(str)) return false;\n    } else if (c === '}') {\n      let str = '';\n      while (stack.length > 0 && stack[stack.length - 1] !== '{') str = stack.pop()! + str;\n      if (stack.length === 0 || stack[stack.length - 1] !== '{') return false;\n      stack.pop();\n      if (!isValid(str)) return false;\n    }\n  }\n  return stack.length === 0;\n}"},{"date":"2021-11-24","time":0,"memory":5.8,"script":"typescript","desc":"stack。","code":"typedef struct Stack\n{\n    int size;\n    int len;\n    int *data;\n} Stack;\nStack *createStack(int len)\n{\n    Stack *s = (Stack *)malloc(sizeof(Stack));\n    s->size = 0;\n    s->len = len;\n    s->data = (int *)malloc(sizeof(int) * len);\n    return s;\n}\nvoid push(Stack *s, int val)\n{\n    if (s->size == s->len)\n        return;\n    s->data[s->size++] = val;\n}\nvoid pop(Stack *s)\n{\n    if (s->size == 0)\n        return;\n    s->size--;\n}\nint isEmpty(Stack *s) {\n    return s->size == 0;\n}\nint top(Stack *s)\n{\n    if (s->size == 0)\n        return -999999999;\n    return s->data[s->size - 1];\n}\nvoid freeStack(Stack *s)\n{\n    free(s->data);\n    free(s);\n}\nvoid showStack(Stack *s, char *title, int type)\n{\n    printf(\"Stack %s : [\", title);\n    for (int i = 0; i < s->size; i++)\n    {\n        i &&printf(\",\");\n        if (type == 1)\n            printf(\"%d\", s->data[i]);\n        if (type == 2)\n            printf(\"%c\", s->data[i]);\n    }\n    printf(\"]\\n\");\n}\nbool isValid(char * s){\n    int len = strlen(s);\n    Stack *stack = createStack(len);\n    for (int i = 0; i < len; i++) {\n        char ch = s[i];\n        if (\n            ch == ')' && !isEmpty(stack) && s[top(stack)] == '(' ||\n            ch == ']' && !isEmpty(stack) && s[top(stack)] == '[' ||\n            ch == '}' && !isEmpty(stack) && s[top(stack)] == '{'\n        ) pop(stack);\n        else push(stack, i);\n    }\n    return stack->size == 0;\n}"}],"tagList":["栈","字符串"],"level":"Easy"}},{"problemName":"21.合并两个有序链表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/21.合并两个有序链表.json","problemData":{"id":"21","name":"21.合并两个有序链表","url":"https://leetcode.cn/problems/merge-two-sorted-lists","desc":"将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。","solutions":[{"date":"2020-05-01","time":84,"memory":35.5,"script":"javascript","desc":"通过队列储存后排序输出。","code":"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar mergeTwoLists = function (l1, l2) {\n  if (l1 === null && l2 === null) return null;\n  let tmp1 = l1,\n    tmp2 = l2;\n  const queue = [];\n  while (tmp1 !== null && tmp2 !== null) {\n    if (tmp1.val <= tmp2.val) {\n      queue.push(tmp1);\n      tmp1 = tmp1.next;\n    } else {\n      queue.push(tmp2);\n      tmp2 = tmp2.next;\n    }\n  }\n  while (tmp1 !== null) {\n    queue.push(tmp1);\n    tmp1 = tmp1.next;\n  }\n  while (tmp2 !== null) {\n    queue.push(tmp2);\n    tmp2 = tmp2.next;\n  }\n  const root = queue[0];\n  let tmp = root;\n  for (let i = 1, len = queue.length; i < len; i++) {\n    const node = queue[i] === undefined ? null : queue[i];\n    tmp.next = node;\n    tmp = tmp.next;\n  }\n  return root;\n};"},{"date":"2021-11-30","time":4,"memory":6.1,"script":"c","desc":"新建一个头结点，遍历两个节点进行比较。","code":"struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2){\n    struct ListNode *root = (struct ListNode *)malloc(sizeof(struct ListNode)), *p = root;\n    while (list1 && list2) {\n        if (list1->val <= list2->val) {\n            p->next = list1;\n            list1 = list1->next;\n        } else {\n            p->next = list2;\n            list2 = list2->next;\n        }\n        p = p->next;\n    }\n    if (!list1) p->next = list2;\n    if (!list2) p->next = list1;\n    return root->next;\n}"},{"script":"cpp","time":8,"memory":14.5,"desc":"dfs。","code":"class Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode *head = new ListNode(), *p = head;\n        while (list1 || list2) {\n            if (!list2 || list1 && list1->val <= list2->val) {\n                p->next = list1;\n                list1 = list1->next;\n            } else {\n                p->next = list2;\n                list2 = list2->next;\n            }\n            p = p->next;\n        }\n\n        return head->next;\n    }\n};","date":"2023-08-05"},{"script":"python","time":52,"memory":15.59,"desc":"同上。","code":"class Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        head = ListNode()\n        p = head\n        while list1 or list2:\n            if not list2 or list1 and list1.val <= list2.val:\n                p.next = list1\n                list1 = list1.next\n            else:\n                p.next = list2\n                list2 = list2.next\n            p = p.next\n        return head.next","date":"2023-08-05"},{"script":"rust","time":0,"memory":2.06,"desc":"同上。","code":"impl Solution {\npub fn merge_two_lists(\n    mut list1: Option<Box<ListNode>>,\n    mut list2: Option<Box<ListNode>>,\n) -> Option<Box<ListNode>> {\n    let mut head = ListNode::new(0);\n    let mut p = &mut head;\n    let tmp = Box::new(ListNode::new(-1));\n    while list1.is_some() || list2.is_some() {\n        if list2.is_none()\n            || list1.is_some() && list1.as_ref().unwrap().val <= list2.as_ref().unwrap().val\n        {\n            let mut node = list1.take().unwrap();\n            let next = node.next.take();\n            p.next = Some(node);\n            list1 = next;\n        } else {\n            let mut node = list2.take().unwrap();\n            let next = node.next.take();\n            p.next = Some(node);\n            list2 = next;\n        }\n        p = p.next.as_mut().unwrap();\n    }\n    head.next\n}\n}","date":"2023-08-05"}],"tagList":["递归","链表"],"level":"Easy"}},{"problemName":"22.括号生成.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/22.括号生成.json","problemData":{"id":"22","name":"22.括号生成","url":"https://leetcode.cn/problems/generate-parentheses","desc":"数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。","solutions":[{"date":"2020-04-09","time":68,"memory":35.1,"script":"javascript","desc":"通过集合去重，再递归判断括号内部。","code":"/**\n * @param {number} n\n * @return {string[]}\n */\nconst cache = new Map();\ncache.set(1, ['()']);\ncache.set(2, ['()()', '(())']);\nvar generateParenthesis = function (n) {\n  if (cache.has(n)) return cache.get(n);\n  const res = new Set();\n  for (let i = 1; i < n; i++) {\n    for (let left of generateParenthesis(i))\n      for (let right of generateParenthesis(n - i)) res.add(`${left}${right}`);\n  }\n  for (let item of generateParenthesis(n - 1)) res.add(`(${item})`);\n  const arr = [...res];\n  cache.set(n, arr);\n  return arr;\n};"}],"tagList":["字符串","动态规划","回溯"],"level":"Medium"}},{"problemName":"23.合并K个升序链表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/23.合并K个升序链表.json","problemData":{"id":"23","name":"23.合并K个升序链表","url":"https://leetcode.cn/problems/merge-k-sorted-lists","desc":"给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。","solutions":[{"date":"2020-04-26","script":"javascript","time":384,"memory":44.78,"desc":"归并排序。","code":"var mergeKLists = function (lists) {\n    if (lists.length === 0) return null;\n    if (lists.length === 1) return lists[0];\n    let resNode;\n    for (const node of lists) {\n        if (node === null) continue;\n        if (resNode === undefined) resNode = node;\n        else resNode = add(resNode, node);\n    }\n    return resNode===undefined?null:resNode;\n};\nfunction add(node1, node2) {\n    let tempNode1 = node1;\n    let tempNode2 = node2;\n    let resNode;\n    let tempNode3;\n    while (tempNode1 !== null || tempNode2 !== null) {\n        let minNode;\n        if (tempNode1 === null) {\n            minNode = tempNode2;\n            tempNode2 = tempNode2.next;\n        } else if (tempNode2 === null) {\n            minNode = tempNode1;\n            tempNode1 = tempNode1.next;\n        } else if (tempNode1.val < tempNode2.val) {\n            minNode = tempNode1;\n            tempNode1 = tempNode1.next;\n        } else {\n            minNode = tempNode2;\n            tempNode2 = tempNode2.next;\n        }\n        if (resNode === undefined) {\n            tempNode3 = resNode = minNode;\n        } else {\n            tempNode3.next = minNode;\n            tempNode3 = tempNode3.next;\n        }\n    }\n    return resNode;\n}"},{"date":"2021-05-13","script":"typescript","time":220,"memory":48.3,"desc":"归并排序。","code":"function mergeKLists(lists: Array<ListNode | null>): ListNode | null {\n  lists = lists.filter(list => list !== null);\n  const len = lists.length;\n  if (len === 0) return null;\n  const merge = (start: number, end: number): ListNode | null => {\n    console.log(start, end);\n    if (start > end) return null;\n    if (start === end) return lists[start];\n    const mid = (start + end) >> 1;\n    const list1 = merge(start, mid);\n    const list2 = merge(mid + 1, end);\n    if (list1 === null) return list2;\n    if (list2 === null) return list1;\n    const first = new ListNode(0);\n    let temp = first;\n    let p1: ListNode | null = list1;\n    let p2: ListNode | null = list2;\n    while (p1 && p2) {\n      if (p1.val <= p2.val) {\n        temp.next = p1;\n        temp = temp.next;\n        p1 = p1.next;\n      } else {\n        temp.next = p2;\n        temp = temp.next;\n        p2 = p2.next;\n      }\n    }\n    if (p1) temp.next = p1;\n    if (p2) temp.next = p2;\n    return first.next;\n  };\n  return merge(0, len - 1);\n}}"},{"script":"cpp","time":16,"memory":12.67,"desc":"堆存储每个头节点。","code":"class Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        ListNode *head = new ListNode(), *p = head;\n        auto cmp = [&](ListNode* n1, ListNode* n2) {\n            return n2->val < n1->val;\n        };\n        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> q(cmp);\n        for (auto &node : lists) {\n            if (node) q.push(node);\n        }\n        while (q.size()) {\n            auto node = q.top();\n            q.pop();\n            p->next = node;\n            p = p->next;\n            if (node->next) q.push(node->next);\n        }\n        return head->next;\n    }\n};","date":"2023-08-12"},{"script":"python","time":136,"memory":19.82,"desc":"同上。","code":"ListNode.__lt__ = lambda a, b: a.val < b.val\n\n    class Solution:\n        def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n            head = ListNode()\n            p = head\n            q = []\n            for node in lists:\n                if node:\n                    print(node)\n                    heappush(q, node)\n    \n            while len(q):\n                node = heappop(q)\n                p.next = node\n                p = p.next\n                if node.next:\n                    heappush(q, node.next)\n            return head.next","date":"2023-08-12"},{"script":"rust","time":4,"memory":3.25,"desc":"同上。","code":"use std::cmp::{Ord, Ordering, PartialOrd};\nimpl Ord for ListNode {\n    fn cmp(&self, other: &Self) -> Ordering {\n        other.val.cmp(&self.val)\n    }\n}\nimpl PartialOrd for ListNode {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        other.val.partial_cmp(&self.val)\n    }\n}\n\nimpl Solution {\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\n        let mut head = Some(Box::new(ListNode::new(0)));\n        let mut p = head.as_mut().unwrap();\n        let mut q = std::collections::BinaryHeap::new();\n        for node in lists {\n            if let Some(node) = node {\n                q.push(node);\n            }\n        }\n        while let Some(mut node) = q.pop() {\n            let next = node.next.take();\n            p.next = Some(node);\n            p = p.next.as_mut().unwrap();\n            if let Some(next) = next {\n                q.push(next);\n            }\n        }\n        head.unwrap().next\n    }\n}","date":"2023-08-12"}],"tagList":["链表","分治","堆（优先队列）","归并排序"],"level":"Hard"}},{"problemName":"24.两两交换链表中的节点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/24.两两交换链表中的节点.json","problemData":{"id":"24","name":"24.两两交换链表中的节点","url":"https://leetcode.cn/problems/swap-nodes-in-pairs","desc":"给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。","solutions":[{"date":"2020-10-13","time":96,"memory":39.5,"script":"typescript","desc":"入队后两两交换顺序后重新组合。","code":"function swapPairs(head: ListNode | null): ListNode | null {\n  if (head === null) return null;\n  const queue: ListNode[] = [];\n  let temp: ListNode | null = head;\n  while (temp !== null) {\n    queue.push(temp);\n    temp = temp.next;\n    queue[queue.length - 1].next = null;\n  }\n  for (let i = 0, l = queue.length; i < l; i++) {\n    if (i & 1) {\n      let tempNode = queue[i];\n      queue[i] = queue[i - 1];\n      queue[i - 1] = tempNode;\n    }\n  }\n  queue.forEach((v, i, arr) => {\n    if (i !== 0) {\n      arr[i - 1].next = v;\n    }\n  });\n  return queue[0];\n}"},{"date":"2020-10-13","time":84,"memory":39.6,"script":"typescript","desc":"递归。","code":"function swapPairs(head: ListNode | null): ListNode | null {\n  if (head === null || head.next === null) return head;\n  const nextHead = head.next;\n  head.next = swapPairs(nextHead.next);\n  nextHead.next = head;\n  return nextHead;\n}"},{"date":"2020-10-13","time":124,"memory":39.3,"script":"typescript","desc":"迭代。","code":"function swapPairs(head: ListNode | null): ListNode | null {\n  let tempNode = new ListNode(0, head);\n  const headNode = tempNode;\n  while (tempNode.next?.next) {\n    const node1 = tempNode.next;\n    const node2 = tempNode.next.next;\n    tempNode.next = node2;\n    node1.next = node2.next;\n    node2.next = node1;\n    tempNode = node1;\n  }\n  return headNode.next;\n}"},{"date":"2021-03-06","time":88,"memory":39.4,"script":"typescript","desc":"进行每 2 个交换,25 题的特殊情况。","code":"function _reverseList(head: ListNode, count: number): ListNode | null {\n  if (count === 1 || head.next === null) return head;\n  const tail = head.next;\n  const nextList = _reverseList(tail, count - 1);\n  head.next = tail.next;\n  tail.next = head;\n  return nextList;\n}\nfunction reverseList(head: ListNode, count: number): ListNode | null {\n  let temp: ListNode | null = head;\n  let c = count;\n  while (--c && temp) temp = temp.next;\n  return temp ? _reverseList(head, count) : head;\n}\nfunction swapPairs(head: ListNode | null): ListNode | null {\n  const dummyHead = new ListNode(0, head);\n  let temp: ListNode = dummyHead;\n  while (temp !== null && temp.next !== null) {\n    temp!.next = reverseList(temp.next!, 2);\n    let count = 2;\n    while (count-- && temp !== null) temp = temp.next!;\n  }\n  return dummyHead.next;\n}"},{"date":"2021-11-19","time":0,"memory":5.8,"script":"c","desc":"dfs。","code":"struct ListNode* swapPairs(struct ListNode* head){\n    if (!head) return NULL;\n    if (head->next == NULL) return head;\n    struct ListNode *next_node = head->next;\n    if (next_node->next != NULL) head->next = swapPairs(next_node->next);\n    else head->next = NULL;\n    next_node->next = head;\n    return next_node;\n}"},{"script":"cpp","time":4,"memory":7.26,"desc":"dfs。","code":"class Solution {\npublic:\n    typedef pair<ListNode*, ListNode*> pll;\n    ListNode* swapPairs(ListNode* head) {\n        return swap(head, 1, 2).first;\n    }\n    pll swap(ListNode* node, int cnt, int max_cnt) {\n        if (!node) {\n            return make_pair(nullptr, nullptr);\n        } else if (cnt == max_cnt) {\n            node->next = swap(node->next, 1, max_cnt).first;\n            return make_pair(node, node);\n        } else if (!node->next) {\n            return make_pair(node, node);\n        } else {\n            auto res = swap(node->next, cnt + 1, max_cnt);\n            node->next = res.second->next;\n            res.second->next = node;\n            return res;\n        }\n    }\n};","date":"2023-08-06"},{"script":"python","time":40,"memory":15.62,"desc":"同上。","code":"def swap(node: Optional[ListNode], cnt: int, max_cnt: int) -> (Optional[ListNode], Optional[ListNode]):\n    if not node:\n        return (None, None)\n    elif cnt == max_cnt:\n        node.next = swap(node.next, 1, max_cnt)[0]\n        return (node, node)\n    elif not node.next:\n        return (node, node)\n    else:\n        res = swap(node.next, cnt + 1, max_cnt)\n        node.next = res[1].next\n        res[1].next = node\n        return res\n\n    class Solution:\n        def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n            return swap(head, 1, 2)[0]","date":"2023-08-06"}],"tagList":["递归","链表"],"level":"Medium"}},{"problemName":"25.K个一组翻转链表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/25.K个一组翻转链表.json","problemData":{"id":"25","name":"25.K个一组翻转链表","url":"https://leetcode.cn/problems/reverse-nodes-in-k-group","desc":"给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。","solutions":[{"date":"2020-05-16","time":96,"memory":37.7,"script":"javascript","desc":"每 K 个进行截取翻转。","code":"function listNodeLastNode(node) {\n  let temp = node;\n  if (temp === null) return null;\n  while (temp.next !== null) temp = temp.next;\n  return temp;\n}\nfunction listNodeReverse(node) {\n  let newRoot;\n  function _reverse(node, prevNode) {\n    if (node.next !== null) _reverse(node.next, node);\n    else newRoot = node;\n    node.next = prevNode;\n  }\n  _reverse(node, null);\n  return newRoot;\n}\nfunction listNodeLength(node) {\n  let l = 0,\n    temp = node;\n  if (temp === null) return l;\n  while (temp !== null) {\n    l++;\n    temp = temp.next;\n  }\n  return l;\n}\n/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} head\n * @param {number} k\n * @return {ListNode}\n */\nvar reverseKGroup = function (head, k) {\n  if (head === null) return null;\n  let temp = head,\n    num = k;\n  const rootArr = [temp];\n  while (temp !== null) {\n    if (--num === 0) {\n      const next = temp.next;\n      temp.next = null;\n      temp = next;\n      num = k;\n      rootArr.push(next);\n    } else temp = temp.next;\n  }\n  const len = rootArr.length;\n  let root, lastNode;\n  for (let i = 0; i < len; i++) {\n    if (i === len - 1) {\n      if (listNodeLength(rootArr[i]) !== k) lastNode.next = rootArr[i];\n      else lastNode.next = listNodeReverse(rootArr[i]);\n    } else {\n      if (i === 0) root = listNodeReverse(rootArr[i]);\n      else lastNode.next = listNodeReverse(rootArr[i]);\n      lastNode = listNodeLastNode(root);\n    }\n  }\n  return root;\n};"},{"date":"2021-03-06","time":100,"memory":42.5,"script":"typescript","desc":"递归。","code":"function _reverseList(head: ListNode, count: number): ListNode | null {\n  if (count === 1 || head.next === null) return head;\n  const tail = head.next;\n  const nextList = _reverseList(tail, count - 1);\n  head.next = tail.next;\n  tail.next = head;\n  return nextList;\n}\nfunction reverseList(head: ListNode, count: number): ListNode | null {\n  let temp: ListNode | null = head;\n  let c = count;\n  while (--c && temp) temp = temp.next;\n  return temp ? _reverseList(head, count) : head;\n}\nfunction reverseKGroup(head: ListNode | null, k: number): ListNode | null {\n  const dummyHead = new ListNode(0, head);\n  let temp: ListNode = dummyHead;\n  while (temp !== null && temp.next !== null) {\n    temp!.next = reverseList(temp.next!, k);\n    let count = k;\n    while (count-- && temp !== null) temp = temp.next!;\n  }\n  return dummyHead.next;\n}"}],"tagList":["递归","链表"],"level":"Hard"}},{"problemName":"26.删除有序数组中的重复项.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/26.删除有序数组中的重复项.json","problemData":{"id":"26","name":"26.删除有序数组中的重复项","url":"https://leetcode.cn/problems/remove-duplicates-from-sorted-array","desc":"给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。","solutions":[{"date":"2021-04-18","time":88,"memory":41.3,"script":"typescript","desc":"快慢指针。","code":"function removeDuplicates(nums: number[]): number {\n  const len = nums.length;\n  if (len === 0 || len === 1) return len;\n  let slow = 0;\n  let fast = 1;\n  while (fast < len) {\n    if (nums[slow] !== nums[fast]) nums[++slow] = nums[fast];\n    fast++;\n  }\n  return slow + 1;\n}"},{"date":"2021-12-20","time":12,"memory":18,"script":"cpp","desc":"双指针。","code":"class Solution {\n   public:\n    int removeDuplicates(vector<int>& nums) {\n        int n = nums.size(), l = 0, r = 0;\n        if (n == 0) return 0;\n        while (r < n) {\n            while (r < n && nums[r] == nums[l]) r++;\n            if (r < n) nums[++l] = nums[r++];\n        }\n        return l + 1;\n    }\n};"}],"tagList":["数组","双指针"],"level":"Easy"}},{"problemName":"28.找出字符串中第一个匹配项的下标.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/28.找出字符串中第一个匹配项的下标.json","problemData":{"id":"28","name":"28.找出字符串中第一个匹配项的下标","url":"https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string","desc":"给你两个字符串  haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回   -1 。","solutions":[{"date":"2021-04-20","time":84,"memory":40.2,"script":"typescript","desc":"直接调用 indexOf。","code":"function strStr(haystack: string, needle: string): number {\n  return haystack.indexOf(needle);\n}"},{"date":"2021-10-12","time":84,"memory":41.8,"script":"typescript","desc":"kmp。","code":"function getNext(needle: string) {\n  const next: number[] = [-1];\n  for (let i = 1, j = -1; needle[i]; i++) {\n    while (j !== -1 && needle[j + 1] !== needle[i]) j = next[j];\n    if (needle[j + 1] === needle[i]) j++;\n    next[i] = j;\n  }\n  return next;\n}\nfunction strStr(haystack: string, needle: string): number {\n  if (needle.length === 0) return 0;\n  const next = getNext(needle);\n  for (let i = 0, j = -1; haystack[i]; i++) {\n    while (j !== -1 && needle[j + 1] !== haystack[i]) j = next[j];\n    if (needle[j + 1] === haystack[i]) j++;\n    if (!needle[j + 1]) return i - j;\n  }\n  return -1;\n}"},{"date":"2021-10-12","time":1504,"memory":42.3,"script":"typescript","desc":"sunday。","code":"function getMap(needle: string) {\n  const map: Record<string, number> = {};\n  for (let i = 0; needle[i]; i++) map[needle[i]] = i;\n  return (c: string) => map[c] ?? -1;\n}\nfunction strStr(haystack: string, needle: string): number {\n  if (needle.length === 0) return 0;\n  const len = needle.length;\n  const map = getMap(needle);\n  for (let i = 0; haystack[i]; i += len - map(haystack[i + len])) {\n    let j = 0;\n    while (needle[j] && haystack[i + j] === needle[j]) j++;\n    if (!needle[j]) return i;\n  }\n  return -1;\n}"}],"tagList":["双指针","字符串","字符串匹配"],"level":"Easy"}},{"problemName":"29.两数相除.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/29.两数相除.json","problemData":{"id":"29","name":"29.两数相除","url":"https://leetcode.cn/problems/divide-two-integers","desc":"给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。","solutions":[{"date":"2021-10-12","time":80,"memory":39.8,"script":"typescript","desc":"不符合题意，直接利用乘法除法计算。","code":"function divide(dividend: number, divisor: number): number {\n  const num =\n    Math.floor(Math.abs(dividend) / Math.abs(divisor)) * (divisor * dividend >= 0 ? 1 : -1);\n  return num >= (-2) ** 31 && num <= 2 ** 31 - 1 ? num : 2 ** 31 - 1;\n}"},{"date":"2021-10-12","time":92,"memory":39.7,"script":"typescript","desc":"利用^判断正负号，利用 num << i === num \\* 2 << i 来取值。","code":"function divide(dividend: number, divisor: number): number {\n  if (dividend === (-2) ** 31 && divisor === -1) return 2 ** 31 - 1;\n  if (dividend === (-2) ** 31 && divisor === 1) return dividend;\n  const flag = (dividend ^ divisor) < 0 ? -1 : 1;\n  dividend = Math.abs(dividend);\n  divisor = Math.abs(divisor);\n  let ans = 0;\n  for (let i = 31; i >= 0; i--) {\n    if (dividend >>> i >= divisor) {\n      ans += 1 << i;\n      dividend -= divisor << i;\n    }\n  }\n  return flag * ans;\n}"}],"tagList":["位运算","数学"],"level":"Medium"}},{"problemName":"3.无重复字符的最长子串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/3.无重复字符的最长子串.json","problemData":{"id":"3","name":"3.无重复字符的最长子串","url":"https://leetcode.cn/problems/longest-substring-without-repeating-characters","desc":"给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。","solutions":[{"date":"2019-09-20","time":128,"memory":37.1,"script":"javascript","desc":"创建数组，遍历每个字符，若字符不存在数组中则压栈，若字符存在则循环出栈直到字符不存在，每次遍历的最后判断数组长度大于 length 长度，则赋值给 length。","code":"var lengthOfLongestSubstring = function (s) {\n  let arr = [],\n    length = 0;\n  for (let c of s) {\n    if (arr.indexOf(c) > -1) {\n      while (arr.indexOf(c) > -1) {\n        arr.shift();\n      }\n    }\n    arr.push(c);\n    if (arr.length > length) {\n      length = arr.length;\n    }\n  }\n  return length;\n};"},{"date":"2021-10-16","time":180,"memory":47.7,"script":"typescript","desc":"二分。","code":"function lengthOfLongestSubstring(s: string): number {\n  if (s.length === 0) return 0;\n  let min = 1;\n  let max = s.length;\n  while (min < max) {\n    const mid = (min + max + 1) >> 1;\n    if (check(mid)) min = mid;\n    else max = mid - 1;\n  }\n  return min;\n  function check(len: number): boolean {\n    const map: Record<string, number> = {};\n    let ans = 0;\n    for (let i = 0; s[i]; i++) {\n      if (!map[s[i]]) ans++;\n      map[s[i]] = (map[s[i]] ?? 0) + 1;\n      if (i >= len) {\n        map[s[i - len]]--;\n        if (map[s[i - len]] === 0) ans--;\n      }\n      if (ans === len) return true;\n    }\n    return false;\n  }\n}"},{"date":"2021-11-30","time":4,"memory":5.7,"script":"c","desc":"滑动窗口判断当前窗口中是否存在超过两次的字符，存在则左侧右移，否则右侧右移。","code":"int lengthOfLongestSubstring(char * s){\n    int arr[128] = {0};\n    int cnt = 0, l = 0, r = 0, n = strlen(s), ans = 0;\n    while (r < n) {\n        while (r < n && cnt == 0) {\n            arr[s[r]] += 1;\n            if (arr[s[r]] == 2) {\n                ++cnt;\n            }\n            ++r;\n            if (cnt == 0 && ans < r - l) ans = r - l;\n        }\n        while (cnt != 0) {\n            arr[s[l]] -= 1;\n            if (arr[s[l]] == 1) --cnt;\n            ++l;\n        }\n    }\n    return ans;\n}"},{"date":"2021-12-24","time":4,"memory":6.7,"script":"cpp","desc":"双指针。","code":"class Solution {\n          public:\n    int lengthOfLongestSubstring(string s) {\n        int arr[200] = {0}, l = 0, r = 0, ans = 0, n = s.size();\n        while (r < n) {\n            while (r < n && arr[s[r]] < 1) arr[s[r++]]++;\n            ans = max(ans, r - l);\n            char ch = s[r++];\n            arr[ch]++;\n            while (s[l] != ch) arr[s[l++]]--;\n            arr[s[l++]]--;\n        }\n        return ans;\n    }\n};"}],"tagList":["哈希表","字符串","滑动窗口"],"level":"Medium"}},{"problemName":"30.串联所有单词的子串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/30.串联所有单词的子串.json","problemData":{"id":"30","name":"30.串联所有单词的子串","url":"https://leetcode.cn/problems/substring-with-concatenation-of-all-words","desc":"给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。","solutions":[{"date":"2022-06-23","time":172,"memory":28.3,"script":"cpp","desc":"检测每一个可能成功的点。","code":"class Solution {\n   public:\n    int wordSize, sSize, wordsSize;\n    unordered_map<string, int> m;\n    string s;\n    vector<string> words;\n    vector<int> findSubstring(string s, vector<string> &words) {\n        this->s = s;\n        this->words = words;\n        sSize = s.size();\n        wordSize = words[0].size();\n        wordsSize = words.size();\n        for (auto &w : words) m[w]++;\n        vector<int> ans, list = getlist();\n        unordered_map<int, int> listmap;\n        for (int i = 0; i < list.size(); i++) listmap[list[i]] = i;\n        for (int i = 0; i < list.size(); i++)\n            if (check(list, listmap, i)) ans.push_back(list[i]);\n        return ans;\n    }\n    vector<int> getlist() {\n        vector<int> list;\n        string tmp = s.substr(0, wordSize);\n        for (int i = wordSize; i < sSize; i++) {\n            if (m.count(tmp)) list.push_back(i - wordSize);\n            tmp = tmp.substr(1, wordSize - 1) + s[i];\n        }\n        if (m.count(tmp)) list.push_back(sSize - wordSize);\n        return list;\n    }\n    bool check(vector<int> &list, unordered_map<int, int> &listmap, int start) {\n        int firstIdx = list[start];\n        int lastIdx = firstIdx + (wordsSize - 1) * wordSize;\n        if (!listmap.count(lastIdx)) return false;\n        return _check(list, listmap, start, m);\n    }\n    bool _check(vector<int> &list, unordered_map<int, int> &listmap, int start,\n                unordered_map<string, int> m) {\n        for (int i = list[start], cnt = 0; cnt < wordsSize;\n             cnt++, i += wordSize) {\n            if (!listmap.count(i)) return false;\n            if (m[s.substr(list[listmap[i]], wordSize)]-- == 0) return false;\n        }\n        return true;\n    }\n};"}],"tagList":["哈希表","字符串","滑动窗口"],"level":"Hard"}},{"problemName":"31.下一个排列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/31.下一个排列.json","problemData":{"id":"31","name":"31.下一个排列","url":"https://leetcode.cn/problems/next-permutation","desc":"实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。","solutions":[{"date":"2020-11-10","time":96,"memory":40,"script":"typescript","desc":"计算最小改动数，逆序遍历检测递增。","code":"function nextPermutation(nums: number[]): void {\n  const len = nums.length;\n  const swap = (i1: number, i2: number) => {\n    const t = nums[i1];\n    nums[i1] = nums[i2];\n    nums[i2] = t;\n  };\n  const reverse = (left: number) => {\n    let right = len - 1;\n    while (left < right) {\n      swap(left, right);\n      left++;\n      right--;\n    }\n  };\n  let i = len - 2;\n  while (i >= 0 && nums[i] >= nums[i + 1]) {\n    i--;\n  }\n  if (i >= 0) {\n    let j = len - 1;\n    while (j >= 0 && nums[i] >= nums[j]) {\n      j--;\n    }\n    swap(i, j);\n  }\n  reverse(i + 1);\n}"}],"tagList":["数组","双指针"],"level":"Medium"}},{"problemName":"32.最长有效括号.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/32.最长有效括号.json","problemData":{"id":"32","name":"32.最长有效括号","url":"https://leetcode.cn/problems/longest-valid-parentheses","desc":"给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。","solutions":[{"date":"2021-11-06","time":84,"memory":40.7,"script":"typescript","desc":"动态规划分析括号出现的状态。","code":"function longestValidParentheses(s: string): number {\n  const n = s.length;\n  const dp = new Array(n + 1).fill(0);\n  let ans = 0;\n  for (let i = 1; i < n; i++) {\n    const ch = s[i];\n    if (ch === '(') dp[i + 1] = 0;\n    else if (s[i - 1] === '(') dp[i + 1] = dp[i - 1] + 2;\n    else if (s[i - dp[i] - 1] === '(') dp[i + 1] = dp[i] + 2 + dp[i - dp[i] - 1];\n    else dp[i + 1] = 0;\n    ans = Math.max(ans, dp[i + 1]);\n  }\n  return ans;\n}"}],"tagList":["栈","字符串","动态规划"],"level":"Hard"}},{"problemName":"33.搜索旋转排序数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/33.搜索旋转排序数组.json","problemData":{"id":"33","name":"33.搜索旋转排序数组","url":"https://leetcode.cn/problems/search-in-rotated-sorted-array","desc":"假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组  [0,1,2,4,5,6,7]  可能变为  [4,5,6,7,0,1,2] )。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回  -1 。","solutions":[{"date":"2020-04-27","time":68,"memory":33.8,"script":"javascript","desc":"直接使用内置 indexOf。","code":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function (nums, target) {\n  return nums.indexOf(target);\n};"},{"date":"2020-04-27","time":72,"memory":33.9,"script":"javascript","desc":"二分查找进行判断是否有转折点。","code":"/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar search = function (nums, target) {\n  const len = nums.length;\n  if (len === 0) return -1;\n  let first = 0;\n  let last = len;\n  if (nums[last - 1] > nums[first]) {\n    return search(first, last);\n  } else\n    while (first < last) {\n      if (last - first === 1 && nums[first] !== target) return -1;\n      const mid = (last + first) >> 1;\n      // console.log(\"======\");\n      // console.log(\"first\", first);\n      // console.log(\"last\", last);\n      // console.log(\"mid\", mid);\n      const midNum = nums[mid];\n      const firstNum = nums[first];\n      if (midNum === target) return mid;\n      if (midNum > firstNum) {\n        if (target >= firstNum && target < midNum) return search(first, mid);\n        else first = mid + 1;\n      }\n      if (midNum < firstNum) {\n        if (target > midNum && nums[last - 1] >= target) return search(mid, last);\n        else last = mid;\n      }\n    }\n  return -1;\n  function search(first, last) {\n    // console.log(\"======\");\n    // console.log(\"search\", first, last);\n    if ((last - first === 1 && nums[first] !== target) || first === last) return -1;\n    const mid = (last + first) >> 1;\n    const num = nums[mid];\n    if (num === target) return mid;\n    else if (num < target) {\n      return search(mid + 1, last);\n    } else {\n      return search(first, mid);\n    }\n  }\n};"}],"tagList":["数组","二分查找"],"level":"Medium"}},{"problemName":"34.在排序数组中查找元素的第一个和最后一个位置.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/34.在排序数组中查找元素的第一个和最后一个位置.json","problemData":{"id":"34","name":"34.在排序数组中查找元素的第一个和最后一个位置","url":"https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array","desc":"给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。","solutions":[{"date":"2020-12-01","time":108,"memory":41.5,"script":"typescript","desc":"直接调用原生方法。","code":"function searchRange(nums: number[], target: number): number[] {\n  return [nums.indexOf(target), nums.lastIndexOf(target)];\n}"},{"date":"2020-12-01","time":80,"memory":41.4,"script":"typescript","desc":"二分查找。","code":"function searchRange(nums: number[], target: number): number[] {\n  const len = nums.length;\n  return [find(), find(false)];\n  function find(order = true, l = 0, r = len): number {\n    if (l >= r) return -1;\n    const mid = ~~((l + r) / 2);\n    const num = nums[mid];\n    if (num > target) {\n      return find(order, l, mid);\n    } else if (num < target) {\n      return find(order, mid + 1, r);\n    } else {\n      let i = mid;\n      const index = order ? find(order, l, mid) : find(order, mid + 1, r);\n      return index === -1 ? i : index;\n    }\n  }\n}"},{"date":"2021-07-22","time":68,"memory":40.6,"script":"typescript","desc":"二分查找。","code":"function searchRange(nums: number[], target: number): number[] {\n  const ans: number[] = new Array(2).fill(-1);\n  const i = bs(target);\n  if (nums[i] !== target) return ans;\n  else ans[0] = i;\n  ans[1] = bs(target + 1) - 1;\n  return ans;\n  function bs(target: number) {\n    let l = 0;\n    let r = nums.length - 1;\n    while (r - l > 3) {\n      const mid = (l + r) >> 1;\n      if (nums[mid] >= target) r = mid;\n      else l = mid + 1;\n    }\n    for (let i = l; i <= r; i++) {\n      if (nums[i] >= target) return i;\n    }\n    return nums.length;\n  }\n}"}],"tagList":["数组","二分查找"],"level":"Medium"}},{"problemName":"35.搜索插入位置.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/35.搜索插入位置.json","problemData":{"id":"35","name":"35.搜索插入位置","url":"https://leetcode.cn/problems/search-insert-position","desc":"给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。","solutions":[{"date":"2020-07-17","time":80,"memory":38.6,"script":"typescript","desc":"二分查找。","code":"function searchInsert(nums: number[], target: number): number {\n  function _search(l: number, r: number): number {\n    if (l >= r) return l;\n    const mid = (l + r) >> 1;\n    const num = nums[mid];\n    if (num < target) return _search(mid + 1, r);\n    else if (num > target) return _search(l, mid);\n    else return mid;\n  }\n  return _search(0, nums.length);\n}"},{"date":"2021-07-22","time":80,"memory":39.5,"script":"typescript","desc":"二分查找。","code":"function searchInsert(nums: number[], target: number): number {\n  let l = 0;\n  let r = nums.length - 1;\n  while (l <= r) {\n    const mid = (l + r) >> 1;\n    const midNum = nums[mid];\n    if (midNum < target) l = mid + 1;\n    else if (midNum > target) r = mid - 1;\n    else return mid;\n  }\n  return l;\n}"},{"date":"2021-11-30","time":0,"memory":6.6,"script":"c","desc":"二分查找。","code":"int searchInsert(int* nums, int numsSize, int target){\n    int m, l = 0, r = numsSize - 1;\n    if (nums[l] > target) return 0;\n    if (nums[r] < target) return numsSize;\n    while (l < r) {\n        m = (l + r) >> 1;\n        if (nums[m] == target) {\n            l = m;\n            break;\n        }\n        if (nums[m] >= target) r = m;\n        else l = m + 1;\n    }\n    return l;\n}"},{"date":"2021-12-20","time":4,"memory":9.5,"script":"cpp","desc":"二分查找。","code":"class Solution {\n   public:\n    int searchInsert(vector<int>& nums, int target) {\n        int l = 0, r = nums.size(), m;\n        while (l < r) {\n            m = (l + r) >> 1;\n            if (nums[m] >= target)\n                r = m;\n            else\n                l = m + 1;\n        }\n        return l;\n    }\n};"}],"tagList":["数组","二分查找"],"level":"Easy"}},{"problemName":"36.有效的数独.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/36.有效的数独.json","problemData":{"id":"36","name":"36.有效的数独","url":"https://leetcode.cn/problems/valid-sudoku","desc":"请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。 。","solutions":[{"date":"2021-09-17","time":96,"memory":43.8,"script":"javascript","desc":"逐行遍历，set 储存。","code":"function isValidSudoku(board: string[][]): boolean {\n        const rows: Set<string>[] = new Array(9).fill(0).map(_ => new Set<string>());\n        const cols: Set<string>[] = new Array(9).fill(0).map(_ => new Set<string>());\n        const blocks: Set<string>[] = new Array(9).fill(0).map(_ => new Set<string>());\n        const getBolck = (row: number, col: number) => ~~(row / 3) * 3 + ~~(col / 3);\n        for (let row = 0; row < 9; row++) {\n          for (let col = 0; col < 9; col++) {\n            const val = board[row][col];\n            const block = getBolck(row, col);\n            if (val === '.') continue;\n            const rowSet = rows[row];\n            const colSet = cols[col];\n            const blockSet = blocks[block];\n            if (rowSet.has(val) || colSet.has(val) || blockSet.has(val)) return false;\n            rowSet.add(val);\n            colSet.add(val);\n            blockSet.add(val);\n          }\n        }\n        return true;\n      }"}],"tagList":["数组","哈希表","矩阵"],"level":"Medium"}},{"problemName":"37.解数独.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/37.解数独.json","problemData":{"id":"37","name":"37.解数独","url":"https://leetcode.cn/problems/sudoku-solver","desc":"编写一个程序，通过已填充的空格来解决数独问题。","solutions":[{"date":"2020-09-15","time":96,"memory":38.4,"script":"typescript","desc":"[参考连接](https://leetcode-cn.com/problems/sudoku-solver/solution/di-gui-hui-su-wei-yun-suan-by-zoffer-3/)。","code":"class Sudoku {\n  private rows = new Array(9).fill(0);\n  private cols = new Array(9).fill(0);\n  private boxs = Array.from({ length: 3 }, () => new Array(3).fill(0));\n  private emptyCells = new Set<number>();\n  constructor(private board: string[][]) {}\n  solve() {\n    //初始化已知的数字\n    for (let i = 0; i < 9; i++) {\n      for (let j = 0; j < 9; j++) {\n        const num = this.board[i][j];\n        if (num !== '.') {\n          //将数字转化为二进制标记\n          //1 -> 0b1, 2 -> 0b10, 3 -> 0b100, 4 -> 0b1000 ...\n          const sign = 1 << (Number(num) - 1);\n          this.rows[i] |= sign;\n          this.cols[j] |= sign;\n          this.boxs[Math.floor(i / 3)][Math.floor(j / 3)] |= sign;\n        } else {\n          this.emptyCells.add((i << 4) | j);\n        }\n      }\n    }\n    //主逻辑\n    return this.fillNext();\n  }\n  fillNext() {\n    let cellInfo = this.getEmptyCell();\n    if (cellInfo === null) {\n      //没有空格，解题成功\n      return true;\n    }\n    let [i, j, possible] = cellInfo;\n    while (possible) {\n      //截取其中一个可能性\n      const sign = -possible & possible;\n      //填入空格\n      this.fillCell(i, j, sign);\n      //继续下一个填充\n      if (this.fillNext()) {\n        //填充成功\n        return true;\n      } else {\n        //排除当前数字\n        possible ^= sign;\n        //清空空格\n        this.cleanCell(i, j, sign);\n      }\n    }\n    //穷尽所有可能性，回溯\n    return false;\n  }\n  getEmptyCell() {\n    let min = 10;\n    let cellInfo = null;\n    for (const id of this.emptyCells) {\n      const i = id >> 4,\n        j = id & 0b1111;\n      const possible = this.getCellPossible(i, j);\n      const count = this.countPossible(possible);\n      if (min > count) {\n        //挑选可能性最少的格子，理论上可减少犯错回溯\n        cellInfo = [i, j, possible];\n        min = count;\n      }\n    }\n    return cellInfo;\n  }\n  countPossible(possible: number) {\n    //计算二进制 1 的数量\n    let count = 0;\n    while (possible) {\n      possible &= possible - 1;\n      count++;\n    }\n    return count;\n  }\n  fillCell(i: number, j: number, sign: number) {\n    //对应位变成1，标记占用\n    this.rows[i] |= sign;\n    this.cols[j] |= sign;\n    this.boxs[Math.floor(i / 3)][Math.floor(j / 3)] |= sign;\n    //填入空格\n    this.emptyCells.delete((i << 4) | j);\n    this.board[i][j] = String(Math.log2(sign) + 1);\n  }\n  cleanCell(i: number, j: number, sign: number) {\n    //对应位变为0，清除占用\n    this.rows[i] &= ~sign;\n    this.cols[j] &= ~sign;\n    this.boxs[Math.floor(i / 3)][Math.floor(j / 3)] &= ~sign;\n    //清空格子\n    this.emptyCells.add((i << 4) | j);\n    this.board[i][j] = '.';\n  }\n  getCellPossible(i: number, j: number) {\n    //获取格子可能的取值，二进制1表示可选\n    return (\n      (this.rows[i] | this.cols[j] | this.boxs[Math.floor(i / 3)][Math.floor(j / 3)]) ^ 0b111111111\n    );\n  }\n}\nfunction solveSudoku(board: string[][]): void {\n  new Sudoku(board).solve();\n}"}],"tagList":["数组","哈希表","回溯","矩阵"],"level":"Hard"}},{"problemName":"38.外观数列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/38.外观数列.json","problemData":{"id":"38","name":"38.外观数列","url":"https://leetcode.cn/problems/count-and-say","desc":"给定一个正整数 n ，输出外观数列的第 n 项。","solutions":[{"date":"2021-10-15","time":80,"memory":40.1,"script":"typescript","desc":"递归层级。","code":"function countAndSay(n: number): string {\n  return findNext();\n  function findNext(str = '1', level = n): string {\n    if (level === 1) return str;\n    let next = '';\n    for (let i = 0, l = str.length; i < l; i++) {\n      const ch = str[i];\n      let cnt = 1;\n      while (i < l - 1 && str[i + 1] === ch) {\n        i++;\n        cnt++;\n      }\n      next += cnt + ch;\n    }\n    return findNext(next, level - 1);\n  }\n}"},{"date":"2021-11-30","time":4,"memory":6.4,"script":"c","desc":"递归对每一层进行处理。","code":"#define MAX 20000\nchar *dfs(char *str, int cnt) {\n    if (cnt == 1) return str;\n    int len = strlen(str), idx = 0;\n    char next[MAX];\n    for (int i = 0; i < len; i++) {\n        char ch = str[i];\n        int cnt = 1;\n        while (i + 1 < len && ch == str[i + 1]) {\n            ++i;\n            ++cnt;\n        }\n        idx += sprintf(next + idx, \"%d\", cnt);\n        next[idx++] = ch;\n    }\n    next[idx] = '\\0';\n    return dfs(next, cnt - 1);\n}\nchar * countAndSay(int n){\n    return dfs(\"1\", n);\n}"},{"date":"2021-12-20","time":0,"memory":6.5,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    string countAndSay(int n) {\n        string str = \"1\";\n        while (--n) {\n            string next = \"\";\n            for (int i = 0, n = str.size(); i < n; i++) {\n                char ch = str[i];\n                int cnt = 1;\n                while (i + 1 < n && str[i + 1] == ch) i++, cnt++;\n                while (cnt) {\n                    next += cnt % 10 + '0';\n                    cnt /= 10;\n                }\n                next += ch;\n            }\n            str = next;\n        }\n        return str;\n    }\n};"}],"tagList":["字符串"],"level":"Medium"}},{"problemName":"39.组合总和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/39.组合总和.json","problemData":{"id":"39","name":"39.组合总和","url":"https://leetcode.cn/problems/combination-sum","desc":"给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。","solutions":[{"date":"2020-09-09","time":104,"memory":44.9,"script":"typescript","desc":"遍历数组递归。","code":"function combinationSum(candidates: number[], target: number): number[][] {\n  const len = candidates.length;\n  if (len === 0) return [];\n  else if (len === 1) {\n    const num = candidates[0];\n    return target % num === 0 ? [new Array(target / num).fill(num)] : [];\n  }\n  const ans: number[][] = [];\n  for (let i = 0; i < len; i++) {\n    const num = candidates[i];\n    let sum = 0;\n    let arr = combinationSum([num], target);\n    let count = 0;\n    if (arr.length !== 0) ans.push(...arr);\n    while ((sum += num) < target) {\n      count++;\n      arr = combinationSum(candidates.slice(i + 1), target - sum);\n      arr.length !== 0 && ans.push(...arr.map(v => new Array(count).fill(num).concat(v)));\n    }\n  }\n  return ans;\n}"},{"date":"2021-07-25","time":92,"memory":40.7,"script":"typescript","desc":"dfs+剪枝，每次遍历时，可以选当前值或者下一值。","code":"function combinationSum(candidates: number[], target: number): number[][] {\n  const ans: number[][] = [];\n  dfs();\n  return ans;\n  function dfs(index = 0, value = 0, list: number[] = []) {\n    if (value >= target || index === candidates.length) {\n      value === target && ans.push([...list]);\n      return;\n    }\n    const candy = candidates[index];\n    list.push(candy);\n    dfs(index, value + candy, list);\n    list.pop();\n    dfs(index + 1, value, list);\n  }\n}"},{"script":"python","time":42,"memory":16.42,"desc":"dfs。","code":"class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        res = []\n        n = len(candidates)\n        def dfs(index: int, cur: int, arr: List[int]):\n            if index == n:\n                if cur == target:\n                    res.append(arr[:])\n            elif cur > target:\n                return\n            else:\n                dfs(index + 1, cur, arr)\n                cnt = 1\n                while cur + cnt * candidates[index] <=  target:\n                    dfs(index + 1, cur + cnt * candidates[index], arr + [candidates[index]] * cnt)\n                    cnt += 1\n\n        dfs(0, 0, [])\n        return res","date":"2024-04-20"}],"tagList":["数组","回溯"],"level":"Medium"}},{"problemName":"4.寻找两个正序数组的中位数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/4.寻找两个正序数组的中位数.json","problemData":{"id":"4","name":"4.寻找两个正序数组的中位数","url":"https://leetcode.cn/problems/median-of-two-sorted-arrays","desc":"给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。","solutions":[{"date":"2020-05-24","time":144,"memory":42.2,"script":"typescript","desc":"合并数组排序后直接求两个中间值。","code":"var findMedianSortedArrays = function (nums1: number[], nums2: number[]): number {\n  const len = nums1.length + nums2.length;\n  const mid1 = len >> 1;\n  const mid2 = len % 2 === 0 ? mid1 - 1 : mid1;\n  const arr = [...nums1, ...nums2].sort((a, b) => a - b);\n  return (arr[mid1] + arr[mid2]) / 2;\n};"},{"date":"2021-07-23","time":124,"memory":42.9,"script":"typescript","desc":"二分查找。","code":"function findMedianSortedArrays(nums1: number[], nums2: number[]): number {\n  const n1 = nums1.length;\n  const n2 = nums2.length;\n  const v1 = find((n1 + n2 + 1) >> 1);\n  if ((n1 + n2) % 2 === 1) return v1;\n  const v2 = find(((n1 + n2 + 1) >> 1) + 1);\n  return (v1 + v2) / 2;\n  function find(k: number, i1: number = 0, i2: number = 0): number {\n    if (i1 === nums1.length) return nums2[i2 + k - 1];\n    if (i2 === nums2.length) return nums1[i1 + k - 1];\n    if (k === 1) return Math.min(nums1[i1], nums2[i2]);\n    let v1 = Math.min(k >> 1, nums1.length - i1);\n    let v2 = Math.min(k - v1, nums2.length - i2);\n    v1 = k - v2;\n    if (nums1[i1 + v1 - 1] <= nums2[i2 + v2 - 1]) return find(k - v1, i1 + v1, i2);\n    else return find(k - v2, i1, i2 + v2);\n  }\n}"}],"tagList":["数组","二分查找","分治"],"level":"Hard"}},{"problemName":"40.组合总和II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/40.组合总和II.json","problemData":{"id":"40","name":"40.组合总和II","url":"https://leetcode.cn/problems/combination-sum-ii","desc":"给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。","solutions":[{"date":"2020-09-10","time":88,"memory":39.7,"script":"typescript","desc":"遍历数组递归。","code":"function combinationSum2(candidates: number[], target: number): number[][] {\n  candidates.sort((a, b) => a - b);\n  const len = candidates.length;\n  const res: number[][] = [];\n  dfs();\n  return res;\n  function dfs(start = 0, temp: number[] = [], sum = 0) {\n    if (sum === target) res.push(temp.slice());\n    else if (sum > target) {\n    } else {\n      for (let i = start; i < len; i++) {\n        const num = candidates[i];\n        if (candidates[i - 1] === num && i - 1 >= start) continue;\n        temp.push(num);\n        dfs(i + 1, temp, sum + num);\n        temp.pop();\n      }\n    }\n  }\n}"}],"tagList":["数组","回溯"],"level":"Medium"}},{"problemName":"41.缺失的第一个正数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/41.缺失的第一个正数.json","problemData":{"id":"41","name":"41.缺失的第一个正数","url":"https://leetcode.cn/problems/first-missing-positive","desc":"给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。","solutions":[{"date":"2020-06-27","time":72,"memory":33.1,"script":"typescript","desc":"直接排序后依次判断。","code":"function firstMissingPositive(nums: number[]): number {\n  nums.sort((a, b) => a - b);\n  let minNum = 1;\n  for (const num of nums) {\n    if (num > minNum) break;\n    else if (num === minNum) minNum++;\n  }\n  return minNum;\n}"},{"date":"2020-06-27","time":96,"memory":39,"script":"typescript","desc":"对数组进行赋值，负数赋值为 len+1,整数则在对应位置上取负。","code":"function firstMissingPositive(nums: number[]): number {\n  const len = nums.length;\n  for (let i = 0; i < len; i++) if (nums[i] <= 0) nums[i] = len + 1;\n  console.log(nums);\n  for (let i = 0; i < len; i++) {\n    const num = Math.abs(nums[i]);\n    if (num <= len) nums[num - 1] = -Math.abs(nums[num - 1]);\n  }\n  for (let i = 0; i < len; i++) if (nums[i] > 0) return i + 1;\n  return len + 1;\n}"},{"date":"2021-08-15","time":92,"memory":57.3,"script":"typescript","desc":"把每个正整数放置正确的位置最后做判断。","code":"function firstMissingPositive(nums: number[]): number {\n  const n = nums.length;\n  for (let i = 0; i < n; i++) {\n    while (nums[i] !== i + 1) {\n      if (nums[i] > n || nums[i] <= 0 || nums[nums[i] - 1] === nums[i]) break;\n      [nums[nums[i] - 1], nums[i]] = [nums[i], nums[nums[i] - 1]];\n    }\n  }\n  let i = 0;\n  while (i < n && nums[i] === i + 1) i++;\n  return i + 1;\n}"},{"date":"2021-08-15","time":92,"memory":57.3,"script":"typescript","desc":"把每个正整数放置正确的位置最后做判断。","code":"function firstMissingPositive(nums: number[]): number {\n  const n = nums.length;\n  for (let i = 0; i < n; i++) {\n    while (nums[i] !== i + 1) {\n      if (nums[i] > n || nums[i] <= 0 || nums[nums[i] - 1] === nums[i]) break;\n      [nums[nums[i] - 1], nums[i]] = [nums[i], nums[nums[i] - 1]];\n    }\n  }\n  let i = 0;\n  while (i < n && nums[i] === i + 1) i++;\n  return i + 1;\n}"}],"tagList":["数组","哈希表"],"level":"Hard"}},{"problemName":"42.接雨水.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/42.接雨水.json","problemData":{"id":"42","name":"42.接雨水","url":"https://leetcode.cn/problems/trapping-rain-water","desc":"给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。","solutions":[{"date":"2020-04-08","time":84,"memory":36.1,"script":"javascript","desc":"先算出每个点的左高和右高，再通过判断两边高度来判断是否储水。","code":"/**\n * @param {number[]} height\n * @return {number}\n */\nvar trap = function (height) {\n  let max = 0;\n  let volumn = 0;\n  const leftMax = [];\n  const rightMax = [];\n  for (let i = 0; i < height.length; i++) {\n    leftMax[i] = max = Math.max(height[i], max);\n  }\n  max = 0;\n  for (let i = height.length - 1; i >= 0; i--) {\n    rightMax[i] = max = Math.max(height[i], max);\n  }\n  for (let i = 0; i < height.length; i++) {\n    volumn += Math.min(leftMax[i], rightMax[i]) - height[i];\n  }\n  return volumn;\n};"},{"date":"2021-07-20","time":88,"memory":39.6,"script":"typescript","desc":"逐层增加。","code":"function trap(height: number[]): number {\n  const n = height.length;\n  const stack: number[] = [];\n  let ans = 0;\n  for (let i = 0; i < n; i++) {\n    const h = height[i];\n    while (stack.length && height[stack[stack.length - 1]] < h) {\n      const cur = stack.pop()!;\n      if (stack.length === 0) continue;\n      const left = stack[stack.length - 1];\n      ans += (Math.min(height[left], h) - height[cur]) * (i - left - 1);\n    }\n    stack.push(i);\n  }\n  return ans;\n}"},{"date":"2021-07-22","time":80,"memory":40.1,"script":"typescript","desc":"按列求出每一列接水量。","code":"function trap(height: number[]): number {\n  const n = height.length;\n  const l = new Array(n).fill(0);\n  const r = new Array(n).fill(0);\n  let max = height[0];\n  for (let i = 1; i < n; i++) {\n    l[i] = max;\n    max = Math.max(max, height[i]);\n  }\n  max = height[n - 1];\n  for (let i = n - 2; i >= 0; i--) {\n    r[i] = max;\n    max = Math.max(max, height[i]);\n  }\n  let ans = 0;\n  for (let i = 0; i < n; i++) ans += Math.max(Math.min(l[i], r[i]) - height[i], 0);\n  return ans;\n}"},{"date":"2021-07-22","time":80,"memory":40.2,"script":"typescript","desc":"合并循环。","code":"function trap(height: number[]): number {\n  const n = height.length;\n  const l = new Array(n).fill(0);\n  const r = new Array(n).fill(0);\n  let maxL = height[0];\n  let maxR = height[n - 1];\n  for (let i = 1; i < n - 1; i++) {\n    l[i] = maxL;\n    maxL = Math.max(maxL, height[i]);\n    r[n - 1 - i] = maxR;\n    maxR = Math.max(maxR, height[n - 1 - i]);\n  }\n  let ans = 0;\n  for (let i = 0; i < n; i++) ans += Math.max(Math.min(l[i], r[i]) - height[i], 0);\n  return ans;\n}"},{"script":"cpp","time":16,"memory":19.6,"desc":"统计左右最大高度。","code":"class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int sum = 0, n = height.size();\n        vector<int> r(n, 0);\n        for (int i = n - 1, cur = 0; i >= 0; i--) {\n            r[i] = cur;\n            cur = max(cur, height[i]);\n        }\n        for (int i = 0, cur = 0; i < n; i++) {\n            cur = max(cur, height[i]);\n            sum += max(0, min(cur, r[i]) - height[i]);\n        }\n        return sum;\n    }\n};","date":"2023-07-23"},{"script":"python","time":68,"memory":17.7,"desc":"同上。","code":"class Solution:\n    def trap(self, height: List[int]) -> int:\n        sum = 0\n        n = len(height)\n        cur = 0\n        r = [0] * n\n        for i in range(n-1, -1, -1):\n            r[i] = cur\n            cur = max(cur, height[i])\n        cur = 0\n        for i in range(n):\n            cur = max(cur, height[i])\n            sum += max(0, min(cur, r[i])-height[i])\n        return sum","date":"2023-07-23"},{"script":"rust","time":0,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn trap(height: Vec<i32>) -> i32 {\n        let mut sum = 0;\n        let n = height.len();\n        let mut cur = 0;\n        let mut r = vec![0; n];\n        for i in (0..n).rev() {\n            r[i] = cur;\n            cur = cur.max(height[i]);\n        }\n        cur = 0;\n        for i in 0..n {\n            cur = cur.max(height[i]);\n            sum += 0.max(cur.min(r[i]) - height[i]);\n        }\n        sum\n    }\n}","date":"2023-07-23"}],"tagList":["栈","数组","双指针","动态规划","单调栈"],"level":"Hard"}},{"problemName":"43.字符串相乘.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/43.字符串相乘.json","problemData":{"id":"43","name":"43.字符串相乘","url":"https://leetcode.cn/problems/multiply-strings","desc":"给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。","solutions":[{"date":"2020-05-13","time":68,"memory":34,"script":"javascript","desc":"使用 BigInt 直接运算。","code":"/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\nvar multiply = (num1, num2) => (BigInt(num1) * BigInt(num2)).toString();"},{"date":"2020-05-13","time":108,"memory":38.3,"script":"javascript","desc":"转换成数组进行每位相乘。","code":"/**\n * @param {string} num1\n * @param {string} num2\n * @return {string}\n */\nvar multiply = (num1, num2) => {\n  if (num1 === '0' || num2 === '0') return '0';\n  const toArr = s =>\n    s\n      .split('')\n      .map(v => +v)\n      .reverse();\n  const merge = (arr1, arr2) => {\n    let jin = 0;\n    let i = 0;\n    let num;\n    for (len = arr2.length; i < len; i++) {\n      if (arr1[i] === undefined) num = arr2[i] + jin;\n      else num = arr1[i] + arr2[i] + jin;\n      jin = Math.floor(num / 10);\n      arr1[i] = num % 10;\n    }\n    if (jin !== 0) arr1[i] = jin;\n  };\n  const arr1 = toArr(num1);\n  const arr2 = toArr(num2);\n  let jin = 0;\n  const res = [],\n    temp = [];\n  for (let i = 0, len1 = arr1.length; i < len1; i++) {\n    temp.length = 0;\n    for (let tempNum = 1; tempNum <= i; tempNum++) temp.push(0);\n    for (let j = 0, len2 = arr2.length; j < len2; j++) {\n      const num = arr2[j] * arr1[i] + jin;\n      jin = Math.floor(num / 10);\n      temp.push(num % 10);\n    }\n    if (jin !== 0) {\n      temp.push(jin);\n      jin = 0;\n    }\n    merge(res, temp);\n  }\n  return res.reverse().join('');\n};"},{"date":"2020-08-13","time":88,"memory":37.9,"script":"typescript","desc":"使用 BigInt 直接相乘。","code":"function multiply(num1: string, num2: string): string {\n  return BigInt(num1) * BigInt(num2) + '';\n}"},{"date":"2021-07-21","time":92,"memory":39.4,"script":"typescript","desc":"bigint。","code":"function multiply(num1: string, num2: string): string {\n  return BigInt(num1) * BigInt(num2) + '';\n}"},{"date":"2021-07-21","time":100,"memory":40.4,"script":"typescript","desc":"统计每一位。","code":"function multiply(num1: string, num2: string): string {\n  const n1 = num1.length;\n  const n2 = num2.length;\n  const list1 = new Array(n1)\n    .fill(0)\n    .map((_, i) => +num1[i])\n    .reverse();\n  const list2 = new Array(n2)\n    .fill(0)\n    .map((_, i) => +num2[i])\n    .reverse();\n  const n = n1 + n2 - 1;\n  const ans: number[] = new Array(n).fill(0);\n  for (let i = 0; i < n1; i++) {\n    for (let j = 0; j < n2; j++) {\n      ans[i + j] += list1[i] * list2[j];\n    }\n  }\n  let add = 0;\n  for (let i = 0; i < n; i++) {\n    if (add) {\n      ans[i] += add;\n      add = 0;\n    }\n    if (ans[i] >= 10) {\n      add = ~~(ans[i] / 10);\n      ans[i] = ans[i] % 10;\n    }\n  }\n  if (add) ans.push(add);\n  while (ans.length > 1 && ans[ans.length - 1] === 0) ans.pop();\n  return ans.reverse().join('');\n}"}],"tagList":["数学","字符串","模拟"],"level":"Medium"}},{"problemName":"44.通配符匹配.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/44.通配符匹配.json","problemData":{"id":"44","name":"44.通配符匹配","url":"https://leetcode.cn/problems/wildcard-matching","desc":"给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '\\*' 的通配符匹配。","solutions":[{"date":"2020-07-05","time":172,"memory":49.9,"script":"typescript","desc":"如果是?或者字母，则匹配前一个，如果是\\*则判断前一个是否能匹配。","code":"function isMatch(s: string, p: string): boolean {\n  const sLen = s.length;\n  const pLen = p.length;\n  const dp = new Array(sLen + 1).fill(0).map(_ => new Array(pLen + 1).fill(false));\n  dp[0][0] = true;\n  for (let i = 1; i <= pLen; i++) {\n    dp[0][i] = p[i - 1] === '*' && dp[0][i - 1];\n  }\n  for (let i = 1; i <= sLen; i++) {\n    for (let j = 1; j <= pLen; j++) {\n      const cP = p[j - 1];\n      if (cP === '?' || s[i - 1] === cP) {\n        dp[i][j] = dp[i - 1][j - 1];\n      } else if (cP === '*' && (dp[i - 1][j] || dp[i][j - 1])) {\n        dp[i][j] = true;\n      }\n    }\n  }\n  return dp[sLen][pLen];\n}"}],"tagList":["贪心","递归","字符串","动态规划"],"level":"Hard"}},{"problemName":"45.跳跃游戏II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/45.跳跃游戏II.json","problemData":{"id":"45","name":"45.跳跃游戏II","url":"https://leetcode.cn/problems/jump-game-ii","desc":"给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。","solutions":[{"date":"2020-05-04","time":84,"memory":36.43,"script":"javascript","desc":"通过递归对每层判断后压栈。","code":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar jump = function (nums) {\n  const len = nums.length;\n  if (len === 1) return 0;\n  // console.log(len);\n  let maxStep = 1;\n  let maxIndex = nums[0];\n  let tempMaxIndex = 0;\n  const newArr = new Array();\n  newArr[0] = 0;\n  newArr[maxIndex] = 1;\n  for (let i = 1; i < len; i++) {\n    const num = nums[i];\n    // console.log(\"==\");\n    // console.log(\"i:\" + i);\n    // console.log(\"num:\" + num);\n    // console.log(\"num+i:\" + (num + i));\n    if (i > maxIndex) {\n      maxIndex = tempMaxIndex;\n      newArr[maxIndex] = ++maxStep;\n      if (newArr.length >= len) break;\n    }\n    const nextIndex = num + i;\n    if (nextIndex >= tempMaxIndex) {\n      tempMaxIndex = nextIndex;\n    }\n  }\n  // console.log(newArr);\n  let resIndex = len - 1;\n  let res = newArr[resIndex];\n  while (res === undefined) {\n    res = newArr[++resIndex];\n  }\n  return res;\n};"},{"date":"2021-07-21","time":84,"memory":40,"script":"typescript","desc":"每次跳跃，获取当前可跳跃范围。","code":"function jump(nums: number[]): number {\n  const n = nums.length;\n  if (n <= 1) return 0;\n  let curP = 0;\n  let maxP = nums[0];\n  let ans = 1;\n  while (maxP + 1 < n) {\n    let nextMaxP = nums[curP];\n    for (let i = curP + 1; i <= maxP; i++) {\n      nextMaxP = Math.max(nums[i] + i, nextMaxP);\n    }\n    curP = maxP;\n    maxP = nextMaxP;\n    ans++;\n  }\n  return ans;\n}"}],"tagList":["贪心","数组","动态规划"],"level":"Medium"}},{"problemName":"46.全排列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/46.全排列.json","problemData":{"id":"46","name":"46.全排列","url":"https://leetcode.cn/problems/permutations","desc":"给定一个 没有重复 数字的序列，返回其所有可能的全排列。","solutions":[{"date":"2020-04-25","time":80,"memory":37.3,"script":"javascript","desc":"通过递归对每层判断后压栈。","code":"/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permute = function (nums) {\n  const len = nums.length;\n  if (len === 1) return [nums];\n  const res = [];\n  for (let i = 0; i < len; i++) {\n    const newNums = permute(nums.filter((_, index) => index !== i));\n    for (const newNum of newNums) res.push([nums[i]].concat(newNum));\n  }\n  return res;\n};"},{"date":"2021-07-21","time":88,"memory":41,"script":"typescript","desc":"全排列。","code":"function permute(nums: number[]): number[][] {\n  const ans: number[][] = [];\n  find();\n  return ans;\n  function find(list = nums, queue: number[] = []): void {\n    if (list.length === 0) {\n      ans.push(queue.slice());\n      return;\n    }\n    for (let i = 0, l = list.length; i < l; i++) {\n      queue.push(list[i]);\n      find([...list.slice(0, i), ...list.slice(i + 1)], queue);\n      queue.pop();\n    }\n  }\n}"}],"tagList":["数组","回溯"],"level":"Medium"}},{"problemName":"47.全排列II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/47.全排列II.json","problemData":{"id":"47","name":"47.全排列II","url":"https://leetcode.cn/problems/permutations-ii","desc":"给定一个可包含重复数字的序列，返回所有不重复的全排列。","solutions":[{"date":"2020-09-18","time":588,"memory":48.9,"script":"typescript","desc":"递归后利用 set 去重。","code":"function permuteUnique(nums: number[]): number[][] {\n  const len = nums.length;\n  if (len === 1) return [nums];\n  const res: number[][] = [];\n  for (let i = 0; i < len; i++) {\n    res.push(\n      ...permuteUnique([...nums.slice(0, i), ...nums.slice(i + 1)]).map(v => [nums[i], ...v])\n    );\n  }\n  // 去重\n  const set = new Set(res.map(v => v.join(':')));\n  const ans: number[][] = [];\n  for (const arr of set) {\n    ans.push(arr.split(':').map(v => parseInt(v)));\n  }\n  return ans;\n}"},{"date":"2021-08-14","time":176,"memory":44.5,"script":"typescript","desc":"set 去重。","code":"function permuteUnique(nums: number[]): number[][] {\n  const ans = new Set<string>();\n  add(nums);\n  return [...ans].map(v => v.split('::').map(v => +v));\n  function add(list: number[], q: number[] = []): void {\n    if (list.length === 1) {\n      q.push(list[0]);\n      ans.add(q.join('::'));\n      q.pop();\n      return;\n    }\n    for (let i = 0; i < list.length; i++) {\n      q.push(list[i]);\n      add([...list.slice(0, i), ...list.slice(i + 1)], q);\n      q.pop();\n    }\n  }\n}"}],"tagList":["数组","回溯"],"level":"Medium"}},{"problemName":"48.旋转图像.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/48.旋转图像.json","problemData":{"id":"48","name":"48.旋转图像","url":"https://leetcode.cn/problems/rotate-image","desc":"给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。","solutions":[{"date":"2020-12-19","time":84,"memory":40.3,"script":"typescript","desc":"利用新数组储存。","code":"function rotate(matrix: number[][]): void {\n  const n = matrix.length;\n  const arr: number[][] = [];\n  for (let i = 0; i < n; i++) {\n    const row: number[] = [];\n    for (let j = n - 1; j >= 0; j--) {\n      row.push(matrix[j][i]);\n    }\n    arr.push(row);\n  }\n  for (let i = 0; i < n; i++) matrix[i] = arr[i];\n}"},{"date":"2020-12-19","time":80,"memory":41.5,"script":"typescript","desc":"利用两次翻转代替旋转。","code":"function rotate(matrix: number[][]): void {\n  const n = matrix.length;\n  // 水平翻转\n  for (let i = 0, max = n / 2; i < max; i++) {\n    for (let j = 0; j < n; j++) {\n      [matrix[i][j], matrix[n - i - 1][j]] = [matrix[n - i - 1][j], matrix[i][j]];\n    }\n  }\n  // 主对角线翻转\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < i; j++) {\n      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n    }\n  }\n}"}],"tagList":["数组","数学","矩阵"],"level":"Medium"}},{"problemName":"49.字母异位词分组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/49.字母异位词分组.json","problemData":{"id":"49","name":"49.字母异位词分组","url":"https://leetcode.cn/problems/group-anagrams","desc":"给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。","solutions":[{"date":"2020-12-14","time":176,"memory":50.8,"script":"typescript","desc":"利用 map 去储存,key 重新变换。","code":"function groupAnagrams(strs: string[]): string[][] {\n  const cache: Record<string, string[]> = {};\n  const toKey = (str: string) =>\n    str\n      .split('')\n      .sort((a, b) => a.codePointAt(0)! - b.codePointAt(0)!)\n      .join('');\n  for (const str of strs) {\n    const key = toKey(str);\n    let arr = cache[key];\n    if (!arr) {\n      cache[key] = arr = [];\n    }\n    arr.push(str);\n  }\n  return Object.values(cache);\n}"},{"date":"2021-12-23","time":24,"memory":19,"script":"cpp","desc":"对字符串进行排序后归并。","code":"class Solution {\n   public:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, vector<string>> m;\n        for (int i = 0; i < strs.size(); i++) {\n            string str = strs[i];\n            string head = str;\n            sort(head.begin(), head.end());\n            m[head].push_back(str);\n        }\n        vector<vector<string>> ans;\n        for (auto it = m.begin(); it != m.end(); it++) {\n            ans.push_back(it->second);\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","字符串","排序"],"level":"Medium"}},{"problemName":"5.最长回文子串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/5.最长回文子串.json","problemData":{"id":"5","name":"5.最长回文子串","url":"https://leetcode.cn/problems/longest-palindromic-substring","desc":"给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。","solutions":[{"date":"2020-04-07","time":84,"memory":42.6,"script":"javascript","desc":"对每个字符依次判断两边是否相等，相等则+1，不相等则跳过。","code":"/**\n * @param {string} s\n * @return {string}\n */\nvar longestPalindrome = function (s) {\n  const len = s.length;\n  let maxRes = '';\n  if (len === 0) return maxRes;\n  for (let i = 0; i < len; i++) {\n    const c = s[i];\n    let left = i - 1;\n    let right = i + 1;\n    let maxS = c;\n    while (i < len && c === s[i + 1]) {\n      maxS += c;\n      right++;\n      i++;\n    }\n    while (left >= 0 && right <= len - 1) {\n      if (s[left] !== s[right]) break;\n      maxS = s[left] + maxS + s[right];\n      left--;\n      right++;\n    }\n    maxRes = maxS.length > maxRes.length ? maxS : maxRes;\n  }\n  return maxRes;\n};"},{"date":"2021-10-16","time":88,"memory":45,"script":"typescript","desc":"马拉车算法。","code":"function longestPalindrome(s: string): string {\n  s = createStr(s);\n  let max = -1;\n  let maxIdx = -1;\n  const n = s.length;\n  const arr = new Array(n).fill(0);\n  let ans = s[0];\n  for (let i = 0; i < n; i++) {\n    if (i <= max) {\n      arr[i] = Math.min(arr[2 * maxIdx - i], max - i);\n    }\n    let l = i - arr[i];\n    let r = i + arr[i];\n    while (l - 1 >= 0 && r + 1 <= n - 1 && s[l - 1] === s[r + 1]) {\n      l--;\n      r++;\n    }\n    if (r > max) {\n      max = r;\n      maxIdx = i;\n    }\n    arr[i] = r - i;\n    if (ans.length < r - l + 1) {\n      ans = s.substring(l, r + 1);\n    }\n  }\n  return ans.replace(/#/g, '');\n  function createStr(s: string) {\n    let ans = '#';\n    for (let i = 0; s[i]; i++) ans += s[i] + '#';\n    return ans;\n  }\n}"}],"tagList":["双指针","字符串","动态规划"],"level":"Medium"}},{"problemName":"50.Pow(x,n).json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/50.Pow(x,n).json","problemData":{"id":"50","name":"50.Pow(x,n)","url":"https://leetcode.cn/problems/powx-n","desc":"实现 pow(x, n) ，即计算 x 的 n 次幂函数。","solutions":[{"date":"2020-05-11","time":5424,"memory":35.1,"script":"javascript","desc":"通过对半拆分进行计算后合并。","code":"/**\n * @param {number} x\n * @param {number}\n * @return {number}\n */\nvar myPow = function (x, n) {\n  const cache = { 0: 1, 1: x };\n  function comp(n) {\n    if (!cache[n]) {\n      const mid = Math.floor(n / 2);\n      cache[n] = comp(mid) * comp(n - mid);\n    }\n    return cache[n];\n  }\n  return n >= 0 ? comp(n) : 1 / comp(-n);\n};"},{"date":"2020-05-11","time":60,"memory":33.6,"script":"javascript","desc":"直接调用原生。","code":"/**\n * @param {number} x\n * @param {number} n\n * @return {number}\n */\nvar myPow = function (x, n) {\n  return Math.pow(x, n);\n};"}],"tagList":["递归","数学"],"level":"Medium"}},{"problemName":"51.N皇后.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/51.N皇后.json","problemData":{"id":"51","name":"51.N皇后","url":"https://leetcode.cn/problems/n-queens","desc":"n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。","solutions":[{"date":"2020-04-27","time":72,"memory":36.1,"script":"javascript","desc":"回溯算法，遍历后剪枝。","code":"/**\n * @param {number} n\n * @return {string[][]}\n */\nvar solveNQueens = function (n) {\n  const cols = new Array(n);\n  const res = [];\n  queues(0);\n  function queues(row) {\n    if (row === n) {\n      res.push(getRes());\n    }\n    for (let col = 0; col < n; col++) {\n      if (isValid(row, col)) {\n        cols[row] = col;\n        queues(row + 1);\n      }\n    }\n  }\n  function isValid(row, col) {\n    for (let i = 0; i < row; i++) {\n      if (cols[i] === col) return false;\n      if (row - i === Math.abs(cols[i] - col)) return false;\n    }\n    return true;\n  }\n  function getRes() {\n    const res = [];\n    for (let row = 0; row < n; row++) {\n      let string = '';\n      for (let col = 0; col < n; col++) {\n        if (cols[row] === col) string += 'Q';\n        else string += '.';\n      }\n      res.push(string);\n    }\n    return res;\n  }\n  return res;\n};"},{"date":"2021-07-25","time":108,"memory":44.7,"script":"typescript","desc":"dfs+剪枝。","code":"function solveNQueens(n: number): string[][] {\n  const ans: string[][] = [];\n  const colSet = new Set<number>();\n  const lineSet = new Set<string>();\n  const board = new Array(n).fill(0).map(_ => new Array(n).fill('.'));\n  dfs();\n  return ans;\n  function getLine(row: number, col: number): [string, string] {\n    return [`y=x+${n - 1 - row - col}${specStr}, ${specStr}y=-x+${n - 1 - row + col}`];\n  }\n  function dfs(row: number = 0) {\n    if (row === n) {\n      const newBoard: string[] = new Array(n).fill(0).map((_, row) =>\n        new Array(n)\n          .fill(0)\n          .map((_, col) => board[row][col])\n          .join('')\n      );\n      ans.push(newBoard);\n      return;\n    }\n    for (let col = 0; col < n; col++) {\n      if (colSet.has(col)) continue;\n      const [line1, line2] = getLine(row, col);\n      if (lineSet.has(line1) || lineSet.has(line2)) continue;\n      colSet.add(col);\n      lineSet.add(line1);\n      lineSet.add(line2);\n      board[row][col] = 'Q';\n      dfs(row + 1);\n      board[row][col] = '.';\n      colSet.delete(col);\n      lineSet.delete(line1);\n      lineSet.delete(line2);\n    }\n  }\n}"}],"tagList":["数组","回溯"],"level":"Hard"}},{"problemName":"52.N皇后II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/52.N皇后II.json","problemData":{"id":"52","name":"52.N皇后II","url":"https://leetcode.cn/problems/n-queens-ii","desc":"n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。","solutions":[{"date":"2020-04-27","time":64,"memory":34.1,"script":"javascript","desc":"回溯算法，遍历后剪枝。","code":"/**\n * @param {number} n\n * @return {string[][]}\n */\nvar totalNQueens = function (n) {\n  const cols = new Array(n);\n  let res = 0;\n  queues(0);\n  function queues(row) {\n    if (row === n) {\n      res++;\n    }\n    for (let col = 0; col < n; col++) {\n      if (isValid(row, col)) {\n        cols[row] = col;\n        queues(row + 1);\n      }\n    }\n  }\n  function isValid(row, col) {\n    for (let i = 0; i < row; i++) {\n      if (cols[i] === col) return false;\n      if (row - i === Math.abs(cols[i] - col)) return false;\n    }\n    return true;\n  }\n  return res;\n};"},{"date":"2020-10-17","time":96,"memory":40,"script":"typescript","desc":"回溯。","code":"function totalNQueens(n: number): number {\n  const cols = new Array(n);\n  let ans = 0;\n  find(0);\n  return ans;\n  function find(row: number) {\n    if (row === n) {\n      ans++;\n      return;\n    }\n    for (let i = 0; i < n; i++) {\n      if (check(row, i)) {\n        cols[row] = i;\n        find(row + 1);\n      }\n    }\n  }\n  function check(row: number, col: number): boolean {\n    for (let i = 0; i < row; i++) {\n      if (cols[i] === col) return false;\n      if (row - i === Math.abs(cols[i] - col)) return false;\n    }\n    return true;\n  }\n}"}],"tagList":["回溯"],"level":"Hard"}},{"problemName":"53.最大子数组和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/53.最大子数组和.json","problemData":{"id":"53","name":"53.最大子数组和","url":"https://leetcode.cn/problems/maximum-subarray","desc":"给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。","solutions":[{"date":"2020-05-03","time":64,"memory":35.4,"script":"javascript","desc":"遍历数组，若前一项大于 0 则当前项+=前一项，最后获取数组中的最大值。","code":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSubArray = function (nums) {\n  const len = nums.length;\n  let max = nums[0];\n  if (len === 1) return nums[0];\n  for (let i = 1; i < len; i++) {\n    if (nums[i - 1] > 0) nums[i] += nums[i - 1];\n    if (max < nums[i]) max = nums[i];\n  }\n  return max;\n};"},{"date":"2020-05-07","time":80,"memory":35.2,"script":"javascript","desc":"分治法。","code":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSubArray = function (nums) {\n  if (nums === null || nums.length === 0) return 0;\n  return _maxSubArray(nums, 0, nums.length);\n  function _maxSubArray(nums, begin, end) {\n    if (end - begin < 2) return nums[begin];\n    const mid = (begin + end) >> 1;\n    let leftMax = -Infinity;\n    let leftSum = 0;\n    for (let i = mid - 1; i >= begin; i--) {\n      leftSum += nums[i];\n      leftMax = Math.max(leftMax, leftSum);\n    }\n    let rightMax = -Infinity;\n    let rightSum = 0;\n    for (let i = mid; i < end; i++) {\n      rightSum += nums[i];\n      rightMax = Math.max(rightMax, rightSum);\n    }\n    const max = leftMax + rightMax;\n    return Math.max(max, _maxSubArray(nums, begin, mid), _maxSubArray(nums, mid, end));\n  }\n};"},{"date":"2020-05-10","time":64,"memory":35.9,"script":"javascript","desc":"动态规划，递推，dp[i]=以 nums[i]结尾的子序列和。","code":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSubArray = function (nums) {\n  const len = nums.length;\n  if (nums == null || len == 0) return 0;\n  const dp = [nums[0]];\n  let max = dp[0];\n  for (let i = 1; i < len; i++) max = Math.max(max, (dp[i] = Math.max(0, dp[i - 1]) + nums[i]));\n  return max;\n};"},{"date":"2020-05-10","time":92,"memory":34.8,"script":"javascript","desc":"跟题解 3 思路一样，优化空间。","code":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSubArray = function (nums) {\n  const len = nums.length;\n  if (nums == null || len == 0) return 0;\n  let max = (dp = nums[0]);\n  for (let i = 1; i < len; i++) max = Math.max(max, (dp = Math.max(0, dp) + nums[i]));\n  return max;\n};"},{"date":"2021-05-14","time":92,"memory":40.5,"script":"typescript","desc":"利用前缀和进行快速相减。","code":"function maxSubArray(nums: number[]): number {\n  const len = nums.length;\n  const prefixSumList = [0];\n  for (let i = 1; i <= len; i++) prefixSumList[i] = prefixSumList[i - 1] + nums[i - 1];\n  let min = prefixSumList[0];\n  let ans = nums[0];\n  for (let i = 1; i <= len; i++)\n    ans = Math.max(prefixSumList[i] - (min = Math.min(min, prefixSumList[i - 1])), ans);\n  return ans;\n}"},{"date":"2021-07-17","time":4620,"memory":46.1,"script":"typescript","desc":"前缀和。","code":"function maxSubArray(nums: number[]): number {\n  let num = 0;\n  const len = nums.length;\n  const sums = [0, ...nums.map(v => (num += v))];\n  let ans = -Infinity;\n  for (let i = 0; i < len; i++) {\n    ans = Math.max(ans, nums[i]);\n    const sum = sums[i + 1];\n    for (let j = 0; j < i; j++) {\n      const num = sum - sums[j];\n      ans = Math.max(ans, num);\n    }\n  }\n  return ans;\n}"},{"date":"2021-07-17","time":88,"memory":47.6,"script":"typescript","desc":"前缀和。","code":"function maxSubArray(nums: number[]): number {\n  let num = 0;\n  const len = nums.length;\n  const sums = [0, ...nums.map(v => (num += v))];\n  let min = 0;\n  let ans = -Infinity;\n  for (let i = 0; i < len; i++) {\n    const sum = sums[i + 1];\n    ans = Math.max(ans, sum - min, nums[i]);\n    min = Math.min(min, sum);\n  }\n  return ans;\n}"},{"date":"2021-07-22","time":72,"memory":39.6,"script":"typescript","desc":"取最大值。","code":"function maxSubArray(nums: number[]): number {\n  let ans = -Infinity;\n  let max = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (max > 0) max += nums[i];\n    else max = nums[i];\n    ans = Math.max(ans, max);\n  }\n  return ans;\n}"},{"date":"2021-07-22","time":72,"memory":39.9,"script":"typescript","desc":"单调递增队列。","code":"function maxSubArray(nums: number[]): number {\n  if (nums.length === 1) return nums[0];\n  const sums = [0];\n  nums.forEach((num, i) => sums.push(sums[i] + num));\n  const queue: number[] = [0];\n  let ans = -Infinity;\n  for (let i = 1; i <= nums.length; i++) {\n    const num = sums[i];\n    ans = Math.max(ans, num - queue[0]);\n    while (queue.length && queue[queue.length - 1] > num) queue.pop();\n    queue.push(num);\n  }\n  return ans;\n}"},{"date":"2021-09-04","time":75,"memory":39.5,"script":"typescript","desc":"前缀和，减去前面前缀和的最小值。","code":"function maxSubArray(nums: number[]): number {\n  const sums = [0];\n  const n = nums.length;\n  for (let i = 0; i < n; i++) sums.push(sums[sums.length - 1] + nums[i]);\n  let ans = -Infinity;\n  let min = 0;\n  for (let i = 1; i <= n; i++) {\n    ans = Math.max(sums[i] - min, ans);\n    min = Math.min(min, sums[i]);\n  }\n  return ans;\n}"},{"date":"2021-12-21","time":164,"memory":66.1,"script":"cpp","desc":"分治，求出左边最大值，右边最大值和中间最大值。","code":"class Solution {\n   public:\n    int maxSubArray(vector<int>& nums) { return dfs(nums, 0, nums.size() - 1); }\n    int dfs(vector<int>& nums, int l, int r) {\n        if (l == r) return nums[l];\n        int m = (l + r) >> 1, lmax = INT_MIN, rmax = INT_MIN, sum = 0;\n        for (int i = m; i >= l; i--) {\n            sum += nums[i];\n            lmax = max(lmax, sum);\n        }\n        sum = 0;\n        for (int i = m + 1; i <= r; i++) {\n            sum += nums[i];\n            rmax = max(rmax, sum);\n        }\n        return max(lmax + rmax, max(dfs(nums, l, m), dfs(nums, m + 1, r)));\n    }\n};"},{"date":"2021-12-21","time":100,"memory":66,"script":"cpp","desc":"遍历，每次求出前面的最大值。","code":"class Solution {\n   public:\n    int maxSubArray(vector<int>& nums) {\n        int sum = nums[0], ans = sum;\n        for (int i = 1; i < nums.size(); i++) {\n            sum = max(0, sum) + nums[i];\n            ans = max(ans, sum);\n        }\n        return ans;\n    }\n};"},{"script":"python","time":168,"memory":30.34,"desc":"遍历后记录前面的最小前缀和。","code":"class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        ans = -inf\n        prev = 0\n        sums = 0\n        for num in nums:\n            sums += num\n            ans = max(ans, sums - prev)\n            prev = min(prev, sums)\n        return ans","date":"2023-11-20"}],"tagList":["数组","分治","动态规划"],"level":"Medium"}},{"problemName":"54.螺旋矩阵.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/54.螺旋矩阵.json","problemData":{"id":"54","name":"54.螺旋矩阵","url":"https://leetcode.cn/problems/spiral-matrix","desc":"给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。","solutions":[{"date":"2020-06-05","time":84,"memory":32.4,"script":"typescript","desc":"递归判断每一圈","code":"function spiralOrder(matrix: number[][]): number[] {\n  const row = matrix.length;\n  if (row === 0) return [];\n  else if (row === 1) return matrix[0];\n  const ans: number[] = [];\n  const col = matrix[0].length;\n  spiral(0, row - 1, 0, col - 1);\n  return ans;\n  function spiral(startI: number, endI: number, startJ: number, endJ: number): void {\n    if (endI < startI || endJ < startJ) return;\n    for (let i = startJ; i <= endJ; i++) ans.push(matrix[startI][i]);\n    for (let i = startI + 1; i <= endI; i++) ans.push(matrix[i][endJ]);\n    for (let i = endJ - 1; startI !== endI && i >= startJ; i--) ans.push(matrix[endI][i]);\n    for (let i = endI - 1; startJ !== endJ && i >= startI + 1; i--) ans.push(matrix[i][startJ]);\n    if (startI !== endI && startJ !== endJ) spiral(startI + 1, endI - 1, startJ + 1, endJ - 1);\n  }\n}"},{"date":"2021-03-15","time":92,"memory":39.1,"script":"typescript","desc":"递归循环遍历。","code":"function spiralOrder(matrix: number[][]): number[] {\n  const ans: number[] = [];\n  dfs(0, 0, matrix.length - 1, matrix[0].length - 1);\n  return ans;\n  function dfs(startRow: number, startCol: number, endRow: number, endCol: number): void {\n    if (startRow > endRow || startCol > endCol) return;\n    for (let i = startCol; i <= endCol; i++) ans.push(matrix[startRow][i]);\n    for (let i = startRow + 1; i <= endRow; i++) ans.push(matrix[i][endCol]);\n    if (endRow !== startRow)\n      for (let i = endCol - 1; i >= startCol; i--) ans.push(matrix[endRow][i]);\n    if (endCol !== startCol)\n      for (let i = endRow - 1; i >= startRow + 1; i--) ans.push(matrix[i][startCol]);\n    dfs(startRow + 1, startCol + 1, endRow - 1, endCol - 1);\n  }\n}"}],"tagList":["数组","矩阵","模拟"],"level":"Medium"}},{"problemName":"55.跳跃游戏.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/55.跳跃游戏.json","problemData":{"id":"55","name":"55.跳跃游戏","url":"https://leetcode.cn/problems/jump-game","desc":"给定一个非负整数数组，你最初位于数组的第一个位置。","solutions":[{"date":"2020-04-17","time":68,"memory":35.8,"script":"javascript","desc":"遍历数组，判断每次跳跃后的最大下标并于当前遍历下标进行比较，如果一个位置能够到达，那么这个位置左侧所有位置都能到达。","code":"/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canJump = function (nums) {\n  let k = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (i > k) return false;\n    k = Math.max(k, i + nums[i]);\n  }\n  return true;\n};"}],"tagList":["贪心","数组","动态规划"],"level":"Medium"}},{"problemName":"56.合并区间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/56.合并区间.json","problemData":{"id":"56","name":"56.合并区间","url":"https://leetcode.cn/problems/merge-intervals","desc":"给出一个区间的集合，请合并所有重叠的区间。","solutions":[{"date":"2020-04-16","time":104,"memory":37.2,"script":"javascript","desc":"先排序，再一次判断是否包含。","code":"/**\n * @param {number[][]} intervals\n * @return {number[][]}\n */\nvar merge = function (intervals) {\n  let res = [];\n  intervals = intervals.sort((arr1, arr2) => arr1[0] - arr2[0]);\n  const include = (num, left, right) => num >= left && num <= right;\n  for (let i = 0, len = intervals.length; i < len; i++) {\n    if (i === 0) {\n      res.push(intervals[i]);\n      continue;\n    }\n    const arr = intervals[i];\n    const [left, right] = arr;\n    const oldArr = res.pop();\n    const [oldLeft, oldRight] = oldArr;\n    if (include(left, oldLeft, oldRight)) {\n      if (include(right, oldLeft, oldRight)) res.push(oldArr);\n      else res.push([oldLeft, right]);\n    } else {\n      res.push(oldArr, arr);\n    }\n  }\n  return res;\n};"},{"date":"2021-12-23","time":16,"memory":13.7,"script":"cpp","desc":"排序后合并。","code":"class Solution {\n   public:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end());\n        vector<vector<int>> ans;\n        for (auto& interval : intervals) {\n            if (ans.size() > 0 && ans[ans.size() - 1][1] >= interval[0]) {\n                ans[ans.size() - 1][1] =\n                    max(interval[1], ans[ans.size() - 1][1]);\n            } else {\n                ans.push_back(interval);\n            }\n        }\n        return ans;\n    }\n};"},{"script":"python","time":56,"memory":19.6,"desc":"同上。","code":"class Solution:\n    def merge(self, intervals: List[List[int]]) -> List[List[int]]:\n        intervals.sort(key=lambda o: o[0])\n        res = []\n        for [start, end] in intervals:\n            if not len(res) or res[-1][1] < start:\n                res.append([start, end])\n            else:\n                res[-1][1] = max(res[-1][1], end)\n        return res","date":"2023-08-27"},{"script":"rust","time":8,"memory":2.83,"desc":"同上。","code":"impl Solution {\n    pub fn merge(mut intervals: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        intervals.sort_by_key(|o| o[0]);\n        let mut res: Vec<Vec<i32>> = vec![];\n        for item in intervals {\n            if res.is_empty() || res.last().unwrap()[1] < item[0] {\n                res.push(item);\n            } else {\n                res.last_mut().unwrap()[1] = res.last_mut().unwrap()[1].max(item[1]);\n            }\n        }\n        res\n    }\n}","date":"2023-08-27"}],"tagList":["数组","排序"],"level":"Medium"}},{"problemName":"57.插入区间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/57.插入区间.json","problemData":{"id":"57","name":"57.插入区间","url":"https://leetcode.cn/problems/insert-interval","desc":"给出一个无重叠的 ，按照区间起始端点排序的区间列表。在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。","solutions":[{"date":"2020-11-04","time":96,"memory":42.7,"script":"javascript","desc":"遍历一遍进行合并数组，并校验是否已插入。","code":"function insert(intervals: number[][], newInterval: number[]): number[][] {\n  let [newStart, newEnd] = newInterval;\n  const ans: number[][] = [];\n  let inserted = false;\n  for (const interval of intervals) {\n    const [start, end] = interval;\n    if (inserted) {\n      ans.push(interval);\n    } else if (start > newEnd) {\n      ans.push([newStart, newEnd]);\n      ans.push(interval);\n      inserted = true;\n    } else if (end < newStart) {\n      ans.push(interval);\n    } else if (start <= newStart && end >= newEnd) {\n      ans.push(interval);\n      inserted = true;\n    } else {\n      newStart = Math.min(start, newStart);\n      newEnd = Math.max(end, newEnd);\n    }\n  }\n  inserted || ans.push([newStart, newEnd]);\n  return ans;\n}"},{"script":"cpp","time":16,"memory":16.22,"desc":"遍历。","code":"class Solution {\npublic:\n    vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n        vector<vector<int>> res;\n        int n = intervals.size(), i = 0;\n        while (i < n && intervals[i][1] < newInterval[0]) {\n            res.push_back(intervals[i]);\n            i += 1;\n        }\n        if (i == n) {\n            res.push_back(newInterval);\n        } else if (intervals[i][0] > newInterval[1]) {\n            res.push_back(newInterval);\n            while (i < n) {\n                res.push_back(intervals[i]);\n                i += 1;\n            }\n        } else {\n            res.push_back(\n                vector<int>{\n                    min(intervals[i][0], newInterval[0]),\n                    max(intervals[i][1], newInterval[1])\n                }\n            );\n            i += 1;\n            while (i < n) {\n                if (res.back()[1] >= intervals[i][0]) {\n                    res.back()[1] = max(res.back()[1], intervals[i][1]);\n                } else {\n                    res.push_back(intervals[i]);\n                }\n                i += 1;\n            }\n        }\n        return res;\n    }\n};","date":"2023-08-28"},{"script":"python","time":60,"memory":17.75,"desc":"同上。","code":"class Solution:\n    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:\n        res = []\n        n = len(intervals)\n        i = 0\n        while i < n and intervals[i][1] < newInterval[0]:\n            res.append(intervals[i])\n            i += 1\n        if i == n:\n            res.append(newInterval)\n        elif intervals[i][0] > newInterval[1]:\n            res.append(newInterval)\n            while i < n:\n                res.append(intervals[i])\n                i += 1\n        else:\n            res.append(\n                [min(intervals[i][0], newInterval[0]),\n                    max(intervals[i][1], newInterval[1])]\n            )\n            i += 1\n            while i < n:\n                if res[-1][1] >= intervals[i][0]:\n                    res[-1][1] = max(res[-1][1], intervals[i][1])\n                else:\n                    res.append(intervals[i])\n                i += 1\n        return res","date":"2023-08-28"},{"script":"rust","time":0,"memory":2.54,"desc":"同上。","code":"impl Solution {\n    pub fn insert(intervals: Vec<Vec<i32>>, new_interval: Vec<i32>) -> Vec<Vec<i32>> {\n        use std::cmp::{max, min};\n        let mut res = vec![];\n        let n = intervals.len();\n        let mut i = 0;\n        while i < n && intervals[i][1] < new_interval[0] {\n            res.push(intervals[i].clone());\n            i += 1;\n        }\n        if i == n {\n            res.push(new_interval);\n        } else if intervals[i][0] > new_interval[1] {\n            res.push(new_interval);\n            while i < n {\n                res.push(intervals[i].clone());\n                i += 1;\n            }\n        } else {\n            res.push(vec![\n                min(intervals[i][0], new_interval[0]),\n                max(intervals[i][1], new_interval[1]),\n            ]);\n            i += 1;\n            while i < n {\n                if res.last().unwrap()[1] >= intervals[i][0] {\n                    res.last_mut().unwrap()[1] = max(res.last().unwrap()[1], intervals[i][1]);\n                } else {\n                    res.push(intervals[i].clone());\n                }\n                i += 1;\n            }\n        }\n        res\n    }\n}","date":"2023-08-28"}],"tagList":["数组"],"level":"Medium"}},{"problemName":"58.最后一个单词的长度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/58.最后一个单词的长度.json","problemData":{"id":"58","name":"58.最后一个单词的长度","url":"https://leetcode.cn/problems/length-of-last-word","desc":"给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。","solutions":[{"date":"2021-09-21","time":72,"memory":39.4,"script":"javascript","desc":"分割。","code":"function lengthOfLastWord(s: string): number {\n  return s.trim().split(' ').slice(-1)[0].length;\n}"},{"date":"2021-09-21","time":64,"memory":39.3,"script":"javascript","desc":"循环。","code":"function lengthOfLastWord(s: string): number {\n  let start = s.length - 1;\n  while (s[start] === ' ') start--;\n  let end = start;\n  while (end >= 0 && s[end] !== ' ') end--;\n  return start - end;\n}"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"59.螺旋矩阵II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/59.螺旋矩阵II.json","problemData":{"id":"59","name":"59.螺旋矩阵II","url":"https://leetcode.cn/problems/spiral-matrix-ii","desc":"给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。","solutions":[{"date":"2021-03-16","time":100,"memory":39.4,"script":"typescript","desc":"旋转赋值。","code":"function generateMatrix(n: number): number[][] {\n  const ans: number[][] = new Array(n).fill(0).map(_ => new Array(n));\n  let num = 1;\n  dfs(0, n - 1);\n  return ans;\n  function dfs(startI: number, endI: number): void {\n    if (startI > endI || startI > endI) return;\n    for (let i = startI; i <= endI; i++) ans[startI][i] = num++;\n    for (let i = startI + 1; i <= endI; i++) ans[i][endI] = num++;\n    for (let i = endI - 1; i >= startI; i--) ans[endI][i] = num++;\n    for (let i = endI - 1; i >= startI + 1; i--) ans[i][startI] = num++;\n    dfs(startI + 1, endI - 1);\n  }\n}"}],"tagList":["数组","矩阵","模拟"],"level":"Medium"}},{"problemName":"6.Z字形变换.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/6.Z字形变换.json","problemData":{"id":"6","name":"6.Z字形变换","url":"https://leetcode.cn/problems/zigzag-conversion","desc":"将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。","solutions":[{"date":"2020-04-07","time":92,"memory":42.5,"script":"javascript","desc":"新建数组依次插入字符，通过字符在哪个位置插入来进行判断。","code":"/**\n * @param {string} s\n * @param {number} numRows\n * @return {string}\n */\nvar convert = function (s, numRows) {\n  if (numRows === 1) return s;\n  let result = '';\n  const arrs = new Array(numRows);\n  for (let i = 0; i < numRows; i++) arrs[i] = [];\n  function comp(i) {\n    if (i < numRows) return i;\n    const loop = numRows + numRows - 2;\n    let num;\n    do {\n      num = i % loop;\n    } while (num > loop);\n    if (num < numRows) return num;\n    else return loop - num;\n  }\n  for (let i = 0; i < s.length; i++) {\n    arrs[comp(i)].push(s[i]);\n  }\n  for (const arr of arrs) {\n    for (const s of arr) {\n      if (s !== undefined) result += s;\n    }\n  }\n  return result;\n};"},{"date":"2022-03-01","time":1060,"memory":9.1,"script":"cpp","desc":"遍历后塞入数组。","code":"class Solution {\n   public:\n    string convert(string s, int numRows) {\n        if (numRows == 1) return s;\n        char arr[1000][1000];\n        memset(arr, 0, sizeof(char) * 1000 * 1000);\n        for (int idx = 0, row = 0, col = 0, n = s.size(); idx < n;) {\n            while (idx < n && row < numRows - 1) arr[row++][col] = s[idx++];\n            while (idx < n && row > 0) arr[row--][col++] = s[idx++];\n        }\n        string ans = \"\";\n        for (int i = 0; i < 1000; i++) {\n            for (int j = 0; j < 1000; j++) {\n                if (arr[i][j]) ans += arr[i][j];\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["字符串"],"level":"Medium"}},{"problemName":"60.排列序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/60.排列序列.json","problemData":{"id":"60","name":"60.排列序列","url":"https://leetcode.cn/problems/permutation-sequence","desc":"给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。给定 n 和 k，返回第 k 个排列。","solutions":[{"date":"2020-09-05","time":5932,"memory":76,"script":"typescript","desc":"遍历所有可能,在达到需要的值时暂停。","code":"function getPermutation(n: number, k: number): string {\n  const ans: string[] = [];\n  dfs();\n  return ans[k - 1];\n  function dfs(arr: number[] = [], set: Set<number> = new Set()): void {\n    if (ans.length > k - 1) return;\n    let f = false;\n    for (let i = 1; i <= n; i++) {\n      if (set.has(i)) continue;\n      f = true;\n      set.add(i);\n      arr.push(i);\n      dfs(arr, set);\n      arr.pop();\n      set.delete(i);\n    }\n    if (!f) ans.push(arr.join(''));\n  }\n}"},{"date":"2020-09-05","time":80,"memory":37.8,"script":"typescript","desc":"[官方题解](https://leetcode-cn.com/problems/permutation-sequence/solution/di-kge-pai-lie-by-leetcode-solution/)。","code":"function getPermutation(n: number, k: number): string {\n  const factorials = [1];\n  for (let i = 1; i < n; i++) factorials[i] = factorials[i - 1] * i;\n  k--;\n  let ans = '';\n  const valid: number[] = new Array(n + 1).fill(1);\n  for (let i = 1; i <= n; i++) {\n    let order = ~~(k / factorials[n - i]) + 1;\n    for (let j = 1; j <= n; j++) {\n      order -= valid[j];\n      if (order === 0) {\n        ans += j;\n        valid[j] = 0;\n        break;\n      }\n    }\n    k %= factorials[n - i];\n  }\n  return ans;\n}"}],"tagList":["递归","数学"],"level":"Hard"}},{"problemName":"61.旋转链表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/61.旋转链表.json","problemData":{"id":"61","name":"61.旋转链表","url":"https://leetcode.cn/problems/rotate-list","desc":"给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。","solutions":[{"date":"2021-03-06","time":84,"memory":39.7,"script":"typescript","desc":"拼接头尾后直接计算新头位置。","code":"function rotateRight(head: ListNode | null, k: number): ListNode | null {\n  if (head === null) return null;\n  let count = 1;\n  let temp = head;\n  while (temp.next !== null) {\n    count++;\n    temp = temp.next;\n  }\n  temp.next = head;\n  temp = head;\n  count = count - (k % count);\n  while (--count) temp = temp.next!;\n  const newHead = temp.next;\n  temp.next = null;\n  return newHead;\n}"},{"date":"2021-03-27","time":96,"memory":39.8,"script":"typescript","desc":"首位相连后判断位置进行断链。","code":"function rotateRight(head: ListNode | null, k: number): ListNode | null {\n  if (head === null) return null;\n  let p: ListNode | null = head;\n  let c = 1;\n  while (p.next !== null) {\n    p = p.next;\n    cpp;\n  }\n  p.next = head;\n  c = c - (k % c);\n  while (--c) head = head!.next;\n  p = head!.next;\n  head!.next = null;\n  return p;\n}"}],"tagList":["链表","双指针"],"level":"Medium"}},{"problemName":"62.不同路径.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/62.不同路径.json","problemData":{"id":"62","name":"62.不同路径","url":"https://leetcode.cn/problems/unique-paths","desc":"一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？。","solutions":[{"date":"2020-12-09","time":88,"memory":40.7,"script":"typescript","desc":"动态规划。","code":"function uniquePaths(m: number, n: number): number {\n  const arr = new Array(n).fill(0).map(_ => new Array(m).fill(0));\n  for (let i = n - 1; i >= 0; i--) {\n    for (let j = m - 1; j >= 0; j--) {\n      if (i === n - 1 || j === m - 1) {\n        arr[i][j] = 1;\n      } else {\n        arr[i][j] = arr[i + 1][j] + arr[i][j + 1];\n      }\n    }\n  }\n  return arr[0][0];\n}"}],"tagList":["数学","动态规划","组合数学"],"level":"Medium"}},{"problemName":"63.不同路径II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/63.不同路径II.json","problemData":{"id":"63","name":"63.不同路径II","url":"https://leetcode.cn/problems/unique-paths-ii","desc":"一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？","solutions":[{"date":"2020-07-06","time":80,"memory":37,"script":"typescript","desc":"dp[i][j] = dp[i+1][j] + dp[i][j+1]。","code":"function uniquePathsWithObstacles(obstacleGrid: number[][]): number {\n  const n = obstacleGrid.length;\n  if (n === 0) return 0;\n  const m = obstacleGrid[0].length;\n  if (m === 0) return 0;\n  else if (obstacleGrid[0][0] === 1) return 0;\n  else if (n === 1) {\n    for (const num of obstacleGrid[0]) if (num === 1) return 0;\n    return 1;\n  } else if (m === 1) {\n    for (let i = 0; i < n; i++) if (obstacleGrid[i][0] === 1) return 0;\n    return 1;\n  } else if (obstacleGrid[n - 1][m - 1] === 1) return 0;\n  else {\n    const dp = new Array(n).fill(0).map(_ => new Array(m).fill(0));\n    dp[n - 1][m - 2] = obstacleGrid[n - 1][m - 2] ^ 1;\n    dp[n - 2][m - 1] = obstacleGrid[n - 2][m - 1] ^ 1;\n    for (let i = n - 1; i >= 0; i--) {\n      for (let j = m - 1; j >= 0; j--) {\n        if (obstacleGrid[i][j] === 1 || dp[i][j] === 1) continue;\n        dp[i][j] = (j + 1 < m ? dp[i][j + 1] : 0) + (i + 1 < n ? (dp[i][j] += dp[i + 1][j]) : 0);\n      }\n    }\n    return dp[0][0];\n  }\n}"}],"tagList":["数组","动态规划","矩阵"],"level":"Medium"}},{"problemName":"64.最小路径和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/64.最小路径和.json","problemData":{"id":"64","name":"64.最小路径和","url":"https://leetcode.cn/problems/minimum-path-sum","desc":"给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。","solutions":[{"date":"2020-07-23","time":116,"memory":40.5,"script":"typescript","desc":"动态规划,dp[i][j]=i，j 坐标时的最小值。","code":"function minPathSum(grid: number[][]): number {\n  const row = grid.length;\n  const col = grid[0].length;\n  const dp = new Array(row).fill(0).map(_ => new Array(col));\n  dp[row - 1][col - 1] = grid[row - 1][col - 1];\n  for (let i = row - 1; i >= 0; i--) {\n    for (let j = col - 1; j >= 0; j--) {\n      const num = grid[i][j];\n      if (i === row - 1 && j === col - 1) {\n      } else if (i === row - 1) {\n        dp[i][j] = dp[i][j + 1] + num;\n      } else if (j === col - 1) {\n        dp[i][j] = dp[i + 1][j] + num;\n      } else {\n        dp[i][j] = Math.min(dp[i][j + 1], dp[i + 1][j]) + num;\n      }\n    }\n  }\n  return dp[0][0];\n}"}],"tagList":["数组","动态规划","矩阵"],"level":"Medium"}},{"problemName":"65.有效数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/65.有效数字.json","problemData":{"id":"65","name":"65.有效数字","url":"https://leetcode.cn/problems/valid-number","desc":"验证给定的字符串是否可以解释为十进制数字。","solutions":[{"date":"2020-04-07","time":108,"memory":36.4,"script":"javascript","desc":"使用 Number 方法直接可判断。","code":"/**\n * @param {string} s\n * @return {boolean}\n */\nvar isNumber = function (s) {\n  if (s.trim() === '') return false;\n  const result = Number(s);\n  return !Number.isNaN(result);\n};"}],"tagList":["字符串"],"level":"Hard"}},{"problemName":"66.加一.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/66.加一.json","problemData":{"id":"66","name":"66.加一","url":"https://leetcode.cn/problems/plus-one","desc":"给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。","solutions":[{"date":"2021-10-21","time":76,"memory":39.2,"script":"typescript","desc":"每次 n-1 个元素加一，理解为每次 1 个元素减一。","code":"function plusOne(digits: number[]): number[] {\n  let add = true;\n  for (let n = digits.length, i = n - 1; add && i >= 0; i--) {\n    if (++digits[i] === 10) digits[i] = 0;\n    else add = false;\n  }\n  if (add) digits.unshift(1);\n  return digits;\n}"}],"tagList":["数组","数学"],"level":"Easy"}},{"problemName":"67.二进制求和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/67.二进制求和.json","problemData":{"id":"67","name":"67.二进制求和","url":"https://leetcode.cn/problems/add-binary","desc":"给你两个二进制字符串，返回它们的和（用二进制表示）。","solutions":[{"date":"2020-06-23","time":72,"memory":33.2,"script":"typescript","desc":"利用字符串转数组后过滤获取所需字符进行判断。","code":"function addBinary(a: string, b: string): string {\n  return (BigInt(`0b${a}`) + BigInt(`0b${b}`)).toString(2);\n}"}],"tagList":["位运算","数学","字符串","模拟"],"level":"Easy"}},{"problemName":"68.文本左右对齐.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/68.文本左右对齐.json","problemData":{"id":"68","name":"68.文本左右对齐","url":"https://leetcode.cn/problems/text-justification","desc":"给定一个单词数组和一个长度 maxWidth，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。","solutions":[{"date":"2021-09-09","time":76,"memory":39.4,"script":"typescript","desc":"逐个分解单词组进行拼接。","code":"function repeat(len: number) {\n  return ''.padEnd(len, ' ');\n}\nfunction fullJustify(words: string[], maxWidth: number): string[] {\n  let idx = 0;\n  const ans: string[] = [];\n  const n = words.length;\n  while (idx < n) {\n    let len = 0;\n    const list: string[] = [];\n    while (idx < n && len + words[idx].length <= maxWidth) {\n      const str = words[idx];\n      len += str.length + 1;\n      list.push(str);\n      idx++;\n    }\n    if (idx === n) {\n      ans.push(list.join(' ').padEnd(maxWidth, ' '));\n    } else if (list.length === 1) {\n      ans.push(list[0].padEnd(maxWidth, ' '));\n    } else {\n      const strlen = list.join('').length;\n      let empty = maxWidth - strlen;\n      const emptyList: number[] = new Array(list.length - 1).fill(0);\n      for (let i = 0; empty !== 0; i = (i + 1) % (list.length - 1)) {\n        emptyList[i]++;\n        empty--;\n      }\n      let str = '';\n      for (let i = 0; i < list.length; i++) {\n        str += list[i] + repeat(emptyList.shift()!);\n      }\n      ans.push(str);\n    }\n  }\n  return ans;\n}"}],"tagList":["数组","字符串","模拟"],"level":"Hard"}},{"problemName":"69.x的平方根.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/69.x的平方根.json","problemData":{"id":"69","name":"69.x的平方根","url":"https://leetcode.cn/problems/sqrtx","desc":"实现 int sqrt(int x) 函数。","solutions":[{"date":"2020-05-09","time":84,"memory":35.5,"script":"javascript","desc":"调用自带 Math 函数即可。","code":"/**\n * @param {number} x\n * @return {number}\n */\nvar mySqrt = function (x) {\n  return Math.floor(Math.sqrt(x));\n};"},{"date":"2020-05-09","time":80,"memory":35.4,"script":"javascript","desc":"手动实现 Math.sqrt(),二分搜索。","code":"/**\n * @param {number} x\n * @return {number}\n */\nvar mySqrt = function (x) {\n  if (x === 1) return 1;\n  let right = x;\n  let left = 1;\n  let mid = (right >> 1) + (left >> 1);\n  while (true) {\n    console.log(mid);\n    if (mid ** 2 <= x) {\n      if ((mid + 1) ** 2 > x) return mid;\n      else {\n        left = mid;\n        mid = (right + left) >> 1;\n      }\n    } else {\n      right = mid;\n      mid = (right + left) >> 1;\n    }\n  }\n};"},{"date":"2021-07-22","time":76,"memory":39.8,"script":"typescript","desc":"二分查找。","code":"function mySqrt(x: number): number {\n  let l = 1;\n  let r = x;\n  while (l <= r) {\n    const mid = r + ((l - r) >> 1);\n    const midNum = mid ** 2;\n    if (midNum > x) r = mid - 1;\n    else if (midNum < x) l = mid + 1;\n    else return mid;\n  }\n  return l - 1;\n}"},{"date":"2021-12-20","time":0,"memory":5.8,"script":"cpp","desc":"二分查找。","code":"class Solution {\n   public:\n    int mySqrt(int x) {\n        double l = 0, r = x, m;\n        while ((int)l != (int)r) {\n            m = l + (r - l) / 2.0;\n            if (m > x / m)\n                r = m;\n            else\n                l = m;\n        }\n        return (int)l;\n    }\n};"},{"date":"2021-12-20","time":0,"memory":6,"script":"cpp","desc":"二分查找。","code":"class Solution {\n   public:\n    int mySqrt(int x) {\n        long long l = 0, r = x, m;\n        while (l < r) {\n            m = (l + r + 1) >> 1;\n            if (m * m <= x)\n                l = m;\n            else\n                r = m - 1;\n        }\n        return l;\n    }\n};"}],"tagList":["数学","二分查找"],"level":"Easy"}},{"problemName":"7.整数反转.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/7.整数反转.json","problemData":{"id":"7","name":"7.整数反转","url":"https://leetcode.cn/problems/reverse-integer","desc":"给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。","solutions":[{"date":"2020-02-11","time":96,"memory":35.7,"script":"javascript","desc":"转换成字符串进行翻转。","code":"var reverse = function (x) {\n  let f = true;\n  if (x < 0) f = false;\n  const rev = parseInt(String(x).split('').reverse().join(''));\n  return rev > 2147483647 || rev < -2147483648 ? 0 : f ? rev : -rev;\n};"},{"date":"2021-05-03","time":92,"memory":39.6,"script":"typescript","desc":"逐个累加。","code":"function reverse(x: number): number {\n  let ans = 0;\n  const maxVal = 2 ** 31 - 1;\n  const minVal = (-2) ** 31;\n  while (x !== 0) {\n    ans = ans * 10 + (x % 10);\n    x = (x / 10) >> 0;\n    if (ans > maxVal || ans < minVal) return 0;\n  }\n  return ans;\n}"},{"date":"2021-05-03","time":100,"memory":39.6,"script":"typescript","desc":"利用字符串翻转。","code":"function reverse(x: number): number {\n  const num = Number(Math.abs(x).toString().split('').reverse().join(''));\n  return (x < 0 ? -1 : 1) * (num > 2 ** 31 - 1 || num < (-2) ** 31 ? 0 : num);\n}"},{"date":"2021-12-20","time":0,"memory":5.8,"script":"cpp","desc":"倒置。","code":"class Solution {\n   public:\n    int reverse(int x) {\n        int f = 1;\n        if (x == INT_MIN) return 0;\n        if (x < 0) {\n            x = -x;\n            f = -1;\n        }\n        int num = 0;\n        while (x) {\n            if (num > INT_MAX / 10) return 0;\n            num = num * 10 + x % 10;\n            x /= 10;\n        }\n        return num * f;\n    }\n};"}],"tagList":["数学"],"level":"Medium"}},{"problemName":"70.爬楼梯.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/70.爬楼梯.json","problemData":{"id":"70","name":"70.爬楼梯","url":"https://leetcode.cn/problems/climbing-stairs","desc":"假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？","solutions":[{"date":"2020-06-13","time":84,"memory":32.3,"script":"typescript","desc":"dp[i]=dp[i-1]+dp[i-2]。","code":"function climbStairs(n: number): number {\n  const dp = [1, 1];\n  for (let i = 2; i <= n; i++) dp[i] = dp[i - 1] + dp[i - 2];\n  return dp[n];\n}"},{"date":"2021-09-03","time":68,"memory":39.4,"script":"typescript","desc":"动态规划。","code":"function climbStairs(n: number): number {\n  const dp = new Array(n + 1);\n  dp[0] = dp[1] = 1;\n  for (let i = 2; i <= n; i++) dp[i] = dp[i - 1] + dp[i - 2];\n  return dp[n];\n}"},{"date":"2021-12-21","time":0,"memory":6.1,"script":"cpp","desc":"动态规划。","code":"class Solution {\n   public:\n    int climbStairs(int n) {\n        vector<int> dp(n + 1, 0);\n        dp[0] = dp[1] = 1;\n        for (int i = 2; i <= n; i++) dp[i] = dp[i - 1] + dp[i - 2];\n        return dp[n];\n    }\n};"},{"script":"python","time":36,"memory":16.67,"desc":"dp。","code":"class Solution:\n    def climbStairs(self, n: int) -> int:\n        if n == 1: return 1\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 2\n        for i in range(3, n + 1):\n            dp[i] = dp[i - 1] + dp[i - 2]\n        print(dp)\n        return dp[n]","date":"2023-12-10"}],"tagList":["记忆化搜索","数学","动态规划"],"level":"Easy"}},{"problemName":"71.简化路径.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/71.简化路径.json","problemData":{"id":"71","name":"71.简化路径","url":"https://leetcode.cn/problems/simplify-path","desc":"返回简化后得到的 规范路径 。","solutions":[{"date":"2022-01-06","time":8,"memory":10.8,"script":"cpp","desc":"栈。","code":"class Solution {\n   public:\n    string simplifyPath(string path) {\n        // 简化最后有点没斜线的状态\n        path += \"/\";\n        stack<string> s;\n        int n = path.size();\n        for (int i = 0; i < n; i++) {\n            char ch = path[i];\n            if (ch == '/') {\n                // 如果前面有点\n                if (s.size() && s.top() == \".\") {\n                    int cnt = 0;\n                    while (s.size() && s.top() == \".\") {\n                        s.pop();\n                        cnt++;\n                    }\n                    // 如果有一个点 不做操作\n                    // 如果有两个点 弹出前面的\n                    // 如果有三个以上，不做操作，重新压栈点\n                    if (cnt == 2 && s.size() > 1) {\n                        s.pop();\n                        s.pop();\n                    } else if (cnt > 2) {\n                        while (cnt--) s.push(\".\");\n                        s.push(\"/\");\n                    }\n                } else {\n                    // 如果前面没点 ， 直接弹出前面所有斜线\n                    while (s.size() && s.top() == \"/\") s.pop();\n                    s.push(\"/\");\n                }\n            } else if (ch == '.') {  // 如果是点直接压栈\n                s.push(\".\");\n            } else {\n                // 否则拼接文件或目录名\n                int next = i + 1;\n                while (next < n && path[next] != '/') next++;\n                string str = path.substr(i, next - i);\n                // 如果此时前面有点，说明这点是文件或目录名中的点\n                while (s.size() && s.top() == \".\") {\n                    str = s.top() + str;\n                    s.pop();\n                }\n                s.push(str);\n                i = next - 1;\n            }\n        }\n        string ans = \"\";\n        while (s.size()) {\n            ans = s.top() + ans;\n            s.pop();\n        }\n        // 如果最后一个是斜线直接删除\n        if (ans.size() > 1 && ans[ans.size() - 1] == '/')\n            ans = ans.substr(0, ans.size() - 1);\n        return ans;\n    }\n};"}],"tagList":["栈","字符串"],"level":"Medium"}},{"problemName":"72.编辑距离.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/72.编辑距离.json","problemData":{"id":"72","name":"72.编辑距离","url":"https://leetcode.cn/problems/edit-distance","desc":"给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。","solutions":[{"script":"python","time":84,"memory":18.8,"desc":"dp判断每种情况下的最小操作数。","code":"class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        n1, n2 = len(word1), len(word2)\n        @cache\n        def dfs(i1: int, i2: int) -> int:\n            if i1 == n1: return n2 - i2\n            if i2 == n2: return n1 - i1\n            if word1[i1] == word2[i2]: return dfs(i1 + 1, i2 + 1)\n            return min(\n                dfs(i1 + 1, i2) + 1,    # i1 删除一个字符\n                dfs(i1, i2 + 1) + 1,    # i1 插入一个字符\n                dfs(i1 + 1, i2 + 1) + 1 # i1 替换一个字符\n            )\n        return dfs(0, 0) ","date":"2023-10-23"}],"tagList":["字符串","动态规划"],"level":"Medium"}},{"problemName":"73.矩阵置零.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/73.矩阵置零.json","problemData":{"id":"73","name":"73.矩阵置零","url":"https://leetcode.cn/problems/set-matrix-zeroes","desc":"给定一个 m x n 的矩阵，如果一个元素为 0，则将其所在行和列的所有元素都设为 0。请使用原地算法。","solutions":[{"date":"2021-03-21","time":116,"memory":41.2,"script":"typescript","desc":"记录 col 要置零的下标。","code":"function setZeroes(matrix: number[][]): void {\n  const rowLen = matrix.length;\n  const colLen = matrix[0].length;\n  const colIndexSet = new Set<number>();\n  for (let i = 0; i < rowLen; i++) {\n    const row = matrix[i];\n    let f = false;\n    for (let j = 0; j < colLen; j++) {\n      if (row[j] === 0) {\n        f = true;\n        colIndexSet.add(j);\n      }\n    }\n    f && row.fill(0);\n  }\n  for (let i = 0; i < rowLen; i++) {\n    for (const j of colIndexSet) {\n      matrix[i][j] = 0;\n    }\n  }\n}"}],"tagList":["数组","哈希表","矩阵"],"level":"Medium"}},{"problemName":"74.搜索二维矩阵.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/74.搜索二维矩阵.json","problemData":{"id":"74","name":"74.搜索二维矩阵","url":"https://leetcode.cn/problems/search-a-2d-matrix","desc":"编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。","solutions":[{"date":"2021-03-30","time":84,"memory":39.3,"script":"typescript","desc":"二分查找。","code":"function searchMatrix(matrix: number[][], target: number): boolean {\n  const colLen = matrix[0].length;\n  const rowLen = matrix.length;\n  let targetRow!: number[];\n  for (let i = 0; i < rowLen; i++) {\n    const row = matrix[i];\n    if (i === rowLen - 1) {\n      targetRow = row;\n    } else if (row[0] <= target && matrix[i + 1][0] > target) {\n      targetRow = row;\n      break;\n    }\n  }\n  if (!targetRow) return false;\n  const find = (start: number, end: number): boolean => {\n    if (start > end) return false;\n    const mid = ~~((start + end) / 2);\n    if (targetRow[mid] < target) return find(mid + 1, end);\n    else if (targetRow[mid] > target) return find(start, mid - 1);\n    else return true;\n  };\n  return find(0, colLen - 1);\n}"},{"date":"2021-03-30","time":84,"memory":39.4,"script":"typescript","desc":"二分查找。","code":"function searchMatrix(matrix: number[][], target: number): boolean {\n  const colLen = matrix[0].length;\n  const rowLen = matrix.length;\n  const findRow = (start: number, end: number): number[] | undefined => {\n    if (start > end) return undefined;\n    const mid = ~~((start + end) / 2);\n    const row = matrix[mid];\n    if (row[0] > target) return findRow(start, mid - 1);\n    else if (row[colLen - 1] < target) return findRow(mid + 1, end);\n    else return row;\n  };\n  const targetRow: number[] | undefined = findRow(0, rowLen - 1);\n  if (!targetRow) return false;\n  const findTarget = (start: number, end: number): boolean => {\n    if (start > end) return false;\n    const mid = ~~((start + end) / 2);\n    if (targetRow[mid] < target) return findTarget(mid + 1, end);\n    else if (targetRow[mid] > target) return findTarget(start, mid - 1);\n    else return true;\n  };\n  return findTarget(0, colLen - 1);\n}"},{"date":"2021-03-30","time":88,"memory":39.2,"script":"typescript","desc":"根据特性把二维数据当作一维进行运算。","code":"function searchMatrix(matrix: number[][], target: number): boolean {\n  const colLen = matrix[0].length;\n  const rowLen = matrix.length;\n  const find = (start: number, end: number): boolean => {\n    if (start > end) return false;\n    const mid = ~~((start + end) / 2);\n    const row = ~~(mid / colLen);\n    const col = mid % colLen;\n    if (matrix[row][col] < target) return find(mid + 1, end);\n    else if (matrix[row][col] > target) return find(start, mid - 1);\n    else return true;\n  };\n  return find(0, colLen * rowLen - 1);\n}"}],"tagList":["数组","二分查找","矩阵"],"level":"Medium"}},{"problemName":"75.颜色分类.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/75.颜色分类.json","problemData":{"id":"75","name":"75.颜色分类","url":"https://leetcode.cn/problems/sort-colors","desc":"给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。","solutions":[{"date":"2020-10-07","time":92,"memory":39.9,"script":"typescript","desc":"利用自带排序算法，但不符合提议。","code":"function sortColors(nums: number[]): void {\n  nums.sort((a, b) => a - b);\n}"},{"date":"2020-10-07","time":84,"memory":39.6,"script":"typescript","desc":"计数后重新生成数组。","code":"function sortColors(nums: number[]): void {\n  const cache: Record<number, number> = {\n    0: 0,\n    1: 0,\n    2: 0,\n  };\n  for (const num of nums) {\n    cache[num]++;\n  }\n  nums.length = 0;\n  nums.push(\n    ...new Array(cache[0]).fill(0),\n    ...new Array(cache[1]).fill(1),\n    ...new Array(cache[2]).fill(2)\n  );\n}"},{"date":"2020-10-07","time":88,"memory":39.5,"script":"typescript","desc":"遍历后交换 0 置前，2 置后。","code":"function sortColors(nums: number[]): void {\n  let c = 0;\n  const len = nums.length;\n  const swap = (i1: number, i2: number) =>\n    i1 !== i2 && ([nums[i2], nums[i1]] = [nums[i1], nums[i2]]);\n  // 0\n  for (let i = 0; i < len; i++) {\n    if (nums[i] === 0) {\n      swap(c, i);\n      cpp;\n    }\n  }\n  // 2\n  c = 0;\n  for (let i = len - 1; i >= 0; i--) {\n    if (nums[i] === 2) {\n      swap(len - 1 - c, i);\n      cpp;\n    }\n  }\n}"},{"date":"2020-10-07","time":96,"memory":39.6,"script":"typescript","desc":"双指针一遍循环，记录 p0 和 p1。","code":"function sortColors(nums: number[]): void {\n  let p0 = 0,\n    p1 = 0;\n  const len = nums.length;\n  const swap = (i1: number, i2: number) =>\n    i1 !== i2 && ([nums[i2], nums[i1]] = [nums[i1], nums[i2]]);\n  for (let i = 0; i < len; i++) {\n    if (nums[i] === 1) {\n      swap(p1, i);\n      p1++;\n    } else if (nums[i] === 0) {\n      swap(p0, i);\n      p0 < p1 && swap(i, p1);\n      p1++;\n      p0++;\n    }\n  }\n}"},{"date":"2020-10-07","time":100,"memory":39.5,"script":"typescript","desc":"双指针一遍循环，记录 p0 和 p2。","code":"function sortColors(nums: number[]): void {\n  const len = nums.length;\n  let p0 = 0,\n    p2 = len - 1;\n  const swap = (i1: number, i2: number) =>\n    i1 !== i2 && ([nums[i2], nums[i1]] = [nums[i1], nums[i2]]);\n  for (let i = 0; i < len; i++) {\n    while (i <= p2 && nums[i] === 2) {\n      swap(i, p2);\n      p2--;\n    }\n    if (nums[i] === 0) {\n      swap(i, p0);\n      p0++;\n    }\n  }\n}"},{"date":"2021-05-07","time":92,"memory":39.4,"script":"typescript","desc":"利用内部排序。","code":"function sortColors(nums: number[]): void {\n  nums.sort((a, b) => a - b);\n}"}],"tagList":["数组","双指针","排序"],"level":"Medium"}},{"problemName":"76.最小覆盖子串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/76.最小覆盖子串.json","problemData":{"id":"76","name":"76.最小覆盖子串","url":"https://leetcode.cn/problems/minimum-window-substring","desc":"给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。","solutions":[{"date":"2020-05-23","time":1400,"memory":43.8,"script":"typescript","desc":"定义 i,j 指向 0，不满足条件时 j++，满足时 i++。","code":"type CharCount = { [c: string]: number };\nvar minWindow = function (s: string, t: string): string {\n  // 储存值\n  const map: CharCount = {};\n  for (const c of t) map[c] = map[c] ? map[c] + 1 : 1;\n  function valid(now: CharCount) {\n    for (const [k, v] of Object.entries(map)) if (!now[k] || now[k] < v) return false;\n    return true;\n  }\n  console.log(map);\n  const slen = s.length;\n  const nowMap: CharCount = {};\n  let i = 0,\n    j = 0;\n  let resi = 0,\n    resj = Number.MAX_VALUE;\n  let isV = false;\n  while (j <= slen) {\n    if ((isV = valid(nowMap))) {\n      if (j - i < resj - resi) {\n        resj = j;\n        resi = i;\n      }\n    }\n    if (isV) {\n      const prevC = s[i++];\n      if (nowMap[prevC] === 1) {\n        delete nowMap[prevC];\n      } else {\n        nowMap[prevC]--;\n      }\n    } else {\n      const nextC = s[j++];\n      nowMap[nextC] = nowMap[nextC] ? nowMap[nextC] + 1 : 1;\n    }\n  }\n  console.log(resi, resj);\n  return resj === Number.MAX_VALUE ? '' : s.substring(resi, resj);\n};"},{"date":"2021-11-07","time":92,"memory":41,"script":"typescript","desc":"滑动窗口。","code":"function minWindow(s: string, t: string): string {\n  let cnt = 0;\n  const map: Record<string, number> = {};\n  for (const ch of t) {\n    map[ch] = (map[ch] ?? 0) + 1;\n    if (map[ch] === 1) cnt++;\n  }\n  let l = 0;\n  let r = 0;\n  let ansLen = s.length + 1;\n  let ans = '';\n  while (r <= s.length) {\n    if (cnt) {\n      const ch = s[r];\n      if (map[ch] !== undefined) {\n        map[ch]--;\n        if (map[ch] === 0) cnt--;\n      }\n      r++;\n    } else {\n      const ch = s[l];\n      if (map[ch] !== undefined) {\n        map[ch]++;\n        if (map[ch] === 1) cnt++;\n      }\n      l++;\n    }\n    if (cnt === 0 && ansLen > r - l) {\n      ans = s.substring(l, r);\n      ansLen = ans.length;\n    }\n  }\n  return ans;\n}"},{"date":"2021-11-07","time":92,"memory":41,"script":"typescript","desc":"滑动窗口。","code":"function minWindow(s: string, t: string): string {\n  let cnt = 0;\n  const map: Record<string, number> = {};\n  for (const ch of t) {\n    map[ch] = (map[ch] ?? 0) + 1;\n    if (map[ch] === 1) cnt++;\n  }\n  let l = 0;\n  let r = 0;\n  let ansLen = s.length + 1;\n  let ans = '';\n  while (r <= s.length) {\n    if (cnt) {\n      const ch = s[r];\n      if (map[ch] !== undefined) {\n        map[ch]--;\n        if (map[ch] === 0) cnt--;\n      }\n      r++;\n    } else {\n      const ch = s[l];\n      if (map[ch] !== undefined) {\n        map[ch]++;\n        if (map[ch] === 1) cnt++;\n      }\n      l++;\n    }\n    if (cnt === 0 && ansLen > r - l) {\n      ans = s.substring(l, r);\n      ansLen = ans.length;\n    }\n  }\n  return ans;\n}"}],"tagList":["哈希表","字符串","滑动窗口"],"level":"Hard"}},{"problemName":"77.组合.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/77.组合.json","problemData":{"id":"77","name":"77.组合","url":"https://leetcode.cn/problems/combinations","desc":"给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。","solutions":[{"date":"2020-09-08","time":600,"memory":46.6,"script":"typescript","desc":"回溯递归，利用 set 进行校验。","code":"function combine(n: number, k: number): number[][] {\n  const arr: number[] = [-1];\n  const ans: number[][] = [];\n  const used = new Set<number>();\n  find();\n  return ans;\n  function find() {\n    if (used.size === k) {\n      ans.push(arr.slice(1));\n      return;\n    }\n    for (let i = 1; i <= n; i++) {\n      if (!used.has(i) && arr[arr.length - 1] < i) {\n        used.add(i);\n        arr.push(i);\n        find();\n        arr.pop();\n        used.delete(i);\n      }\n    }\n  }\n}"},{"date":"2020-09-08","time":140,"memory":46.2,"script":"typescript","desc":"回溯+剪枝。","code":"function combine(n: number, k: number): number[][] {\n  const ans: number[][] = [];\n  dfs();\n  return ans;\n  function dfs(cur: number = 1, arr: number[] = []): void {\n    // 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp\n    if (arr.length + (n - cur + 1) < k) return;\n    if (arr.length === k) {\n      ans.push(arr);\n      return;\n    }\n    dfs(cur + 1, [...arr, cur]);\n    dfs(cur + 1, arr);\n  }\n}"},{"date":"2021-08-20","time":164,"memory":46.5,"script":"typescript","desc":"dfs。","code":"function combine(n: number, k: number): number[][] {\n  const set = new Set<number>();\n  const ans: number[][] = [];\n  dfs();\n  return ans;\n  function dfs(list: number[] = [], min = 1) {\n    if (list.length === k) {\n      ans.push(list.slice());\n      return;\n    }\n    if (min > n) return;\n    for (let i = min; i <= n; i++) {\n      if (set.has(i)) continue;\n      list.push(i);\n      set.add(i);\n      dfs(list, i + 1);\n      set.delete(i);\n      list.pop();\n    }\n  }\n}"},{"date":"2021-09-20","time":116,"memory":43.4,"script":"javascript","desc":"dfs。","code":"function combine(n: number, k: number): number[][] {\n  const ans: number[][] = [];\n  for (let i = 1; i <= n; i++) dfs(i);\n  return ans;\n  function dfs(num: number, list: number[] = []): void {\n    if (num === n + 1) return;\n    list.push(num);\n    if (list.length === k) ans.push(list.slice());\n    else for (let i = num + 1; i <= n; i++) dfs(i, list);\n    list.pop();\n  }\n}"}],"tagList":["回溯"],"level":"Medium"}},{"problemName":"78.子集.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/78.子集.json","problemData":{"id":"78","name":"78.子集","url":"https://leetcode.cn/problems/subsets","desc":"给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。","solutions":[{"date":"2020-09-20","time":84,"memory":39.6,"script":"typescript","desc":"递归,利用二进制进行去重。","code":"function subsets(nums: number[]): number[][] {\n  const ans: number[][] = [];\n  const len = nums.length;\n  for (let i = 0; i < 1 << len; i++) ans.push(getArr(i));\n  return ans;\n  function getArr(num: number): number[] {\n    const arr: number[] = [];\n    for (let i = 0; i < len; ++i) num & (1 << i) && arr.push(nums[i]);\n    return arr;\n  }\n}"},{"date":"2021-08-14","time":80,"memory":39.9,"script":"typescript","desc":"二进制逐位判断。","code":"function subsets(nums: number[]): number[][] {\n  const n = nums.length;\n  const ans: number[][] = [];\n  for (let i = 0; i < 1 << n; i++) add(i);\n  return ans;\n  function add(num: number) {\n    const arr: number[] = [];\n    ans.push(arr);\n    for (let i = 0; i < n; i++) {\n      if (num & (1 << i)) arr.push(nums[i]);\n    }\n  }\n}"}],"tagList":["位运算","数组","回溯"],"level":"Medium"}},{"problemName":"79.单词搜索.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/79.单词搜索.json","problemData":{"id":"79","name":"79.单词搜索","url":"https://leetcode.cn/problems/word-search","desc":"给定一个二维网格和一个单词，找出该单词是否存在于网格中。","solutions":[{"date":"2020-09-13","time":168,"memory":44.1,"script":"typescript","desc":"深度优先搜索。","code":"function exist(board: string[][], word: string): boolean {\n  const rowLen = board.length;\n  const colLen = board[0].length;\n  const used = new Set<string>();\n  const format = (row: number, col: number) => `${row}:${col}`;\n  const startArr = getStarStArr(word[0]);\n  if (startArr.length === 0) return false;\n  return find(word, startArr);\n  function find(word: string, startArr: [number, number][] = []): boolean {\n    if (word.length === 1) {\n      for (const [row, col] of startArr) {\n        if (board[row][col] === word && !used.has(format(row, col))) return true;\n      }\n      return false;\n    }\n    const nextWord = word.substr(1);\n    for (const [row, col] of startArr) {\n      const formatName = format(row, col);\n      if (used.has(formatName)) continue;\n      used.add(formatName);\n      const arr = findNext(row, col, nextWord[0]);\n      if (arr.length === 0) {\n      } else if (find(nextWord, arr)) return true;\n      used.delete(formatName);\n    }\n    return false;\n  }\n  function getStarStArr(char: string): [number, number][] {\n    const ans: [number, number][] = [];\n    for (let i = 0; i < rowLen; i++)\n      for (let j = 0; j < colLen; j++) {\n        board[i][j] === char && ans.push([i, j]);\n      }\n    return ans;\n  }\n  function findNext(row: number, col: number, char: string): [number, number][] {\n    const ans: [number, number][] = [];\n    row !== 0 && board[row - 1][col] === char && ans.push([row - 1, col]);\n    col !== 0 && board[row][col - 1] === char && ans.push([row, col - 1]);\n    row !== rowLen - 1 && board[row + 1][col] === char && ans.push([row + 1, col]);\n    col !== colLen - 1 && board[row][col + 1] === char && ans.push([row, col + 1]);\n    return ans;\n  }\n}"},{"date":"2022-02-18","time":144,"memory":7.8,"script":"cpp","desc":"dfs。","code":"int dirs[4][2] = {\n    {0, 1},\n    {0, -1},\n    {1, 0},\n    {-1, 0},\n};\nclass Solution {\n   public:\n    int n, m, check[10][10] = {0};\n    bool dfs(vector<vector<char>>& board, string& s, int idx, int row,\n             int col) {\n        if (idx == s.size() - 1) return board[row][col] == s[idx];\n        if (s[idx] != board[row][col]) return 0;\n        check[row][col] = 1;\n        int res = 0;\n        for (int i = 0; i < 4; i++) {\n            int nrow = row + dirs[i][0], ncol = col + dirs[i][1];\n            if (nrow < 0 || nrow >= n || ncol < 0 || ncol >= m ||\n                check[nrow][ncol])\n                continue;\n            if (dfs(board, s, idx + 1, nrow, ncol)) {\n                res = 1;\n                break;\n            }\n        }\n        check[row][col] = 0;\n        return res;\n    }\n    bool exist(vector<vector<char>>& board, string word) {\n        n = board.size();\n        m = board[0].size();\n        for (int row = 0; row < n; row++) {\n            for (int col = 0; col < m; col++) {\n                if (dfs(board, word, 0, row, col)) return 1;\n            }\n        }\n        return 0;\n    }\n};"}],"tagList":["数组","字符串","回溯","矩阵"],"level":"Medium"}},{"problemName":"8.字符串转换整数(atoi).json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/8.字符串转换整数(atoi).json","problemData":{"id":"8","name":"8.字符串转换整数(atoi)","url":"https://leetcode.cn/problems/string-to-integer-atoi","desc":"请你来实现一个 atoi 函数，使其能将字符串转换成整数。","solutions":[{"date":"2020-04-07","time":88,"memory":35.7,"script":"javascript","desc":"判断各种情况","code":"/**\n * @param {string} str\n * @return {number}\n */\nvar myAtoi = function (str) {\n  const eIndexOf = str.indexOf('e');\n  if (eIndexOf > -1) str = str.substring(0, eIndexOf);\n  const result = Number.parseFloat(str);\n  if (Number.isNaN(result)) return 0;\n  const maxFinite = Math.pow(2, 31) - 1;\n  const minFinite = -Math.pow(2, 31);\n  if (result < minFinite) return minFinite;\n  if (result > maxFinite) return maxFinite;\n  return result;\n};"},{"date":"2021-07-30","time":112,"memory":39.8,"script":"typescript","desc":"逐位检测赋值。","code":"function myAtoi(s: string): number {\n  let idx = 0;\n  while (s[idx] === ' ') idx++;\n  let flag = 1;\n  if (s[idx] === '+') idx++;\n  else if (s[idx] === '-') {\n    idx++;\n    flag = -1;\n  }\n  let ans = 0;\n  for (; idx < s.length; idx++) {\n    const num = s.codePointAt(idx)! - '0'.codePointAt(0)!;\n    if (num < 0 || num >= 10) break;\n    ans = ans * 10 + num;\n  }\n  const MAX = 2 ** 31 - 1;\n  const MIN = -(2 ** 31);\n  ans *= flag;\n  return ans > MAX ? MAX : ans < MIN ? MIN : ans;\n}"}],"tagList":["字符串"],"level":"Medium"}},{"problemName":"80.删除有序数组中的重复项II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/80.删除有序数组中的重复项II.json","problemData":{"id":"80","name":"80.删除有序数组中的重复项II","url":"https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii","desc":"给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。","solutions":[{"date":"2021-04-06","time":104,"memory":40.1,"script":"typescript","desc":"检测到一个重复数就后移。","code":"function removeDuplicates(nums: number[]): number {\n  const len = nums.length;\n  const remove = (index: number) => {\n    const num = nums[index];\n    nums.splice(index, 1);\n    nums.push(num);\n  };\n  let lastIndex = len;\n  for (let i = 0; i < lastIndex - 1; i++) {\n    const num = nums[i];\n    if (nums[i] !== nums[i + 1]) continue;\n    while (i + 2 < lastIndex && nums[i + 2] === num) {\n      remove(i);\n      lastIndex--;\n    }\n  }\n  return lastIndex;\n}"},{"date":"2021-04-06","time":92,"memory":39.7,"script":"typescript","desc":"利用快慢指针，慢指针赋值，快指针读取最新值。","code":"function removeDuplicates(nums: number[]): number {\n  const len = nums.length;\n  if (len <= 2) return len;\n  let slow = 2;\n  for (let fast = 2; fast < len; fast++) {\n    const num = nums[fast];\n    if (nums[slow - 2] !== num) {\n      nums[slow++] = num;\n    }\n  }\n  return slow;\n}"}],"tagList":["数组","双指针"],"level":"Medium"}},{"problemName":"81.搜索旋转排序数组II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/81.搜索旋转排序数组II.json","problemData":{"id":"81","name":"81.搜索旋转排序数组II","url":"https://leetcode.cn/problems/search-in-rotated-sorted-array-ii","desc":"给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。","solutions":[{"date":"2021-04-07","time":84,"memory":39.8,"script":"typescript","desc":"先获取偏移值再进行二分查找。","code":"function search(nums: number[], target: number): boolean {\n  const len = nums.length;\n  let k = 1;\n  for (; k < len; k++) if (nums[k - 1] > nums[k]) break;\n  const find = (start: number, end: number): boolean => {\n    if (start > end) return false;\n    const mid = ~~((start + end) / 2);\n    const num = nums[(mid + k) % len];\n    if (num > target) return find(start, mid - 1);\n    else if (num < target) return find(mid + 1, end);\n    else return true;\n  };\n  return find(0, len - 1);\n}"},{"date":"2021-07-23","time":80,"memory":39.4,"script":"typescript","desc":"二分查找。","code":"function search(nums: number[], target: number): boolean {\n  let l = 0;\n  let r = nums.length - 1;\n  if (nums[l] === target || nums[r] === target) return true;\n  while (l < r) {\n    while (l < r && nums[l] !== target && nums[l] === nums[r]) {\n      l++;\n      r--;\n    }\n    if (nums[l] === target || nums[r] === target) return true;\n    const mid = (r + l) >> 1;\n    const midNum = nums[mid];\n    if (midNum === target) return true;\n    if (midNum <= nums[r]) {\n      if (midNum <= target && target <= nums[r]) l = mid + 1;\n      else r = mid - 1;\n    } else {\n      if (nums[l] <= target && target <= midNum) r = mid - 1;\n      else l = mid + 1;\n    }\n  }\n  return false;\n}"}],"tagList":["数组","二分查找"],"level":"Medium"}},{"problemName":"82.删除排序链表中的重复元素II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/82.删除排序链表中的重复元素II.json","problemData":{"id":"82","name":"82.删除排序链表中的重复元素II","url":"https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii","desc":"给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。","solutions":[{"date":"2020-02-13","time":5,"memory":44.3,"script":"java","desc":"使用 map 储存元素，若元素不存在则 put 元素值为 1，若存在则值加 1，最后遍历若值不为 1 则删除。","code":"class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if (head == null) {\n\t\t\treturn null;\n\t\t}\n\t\tHashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tListNode newHead = new ListNode(0);\n\t\tnewHead.next = head;\n\t\twhile (head != null) {\n\t\t\tint tem = head.val;\n\t\t\tif (map.containsKey(tem)) {\n\t\t\t\tint num = map.get(tem) + 1;\n\t\t\t\tmap.put(tem, num);\n\t\t\t} else {\n\t\t\t\tmap.put(tem, 1);\n\t\t\t}\n\t\t\thead = head.next;\n\t\t}\n\t\thead = newHead;\n\t\twhile (head.next != null) {\n\t\t\tint val = head.next.val;\n\t\t\tif (map.get(val) > 1) {\n\t\t\t\thead.next = head.next.next;\n\t\t\t} else {\n\t\t\t\thead = head.next;\n\t\t\t}\n\t\t}\n\t\treturn newHead.next;\n    }\n}"},{"date":"2021-03-06","time":80,"memory":39.9,"script":"typescript","desc":"利用已排序的特点直接进行比较。","code":"function deleteDuplicates(head: ListNode | null): ListNode | null {\n  if (head === null) return null;\n  const dummyHead = new ListNode(0, head);\n  let p = dummyHead;\n  let q: ListNode | null = dummyHead;\n  while (p.next !== null) {\n    if (p.next.next && p.next.val === p.next.next.val) {\n      q = p.next.next;\n      while (q && q.val === p.next.val) q = q.next;\n      p.next = q;\n    } else {\n      p = p.next;\n    }\n  }\n  return dummyHead.next;\n}"},{"date":"2021-03-25","time":96,"memory":39.8,"script":"typescript","desc":"创建虚拟头节点依次比较值。","code":"function deleteDuplicates(head: ListNode | null): ListNode | null {\n  if (head === null) return null;\n  const dummyHead = new ListNode(0, head);\n  let p: ListNode | null = dummyHead;\n  while (p !== null) {\n    let q: ListNode | null = p.next;\n    if (q === null || q.next === null) break;\n    else if (q.val !== q.next.val) {\n      p.next = q;\n      p = q;\n    } else {\n      const val = q.val;\n      while (q !== null && q.val === val) q = q.next;\n      p.next = q;\n    }\n  }\n  return dummyHead.next;\n}"},{"script":"python","time":44,"memory":16.9,"desc":"遍历。","code":"class Solution:\n    def deleteDuplicates(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        p = tmp_head = ListNode(0, head)\n        while p.next:\n            next = p.next\n            val = next.val\n            while next and next.val == val: next = next.next\n            if p.next.next == next: p = p.next\n            else: p.next = next\n        return tmp_head.next","date":"2024-01-15"},{"script":"rust","time":0,"memory":2.11,"desc":"同上。","code":"impl Solution {\n    pub fn delete_duplicates(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        let mut tmp_head = Box::new(ListNode::new(0));\n        tmp_head.next = head;\n        let mut p = &tmp_head;\n        let mut map = [0; 300];\n        while let Some(ref next) = p.next {\n            map[(next.val + 100) as usize] += 1;\n            p = next;\n        }\n        let mut p = &mut tmp_head;\n        while let Some(next) = p.next.take() {\n            if map[(next.val + 100) as usize] > 1 {\n                p.next = next.next;\n            } else {\n                p.next = Some(next);\n                p = p.next.as_mut().unwrap();\n            }\n        }\n        tmp_head.next.take()\n    }\n}","date":"2024-01-15"}],"tagList":["链表","双指针"],"level":"Medium"}},{"problemName":"83.删除排序链表中的重复元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/83.删除排序链表中的重复元素.json","problemData":{"id":"83","name":"83.删除排序链表中的重复元素","url":"https://leetcode.cn/problems/remove-duplicates-from-sorted-list","desc":"给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。","solutions":[{"date":"2020-02-13","time":3,"memory":45,"script":"java","desc":"使用 set 储存元素，储存前会先判断 set 中是否已存在，若存在则移除。","code":"class Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if(head==null) {\n\t\t\treturn null;\n\t\t}\n\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\tListNode newHead=head;\n\t\tset.add(head.val);\n\t\twhile(head.next!=null) {\n\t\t\tif(!set.contains(head.next.val)) {\n\t\t\t\tset.add(head.next.val);\n\t\t\t\thead=head.next;\n\t\t\t}else {\n\t\t\t\thead.next=head.next.next;\n\t\t\t}\n\t\t}\n        return newHead;\n    }\n}"},{"date":"2021-03-06","time":100,"memory":40,"script":"typescript","desc":"利用已排序的特点直接进行比较。","code":"function deleteDuplicates(head: ListNode | null): ListNode | null {\n  if (head === null) return null;\n  let p = head;\n  while (p.next !== null)\n    if (p.val === p.next.val) p.next = p.next.next;\n    else p = p.next;\n  return head;\n}"},{"date":"2021-03-26","time":96,"memory":39.9,"script":"typescript","desc":"依次判断是否与下一个值相等。","code":"function deleteDuplicates(head: ListNode | null): ListNode | null {\n  if (head === null) return null;\n  let p: ListNode | null = head;\n  while (p !== null) {\n    while (p.next !== null && p.val === p.next.val) p.next = p.next.next;\n    p = p.next;\n  }\n  return head;\n}"},{"date":"2021-11-19","time":4,"memory":6.2,"script":"c","desc":"双指针。","code":"struct ListNode* deleteDuplicates(struct ListNode* head){\n    struct ListNode *p = head;\n    struct ListNode *work_p = head;\n    while (work_p) {\n        while (work_p && work_p->val == p->val) work_p = work_p->next;\n        p->next = work_p;\n        p = p->next;\n    }\n    return head;\n}"}],"tagList":["链表"],"level":"Easy"}},{"problemName":"84.柱状图中最大的矩形.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/84.柱状图中最大的矩形.json","problemData":{"id":"84","name":"84.柱状图中最大的矩形","url":"https://leetcode.cn/problems/largest-rectangle-in-histogram","desc":"给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。","solutions":[{"date":"2020-05-30","time":1300,"memory":35.8,"script":"typescript","desc":"暴力循环。","code":"var largestRectangleArea = function (heights: number[]): number {\n  const len = heights.length;\n  if (len === 0) return 0;\n  let max = 0;\n  for (let i = 0; i < len; i++) max = Math.max(getR(i), max);\n  return max;\n  function getR(i: number): number {\n    const num = heights[i];\n    let max = num;\n    let w = 1;\n    let low = num;\n    let temp = num;\n    while (temp >= 0 && i >= 1) {\n      temp = (low = Math.min(heights[--i], low)) * ++w;\n      max = Math.max(temp, max);\n    }\n    return max;\n  }\n};"},{"date":"2021-07-19","time":104,"memory":49,"script":"typescript","desc":"单调栈，获取两边比当前小的值。","code":"function largestRectangleArea(heights: number[]): number {\n  const len = heights.length;\n  const left = new Array(len).fill(-1);\n  const right = new Array(len).fill(len);\n  const stack: number[] = [];\n  let ans = 0;\n  for (let i = 0; i < len; i++) {\n    const h = heights[i];\n    while (stack.length && heights[stack[stack.length - 1]] >= h) right[stack.pop()!] = i;\n    if (stack.length) left[i] = stack[stack.length - 1];\n    stack.push(i);\n  }\n  for (let i = 0; i < len; i++) ans = Math.max(ans, (right[i] - left[i] - 1) * heights[i]);\n  return ans;\n}"}],"tagList":["栈","数组","单调栈"],"level":"Hard"}},{"problemName":"86.分隔链表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/86.分隔链表.json","problemData":{"id":"86","name":"86.分隔链表","url":"https://leetcode.cn/problems/partition-list","desc":"给你一个链表和一个特定值 x ，请你对链表进行分隔，使得所有小于 x 的节点都出现在大于或等于 x 的节点之前。","solutions":[{"date":"2021-01-03","time":92,"memory":40.5,"script":"typescript","desc":"利用两个节点进行储存。","code":"function partition(head: ListNode | null, x: number): ListNode | null {\n  if (head === null) return null;\n  const small = new ListNode(0);\n  let smallTemp = small;\n  const big = new ListNode(0);\n  let bigTemp = big;\n  let temp: ListNode | null = head;\n  while (temp !== null) {\n    if (temp.val < x) {\n      smallTemp.next = temp;\n      smallTemp = smallTemp.next;\n    } else {\n      bigTemp.next = temp;\n      bigTemp = bigTemp.next;\n    }\n    temp = temp.next;\n  }\n  smallTemp.next = big.next;\n  bigTemp.next = null;\n  return small.next;\n}"},{"date":"2021-03-14","time":100,"memory":39.4,"script":"typescript","desc":"创建新链表进行储存 x 两边的值。","code":"function partition(head: ListNode | null, x: number): ListNode | null {\n  if (head === null) return null;\n  const big = new ListNode(0);\n  let bigP = big;\n  const small = new ListNode(0);\n  let smallP = small;\n  let p: ListNode | null = head;\n  while (p !== null) {\n    if (p.val >= x) {\n      bigP.next = p;\n      bigP = p;\n      p = p.next;\n      bigP.next = null;\n    } else {\n      smallP.next = p;\n      smallP = p;\n      p = p.next;\n      smallP.next = null;\n    }\n  }\n  smallP.next = big.next;\n  return small.next;\n}"}],"tagList":["链表","双指针"],"level":"Medium"}},{"problemName":"88.合并两个有序数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/88.合并两个有序数组.json","problemData":{"id":"88","name":"88.合并两个有序数组","url":"https://leetcode.cn/problems/merge-sorted-array","desc":"给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。","solutions":[{"date":"2021-04-05","time":72,"memory":39.4,"script":"typescript","desc":"从后往前遍历，节省空间。","code":"function merge(nums1: number[], m: number, nums2: number[], n: number): void {\n  if (m === 0) {\n    nums1.length = 0;\n    nums1.push(...nums2);\n  } else if (n === 0) {\n  } else {\n    let lPos = m - 1;\n    let rPos = n - 1;\n    let curPos = m + n - 1;\n    while (curPos >= 0) {\n      const num1 = nums1[lPos];\n      const num2 = nums2[rPos];\n      let curNum = num1;\n      if (lPos < 0) {\n        rPos--;\n        curNum = num2;\n      } else if (rPos < 0) {\n        lPos--;\n      } else if (num1 >= num2) {\n        lPos--;\n      } else {\n        rPos--;\n        curNum = num2;\n      }\n      nums1[curPos--] = curNum;\n    }\n  }\n}"},{"date":"2021-11-30","time":4,"memory":5.9,"script":"c","desc":"从后往前遍历。","code":"void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){\n    int i = m + n - 1, i1 = m - 1, i2 = n - 1;\n    while (i >= 0 && i1 >= 0 && i2 >= 0) {\n        if (nums1[i1] >= nums2[i2]) nums1[i--] = nums1[i1--];\n        else nums1[i--] = nums2[i2--];\n    }\n    if (i1 < 0 && i2 >= 0) while(i >= 0) nums1[i--] = nums2[i2--];\n}"},{"date":"2021-11-30","time":20,"memory":8.7,"script":"c","desc":"排序。","code":"int comp(const void *a, const void *b) {\n    return *(int *)a - *(int *)b;\n}\nbool containsDuplicate(int* nums, int numsSize){\n    qsort(nums, numsSize, sizeof(int), comp);\n    int f = 0;\n    for (int i = 1; i < numsSize; i++) {\n        if (nums[i - 1] == nums[i]) {\n            f = 1;\n            break;\n        }\n    }\n    return f;\n}"},{"date":"2021-12-21","time":0,"memory":8.7,"script":"cpp","desc":"从后往前遍历。","code":"class Solution {\n   public:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        int idx = m + n - 1, idx1 = m - 1, idx2 = n - 1;\n        while (idx1 >= 0 || idx2 >= 0) {\n            if (idx1 >= 0 && (idx2 < 0 || nums1[idx1] >= nums2[idx2])) {\n                nums1[idx--] = nums1[idx1--];\n            } else {\n                nums1[idx--] = nums2[idx2--];\n            }\n        }\n    }\n};"},{"script":"cpp","time":0,"memory":8.77,"desc":"双指针遍历。","code":"class Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        for (int idx = nums1.size() - 1, i1 = m - 1, i2 = n - 1; idx >= 0; idx--) {\n            if (i2 < 0 || i1 >= 0 && nums1[i1] > nums2[i2]) {\n                nums1[idx] = nums1[i1--];\n            } else {\n                nums1[idx] = nums2[i2--];\n            }\n        }\n    }\n};","date":"2023-08-13"},{"script":"python","time":44,"memory":15.68,"desc":"同上。","code":"class Solution:\n    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:\n        i1 = m-1\n        i2 = n-1\n        for idx in range(len(nums1) - 1, -1, -1):\n            if i2 < 0 or i1 >= 0 and nums1[i1] > nums2[i2]:\n                nums1[idx] = nums1[i1]\n                i1 -= 1\n            else:\n                nums1[idx] = nums2[i2]\n                i2 -= 1","date":"2023-08-13"},{"script":"rust","time":0,"memory":2.09,"desc":"同上。","code":"impl Solution {\n    pub fn merge(nums1: &mut Vec<i32>, m: i32, nums2: &mut Vec<i32>, n: i32) {\n        let m = m as usize;\n        let n = n as usize;\n        let mut i1 = m - 1;\n        let mut i2 = n - 1;\n        for idx in (0..nums1.len()).rev() {\n            if i2 >= n || i1 < m && nums1[i1] > nums2[i2] {\n                nums1[idx] = nums1[i1];\n                i1 -= 1;\n            } else {\n                nums1[idx] = nums2[i2];\n                i2 -= 1;\n            }\n        }\n    }\n}","date":"2023-08-13"}],"tagList":["数组","双指针","排序"],"level":"Easy"}},{"problemName":"89.格雷编码.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/89.格雷编码.json","problemData":{"id":"89","name":"89.格雷编码","url":"https://leetcode.cn/problems/gray-code","desc":"给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。","solutions":[{"date":"2021-11-07","time":140,"memory":54.1,"script":"typescript","desc":"dfs。","code":"function grayCode(n: number): number[] {\n  if (n === 0) return [0];\n  const set = new Set<number>([0]);\n  const ans: number[] = [0];\n  dfs();\n  return ans;\n  function dfs(num = 0): boolean {\n    if (set.size === 2 ** n) {\n      return true;\n    }\n    for (let i = 0; i <= n; i++) {\n      const bit = 1 << i;\n      const nextNum = num & bit ? num & ~bit : num | bit;\n      if (set.has(nextNum)) continue;\n      set.add(nextNum);\n      ans.push(nextNum);\n      if (dfs(nextNum)) return true;\n      ans.pop();\n      set.delete(nextNum);\n    }\n    return false;\n  }\n}"},{"date":"2021-11-07","time":108,"memory":50.3,"script":"typescript","desc":"后半部分逆序输出。","code":"function grayCode(n: number): number[] {\n  const ans = [0];\n  if (n === 0) return ans;\n  while (n--) {\n    ans.push(\n      ...Array.from(ans)\n        .reverse()\n        .map(v => v | (1 << n))\n    );\n  }\n  return ans;\n}"},{"date":"2022-01-08","time":8,"memory":11.5,"script":"cpp","desc":"每次反向覆盖。","code":"class Solution {\n   public:\n    vector<int> grayCode(int n) {\n        vector<int> ans(2, 0);\n        ans[1] = 1;\n        for (int i = 1; i < n; i++) {\n            for (int j = ans.size() - 1; j >= 0; j--) {\n                ans.push_back(ans[j] | 1 << i);\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["位运算","数学","回溯"],"level":"Medium"}},{"problemName":"9.回文数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/9.回文数.json","problemData":{"id":"9","name":"9.回文数","url":"https://leetcode.cn/problems/palindrome-number","desc":"给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '\\*' 的正则表达式匹配。","solutions":[{"date":"2020-04-12","time":248,"memory":46.1,"script":"javascript","desc":"转换成字符串进行翻转判断。","code":"/**\n * @param {number} x\n * @return {boolean}\n */\nvar isPalindrome = x => x.toString() === x.toString().split('').reverse().join('');"},{"date":"2020-06-10","time":208,"memory":44.3,"script":"typescript","desc":"转换成字符串依次判断。","code":"function isPalindrome(x: number): boolean {\n  if (x < 0) return false;\n  if (x === 0) return true;\n  const str = x + '';\n  const len = str.length;\n  let i = -1,\n    j = len;\n  while (++i < --j) if (str[i] !== str[j]) return false;\n  return true;\n}"},{"date":"2020-06-10","time":220,"memory":45.4,"script":"typescript","desc":"转换成字符串进行翻转判断。","code":"function isPalindrome(x: number): boolean {\n  return x.toString() === x.toString().split('').reverse().join('');\n}"},{"date":"2020-06-10","time":232,"memory":45.8,"script":"typescript","desc":"压栈后观察两数是否相等。","code":"function isPalindrome(x: number): boolean {\n  if (x < 0) return false;\n  if (x < 10) return true;\n  let len = 0;\n  let temp = x;\n  while (temp !== 0) {\n    temp = ~~(temp / 10);\n    len++;\n  }\n  const stack = [];\n  temp = x;\n  while (stack.length < len >> 1) {\n    stack.push(temp % 10);\n    temp = ~~(temp / 10);\n  }\n  if ((len & 1) !== 0) temp = ~~(temp / 10);\n  const num = parseInt(stack.join(''));\n  return temp === num;\n}"},{"date":"2020-06-10","time":272,"memory":45.8,"script":"typescript","desc":"翻转一半的数字进行判断。","code":"function isPalindrome(x: number): boolean {\n  if (x < 0 || (x % 10 === 0 && x !== 0)) return false;\n  let revertedNumber: number = 0;\n  while (x > revertedNumber) {\n    revertedNumber = revertedNumber * 10 + (x % 10);\n    x = ~~(x / 10);\n  }\n  return x === revertedNumber || x === ~~(revertedNumber / 10);\n}"}],"tagList":["数学"],"level":"Easy"}},{"problemName":"90.子集II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/90.子集II.json","problemData":{"id":"90","name":"90.子集II","url":"https://leetcode.cn/problems/subsets-ii","desc":"给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。","solutions":[{"date":"2021-03-31","time":108,"memory":44.8,"script":"typescript","desc":"二分查找。","code":"function subsetsWithDup(nums: number[]): number[][] {\n  const set = new Set<string>();\n  const ans: number[][] = [[]];\n  const find = (arr: number[]) => {\n    const len = arr.length;\n    if (len === 0) return;\n    const str = arr.sort((a, b) => a - b).join(':');\n    if (set.has(str)) return;\n    set.add(str);\n    ans.push(arr);\n    for (let i = 0; i < len; i++) find([...arr.slice(0, i), ...arr.slice(i + 1)]);\n  };\n  find(nums);\n  return ans;\n}"}],"tagList":["位运算","数组","回溯"],"level":"Medium"}},{"problemName":"92.反转链表II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/92.反转链表II.json","problemData":{"id":"92","name":"92.反转链表II","url":"https://leetcode.cn/problems/reverse-linked-list-ii","desc":"反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。","solutions":[{"date":"2021-03-06","time":80,"memory":39.5,"script":"typescript","desc":"递归计算剩余翻转节点个数。","code":"function reverseList(head: ListNode, count: number): ListNode | null {\n  if (count === 1 || head.next === null) return head;\n  const tail = head.next;\n  const nextList = reverseList(tail, count - 1);\n  head.next = tail.next;\n  tail.next = head;\n  return nextList;\n}\nfunction reverseBetween(head: ListNode | null, left: number, right: number): ListNode | null {\n  const dummyHead = new ListNode(0, head);\n  let temp: ListNode = dummyHead;\n  const count = right - left + 1;\n  while (--left) temp = temp.next!;\n  temp!.next = reverseList(temp.next!, count);\n  return dummyHead.next;\n}"},{"date":"2021-03-18","time":100,"memory":39.5,"script":"typescript","desc":"递归翻转。","code":"function reverseBetween(head: ListNode | null, left: number, right: number): ListNode | null {\n  if (head === null) return null;\n  const dummyNode = new ListNode(0, head);\n  let p: ListNode | null = dummyNode;\n  let c = 0;\n  let prev!: ListNode;\n  while (c !== left && p !== null) {\n    cpp;\n    prev = p;\n    p = p.next;\n  }\n  const reverse = (node: ListNode | null, count: number): ListNode | null => {\n    if (count === 1 || node === null) return node;\n    const nextNode: ListNode = node.next!;\n    const newNode = reverse(nextNode, count - 1);\n    node.next = nextNode.next;\n    nextNode.next = node;\n    return newNode;\n  };\n  const newNode = reverse(p, right - left + 1);\n  prev.next = newNode;\n  return dummyNode.next;\n}"}],"tagList":["链表"],"level":"Medium"}},{"problemName":"93.复原IP地址.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/93.复原IP地址.json","problemData":{"id":"93","name":"93.复原IP地址","url":"https://leetcode.cn/problems/restore-ip-addresses","desc":"给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。","solutions":[{"date":"2020-08-10","time":88,"memory":37.3,"script":"typescript","desc":"回溯+剪枝。","code":"function restoreIpAddresses(s: string): string[] {\n  const ans: string[] = [];\n  find(s);\n  return ans;\n  function find(s: string, now = '', need = 4): void {\n    if (need <= 0) return;\n    for (let l = 1; l <= s.length; l++) {\n      const subS = s.substr(0, l);\n      if (Number(subS) > 255) return;\n      const nextSubStr = s.substr(l);\n      const nextNow = now.length === 0 ? subS : now + '.' + subS;\n      if (need === 1 && nextSubStr.length === 0) ans.push(nextNow);\n      else find(nextSubStr, nextNow, need - 1);\n      if (s[0] === '0') return;\n    }\n  }\n}"},{"date":"2021-07-21","time":76,"memory":40.1,"script":"typescript","desc":"深度遍历。","code":"function restoreIpAddresses(s: string): string[] {\n  const n = s.length;\n  const ans: string[] = [];\n  find();\n  return ans;\n  function find(index = 0, list: (string | number)[] = []): void {\n    if (list.length === 4 && index !== n) return;\n    if (index === n) {\n      list.length === 4 && ans.push(list.join('.'));\n      return;\n    }\n    if (s[index] === '0') {\n      list.push(0);\n      find(index + 1, list);\n      list.pop();\n      return;\n    }\n    const num1 = getNum(index);\n    let num2!: number;\n    let num3!: number;\n    list.push(num1);\n    find(index + 1, list);\n    list.pop();\n    if (index + 1 < n) {\n      num2 = num1 * 10 + getNum(index + 1);\n      list.push(num2);\n      find(index + 2, list);\n      list.pop();\n    }\n    if (index + 2 < n) {\n      num3 = num2 * 10 + getNum(index + 2);\n      if (num3 <= 255) {\n        list.push(num3);\n        find(index + 3, list);\n        list.pop();\n      }\n    }\n  }\n  function getNum(index: number) {\n    return s[index].codePointAt(0)! - '0'.codePointAt(0)!;\n  }\n}"}],"tagList":["字符串","回溯"],"level":"Medium"}},{"problemName":"94.二叉树的中序遍历.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/94.二叉树的中序遍历.json","problemData":{"id":"94","name":"94.二叉树的中序遍历","url":"https://leetcode.cn/problems/binary-tree-inorder-traversal","desc":"给定一个二叉树，返回它的中序 遍历。","solutions":[{"date":"2020-02-21","time":0,"memory":38,"script":"java","desc":"递归。","code":"class Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n    \tLinkedList<Integer> list = new LinkedList<Integer>();\n        if(root==null)return list;\n        inorder(list,root);\n        return list;\n    }\n    public void inorder(List<Integer> list,TreeNode node) {\n    \tif(node.left!=null)inorder(list, node.left);\n    \tlist.add(node.val);\n    \tif(node.right!=null)inorder(list, node.right);\n    }\n}"},{"date":"2020-02-21","time":1,"memory":37.8,"script":"java","desc":"迭代。","code":"public List<Integer> inorderTraversal(TreeNode root) {\n\tList<Integer> list = new LinkedList<Integer>();\n\tif(root==null) return list;\n\tStack<TreeNode> stack= new Stack<TreeNode>();\n\tTreeNode node = root;\n\twhile(!stack.isEmpty()||node!=null) {\n\t\twhile(node!=null) {\n\t\t\tstack.push(node);\n\t\t\tnode=node.left;\n\t\t}\n\t\tnode=stack.pop();\n\t\tlist.add(node.val);\n\t\tnode=node.right;\n\t}\n\treturn list;\n}"},{"date":"2020-09-14","time":72,"memory":37.5,"script":"typescript","desc":"递归。","code":"function inorderTraversal(root: TreeNode | null): number[] {\n  const ans: number[] = [];\n  _inorder(root);\n  return ans;\n  function _inorder(node: TreeNode | null): void {\n    if (node === null) return;\n    node.left !== null && _inorder(node.left);\n    ans.push(node.val);\n    node.right !== null && _inorder(node.right);\n  }\n}"},{"date":"2020-09-14","time":84,"memory":37.5,"script":"typescript","desc":"迭代。","code":"function inorderTraversal(root: TreeNode | null): number[] {\n  if (root === null) return [];\n  const ans: number[] = [];\n  const stack: TreeNode[] = [root];\n  const used = new Set<TreeNode>();\n  while (stack.length !== 0) {\n    const node = stack.pop() as TreeNode;\n    if (used.has(node)) {\n      ans.push(node.val);\n    } else {\n      used.add(node);\n      node.right && stack.push(node.right);\n      stack.push(node);\n      node.left && stack.push(node.left);\n    }\n  }\n  return ans;\n}"},{"date":"2021-11-27","time":0,"memory":5.6,"script":"c","desc":"递归。","code":"// 先递归左，再计算当前节点，再递归右\nvoid order(struct TreeNode *root, int *arr, int *idx){\n    if (!root) return ;\n    order(root->left, arr, idx);\n    arr[(*idx)++] = root->val;\n    order(root->right, arr, idx);\n}\nint* inorderTraversal(struct TreeNode* root, int* returnSize){\n    int *arr = (int *)malloc(sizeof(int) * 100);\n    *returnSize = 0;\n    order(root, arr, returnSize);\n    return arr;\n}"},{"script":"python","time":38,"memory":16.41,"desc":"dfs。","code":"class Solution:\n    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        arr = []\n        def dfs(node: Optional[TreeNode]):\n            if not node: return\n            dfs(node.left)\n            arr.append(node.val)\n            dfs(node.right)\n        dfs(root)\n        return arr","date":"2024-02-10"}],"tagList":["栈","树","深度优先搜索","二叉树"],"level":"Easy"}},{"problemName":"95.不同的二叉搜索树II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/95.不同的二叉搜索树II.json","problemData":{"id":"95","name":"95.不同的二叉搜索树II","url":"https://leetcode.cn/problems/unique-binary-search-trees-ii","desc":"给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。","solutions":[{"date":"2020-07-21","time":108,"memory":45.8,"script":"typescript","desc":"递归遍历。","code":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nfunction generateTrees(n: number): Array<TreeNode | null> {\n  if (n === 0) return [];\n  return _genTrees(1, n);\n  function _genTrees(start: number, end: number): Array<TreeNode | null> {\n    const trees: Array<TreeNode | null> = [];\n    if (start > end) {\n      trees.push(null);\n      return trees;\n    }\n    for (let i = start; i <= end; i++) {\n      const lefts = _genTrees(start, i - 1);\n      const rights = _genTrees(i + 1, end);\n      for (const left of lefts) {\n        for (const right of rights) {\n          const tree = new TreeNode(i);\n          tree.left = left;\n          tree.right = right;\n          trees.push(tree);\n        }\n      }\n    }\n    return trees;\n  }\n}"},{"date":"2021-05-07","time":112,"memory":46,"script":"typescript","desc":"递归左右子树。","code":"function generateTrees(n: number): Array<TreeNode | null> {\n  const createTree = (startNum: number, endNum: number): (TreeNode | null)[] => {\n    const ans: TreeNode[] = [];\n    if (startNum > endNum) return [null];\n    for (let i = startNum; i <= endNum; i++) {\n      const leftList = createTree(startNum, i - 1);\n      const rightList = createTree(i + 1, endNum);\n      for (const left of leftList) {\n        for (const right of rightList) {\n          const node = new TreeNode(i, left, right);\n          ans.push(node);\n        }\n      }\n    }\n    return ans;\n  };\n  return createTree(1, n);\n}"}],"tagList":["树","二叉搜索树","动态规划","回溯","二叉树"],"level":"Medium"}},{"problemName":"96.不同的二叉搜索树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/96.不同的二叉搜索树.json","problemData":{"id":"96","name":"96.不同的二叉搜索树","url":"https://leetcode.cn/problems/unique-binary-search-trees","desc":"给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？","solutions":[{"date":"2020-07-15","time":68,"memory":32.3,"script":"typescript","desc":"通过缓存进行递归。","code":"function numTrees(n: number): number {\n  const cache: Record<number, number> = { 0: 0, 1: 1, 2: 2 };\n  function get(num: number): number {\n    if (cache[num]) return cache[num];\n    let sum = 0;\n    for (let i = 1; i < num - 1; i++) sum += get(i) * get(num - 1 - i);\n    sum += get(num - 1) * 2;\n    cache[num] = sum;\n    return sum;\n  }\n  return get(n);\n}"},{"date":"2020-07-15","time":84,"memory":32.4,"script":"typescript","desc":"dp[i]=i 个数会有多少种方式。","code":"function numTrees(n: number): number {\n  const dp = [0, 1, 2];\n  for (let i = 3; i <= n; i++) {\n    let sum = 0;\n    for (let j = 1; j < i - 1; j++) {\n      sum += dp[j] * dp[i - 1 - j];\n    }\n    sum += dp[i - 1] * 2;\n    dp[i] = sum;\n  }\n  return dp[n];\n}"}],"tagList":["树","二叉搜索树","数学","动态规划","二叉树"],"level":"Medium"}},{"problemName":"97.交错字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/97.交错字符串.json","problemData":{"id":"97","name":"97.交错字符串","url":"https://leetcode.cn/problems/interleaving-string","desc":"给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。","solutions":[{"date":"2020-07-18","time":7876,"memory":45.1,"script":"typescript","desc":"暴力解题。","code":"function isInterleave(s1: string, s2: string, s3: string): boolean {\n  if (s1 === '' && s2 === '' && s3 === '') return true;\n  if (s1.length + s2.length !== s3.length) return false;\n  if (s1[0] === s3[0]) {\n    if (isInterleave(s1.substr(1), s2, s3.substr(1))) return true;\n  }\n  if (s2[0] === s3[0]) {\n    if (isInterleave(s1, s2.substr(1), s3.substr(1))) return true;\n  }\n  return false;\n}"}],"tagList":["字符串","动态规划"],"level":"Medium"}},{"problemName":"98.验证二叉搜索树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/98.验证二叉搜索树.json","problemData":{"id":"98","name":"98.验证二叉搜索树","url":"https://leetcode.cn/problems/validate-binary-search-tree","desc":"给定一个二叉树，判断其是否是一个有效的二叉搜索树。","solutions":[{"date":"2020-02-23","time":334,"memory":41.3,"script":"java","desc":"使用中序遍历，再进行冒泡排序，若存在排序则为非 bst。","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n\tArrayList<Integer> list = new ArrayList<Integer>();\n\n\tpublic boolean isValidBST(TreeNode root) {\n\t\tif (root == null)\n\t\t\treturn true;\n\t\tpreorder(root);\n\t\tint size = list.size();\n\t\tfor (int i = 0; i < size - 1; i++)\n\t\t\tfor (int j = 0; j < size - 1 - i; j++)\n\t\t\t\tif (list.get(j) >= list.get(j + 1))\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic void preorder(TreeNode node) {\n\t\tif (node.left != null) {\n\t\t\tpreorder(node.left);\n\t\t}\n\t\tlist.add(node.val);\n\t\tif (node.right != null) {\n\t\t\tpreorder(node.right);\n\t\t}\n\t}\n}"},{"date":"2021-08-07","time":96,"memory":43.1,"script":"typescript","desc":"中序遍历。","code":"function isValidBST(root: TreeNode | null): boolean {\n  if (root === null) return true;\n  const q: number[] = [];\n  inorder(root);\n  for (let i = 1; i < q.length; i++) if (q[i] <= q[i - 1]) return false;\n  return true;\n  function inorder(node: TreeNode | null): void {\n    if (node === null) return;\n    inorder(node.left);\n    q.push(node.val);\n    inorder(node.right);\n  }\n}"}],"tagList":["树","深度优先搜索","二叉搜索树","二叉树"],"level":"Medium"}},{"problemName":"99.恢复二叉搜索树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1-100/99.恢复二叉搜索树.json","problemData":{"id":"99","name":"99.恢复二叉搜索树","url":"https://leetcode.cn/problems/recover-binary-search-tree","desc":"二叉搜索树中的两个节点被错误地交换。","solutions":[{"date":"2020-02-24","time":4,"memory":40.9,"script":"java","desc":"中序遍历后查看顺序不一的值。","code":"class Solution {\n    ArrayList<TreeNode> list = new ArrayList<TreeNode>();\n\tpublic void recoverTree(TreeNode root) {\n\t\tif(root==null)return;\n\t\tinorder(root);\n\t\tTreeNode node1=null,node2=null;\n\t\tfor(int i=0,len=list.size()-1;i<len;i++) {\n\t\t\tif(list.get(i+1).val<list.get(i).val) {\n\t\t\t\tif(node1==null) {\n\t\t\t\t    node1=list.get(i);\n\t\t\t\t\tnode2=list.get(i+1);\n\t\t\t\t}else{\n\t\t\t\t\tnode2=list.get(i+1);\n                }\n\t\t\t}\n\t\t}\n\t\tint temp=node1.val;\n\t\tnode1.val=node2.val;\n\t\tnode2.val=temp;\n    }\n\tpublic void inorder(TreeNode node) {\n\t\tif (node.left != null)\n\t\t\tinorder(node.left);\n\t\tlist.add(node);\n\t\tif (node.right != null)\n\t\t\tinorder(node.right);\n\t}\n}"},{"date":"2020-08-08","time":192,"memory":48,"script":"typescript","desc":"排序值替换。","code":"function recoverTree(root: TreeNode | null): void {\n  if (root === null) return;\n  const list: TreeNode[] = [];\n  inorder(root);\n  for (let i = 0, len = list.length; i < len - 1; i++) {\n    for (let j = 0; j < len - 1 - i; j++) {\n      if (list[j].val > list[j + 1].val) swap(list[j], list[j + 1]);\n    }\n  }\n  function swap(n1: TreeNode, n2: TreeNode) {\n    const num = n1.val;\n    n1.val = n2.val;\n    n2.val = num;\n  }\n  function inorder(node: TreeNode | null): void {\n    if (node === null) return;\n    inorder(node.left);\n    list.push(node);\n    inorder(node.right);\n  }\n}"},{"date":"2021-08-20","time":144,"memory":47.5,"script":"typescript","desc":"中序排序后比较。","code":"function recoverTree(root: TreeNode | null): void {\n  if (root === null) return;\n  const q: TreeNode[] = [];\n  inorder(root);\n  let n1!: TreeNode;\n  let n2!: TreeNode;\n  for (let i = 1; i < q.length; i++) {\n    if (q[i].val < q[i - 1].val) {\n      if (n1) {\n        n2 = q[i];\n      } else {\n        n1 = q[i - 1];\n        n2 = q[i];\n      }\n    }\n  }\n  [n1.val, n2.val] = [n2.val, n1.val];\n  function inorder(node: TreeNode | null) {\n    if (node === null) return;\n    inorder(node.left);\n    q.push(node);\n    inorder(node.right);\n  }\n}"}],"tagList":["树","深度优先搜索","二叉搜索树","二叉树"],"level":"Medium"}}]},{"dirName":"1001-1100","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\1001-1100","problems":[{"problemName":"1001.网格照明.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1001.网格照明.json","problemData":{"id":"1043","name":"1001.网格照明","url":"https://leetcode.cn/problems/grid-illumination","desc":"在大小为 n x n 的网格 grid 上，每个单元格都有一盏灯，最初灯都处于 关闭 状态。返回一个整数数组 ans 作为答案， ans[j] 应等于第 j 次查询 queries[j] 的结果，1 表示照亮，0 表示未照亮。","solutions":[{"date":"2022-02-08","time":644,"memory":178.3,"script":"cpp","desc":"哈希存储每个点的行列斜线。","code":"int dirs[9][2] = {{0, 1},  {0, -1},  {1, 0},  {-1, 0}, {1, 1},\n                  {1, -1}, {-1, -1}, {-1, 1}, {0, 0}};\nclass Solution {\n   public:\n    int get_b(int x, int y, int k) { return y - x * k; }\n    vector<int> gridIllumination(int n, vector<vector<int>>& lamps,\n                                 vector<vector<int>>& queries) {\n        unordered_map<int, unordered_set<int>> m;\n        unordered_map<int, int> m_x, m_y, m_k1, m_k2;\n        for (auto& item : lamps) {\n            int x = item[0], y = item[1];\n            if (m[x].count(y)) continue;\n            m[x].insert(y);\n            m_x[x]++;\n            m_y[y]++;\n            m_k1[get_b(x, n - y - 1, 1)]++;\n            m_k2[get_b(x, n - y - 1, -1)]++;\n        }\n        vector<int> ans;\n        for (auto& item : queries) {\n            int x = item[0], y = item[1], state = 0;\n            if (m_x[x] || m_y[y] || m_k1[get_b(x, n - y - 1, 1)] ||\n                m_k2[get_b(x, n - y - 1, -1)])\n                state = 1;\n            ans.push_back(state);\n            for (int i = 0; i < 9; i++) {\n                int nx = x + dirs[i][0], ny = y + dirs[i][1];\n                if (nx < 0 || ny < 0 || nx >= n || ny >= n || !m[nx].count(ny))\n                    continue;\n                m_x[nx]--;\n                m_y[ny]--;\n                m_k1[get_b(nx, n - ny - 1, 1)]--;\n                m_k2[get_b(nx, n - ny - 1, -1)]--;\n                m[nx].erase(ny);\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表"],"level":"Hard"}},{"problemName":"1002.查找共用字符.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1002.查找共用字符.json","problemData":{"id":"1044","name":"1002.查找共用字符","url":"https://leetcode.cn/problems/find-common-characters","desc":"给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。","solutions":[{"date":"2020-10-14","time":120,"memory":41.7,"script":"typescript","desc":"计数。","code":"function commonChars(A: string[]): string[] {\n  if (A.length === 0) return [];\n  else if (A.length === 1) return A[0].split('');\n  const cache: number[] = new Array(26).fill(Infinity);\n  const compIndex = (c: string) => c.charCodeAt(0) - 'a'.charCodeAt(0);\n  for (const str of A) {\n    const count: number[] = new Array(26).fill(0);\n    const addCount = (i: number) => (count[i] = 1 + (count[i] ?? 0));\n    for (const c of str) {\n      addCount(compIndex(c));\n    }\n    count.forEach((v, i) => (cache[i] = Math.min(cache[i], v)));\n  }\n  const ans: string[] = [];\n  for (let i = 0; i < 26; i++) {\n    const v = cache[i];\n    if (v === Infinity) continue;\n    new Array(v).fill(0).forEach(_ => ans.push(String.fromCharCode(i + 97)));\n  }\n  return ans;\n}"}],"tagList":["数组","哈希表","字符串"],"level":"Easy"}},{"problemName":"1003.检查替换后的词是否有效.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1003.检查替换后的词是否有效.json","problemData":{"id":"1045","name":"1003.检查替换后的词是否有效","url":"https://leetcode.cn/problems/check-if-word-is-valid-after-substitutions","desc":"给你一个字符串 s ，请你判断它是否 有效 。","solutions":[{"script":"typescript","time":184,"memory":48.3,"desc":"遍历。","code":"function isValid(s: string): boolean {\n    while (s != \"\") {\n        const n = s.replace(\"abc\", \"\");\n        if (n == s) return false;\n        s = n;\n    }\n    return s == \"\";\n};","date":"2023-05-03"},{"script":"cpp","time":328,"memory":8.4,"desc":"一直找abc子串，替换成空串，直到不能再替换。","code":"class Solution {\npublic:\n    bool isValid(string s) {\n        string next;\n        do {\n            int p = s.find(\"abc\", 0);\n            if (p == -1) return false;\n            next = s.replace(p, 3, \"\");\n        } while (next != \"\");\n        return true;\n    }\n};","date":"2023-05-03"},{"script":"python","time":56,"memory":16.2,"desc":"同上。","code":"class Solution:\n    def isValid(self, s: str) -> bool:\n        while s != \"\":\n            n = s.replace(\"abc\", \"\")\n            if n == s: return False\n            s = n\n        return s == \"\"","date":"2023-05-03"},{"script":"rust","time":4,"memory":2.1,"desc":"同上。","code":"impl Solution {\n    pub fn is_valid(mut s: String) -> bool {\n        while s != \"\" {\n            let n = s.replace(\"abc\", \"\");\n            if n == s {\n                return false;\n            }\n            s = n;\n        }\n        s == \"\"\n    }\n}\n","date":"2023-05-03"}],"tagList":["栈","字符串"],"level":"Medium"}},{"problemName":"1004.最大连续1的个数III.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1004.最大连续1的个数III.json","problemData":{"id":"1046","name":"1004.最大连续1的个数III","url":"https://leetcode.cn/problems/max-consecutive-ones-iii","desc":"给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。返回仅包含 1 的最长（连续）子数组的长度。","solutions":[{"date":"2021-02-19","time":112,"memory":44.1,"script":"typescript","desc":"双指针。","code":"function longestOnes(A: number[], K: number): number {\n  if (A.every(v => !(v & 1))) return K;\n  let l = 0;\n  let r = 0;\n  let sum0 = A[0] & 1 ? 0 : 1;\n  let ans = sum0;\n  const len = A.length;\n  while (r < len) {\n    if (sum0 <= K) {\n      !(A[++r] & 1) && sum0++;\n      ans = Math.max(ans, r - l);\n    } else {\n      while (sum0 > K) {\n        !(A[l++] & 1) && sum0--;\n      }\n    }\n  }\n  return ans;\n}"},{"date":"2022-01-07","time":52,"memory":54.2,"script":"cpp","desc":"滑动窗口维护窗口内 0 数。","code":"class Solution {\n   public:\n    int longestOnes(vector<int>& nums, int k) {\n        int ans = 0, l = 0, r = -1, cnt0 = 0;\n        while (1) {\n            if (cnt0 <= k) {\n                r++;\n                if (r == nums.size()) break;\n                if (nums[r] == 0) cnt0++;\n            } else {\n                if (nums[l] == 0) cnt0--;\n                l++;\n            }\n            if (cnt0 <= k) ans = max(ans, r - l + 1);\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","二分查找","前缀和","滑动窗口"],"level":"Medium"}},{"problemName":"1005.K次取反后最大化的数组和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1005.K次取反后最大化的数组和.json","problemData":{"id":"1047","name":"1005.K次取反后最大化的数组和","url":"https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations","desc":"返回数组 可能的最大和。","solutions":[{"date":"2021-12-03","time":80,"memory":39.5,"script":"typescript","desc":"排序。","code":"function largestSumAfterKNegations(nums: number[], k: number): number {\n  const n = nums.length;\n  nums.sort((a, b) => a - b);\n  for (let i = 0; i < n && nums[i] < 0 && k > 0; i++) {\n    nums[i] *= -1;\n    k--;\n  }\n  const sum = nums.reduce((total, num) => total + num, 0);\n  if ((k & 1) === 0) return sum;\n  return sum - 2 * Math.min(...nums);\n}"},{"date":"2021-12-03","time":0,"memory":5.7,"script":"c","desc":"遍历。","code":"int comp(const void *a, const void *b) {\n    return *(int *)a - *(int *)b;\n}\nint largestSumAfterKNegations(int* nums, int numsSize, int k){\n    qsort(nums, numsSize, sizeof(int), comp);\n    for (int i = 0; i < numsSize && nums[i] < 0 && k > 0; i++) {\n      nums[i] *= -1;\n      k--;\n    }\n    int sum = 0, min = 10000;\n    for (int i = 0; i < numsSize; i++) {\n        sum += nums[i];\n        if (min > nums[i]) min = nums[i];\n    }\n    if ((k & 1) == 0) return sum;\n    return sum - 2 * min;\n}"}],"tagList":["贪心","数组","排序"],"level":"Easy"}},{"problemName":"1006.笨阶乘.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1006.笨阶乘.json","problemData":{"id":"1048","name":"1006.笨阶乘","url":"https://leetcode.cn/problems/clumsy-factorial","desc":"给定一个整数 N，它返回 N 的笨阶乘。","solutions":[{"date":"2021-04-01","time":112,"memory":45.8,"script":"typescript","desc":"先算出模板，再利用模板进行运算。","code":"const op = ['*', '/', '+', '-'];\nconst opMap: Record<string, (num1: number, num2: number) => number> = {\n  '*': (num1, num2) => num1 * num2,\n  '/': (num1, num2) => ~~(num1 / num2),\n  '+': (num1, num2) => num1 + num2,\n  '-': (num1, num2) => num1 - num2,\n};\nfunction clumsy(N: number): number {\n  let curOp = 0;\n  const template: (number | string)[] = [];\n  while (N) {\n    template.push(N--);\n    template.push(op[curOp]);\n    curOp = (curOp + 1) % 4;\n  }\n  template.pop();\n  const stack: (number | string)[] = [];\n  for (let i = 0, l = template.length; i < l; i++) {\n    const c = template[i];\n    if (c === '*' || c === '/') {\n      const num1 = stack.pop() as number;\n      const num2 = template[++i] as number;\n      stack.push(opMap[c](num1, num2));\n    } else stack.push(c);\n  }\n  template.length = 0;\n  template.push(...stack);\n  stack.length = 0;\n  for (let i = 0, l = template.length; i < l; i++) {\n    const c = template[i];\n    if (c === '+' || c === '-') {\n      const num1 = stack.pop() as number;\n      const num2 = template[++i] as number;\n      stack.push(opMap[c](num1, num2));\n    } else stack.push(c);\n  }\n  return stack[0] as number;\n}"}],"tagList":["栈","数学","模拟"],"level":"Medium"}},{"problemName":"1008.前序遍历构造二叉搜索树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1008.前序遍历构造二叉搜索树.json","problemData":{"id":"1050","name":"1008.前序遍历构造二叉搜索树","url":"https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal","desc":"返回与给定前序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。","solutions":[{"date":"2021-08-07","time":72,"memory":39.6,"script":"typescript","desc":"获取左子树和右子树分别构造。","code":"function bstFromPreorder(preorder: number[]): TreeNode | null {\n  const n = preorder.length;\n  if (n === 0) return null;\n  const mid = preorder[0];\n  let i = 1;\n  while (i < n && preorder[i] < mid) i++;\n  return new TreeNode(\n    mid,\n    bstFromPreorder(preorder.slice(1, i)),\n    bstFromPreorder(preorder.slice(i))\n  );\n}"}],"tagList":["栈","树","二叉搜索树","数组","二叉树","单调栈"],"level":"Medium"}},{"problemName":"1009.十进制整数的反码.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1009.十进制整数的反码.json","problemData":{"id":"1054","name":"1009.十进制整数的反码","url":"https://leetcode.cn/problems/complement-of-base-10-integer","desc":"给你一个十进制数 N，请你返回其二进制表示的反码所对应的十进制整数。","solutions":[{"date":"2021-10-18","time":72,"memory":39.4,"script":"typescript","desc":"利用字符串翻转。","code":"function findComplement(num: number): number {\n  const bitStr = num\n    .toString(2)\n    .split('')\n    .map(v => (v === '1' ? '0' : '1'))\n    .join('');\n  return parseInt(bitStr, 2);\n}"},{"date":"2021-10-18","time":76,"memory":39.1,"script":"typescript","desc":"获取最高位进行翻转，利用异或取反。","code":"function bitwiseComplement(n: number): number {\n  if (n === 0) return 1;\n  let bit = 0;\n  for (; bit <= 30; bit++) if (n < 1 << bit) break;\n  if (bit === 31) bit = 0x7fffffff;\n  bit = (1 << bit) - 1;\n  return bit ^ n;\n}"}],"tagList":["位运算"],"level":"Easy"}},{"problemName":"1010.总持续时间可被60整除的歌曲.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1010.总持续时间可被60整除的歌曲.json","problemData":{"id":"1055","name":"1010.总持续时间可被60整除的歌曲","url":"https://leetcode.cn/problems/pairs-of-songs-with-total-durations-divisible-by-60","desc":"返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。","solutions":[{"script":"cpp","time":28,"memory":27.5,"desc":"取模后求逆元。","code":"class Solution {\npublic:\n    int numPairsDivisibleBy60(vector<int>& time) {\n        unordered_map<int, int> m;\n        int res = 0;\n        for (auto &t : time) {\n            if (t % 60 == 0) res += m[0];\n            else res += m[60 - t % 60];\n            m[t % 60]++;\n        }\n        return res;\n    }\n};","date":"2023-05-07"},{"script":"python","time":88,"memory":19.6,"desc":"同上。","code":"class Solution:\n    def numPairsDivisibleBy60(self, time: List[int]) -> int:\n        m = Counter()\n        res = 0\n        for t in time:\n            if t % 60 == 0:\n                res += m[0]\n            else:\n                res += m[60-t % 60]\n            m[t % 60] += 1\n        return res","date":"2023-05-07"},{"script":"rust","time":12,"memory":2.4,"desc":"同上。","code":"impl Solution {\n    pub fn num_pairs_divisible_by60(time: Vec<i32>) -> i32 {\n        let mut m = std::collections::HashMap::<i32, i32>::new();\n        let mut res = 0;\n        for t in time {\n            if t % 60 == 0 {\n                res += m.get(&0).unwrap_or(&0);\n            } else {\n                res += m.get(&(60 - t % 60)).unwrap_or(&0);\n            }\n            *m.entry(t % 60).or_insert(0) += 1;\n        }\n        res\n    }\n}","date":"2023-05-07"}],"tagList":["数组","哈希表","计数"],"level":"Medium"}},{"problemName":"1011.在D天内送达包裹的能力.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1011.在D天内送达包裹的能力.json","problemData":{"id":"1056","name":"1011.在D天内送达包裹的能力","url":"https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days","desc":"返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。","solutions":[{"date":"2021-04-26","time":1672,"memory":42.4,"script":"typescript","desc":"二分查找，确定左右边界进行查找。","code":"function shipWithinDays(weights: number[], D: number): number {\n  let left = Math.max(...weights);\n  let right = weights.reduce((total, cur) => total + cur, 0);\n  while (left < right) {\n    const mid = (left + right) >> 1;\n    let curWeight = 0;\n    let curDay = 1;\n    for (const weight of weights) {\n      if (curWeight + weight > mid) {\n        curWeight = 0;\n        curDay++;\n      }\n      curWeight += weight;\n    }\n    if (curDay > D) left++;\n    else right = mid;\n  }\n  return left;\n}"}],"tagList":["数组","二分查找"],"level":"Medium"}},{"problemName":"1012.至少有1位重复的数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1012.至少有1位重复的数字.json","problemData":{"id":"1057","name":"1012.至少有1位重复的数字","url":"https://leetcode.cn/problems/numbers-with-repeated-digits","desc":"给定正整数 n，返回在 [1, n] 范围内具有 至少 1 位 重复数字的正整数的个数。","solutions":[{"script":"cpp","time":72,"memory":14.3,"desc":"数位dp。","code":"class Solution {\npublic:\n    unordered_map<int, unordered_map<int, int>> m;\n    int dfs(string &sn, int idx, int mask, bool limit, bool empty) {\n        if (idx == sn.size()) return empty ? 0 : 1;\n        if (!limit && !empty && m[idx].count(mask)) return m[idx][mask];\n        int res = 0;\n        if (empty) res += dfs(sn, idx + 1, mask, false, true);\n        for (int j = empty ? 1 : 0, nmax = limit ? sn[idx] - '0' : 9; j <= nmax; j++)\n            if ((mask & (1 << j)) == 0) res += dfs(sn, idx + 1, mask | (1 << j), limit && j == nmax, false);\n        return m[idx][mask] = res;\n    };\n    int numDupDigitsAtMostN(int n) {\n        string sn = to_string(n);\n        return n - dfs(sn, 0, 0, true, true);\n    }\n};","date":"2023-03-20"},{"script":"python","time":280,"memory":19.4,"desc":"同上。","code":"class Solution:\n    def numDupDigitsAtMostN(self, n: int) -> int:\n        sn = str(n)\n  \n        @cache\n        def dfs(idx: int, mask: int, limit: bool, empty: bool):\n            if idx == len(sn):\n                return 0 if empty else 1\n            res = 0\n            if empty:\n                res += dfs(idx+1, mask, False, True)\n            nmax = int(sn[idx]) if limit else 9\n            for j in range(1 if empty else 0, nmax+1):\n                if (mask & (1 << j)) == 0:\n                    res += dfs(idx+1, mask | (1 << j),\n                               limit and j == nmax, False)\n            return res\n        return n - dfs(0, 0, True, True)","date":"2023-03-20"},{"script":"rust","time":8,"memory":1.9,"desc":"同上。","code":"impl Solution {\n    pub fn num_dup_digits_at_most_n(n: i32) -> i32 {\n        let sn = format!(\"{}\", n).chars().collect::<Vec<char>>();\n        let mut m = vec![vec![-1; 1 << 10]; sn.len()];\n        fn dfs(\n            sn: &Vec<char>,\n            m: &mut Vec<Vec<i32>>,\n            idx: usize,\n            mask: usize,\n            limit: bool,\n            empty: bool,\n        ) -> i32 {\n            if idx == sn.len() {\n                if empty {\n                    0\n                } else {\n                    1\n                }\n            } else if !limit && !empty && m[idx][mask] != -1 {\n                m[idx][mask]\n            } else {\n                let mut res = if empty {\n                    dfs(sn, m, idx + 1, mask, false, true)\n                } else {\n                    0\n                };\n                let nmax = if limit {\n                    sn[idx] as usize - '0' as usize\n                } else {\n                    9\n                };\n                for j in (if empty { 1 } else { 0 })..=nmax {\n                    if (mask & (1 << j)) == 0 {\n                        res += dfs(sn, m, idx + 1, mask | (1 << j), limit && j == nmax, false);\n                    }\n                }\n                m[idx][mask] = res;\n                res\n            }\n        }\n        return n - dfs(&sn, &mut m, 0, 0, true, true);\n    }\n}","date":"2023-03-20"}],"tagList":["数学","动态规划"],"level":"Hard"}},{"problemName":"1013.将数组分成和相等的三个部分.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1013.将数组分成和相等的三个部分.json","problemData":{"id":"1062","name":"1013.将数组分成和相等的三个部分","url":"https://leetcode.cn/problems/partition-array-into-three-parts-with-equal-sum","desc":"给你一个整数数组 arr，只有可以将其划分为三个和相等的 非空 部分时才返回 true，否则返回 false。","solutions":[{"script":"python","time":248,"memory":26.3,"desc":"dfs。","code":"class Solution:\ndef canThreePartsEqualSum(self, arr: List[int]) -> bool:\n    print(arr)\n    n = len(arr)\n    nsum = sum(arr)\n    print(nsum)\n    if nsum / 3 != nsum // 3:\n        return False\n    num = nsum // 3\n    f: bool = False\n    def dfs(i: int, frag: int):\n        nonlocal f\n        if i == n:\n            if frag == 3:\n                f = True\n            return\n        vsum = 0\n        for i in range(i, n):\n            vsum += arr[i]\n            if vsum == num:\n                dfs(i + 1, frag + 1)\n    dfs(0, 0)\n    return f","date":"2023-01-21"}],"tagList":["贪心","数组"],"level":"Easy"}},{"problemName":"1014.最佳观光组合.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1014.最佳观光组合.json","problemData":{"id":"1063","name":"1014.最佳观光组合","url":"https://leetcode.cn/problems/best-sightseeing-pair","desc":"给定正整数数组  A，A[i]  表示第 i 个观光景点的评分，并且两个景点  i 和  j  之间的距离为  j - i。一对景点（i < j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。返回一对观光景点能取得的最高分。","solutions":[{"date":"2020-06-17","time":8640,"memory":40.7,"script":"typescript","desc":"暴力运算。","code":"function maxScoreSightseeingPair(A: number[]): number {\n  const len = A.length;\n  let max = 0;\n  for (let i = 0; i < len; i++) {\n    for (let j = i + 1; j < len; j++) {\n      const num = comp(i, j);\n      if (num > max) max = num;\n    }\n  }\n  return max;\n  function comp(i: number, j: number): number {\n    return A[i] + A[j] + i - j;\n  }\n}"},{"date":"2020-06-17","time":324,"memory":40.7,"script":"typescript","desc":"在题解 1 的基础上增加小于 0 的值的判断，若小于 0 则跳出当前循环。","code":"function maxScoreSightseeingPair(A: number[]): number {\n  const len = A.length;\n  let max = 0;\n  for (let i = 0; i < len; i++) {\n    for (let j = i + 1; j < len; j++) {\n      const num = comp(i, j);\n      if (num > max) max = num;\n      if (num < 0) break;\n    }\n  }\n  return max;\n  function comp(i: number, j: number): number {\n    return A[i] + A[j] + i - j;\n  }\n}"},{"date":"2020-06-17","time":80,"memory":40.7,"script":"typescript","desc":"题目转化为 A[i]+i+A[j]-j,只要求出最大 A[i]+i，并于当前 i 值进行判断即可。","code":"function maxScoreSightseeingPair(A: number[]): number {\n  const len = A.length;\n  let ans = 0;\n  let mx = A[0];\n  for (let i = 1; i < len; i++) {\n    ans = Math.max(ans, mx + A[i] - i);\n    mx = Math.max(mx, A[i] + i);\n  }\n  return ans;\n}"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"1015.可被K整除的最小整数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1015.可被K整除的最小整数.json","problemData":{"id":"1064","name":"1015.可被K整除的最小整数","url":"https://leetcode.cn/problems/smallest-integer-divisible-by-k","desc":"给定正整数 k ，你需要找出可以被 k 整除的、仅包含数字 1 的最 小 正整数 n 的长度。","solutions":[{"script":"cpp","time":0,"memory":5.9,"desc":"欧拉函数。","code":"typedef long long ll;\nll gcd(ll a, ll b) {\n    if (a < b) return gcd(b, a);\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\nll phi(ll n) {\n    ll i = 2, x = n;\n    while (i * i <= n) {\n        if (x % i == 0) n -= n / i;\n        while (x % i == 0) x /= i;\n        i += 1;\n    }\n    if (x != 1) n -= n / x;\n    return n;\n}\nll quick_mul(ll a, ll b, ll mod) {\n    ll ans = 0, temp = a;\n    while (b) {\n        if (b & 1) ans = (ans + temp) % mod;\n        temp = (temp + temp) % mod;\n        b >>= 1;\n    }\n    return ans;\n}\nll quick_pow(ll a, ll b, ll mod) {\n    ll ans = 1, temp = a;\n    while (b) {\n        if (b & 1) ans = quick_mul(ans, temp, mod) % mod;\n        temp = quick_mul(temp, temp, mod) % mod;\n        b >>= 1;\n    }\n    return ans;\n}\nset<ll> get_factors(ll num) {\n    set<ll> s;\n    ll i = 1;\n    for (; i * i <= num; i++) {\n        if (num % i == 0) {\n            s.insert(i);\n            s.insert(num / i);\n        }\n    }\n    return s;\n}\nclass Solution {\npublic:\n    int smallestRepunitDivByK(int k) {\n        if (gcd(10, 9 * k) != 1) return -1;\n        k *= 9;\n        ll n = phi(k);\n        auto factors = get_factors(n);\n        for (auto &num : factors) {\n            if (quick_pow(10, num, k) == 1) return num;\n        }\n        return -1;\n    }\n};","date":"2023-05-10"}],"tagList":["哈希表","数学"],"level":"Medium"}},{"problemName":"1016.子串能表示从1到N数字的二进制串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1016.子串能表示从1到N数字的二进制串.json","problemData":{"id":"1065","name":"1016.子串能表示从1到N数字的二进制串","url":"https://leetcode.cn/problems/binary-string-with-substrings-representing-1-to-n","desc":"给定一个二进制字符串 s 和一个正整数 n，如果对于 [1, n] 范围内的每个整数，其二进制表示都是 s 的 子字符串 ，就返回 true，否则返回 false 。","solutions":[{"script":"cpp","time":4,"memory":6.3,"desc":"对于s统计所有出现的数字。","code":"class Solution {\npublic:\n    bool queryString(string s, int n) {\n        unordered_set<int> sset;\n        int len = s.size();\n        for (int i = 0; i < len; i++) {\n            int num = 0;\n            for (int j = i; j < len && j - i + 1 < 32; j++) {\n                num = (num << 1) | (s[j] - '0');\n                if (num <= n) sset.insert(num);\n                else break;\n            }\n        }\n        sset.erase(0);\n        return sset.size() == n;\n    }\n};","date":"2023-05-11"},{"script":"cpp","time":0,"memory":6.1,"desc":"对于所有n计算二进制字符串是否存在s里。","code":"class Solution {\npublic:\n    bool queryString(string s, int n) {\n        for (int num = 1; num <= n; num++) {\n            string bin = bitset<32>(num).to_string(); \n            bin = bin.substr(bin.find('1'));\n            if (s.find(bin) == string::npos) return false;\n        }\n        return true;\n    }\n};","date":"2023-05-11"},{"script":"python","time":52,"memory":16.1,"desc":"同上。","code":"class Solution:\n    def queryString(self, s: str, n: int) -> bool:\n        return all(bin(num)[2:] in s for num in range(1, n + 1))","date":"2023-05-11"},{"script":"rust","time":0,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn query_string(s: String, n: i32) -> bool {\n        for num in 1..=n {\n            let snum = format!(\"{:b}\", num);\n            if !s.contains(&snum) {\n                return false;\n            }\n        }\n        true\n    }\n}","date":"2023-05-11"}],"tagList":["字符串"],"level":"Medium"}},{"problemName":"1017.负二进制转换.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1017.负二进制转换.json","problemData":{"id":"1070","name":"1017.负二进制转换","url":"https://leetcode.cn/problems/convert-to-base-2","desc":"给你一个整数 n ，以二进制字符串的形式返回该整数的 负二进制（base -2）表示。","solutions":[{"script":"cpp","time":0,"memory":5.8,"desc":"遍历。","code":"class Solution {\npublic:\n    string baseNeg2(int n) {\n        return n == 0 ? \"0\" :\n               n == 1 ? \"1\" :\n               n % 2 != 0 ? baseNeg2((n - 1) / -2) + \"1\" :\n               baseNeg2(n / -2) + \"0\";\n    }\n};","date":"2023-04-06"},{"script":"python","time":40,"memory":14.7,"desc":"同上。","code":"class Solution:\n    def baseNeg2(self, n: int) -> str:\n        if n == 0:\n            return \"0\"\n        elif n == 1:\n            return \"1\"\n        elif n % 2 != 0:\n            return self.baseNeg2((n - 1) / -2) + \"1\"\n        else:\n            return self.baseNeg2(n / -2) + \"0\"","date":"2023-04-06"},{"script":"rust","time":0,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn base_neg2(n: i32) -> String {\n        if n == 0 {\n            \"0\".to_string()\n        } else if n == 1 {\n            \"1\".to_string()\n        } else if n % 2 != 0 {\n            Solution::base_neg2((n - 1) / -2) + \"1\"\n        } else {\n            Solution::base_neg2(n / -2) + \"0\"\n        }\n    }\n}","date":"2023-04-06"}],"tagList":["数学"],"level":"Medium"}},{"problemName":"1018.可被5整除的二进制前缀.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1018.可被5整除的二进制前缀.json","problemData":{"id":"1071","name":"1018.可被5整除的二进制前缀","url":"https://leetcode.cn/problems/binary-prefix-divisible-by-5","desc":"给定由若干  0  和  1  组成的数组 A。我们定义  N_i：从  A[0] 到  A[i]  的第 i  个子数组被解释为一个二进制数（从最高有效位到最低有效位）。返回布尔值列表  answer，只有当  N_i  可以被 5  整除时，答案  answer[i] 为  true，否则为 false。","solutions":[{"date":"2021-01-14","time":104,"memory":42.7,"script":"typescript","desc":"只保留后尾。","code":"function prefixesDivBy5(A: number[]): boolean[] {\n  const list = [];\n  let prefix = 0;\n  const length = A.length;\n  for (let i = 0; i < length; i++) {\n    prefix = ((prefix << 1) + A[i]) % 5;\n    list.push(prefix === 0);\n  }\n  return list;\n}"}],"tagList":["位运算","数组"],"level":"Easy"}},{"problemName":"1019.链表中的下一个更大节点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1019.链表中的下一个更大节点.json","problemData":{"id":"1072","name":"1019.链表中的下一个更大节点","url":"https://leetcode.cn/problems/next-greater-node-in-linked-list","desc":"返回一个整数数组 answer ，其中 answer[i] 是第 i 个节点( 从1开始 )的下一个更大的节点的值。如果第 i 个节点没有下一个更大的节点，设置 answer[i] = 0 。","solutions":[{"script":"cpp","time":72,"memory":43.8,"desc":"单调栈。","code":"class Solution {\npublic:\n    vector<int> nextLargerNodes(ListNode* head) {\n        int idx = 0;\n        ListNode *tmp = head;\n        vector<int> vlist, res;\n        stack<int> s;\n        while (tmp) {\n            vlist.push_back(tmp->val);\n            res.push_back(0);\n            while (s.size() && vlist[s.top()] < tmp->val) {\n                int top = s.top();\n                s.pop();\n                res[top] = tmp->val;\n            }\n            s.push(idx);\n            idx++;\n            tmp = tmp->next;\n        }\n        return res;\n    }\n};","date":"2023-04-10"},{"script":"python","time":220,"memory":19.8,"desc":"同上。","code":"class Solution:\n    def nextLargerNodes(self, head: Optional[ListNode]) -> List[int]:\n        idx = 0\n        tmp = head\n        vlist, res, s = [], [], []\n        while tmp:\n            vlist.append(tmp.val)\n            res.append(0)\n            while len(s) and vlist[s[-1]] < tmp.val:\n                res[s.pop()] = tmp.val\n            s.append(idx)\n            idx += 1\n            tmp = tmp.next\n        return res","date":"2023-04-10"},{"script":"rust","time":24,"memory":2.9,"desc":"同上。","code":"impl Solution {\n    pub fn next_larger_nodes(head: Option<Box<ListNode>>) -> Vec<i32> {\n        let mut tmp = &head;\n        let mut idx = 0;\n        let mut vlist = vec![];\n        let mut res = vec![];\n        let mut s = vec![];\n        while let Some(ref node) = tmp {\n            vlist.push(node.val);\n            res.push(0);\n            while !s.is_empty() && vlist[*s.last().unwrap()] < node.val {\n                res[s.pop().unwrap()] = node.val;\n            }\n            s.push(idx);\n            idx += 1;\n            tmp = &node.next;\n        }\n        res\n    }\n}","date":"2023-04-10"}],"tagList":["栈","数组","链表","单调栈"],"level":"Medium"}},{"problemName":"1020.飞地的数量.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1020.飞地的数量.json","problemData":{"id":"1073","name":"1020.飞地的数量","url":"https://leetcode.cn/problems/number-of-enclaves","desc":"返回网格中 无法 在任意次数的移动中离开网格边界的陆地单元格的数量。","solutions":[{"date":"2022-02-12","time":48,"memory":21.6,"script":"cpp","desc":"bfs,对于每个出口进行遍历,遍历到的陆地都可出。","code":"int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nclass Solution {\n   public:\n    typedef pair<int, int> node;\n    int m, n;\n    int numEnclaves(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n        queue<node> q;\n        for (int i = 0; i < n; i++) {\n            if (grid[i][0]) {\n                q.push(make_pair(i, 0));\n                grid[i][0] = 0;\n            }\n            if (m > 1 && grid[i][m - 1]) {\n                q.push(make_pair(i, m - 1));\n                grid[i][m - 1] = 0;\n            }\n        }\n        for (int i = 1; i < m - 1; i++) {\n            if (grid[0][i]) {\n                q.push(make_pair(0, i));\n                grid[0][i] = 0;\n            }\n            if (n > 1 && grid[n - 1][i]) {\n                q.push(make_pair(n - 1, i));\n                grid[n - 1][i] = 0;\n            }\n        }\n        while (q.size()) {\n            node v = q.front();\n            q.pop();\n            for (int i = 0; i < 4; i++) {\n                int nrow = v.first + dirs[i][0], ncol = v.second + dirs[i][1];\n                if (nrow < 0 || nrow >= n || ncol < 0 || ncol >= m ||\n                    grid[nrow][ncol] == 0)\n                    continue;\n                q.push(make_pair(nrow, ncol));\n                grid[nrow][ncol] = 0;\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j]) ans++;\n            }\n        }\n        return ans;\n    }\n};"},{"date":"2022-02-12","time":44,"memory":21.1,"script":"cpp","desc":"dfs,对于每个出口进行遍历,遍历到的陆地都可出。","code":"int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nclass Solution {\n   public:\n    typedef pair<int, int> node;\n    int m, n;\n    int numEnclaves(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n        for (int i = 0; i < n; i++) {\n            if (grid[i][0]) {\n                grid[i][0] = 0;\n                dfs(grid, i, 0);\n            }\n            if (m > 1 && grid[i][m - 1]) {\n                grid[i][m - 1] = 0;\n                dfs(grid, i, m - 1);\n            }\n        }\n        for (int i = 1; i < m - 1; i++) {\n            if (grid[0][i]) {\n                grid[0][i] = 0;\n                dfs(grid, 0, i);\n            }\n            if (n > 1 && grid[n - 1][i]) {\n                grid[n - 1][i] = 0;\n                dfs(grid, n - 1, i);\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j]) ans++;\n            }\n        }\n        return ans;\n    }\n    void dfs(vector<vector<int>>& grid, const int row, const int col) {\n        for (int i = 0; i < 4; i++) {\n            int nrow = row + dirs[i][0], ncol = col + dirs[i][1];\n            if (nrow < 0 || nrow >= n || ncol < 0 || ncol >= m ||\n                grid[nrow][ncol] == 0)\n                continue;\n            grid[nrow][ncol] = 0;\n            dfs(grid, nrow, ncol);\n        }\n    }\n};"},{"date":"2022-02-12","time":84,"memory":23.6,"script":"cpp","desc":"uf,统计所有出口。","code":"int dirs[4][2] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\nclass UnionFind {\n   public:\n    vector<int> data;\n    UnionFind(int size) : data(size) {\n        for (int i = 0; i < size; i++) data[i] = i;\n    }\n    int find(int e) {\n        if (data[e] == e) return e;\n        return data[e] = find(data[e]);\n    }\n    void uni(int e1, int e2) { data[find(e2)] = find(e1); }\n};\nclass Solution {\n   public:\n    int n, m;\n    int get_idx(int row, int col) { return row * m + col; }\n    int numEnclaves(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n        int ans = 0;\n        UnionFind uf(n * m);\n        unordered_set<int> s1, s2;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 0) continue;\n                ans++;\n                if (i == 0 || j == 0 || i == n - 1 || j == m - 1)\n                    s1.insert(get_idx(i, j));\n                for (int k = 0; k < 4; k++) {\n                    int ni = i + dirs[k][0], nj = j + dirs[k][1];\n                    if (ni < 0 || ni >= n || nj < 0 || nj >= m ||\n                        grid[ni][nj] == 0)\n                        continue;\n                    uf.uni(get_idx(i, j), get_idx(ni, nj));\n                }\n            }\n        }\n        for (auto& idx : s1) s2.insert(uf.find(idx));\n        for (int i = 0; i < n * m; i++) {\n            if (s2.count(uf.find(i))) ans--;\n        }\n        return ans;\n    }\n};"}],"tagList":["深度优先搜索","广度优先搜索","并查集","数组","矩阵"],"level":"Medium"}},{"problemName":"1021.删除最外层的括号.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1021.删除最外层的括号.json","problemData":{"id":"1078","name":"1021.删除最外层的括号","url":"https://leetcode.cn/problems/remove-outermost-parentheses","desc":"对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。","solutions":[{"date":"2021-03-19","time":96,"memory":39.7,"script":"typescript","desc":"利用栈维护内层括号。","code":"function removeOuterParentheses(S: string): string {\n  const stack: string[] = [];\n  let ans = '';\n  let deep = 0;\n  let count = 0;\n  for (const c of S) {\n    if (c === '(') {\n      stack.push(c);\n      deep++;\n      count++;\n    } else if (--deep === 0) {\n      let str = '';\n      while (--count !== 0) str = stack.pop()! + str;\n      ans += str;\n    } else {\n      stack.push(c);\n      count++;\n    }\n  }\n  return ans;\n}"},{"date":"2022-05-28","time":0,"memory":6.4,"script":"cpp","desc":"一次遍历, 储存当前等级。","code":"class Solution {\n   public:\n    string removeOuterParentheses(string s) {\n        string ans = \"\";\n        int level = 0;\n        for (auto& ch : s) {\n            if (ch == '(') {\n                if (level != 0) ans += ch;\n                level++;\n            } else {\n                level--;\n                if (level != 0) ans += ch;\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["栈","字符串"],"level":"Easy"}},{"problemName":"1023.驼峰式匹配.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1023.驼峰式匹配.json","problemData":{"id":"1080","name":"1023.驼峰式匹配","url":"https://leetcode.cn/problems/camelcase-matching","desc":"如果我们可以将小写字母插入模式串 pattern 得到待查询项 query，那么待查询项与给定模式串匹配。","solutions":[{"script":"cpp","time":4,"memory":6.9,"desc":"遍历。","code":"class Solution {\npublic:\n    vector<bool> camelMatch(vector<string>& queries, string pattern) {\n        auto check = [&](string &s) {\n            int pidx = 0;\n            for (int i = 0; i < s.size(); i++) {\n                if (pidx < pattern.size() && s[i] == pattern[pidx]) pidx++;\n                else if (isupper(s[i])) return false;\n            }\n            return pidx == pattern.size();\n        };\n        vector<bool> res;\n        for (auto &q : queries) res.push_back(check(q));\n        return res;\n    }\n};","date":"2023-04-14"},{"script":"python","time":36,"memory":14.8,"desc":"同上。","code":"class Solution:\n    def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:\n        def check(s: str):\n            pidx = 0\n            for c in s:\n                if pidx < len(pattern) and c == pattern[pidx]:\n                    pidx += 1\n                elif c.isupper():\n                    return False\n            return pidx == len(pattern)\n        return [check(s) for s in queries]","date":"2023-04-14"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn camel_match(queries: Vec<String>, pattern: String) -> Vec<bool> {\n        let pattern = pattern.chars().collect::<Vec<_>>();\n        queries\n            .into_iter()\n            .map(|s| {\n                let mut pidx = 0;\n                for c in s.chars() {\n                    if pidx < pattern.len() && c == pattern[pidx] {\n                        pidx += 1\n                    } else if c.is_uppercase() {\n                        return false;\n                    }\n                }\n                pidx == pattern.len()\n            })\n            .collect::<Vec<_>>()\n    }\n}","date":"2023-04-14"}],"tagList":["字典树","数组","双指针","字符串","字符串匹配"],"level":"Medium"}},{"problemName":"1024.视频拼接.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1024.视频拼接.json","problemData":{"id":"1081","name":"1024.视频拼接","url":"https://leetcode.cn/problems/video-stitching","desc":"你将会获得一系列视频片段，这些片段来自于一项持续时长为  T  秒的体育赛事。这些片段可能有所重叠，也可能长度不一。视频片段  clips[i]  都用区间进行表示：开始于  clips[i][0]  并于  clips[i][1]  结束。我们甚至可以对这些片段自由地再剪辑，例如片段  [0, 7]  可以剪切成  [0, 1] + [1, 3] + [3, 7]  三部分。我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, T]）。返回所需片段的最小数目，如果无法完成该任务，则返回  -1 。","solutions":[{"date":"2020-10-24","time":100,"memory":40.6,"script":"typescript","desc":"[参考连接](https://leetcode-cn.com/problems/video-stitching/solution/shi-pin-pin-jie-by-leetcode-solution/)。","code":"function videoStitching(clips: number[][], T: number): number {\n  const dp = new Array(T + 1).fill(Infinity);\n  dp[0] = 0;\n  for (let i = 0; i <= T; i++) {\n    for (const clip of clips) {\n      if (clip[0] < i && i <= clip[1]) {\n        dp[i] = Math.min(dp[i], dp[clip[0]] + 1);\n      }\n    }\n  }\n  return dp[T] === Infinity ? -1 : dp[T];\n}"}],"tagList":["贪心","数组","动态规划"],"level":"Medium"}},{"problemName":"1025.除数博弈.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1025.除数博弈.json","problemData":{"id":"1086","name":"1025.除数博弈","url":"https://leetcode.cn/problems/divisor-game","desc":"爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。","solutions":[{"date":"2020-07-24","time":88,"memory":40,"script":"typescript","desc":"动态规划,dp[i]=i 数时是否能赢，dp[i]=可余数中是否有数可匹配。","code":"function divisorGame(N: number): boolean {\n  const dp = new Array(N).fill(false);\n  for (let i = 2; i <= N; i++) dp[i - 1] = getMods(i).some(num => !dp[i - num - 1]);\n  return dp[N - 1];\n  function getMods(num: number) {\n    const arr = [1];\n    for (let i = 2; i < num; i++) {\n      if (num % i === 0) arr.push(i);\n    }\n    return arr;\n  }\n}"},{"date":"2020-07-24","time":76,"memory":37.4,"script":"typescript","desc":"枚举后推断是否能取余 2。","code":"function divisorGame(N: number): boolean {\n  return !(N & 1);\n}"}],"tagList":["脑筋急转弯","数学","动态规划","博弈"],"level":"Easy"}},{"problemName":"1026.节点与其祖先之间的最大差值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1026.节点与其祖先之间的最大差值.json","problemData":{"id":"1092","name":"1026.节点与其祖先之间的最大差值","url":"https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor","desc":"给定二叉树的根节点 root，找出存在于 不同 节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。","solutions":[{"script":"cpp","time":8,"memory":14.4,"desc":"dfs。","code":"class Solution {\npublic:\n    int maxAncestorDiff(TreeNode* root) {\n        function<vector<int>(TreeNode*)> dfs = [&](TreeNode *node) -> vector<int> {\n            vector<int> res{ node->val, node->val, 0};\n            if (node->left) {\n                auto v = dfs(node->left);\n                res[0] = min(res[0], v[0]);\n                res[1] = max(res[1], v[1]);\n                res[2] = max(res[2], max(v[2], max(abs(res[0] - node->val), abs(res[1] - node->val))));\n            }\n            if (node->right) {\n                auto v = dfs(node->right);\n                res[0] = min(res[0], v[0]);\n                res[1] = max(res[1], v[1]);\n                res[2] = max(res[2], max(v[2], max(abs(res[0] - node->val), abs(res[1] - node->val))));\n            }\n            return res;\n        };\n        return dfs(root)[2];\n    }\n};","date":"2023-04-18"},{"script":"python","time":40,"memory":21.8,"desc":"同上。","code":"class Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        def dfs(node: TreeNode) -> List[int]:\n            res = [node.val, node.val, 0]\n            if node.left != None:\n                v = dfs(node.left)\n                res[0] = min(res[0], v[0])\n                res[1] = max(res[1], v[1])\n                res[2] = max(res[2], max(\n                    v[2], max(abs(res[0] - node.val), abs(res[1] - node.val))))\n            if node.right != None:\n                v = dfs(node.right)\n                res[0] = min(res[0], v[0])\n                res[1] = max(res[1], v[1])\n                res[2] = max(res[2], max(\n                    v[2], max(abs(res[0] - node.val), abs(res[1] - node.val))))\n            return res\n        return dfs(root)[2]","date":"2023-04-18"},{"script":"rust","time":4,"memory":3.2,"desc":"同上。","code":"use std::rc::Rc;\nuse std::cell::RefCell;\nimpl Solution {\n    pub fn max_ancestor_diff(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        use std::cmp::{max, min};\n        let root = root.unwrap();\n        fn dfs(node: &Rc<RefCell<TreeNode>>) -> Vec<i32> {\n            let node = node.as_ref().borrow();\n            let mut res = vec![node.val, node.val, 0];\n            if node.left.is_some() {\n                let v = dfs(&node.left.as_ref().unwrap());\n                res[0] = min(res[0], v[0]);\n                res[1] = max(res[1], v[1]);\n                res[2] = max(\n                    res[2],\n                    max(\n                        v[2],\n                        max(i32::abs(res[0] - node.val), i32::abs(res[1] - node.val)),\n                    ),\n                );\n            }\n            if node.right.is_some() {\n                let v = dfs(&node.right.as_ref().unwrap());\n                res[0] = min(res[0], v[0]);\n                res[1] = max(res[1], v[1]);\n                res[2] = max(\n                    res[2],\n                    max(\n                        v[2],\n                        max(i32::abs(res[0] - node.val), i32::abs(res[1] - node.val)),\n                    ),\n                );\n            }\n            res\n        }\n        dfs(&root)[2]\n    }\n}","date":"2023-04-18"},{"script":"python","time":46,"memory":18.54,"desc":"dfs。","code":"class Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        ans = 0\n        def dfs(node: TreeNode) -> Tuple[int, int]:\n            nonlocal ans\n            nmin = nmax = node.val\n            if node.left:\n                lmin, lmax = dfs(node.left)\n                nmin = min(nmin, lmin)\n                nmax = max(nmax, lmax)\n            if node.right:\n                rmin, rmax = dfs(node.right)\n                nmin = min(nmin, rmin)\n                nmax = max(nmax, rmax)\n            ans = max(ans, abs(node.val - nmin), abs(node.val - nmax))\n            return [nmin, nmax]\n        dfs(root)\n        return ans","date":"2024-04-05"}],"tagList":["树","深度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"1027.最长等差数列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1027.最长等差数列.json","problemData":{"id":"1087","name":"1027.最长等差数列","url":"https://leetcode.cn/problems/longest-arithmetic-subsequence","desc":"给你一个整数数组 nums，返回 nums 中最长等差子序列的长度。","solutions":[{"script":"cpp","time":268,"memory":138.1,"desc":"dp[i][j]表示以i为结尾，公差为j的最大序列长度。","code":"class Solution {\n    public:\n        int longestArithSeqLength(vector<int>& nums) {\n            int n = nums.size(), res = 0;\n            vector<vector<int>> dp(n, vector<int>(1005, 0));\n            for (int i = 0; i < n; i++) {\n                for (int j = i - 1; j >= 0; j--) {\n                    int num = nums[i] - nums[j] + 500;\n                    dp[i][num] = max(dp[i][num], dp[j][num] + 1);\n                    res = max(res, dp[i][num]);\n                }\n            }\n            return res + 1;\n        }\n    };","date":"2023-04-22"},{"script":"python","time":2916,"memory":22.9,"desc":"同上。","code":"class Solution:\n    def longestArithSeqLength(self, nums: List[int]) -> int:\n        n = len(nums)\n        res = 0\n        dp = [[0] * 1005 for _ in range(n)]\n        for i in range(n):\n            for j in range(i-1, -1, -1):\n                num = nums[i] - nums[j] + 500\n                dp[i][num] = max(dp[i][num], dp[j][num] + 1)\n                res = max(dp[i][num], res)\n        return res + 1","date":"2023-04-22"},{"script":"rust","time":40,"memory":5.9,"desc":"同上。","code":"impl Solution {\n    pub fn longest_arith_seq_length(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        let mut res = 0;\n        let mut dp = vec![vec![0; 1005]; n];\n        for i in 0..n {\n            for j in (0..i).rev() {\n                let num = (nums[i] - nums[j] + 500) as usize;\n                dp[i][num] = dp[i][num].max(dp[j][num] + 1);\n                res = res.max(dp[i][num]);\n            }\n        }\n        res + 1\n    }\n}","date":"2023-04-22"}],"tagList":["数组","哈希表","二分查找","动态规划"],"level":"Medium"}},{"problemName":"1028.从先序遍历还原二叉树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1028.从先序遍历还原二叉树.json","problemData":{"id":"1093","name":"1028.从先序遍历还原二叉树","url":"https://leetcode.cn/problems/recover-a-tree-from-preorder-traversal","desc":"我们从二叉树的根节点 root  开始进行深度优先搜索。在遍历中的每个节点处，我们输出  D  条短划线（其中  D  是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。如果节点只有一个子节点，那么保证该子节点为左子节点。给出遍历输出  S，还原树并返回其根节点  root。","solutions":[{"date":"2020-06-18","time":148,"memory":43.1,"script":"typescript","desc":"利用正则解析字符串，使用递归去深度获取节点，由于 leetcode 存在 Bug 无法在函数内 new TreeNode()，使用内建 TreeNode1 代替内部 TreeNode。","code":"class TreeNode1 {\n  val: number;\n  left: TreeNode | null;\n  right: TreeNode | null;\n  constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n    this.val = val === undefined ? 0 : val;\n    this.left = left === undefined ? null : left;\n    this.right = right === undefined ? null : right;\n  }\n}\nfunction recoverFromPreorder(S: string): TreeNode | null {\n  const maxVal = 10 ** 9;\n  const maxValLen = maxVal.toString().length;\n  const maxValReg = `\\d{1,${maxValLen}}`;\n  const nextReg = (h: string): string => `${maxValReg}${h}${maxValReg}`;\n  return getNode(S, 1);\n  function getNode(nodeStr: string, level: number): TreeNode | null {\n    // console.log(\"====\");\n    // console.log(\"nodeStr:\" + nodeStr);\n    // console.log(\"level:\" + level);\n    const nodeStrLen = nodeStr.length;\n    if (nodeStrLen === 0) return null;\n    const h = ''.padStart(level, '-');\n    const reg = new RegExp(nextReg(h), 'g');\n    // console.log(reg);\n    const node = new TreeNode1(parseInt(nodeStr));\n    const cache: { index: number; str: string }[] = [];\n    let index = -1;\n    let match: RegExpMatchArray | null = nodeStr.substr(index + 1).match(reg);\n    while (match !== null) {\n      // console.log(match);\n      index = nodeStr.indexOf(match[0]);\n      const str = match[0];\n      cache.push({\n        index,\n        str,\n      });\n      const tempIndexH = str.indexOf('-');\n      const newNodeStr = nodeStr.substr(index + tempIndexH + h.length);\n      // console.log(str);\n      match = newNodeStr.match(reg);\n      // console.log(match);\n    }\n    // console.log(cache);\n    for (let i = 0, len = cache.length; i < len; i++) {\n      const { index, str } = cache[i];\n      const indexH = str.indexOf(h);\n      const newStr = nodeStr.substr(\n        index + indexH + h.length,\n        i === len - 1 ? nodeStrLen : cache[i + 1].index\n      );\n      if (node.left === null) {\n        node.left = getNode(newStr, level + 1);\n      } else {\n        node.right = getNode(newStr, level + 1);\n      }\n    }\n    return node;\n  }\n}"}],"tagList":["树","深度优先搜索","字符串","二叉树"],"level":"Hard"}},{"problemName":"1030.距离顺序排列矩阵单元格.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1030.距离顺序排列矩阵单元格.json","problemData":{"id":"1094","name":"1030.距离顺序排列矩阵单元格","url":"https://leetcode.cn/problems/matrix-cells-in-distance-order","desc":"给出 R 行 C 列的矩阵，其中的单元格的整数坐标为 (r, c)，满足 0 <= r < R 且 0 <= c < C。另外，我们在该矩阵中给出了一个坐标为  (r0, c0) 的单元格。返回矩阵中的所有单元格的坐标，并按到 (r0, c0) 的距离从最小到最大的顺序排，其中，两单元格(r1, c1) 和 (r2, c2) 之间的距离是曼哈顿距离，|r1 - r2| + |c1 - c2|。（你可以按任何满足此条件的顺序返回答案。）。","solutions":[{"date":"2020-11-17","time":284,"memory":54,"script":"typescript","desc":"遍历所有情况再进行排序。","code":"function allCellsDistOrder(R: number, C: number, r0: number, c0: number): number[][] {\n  const cache: Record<string, number> = {};\n  const format = (r: number, c: number) => `${r}:${c}`;\n  const comp = (r: number, c: number) => {\n    const name = format(r, c);\n    if (cache[name]) return cache[name];\n    else {\n      const num = Math.abs(r - r0) + Math.abs(c - c0);\n      cache[name] = num;\n      return num;\n    }\n  };\n  const ans: number[][] = [];\n  for (let i = 0; i < R; i++) {\n    for (let j = 0; j < C; j++) {\n      ans.push([i, j]);\n    }\n  }\n  return ans.sort(([r1, c1], [r2, c2]) => comp(r1, c1) - comp(r2, c2));\n}"}],"tagList":["几何","数组","数学","矩阵","排序"],"level":"Easy"}},{"problemName":"1031.两个非重叠子数组的最大和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1031.两个非重叠子数组的最大和.json","problemData":{"id":"1096","name":"1031.两个非重叠子数组的最大和","url":"https://leetcode.cn/problems/maximum-sum-of-two-non-overlapping-subarrays","desc":"给你一个整数数组 nums 和两个整数 firstLen 和 secondLen，请你找出并返回两个非重叠 子数组 中元素的最大和，长度分别为 firstLen 和 secondLen 。","solutions":[{"script":"cpp","time":4,"memory":8.1,"desc":"分别计算左右。","code":"class Solution {\npublic:\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\n        int n = nums.size(), lmax[n + 1], mmax[n + 1];\n        memset(lmax, 0, sizeof(lmax));\n        memset(mmax, 0, sizeof(mmax));\n        for (int i = n - 1, lsum = 0, msum = 0; i >= 0; i--) {\n            lsum += nums[i];\n            msum += nums[i];\n            if (i + firstLen < n) lsum -= nums[i + firstLen];\n            if (i + secondLen < n) msum -= nums[i + secondLen];\n            if (i + firstLen <= n) lmax[i] = max(lmax[i + 1], lsum); \n            if (i + secondLen <= n) mmax[i] = max(mmax[i + 1], msum); \n        }\n        int ans = 0;\n        for (int i = 0, lsum = 0, msum = 0; i < n; i++) {\n            lsum += nums[i];\n            msum += nums[i];\n            if (i >= firstLen) lsum -= nums[i - firstLen];\n            if (i >= secondLen) msum -= nums[i - secondLen];\n            ans = max(ans, lsum + mmax[i + 1]);\n            ans = max(ans, msum + lmax[i + 1]);\n        }\n        return ans;\n    }\n};","date":"2022-01-14"},{"script":"cpp","time":12,"memory":8.4,"desc":"遍历。","code":"vector<int> get_sums(vector<int> &arr) {\n    vector<int> sums(1, 0);\n    for (auto &num : arr) sums.push_back(sums.back() + num);\n    return sums;\n}\nclass Solution {\npublic:\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\n        int n = nums.size(), res = 0;\n        auto sums = get_sums(nums);\n        for (int i = 0; i + firstLen <= n; i++) {\n            int num = sums[i + firstLen] - sums[i];\n            for (int j = 0; j + secondLen < i; j++) res = max(res, sums[j + secondLen] - sums[j] + num);\n            for (int j = i + firstLen; j + secondLen <= n; j++) res = max(res, sums[j + secondLen] - sums[j] + num);\n        }\n        return res;\n    }\n};","date":"2023-04-26"},{"script":"python","time":260,"memory":15,"desc":"同上。","code":"class Solution:\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\n        sums = [0]\n        for num in nums:\n            sums.append(sums[-1] + num)\n        n = len(nums)\n        res = i = 0\n        while i + firstLen <= n:\n            num = sums[i+firstLen] - sums[i]\n            j = 0\n            while j + secondLen < i:\n                res = max(res, sums[j + secondLen] - sums[j] + num)\n                j += 1\n            j = i + firstLen\n            while j + secondLen <= n:\n                res = max(res, sums[j + secondLen] - sums[j] + num)\n                j += 1\n            i += 1\n        return res","date":"2023-04-26"},{"script":"rust","time":4,"memory":2.2,"desc":"同上。","code":"fn get_sums(arr: &Vec<i32>) -> Vec<i32> {\n    let mut sums = vec![0];\n    for num in arr {\n        sums.push(sums.last().unwrap() + *num);\n    }\n    sums\n}\n\nimpl Solution {\n    pub fn max_sum_two_no_overlap(nums: Vec<i32>, first_len: i32, second_len: i32) -> i32 {\n        use std::cmp::max;\n        let sums = get_sums(&nums);\n        let (first_len, second_len) = (first_len as usize, second_len as usize);\n        let n = nums.len();\n        let mut res = 0;\n        let mut i = 0;\n        while i + first_len <= n {\n            let num = sums[i + first_len] - sums[i];\n            let mut j = 0;\n            while j + second_len < i {\n                res = max(res, sums[j + second_len] - sums[j] + num);\n                j += 1;\n            }\n            j = i + first_len;\n            while j + second_len <= n {\n                res = max(res, sums[j + second_len] - sums[j] + num);\n                j += 1;\n            }\n            i += 1\n        }\n        res\n    }\n}","date":"2023-04-26"}],"tagList":["数组","动态规划","滑动窗口"],"level":"Medium"}},{"problemName":"1032.字符流.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1032.字符流.json","problemData":{"id":"1097","name":"1032.字符流","url":"https://leetcode.cn/problems/stream-of-characters","desc":"设计一个算法：接收一个字符流，并检查这些字符的后缀是否是字符串数组 words 中的一个字符串。","solutions":[{"script":"cpp","time":140,"memory":90.7,"desc":"ac自动机，对每个trie的无效节点赋值下一跳。","code":"struct TrieNode {\n    bool end;\n    TrieNode *fail, *children[26];\n    TrieNode(): end(false), fail(nullptr) {\n        memset(children, 0, sizeof(children));\n    }\n};\n\nclass StreamChecker {\npublic:\n    TrieNode *root, *current;\n    StreamChecker(vector<string>& words): root(new TrieNode()), current(root) {\n        for (auto &word : words) {\n            TrieNode *node = root;\n            for (auto &c : word) {\n                int idx = c - 'a';\n                if (!node->children[idx]) node->children[idx] = new TrieNode();\n                node = node->children[idx];\n            }\n            node->end = true;\n        }\n        queue<TrieNode *> q;\n        for (int i = 0; i < 26; i++) {\n            if (root->children[i]) root->children[i]->fail = root, q.push(root->children[i]);\n            else root->children[i] = root;\n        }\n        while (q.size()) {\n            TrieNode *node = q.front();\n            q.pop();\n            node->end = node->end || node->fail->end;\n            for (int i = 0; i < 26; i++) {\n                if (node->children[i]) node->children[i]->fail = node->fail->children[i], q.push(node->children[i]);\n                else node->children[i] = node->fail->children[i];\n            }\n        }\n    }\n\n    bool query(char letter) {\n        current = current->children[letter - 'a'];\n        return current->end;\n    }\n};","date":"2023-03-24"},{"script":"python","time":544,"memory":50.4,"desc":"同上。","code":"from queue import Queue\n\nclass TrieNode:\n    def __init__(self) -> None:\n        self.end = False\n        self.fail = None\n        self.children: List[TrieNode] = [None] * 26\n\n\nclass StreamChecker:\n\n    def __init__(self, words: List[str]):\n        self.root = self.current = TrieNode()\n        for word in words:\n            node = self.root\n            for c in word:\n                idx = ord(c) - ord('a')\n                if not node.children[idx]:\n                    node.children[idx] = TrieNode()\n                node = node.children[idx]\n            node.end = True\n        q = Queue()\n        self.root.fail = self.root\n        for i in range(26):\n            if self.root.children[i]:\n                self.root.children[i].fail = self.root\n                q.put(self.root.children[i])\n            else:\n                self.root.children[i] = self.root\n        while q.qsize():\n            node: TrieNode = q.get()\n            node.end = node.end or node.fail.end\n            for i in range(26):\n                if node.children[i]:\n                    node.children[i].fail = node.fail.children[i]\n                    q.put(node.children[i])\n                else:\n                    node.children[i] = node.fail.children[i]\n\n    def query(self, letter: str) -> bool:\n        self.current = self.current.children[ord(letter) - ord('a')]\n        return self.current.end","date":"2023-03-24"},{"script":"rust","time":56,"memory":33.4,"desc":"同上。","code":"pub use std::{cell::RefCell, rc::Rc};\nstruct TrieNode {\n    end: bool,\n    fail: Option<Rc<RefCell<TrieNode>>>,\n    children: Vec<Option<Rc<RefCell<TrieNode>>>>,\n}\nimpl TrieNode {\n    fn new() -> Rc<RefCell<Self>> {\n        Rc::new(RefCell::new(Self {\n            end: false,\n            fail: None,\n            children: vec![None; 26],\n        }))\n    }\n}\nstruct StreamChecker {\n    root: Rc<RefCell<TrieNode>>,\n    current: Rc<RefCell<TrieNode>>,\n}\nimpl StreamChecker {\n    fn new(words: Vec<String>) -> Self {\n        let root = TrieNode::new();\n        let current = root.clone();\n        for word in words {\n            let mut node = root.clone();\n            for c in word.chars() {\n                let idx = c as usize - 'a' as usize;\n                let node_ref = node.as_ref();\n                {\n                    let mut node = node_ref.borrow_mut();\n                    if node.children[idx].is_none() {\n                        node.children[idx] = Some(TrieNode::new());\n                    }\n                }\n                let next_node = node_ref.borrow().children[idx].clone().unwrap();\n                node = next_node;\n            }\n            node.as_ref().borrow_mut().end = true;\n        }\n        let mut q = std::collections::VecDeque::<Rc<RefCell<TrieNode>>>::new();\n        {\n            let mut root_ref = root.as_ref().borrow_mut();\n            for i in 0..26 {\n                if root_ref.children[i].is_some() {\n                    q.push_back(root_ref.children[i].clone().unwrap());\n                    root_ref.children[i]\n                        .clone()\n                        .unwrap()\n                        .as_ref()\n                        .borrow_mut()\n                        .fail = Some(root.clone());\n                } else {\n                    root_ref.children[i] = Some(root.clone());\n                }\n            }\n        }\n        while !q.is_empty() {\n            let node = q.pop_front().unwrap();\n            {\n                let node = node.as_ref();\n                let end = node.borrow().end;\n                node.borrow_mut().end =\n                    end || node.borrow().fail.as_ref().unwrap().as_ref().borrow().end;\n            }\n            for i in 0..26 {\n                let node = node.as_ref();\n                let fail_node = node\n                    .borrow()\n                    .fail\n                    .as_ref()\n                    .unwrap()\n                    .as_ref()\n                    .borrow()\n                    .children[i]\n                    .clone();\n                if node.borrow().children[i].is_some() {\n                    q.push_back(node.borrow().children[i].clone().unwrap());\n                    let child = node.borrow().children[i].clone().unwrap();\n                    child.as_ref().borrow_mut().fail = fail_node.clone();\n                } else {\n                    node.borrow_mut().children[i] = fail_node.clone();\n                }\n            }\n        }\n        Self { root, current }\n    }\n\n    fn query(&mut self, letter: char) -> bool {\n        let current = self.current.as_ref();\n        let next = current.borrow().children[letter as usize - 'a' as usize]\n            .as_ref()\n            .unwrap()\n            .clone();\n        self.current = next;\n        self.current.as_ref().borrow().end\n    }\n}","date":"2023-03-24"}],"tagList":["设计","字典树","数组","字符串","数据流"],"level":"Hard"}},{"problemName":"1033.移动石子直到连续.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1033.移动石子直到连续.json","problemData":{"id":"1103","name":"1033.移动石子直到连续","url":"https://leetcode.cn/problems/moving-stones-until-consecutive","desc":"三枚石子放置在数轴上，位置分别为 a，b，c。使游戏结束，你可以执行的最小和最大移动次数分别是多少？。","solutions":[{"script":"cpp","time":0,"memory":6.1,"desc":"贪心，先排序，最大数就是ac一步步往b靠，最小数是如果有两个数紧挨或者两个数中间空一格，那就可以一步到位，否则需要两步。","code":"void sort3(int &a, int &b, int &c) {\n    if (a > c) swap(a, c);\n    if (a > b) swap(a, b);\n    if (b > c) swap(b, c);\n}\nclass Solution {\npublic:\n    vector<int> numMovesStones(int a, int b, int c) {\n        sort3(a, b, c);\n        vector<int> res(2, 0);\n        if (a + 2 == c) return res;\n        res[0] = a + 1 == b || b + 1 == c || a + 2 == b || b + 2 == c ? 1 : 2;\n        res[1] = c - b - 1 + b - a - 1;\n        return res;\n    }\n};","date":"2023-04-30"},{"script":"python","time":36,"memory":16.1,"desc":"同上。","code":"def sort3(a: int, b: int, c: int) -> Tuple[int, int, int]:\n    if a > c:\n        a, c = c, a\n    if a > b:\n        a, b = b, a\n    if b > c:\n        b, c = c, b\n    return (a, b, c)\n\n\nclass Solution:\n    def numMovesStones(self, a: int, b: int, c: int) -> List[int]:\n        a, b, c = sort3(a, b, c)\n        if a + 2 == c:\n            return [0, 0]\n        return [\n            1 if a + 1 == b or b + 1 == c or a + 2 == b or b + 2 == c else 2,\n            c - b - 1 + b - a - 1\n        ]","date":"2023-04-30"},{"script":"rust","time":0,"memory":1.9,"desc":"同上。","code":"fn sort3(a: &mut i32, b: &mut i32, c: &mut i32) {\n    use std::ptr::swap;\n    unsafe {\n        if a > c {\n            swap(a, c);\n        }\n        if a > b {\n            swap(a, b);\n        }\n        if b > c {\n            swap(b, c);\n        }\n    };\n}\n\nimpl Solution {\n    pub fn num_moves_stones(mut a: i32, mut b: i32, mut c: i32) -> Vec<i32> {\n        sort3(&mut a, &mut b, &mut c);\n        if a + 2 == c {\n            vec![0, 0]\n        } else {\n            vec![\n                if a + 1 == b || b + 1 == c || a + 2 == b || b + 2 == c {\n                    1\n                } else {\n                    2\n                },\n                c - b - 1 + b - a - 1,\n            ]\n        }\n    }\n}","date":"2023-04-30"}],"tagList":["脑筋急转弯","数学"],"level":"Medium"}},{"problemName":"1034.边界着色.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1034.边界着色.json","problemData":{"id":"1104","name":"1034.边界着色","url":"https://leetcode.cn/problems/coloring-a-border","desc":"请你使用指定颜色 color 为所有包含网格块 grid[row][col] 的 连通分量的边界 进行着色，并返回最终的网格 grid 。","solutions":[{"date":"2021-12-07","time":84,"memory":41.7,"script":"typescript","desc":"dfs。","code":"function colorBorder(grid: number[][], row: number, col: number, color: number): number[][] {\n  const ori_color = grid[row][col];\n  const m = grid.length;\n  const n = grid[0].length;\n  const list: number[][] = [];\n  const set = new Set<string>();\n  const format = (row: number, col: number) => `${row}:${col}`;\n  draw(row, col);\n  for (const [row, col] of list) grid[row][col] = color;\n  return grid;\n  function draw(row: number, col: number) {\n    if (\n      row < 0 ||\n      row >= m ||\n      col < 0 ||\n      col >= n ||\n      grid[row][col] !== ori_color ||\n      set.has(format(row, col))\n    )\n      return;\n    set.add(format(row, col));\n    if (\n      !(\n        row > 0 &&\n        col > 0 &&\n        row < m - 1 &&\n        col < n - 1 &&\n        grid[row - 1][col] === ori_color &&\n        grid[row + 1][col] === ori_color &&\n        grid[row][col - 1] === ori_color &&\n        grid[row][col + 1] === ori_color\n      )\n    ) {\n      list.push([row, col]);\n    }\n    draw(row - 1, col);\n    draw(row + 1, col);\n    draw(row, col - 1);\n    draw(row, col + 1);\n  }\n}"}],"tagList":["深度优先搜索","广度优先搜索","数组","矩阵"],"level":"Medium"}},{"problemName":"1035. 不相交的线.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1035. 不相交的线.json","problemData":{"name":"1035.不相交的线","url":"https://leetcode.cn/problems/uncrossed-lines","level":"Easy","tagList":[],"desc":"以这种方法绘制线条，并返回可以绘制的最大连线数。","solutions":[{"script":"python","time":169,"memory":23.7,"desc":"记忆话dfs遍历所有不想交的可能","code":"class Solution:\n    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:\n        map2 = defaultdict(list)\n        for i, num in enumerate(nums2): map2[num].append(i)\n        @cache\n        def run(idx: int, last: int) -> int:\n            if idx == len(nums1): return 0\n            res = run(idx + 1, last)\n            for next_idx in map2[nums1[idx]]:\n                if next_idx <= last: continue\n                res = max(res, run(idx + 1, next_idx) + 1)\n            return res\n        return run(0, -1)"}]}},{"problemName":"1036.逃离大迷宫.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1036.逃离大迷宫.json","problemData":{"id":"1106","name":"1036.逃离大迷宫","url":"https://leetcode.cn/problems/escape-a-large-maze","desc":"只有在可以通过一系列的移动从源方格 source 到达目标方格 target 时才返回 true。否则，返回 false。","solutions":[{"date":"2022-01-11","time":1556,"memory":59.4,"script":"typescript","desc":"bfs,判断是否被包围。","code":"const format = (row: number, col: number) => `${row}:${col}`;\nconst dirs: number[][] = [\n  [1, 0],\n  [-1, 0],\n  [0, 1],\n  [0, -1],\n];\nconst MAX = 10 ** 6;\nconst MAX_CNT = 200 * 200;\nfunction check(blocked: Set<string>, source: number[], target: number[]): boolean {\n  const set = new Set<string>();\n  const queue: number[][] = [[source[0], source[1]]];\n  let cnt = MAX_CNT;\n  while (queue.length) {\n    const [row, col] = queue.shift()!;\n    for (const [addrow, addcol] of dirs) {\n      const nrow = row + addrow;\n      const ncol = col + addcol;\n      const str = format(nrow, ncol);\n      if (nrow < 0 || nrow >= MAX || ncol < 0 || ncol >= MAX || blocked.has(str) || set.has(str))\n        continue;\n      if (--cnt == 0 || (nrow === target[0] && ncol === target[1])) return true;\n      set.add(str);\n      queue.push([nrow, ncol]);\n    }\n  }\n  return false;\n}\nfunction isEscapePossible(blocked: number[][], source: number[], target: number[]): boolean {\n  if (blocked.length <= 1) return true;\n  const blocked_set = new Set(blocked.map(([row, col]) => format(row, col)));\n  return check(blocked_set, source, target) && check(blocked_set, target, source);\n}"}],"tagList":["深度优先搜索","广度优先搜索","数组","哈希表"],"level":"Hard"}},{"problemName":"1038.从二叉搜索树到更大和树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1038.从二叉搜索树到更大和树.json","problemData":{"id":"1114","name":"1038.从二叉搜索树到更大和树","url":"https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree","desc":"给定一个二叉搜索树 root (BST)，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。","solutions":[{"script":"python","time":32,"memory":16.11,"desc":"利用bst的特性，dfs。","code":"class Solution:\n    def bstToGst(self, root: TreeNode) -> TreeNode:\n        sums = 0\n        def dfs(node: Optional[TreeNode]):\n            nonlocal sums\n            if not node: return\n            dfs(node.right)\n            sums += node.val\n            node.val = sums\n            dfs(node.left)\n        dfs(roo)\n        return root","date":"2023-12-04"},{"script":"cpp","time":0,"memory":8.3,"desc":"同上。","code":"class Solution {\npublic:\n    TreeNode* bstToGst(TreeNode* root) {\n        int sums = 0;\n        function<void(TreeNode*)> dfs = [&](TreeNode *node) {\n            if (!node) return;\n            dfs(node->right);\n            sums += node->val;\n            node->val = sums;\n            dfs(node->left);\n        };\n        dfs(root);\n        return root;\n    }\n};","date":"2023-12-04"},{"script":"rust","time":0,"memory":2.17,"desc":"同上。","code":"use std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn bst_to_gst(mut root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\n        let mut sums = 0;\n        fn dfs(node: &mut Option<Rc<RefCell<TreeNode>>>, sums: &mut i32) {\n            if let Some(node) = node {\n                let mut node_ref = node.as_ref().borrow_mut();\n                dfs(&mut node_ref.right, sums);\n                *sums += node_ref.val;\n                node_ref.val = *sums;\n                dfs(&mut node_ref.left, sums);\n            }\n        }\n        dfs(&mut root, &mut sums);\n        root\n    }\n}","date":"2023-12-04"}],"tagList":["树","深度优先搜索","二叉搜索树","二叉树"],"level":"Medium"}},{"problemName":"1039.多边形三角剖分的最低得分.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1039.多边形三角剖分的最低得分.json","problemData":{"id":"1111","name":"1039.多边形三角剖分的最低得分","url":"https://leetcode.cn/problems/minimum-score-triangulation-of-polygon","desc":"假设将多边形 剖分 为 n - 2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 n - 2 个三角形的值之和。返回 多边形进行三角剖分后可以得到的最低分 。","solutions":[{"script":"cpp","time":56,"memory":9.4,"desc":"dp[i][j]表示从第i个点到第j个点能组成的三角形最小值，每次从中选一个点，把这一段分成三部分进行递归。","code":"class Solution {\npublic:\n    int minScoreTriangulation(vector<int>& values) {\n        unordered_map<int, unordered_map<int, int>> m;\n        int n = values.size();\n        function<int(int, int)> dfs = [&](int start, int end) {\n            if (start + 2 > end) return 0;\n            else if (start + 2 == end) return values[start] * values[start + 1] * values[end];\n            else if (m.count(start) && m[start].count(end)) return m[start][end];\n            else {\n                int s = INT_MAX;\n                for (int i = start + 1; i < end; i++) {\n                    s = min(s, values[start] * values[end] * values[i] + dfs(start, i) + dfs(i, end));\n                }\n                return m[start][end] = s;\n            }\n        };\n        return dfs(0, n - 1);\n    }\n};","date":"2023-04-02"},{"script":"python","time":128,"memory":15.5,"desc":"同上。","code":"class Solution:\n      def minScoreTriangulation(self, values: List[int]) -> int:\n          n = len(values)\n  \n          @cache\n          def dfs(start: int, end: int):\n              if start + 2 > end:\n                  return 0\n              elif start + 2 == end:\n                  return values[start] * values[start + 1] * values[end]\n              else:\n                  s = 0x7fffffff\n                  for i in range(start + 1, end):\n                      s = min(s, values[start] * values[end] * values[i] + dfs(start, i) + dfs(i, end))\n                  return s\n          return dfs(0, n-1)","date":"2023-04-02"},{"script":"rust","time":36,"memory":2.1,"desc":"同上。","code":"impl Solution {\n    pub fn min_score_triangulation(values: Vec<i32>) -> i32 {\n        use std::collections::HashMap;\n        let mut m: HashMap<usize, HashMap<usize, i32>> = HashMap::new();\n        let n = values.len();\n        fn dfs(\n            m: &mut HashMap<usize, HashMap<usize, i32>>,\n            values: &Vec<i32>,\n            n: usize,\n            start: usize,\n            end: usize,\n        ) -> i32 {\n            if start + 2 > end {\n                0\n            } else if start + 2 == end {\n                values[start] * values[start + 1] * values[end]\n            } else if m.contains_key(&start) && m.get(&start).unwrap().contains_key(&end) {\n                *m.get(&start).unwrap().get(&end).unwrap()\n            } else {\n                let mut s = i32::MAX;\n                for i in start + 1..end {\n                    s = s.min(\n                        values[start] * values[end] * values[i]\n                            + dfs(m, values, n, start, i)\n                            + dfs(m, values, n, i, end),\n                    )\n                }\n                m.entry(start).or_insert(HashMap::new()).insert(end, s);\n                s\n            }\n        }\n        dfs(&mut m, &values, n, 0, n - 1)\n    }\n}","date":"2023-04-02"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"1040.移动石子直到连续II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1040.移动石子直到连续II.json","problemData":{"id":"1113","name":"1040.移动石子直到连续II","url":"https://leetcode.cn/problems/moving-stones-until-consecutive-ii","desc":"在一个长度 无限 的数轴上，第 i 颗石子的位置为 stones[i]。如果一颗石子的位置最小/最大，那么该石子被称作 端点石子 。每个回合，你可以将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。值得注意的是，如果石子像 stones = [1,2,5] 这样，你将 无法 移动位于位置 5 的端点石子，因为无论将它移动到任何位置（例如 0 或 3），该石子都仍然会是端点石子。当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves] 。","solutions":[{"script":"cpp","time":20,"memory":12.9,"desc":"遍历。","code":"class Solution {\npublic:\n    vector<int> numMovesStonesII(vector<int>& stones) {\n        int n = stones.size();\n        sort(stones.begin(), stones.end());\n        if (stones[n - 1] - stones[0] + 1 == n) return vector<int>{0, 0};\n        // nmax : [1,2,4,8,9], 滚动的防止把1放入[2,9]或者把9放入[1,8], 计算空位再减去已经存在位置上的数字个数\n        int nmin = INT_MAX, nmax = max(stones[n - 1] - stones[1] - 1 - (n - 3), stones[n - 2] - stones[0] - 1 - (n - 3));\n        // ec: [l, r]中的空位\n        for (int l = 0, r = 0, ec = 0; r < n; l++) {\n            // 保证空位数量>=外面的数量\n            while (r + 1 < n && n - (r - l + 1) > ec) ec += stones[r + 1] - stones[r] - 1, r++;\n            if (r + 1 == n && n - (r - l + 1) > ec) break;\n            // cnt: [l, r]外面还剩几个数字, lc: 外面的数字填空后还剩几个空位\n            int cnt = n - (r - l + 1), lc = ec - cnt;\n            // eg: [1,10,100]如果所有的数字都用完了但还存在lc, 那就直接逐个放入lc\n            if (cnt == 0 && lc) nmin = min(nmin, lc);\n            // eg: [1,2,4,8]如果lc没了说明刚好放完\n            else if (lc == 0) nmin = min(nmin, cnt);\n            // eg: [1,2,4]如果lc还剩1个，剩下的1个不能直接放入空位，需要借助另一端的一个制造只剩生\n            else if (lc == 1) nmin = min(nmin, cnt + 2);\n            else nmin = min(nmin, cnt + 1);\n            ec -= stones[l + 1] - stones[l] - 1;\n        }\n        return vector<int>{nmin, nmax};\n    }\n};","date":"2023-04-07"},{"script":"python","time":84,"memory":16.1,"desc":"同上。","code":"class Solution:\n    def numMovesStonesII(self, stones: List[int]) -> List[int]:\n        n = len(stones)\n        stones.sort()\n        if stones[n - 1] - stones[0] + 1 == n:\n            return [0, 0]\n        nmin, nmax = 0x7fffffff, max(\n            stones[n - 1] - stones[1] - 1 - (n - 3), stones[n - 2] - stones[0] - 1 - (n - 3))\n        l = r = ec = 0\n        while r < n:\n            while r + 1 < n and n - (r - l + 1) > ec:\n                ec += stones[r + 1] - stones[r] - 1\n                r += 1\n            if r + 1 == n and n - (r - l + 1) > ec:\n                break\n            cnt = n - (r - l + 1)\n            lc = ec - cnt\n            if cnt == 0 and lc:\n                nmin = min(nmin, lc)\n            elif lc == 0:\n                nmin = min(nmin, cnt)\n            elif lc == 1:\n                nmin = min(nmin, cnt + 2)\n            else:\n                nmin = min(nmin, cnt + 1)\n            ec -= stones[l + 1] - stones[l] - 1\n            l += 1\n        return [nmin, nmax]","date":"2023-04-07"},{"script":"rust","time":4,"memory":2.3,"desc":"同上。","code":"impl Solution {\n    pub fn num_moves_stones_ii(mut stones: Vec<i32>) -> Vec<i32> {\n        use std::cmp::{max, min};\n        let n = stones.len();\n        stones.sort();\n        if stones[n - 1] - stones[0] + 1 == n as i32 {\n            vec![0, 0]\n        } else {\n            let (mut nmin, nmax) = (\n                i32::MAX,\n                max(\n                    stones[n - 1] - stones[1] - 1 - (n as i32 - 3),\n                    stones[n - 2] - stones[0] - 1 - (n as i32 - 3),\n                ),\n            );\n            let (mut l, mut r, mut ec) = (0, 0, 0);\n            while r < n {\n                while r + 1 < n && n - (r - l + 1) > ec {\n                    ec += (stones[r + 1] - stones[r] - 1) as usize;\n                    r += 1;\n                }\n                if r + 1 == n && n - (r - l + 1) > ec {\n                    break;\n                }\n                let cnt = n - (r - l + 1);\n                let lc = ec - cnt;\n                if cnt == 0 && lc > 0 {\n                    nmin = min(nmin, lc as i32);\n                }\n                // eg: [1,2,4,8]如果lc没了说明刚好放完\n                else if lc == 0 {\n                    nmin = min(nmin, cnt as i32);\n                }\n                // eg: [1,2,4]如果lc还剩1个，剩下的1个不能直接放入空位，需要借助另一端的一个制造只剩生\n                else if lc == 1 {\n                    nmin = min(nmin, cnt as i32 + 2);\n                } else {\n                    nmin = min(nmin, cnt as i32 + 1);\n                }\n                ec -= (stones[l + 1] - stones[l] - 1) as usize;\n                l += 1;\n            }\n            vec![nmin, nmax]\n        }\n    }\n}","date":"2023-04-07"}],"tagList":["数组","数学","双指针","排序"],"level":"Medium"}},{"problemName":"1041.困于环中的机器人.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1041.困于环中的机器人.json","problemData":{"id":"1119","name":"1041.困于环中的机器人","url":"https://leetcode.cn/problems/robot-bounded-in-circle","desc":"机器人按顺序执行指令 instructions，并一直重复它们。只有在平面中存在环使得机器人永远无法离开时，返回 true。否则，返回 false。","solutions":[{"script":"cpp","time":4,"memory":6,"desc":"做四次模拟回到原点的一定是循环。","code":"class Solution {\npublic:\n    bool isRobotBounded(string instructions) {\n        vector<vector<int>> dirs = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n        int n = instructions.size(), dir = 0, x = 0, y = 0;\n        for (int cnt = 0; cnt < 4; cnt++) {\n            for (int i = 0; i < n; i++) {\n                switch (instructions[i]) {\n                    case 'L': dir = (dir + 4 - 1) % 4; break;\n                    case 'R': dir = (dir + 1) % 4; break;\n                    case 'G': x = x + dirs[dir][0], y = y + dirs[dir][1]; break;\n                }\n            }\n        }\n        return x == 0 && y == 0;\n    }\n};","date":"2023-04-11"},{"script":"python","time":32,"memory":14.8,"desc":"同上。","code":"class Solution:\n    def isRobotBounded(self, instructions: str) -> bool:\n        dirs = [[1, 0], [0, 1], [-1, 0], [0, -1]]\n        x = y = dir = 0\n        for _ in range(4):\n            for i in instructions:\n                match i:\n                    case 'L':\n                        dir = (dir + 4 - 1) % 4\n                    case 'R':\n                        dir = (dir + 1) % 4\n                    case 'G':\n                        x = x + dirs[dir][0]\n                        y = y + dirs[dir][1]\n        return x == 0 and y == 0","date":"2023-04-11"},{"script":"rust","time":0,"memory":2.2,"desc":"同上。","code":"const dirs: [[i32; 2]; 4] = [[1, 0], [0, 1], [-1, 0], [0, -1]];\nimpl Solution {\n    pub fn is_robot_bounded(instructions: String) -> bool {\n        let instructions = instructions.chars().collect::<Vec<char>>();\n        let (mut x, mut y, mut dir) = (0, 0, 0i32);\n        for _ in 0..4 {\n            for i in &instructions {\n                match *i {\n                    'L' => {\n                        dir = (dir + 4 - 1) % 4;\n                    }\n                    'R' => {\n                        dir = (dir + 1) % 4;\n                    }\n                    'G' => {\n                        x = x + dirs[dir as usize][0];\n                        y = y + dirs[dir as usize][1];\n                    }\n                    _ => {}\n                }\n            }\n        }\n        x == 0 && y == 0\n    }\n}","date":"2023-04-11"}],"tagList":["数学","字符串","模拟"],"level":"Medium"}},{"problemName":"1042.不邻接植花.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1042.不邻接植花.json","problemData":{"id":"1120","name":"1042.不邻接植花","url":"https://leetcode.cn/problems/flower-planting-with-no-adjacent","desc":"有 n 个花园，按从 1 到 n 标记。另有数组 paths ，其中 paths[i] = [xi, yi] 描述了花园 xi 到花园 yi 的双向路径。在每个花园中，你打算种下四种花之一。另外，所有花园 最多 有 3 条路径可以进入或离开.你需要为每个花园选择一种花，使得通过路径相连的任何两个花园中的花的种类互不相同。以数组形式返回 任一 可行的方案作为答案 answer，其中 answer[i] 为在第 (i+1) 个花园中种植的花的种类。花的种类用  1、2、3、4 表示。保证存在答案。","solutions":[{"script":"cpp","time":92,"memory":39,"desc":"直接找周围还空的位置。","code":"class Solution {\npublic:\n    vector<int> gardenNoAdj(int n, vector<vector<int>>& paths) {\n        vector<vector<int>> list(n);\n        for (auto &p : paths)\n            list[p[0] - 1].push_back(p[1] - 1),\n            list[p[1] - 1].push_back(p[0] - 1);\n        vector<int> res(n, 0);\n        for (int i = 0; i < n; i++) {\n            int cache[5] = {0};\n            for (int next : list[i])\n                if (res[next] != 0) cache[res[next]] = 1;\n            for (int j = 1; j < 5; j++)\n                if (cache[j] != 1) { res[i] = j; break; }\n        }\n        return res;\n    }\n};","date":"2023-04-15"},{"script":"python","time":88,"memory":20.1,"desc":"同上。","code":"class Solution:\n    def gardenNoAdj(self, n: int, paths: List[List[int]]) -> List[int]:\n        list = [[] for _ in range(n)]\n        for [p1, p2] in paths:\n            list[p1-1].append(p2-1)\n            list[p2-1].append(p1-1)\n        res = [0] * n\n        for i in range(n):\n            cache = [False] * 5\n            for next in list[i]:\n                if res[next] != 0:\n                    cache[res[next]] = 1\n            for j in range(1, 5):\n                if cache[j] != 1:\n                    res[i] = j\n                    break\n        return res","date":"2023-04-15"},{"script":"rust","time":12,"memory":3.6,"desc":"同上。","code":"impl Solution {\n    pub fn garden_no_adj(n: i32, paths: Vec<Vec<i32>>) -> Vec<i32> {\n        let n = n as usize;\n        let mut list = vec![vec![]; n];\n        for p in paths {\n            let (p0, p1) = (p[0] as usize, p[1] as usize);\n            list[p0 - 1].push(p1 - 1);\n            list[p1 - 1].push(p0 - 1);\n        }\n        let mut res = vec![0; n];\n        for i in 0..n {\n            let mut cache = [false; 5];\n            for next in list[i].iter() {\n                if res[*next] != 0 {\n                    cache[res[*next]] = true;\n                }\n            }\n            for j in 1..5 {\n                if !cache[j] {\n                    res[i] = j;\n                    break;\n                }\n            }\n        }\n        res.into_iter().map(|v| v as i32).collect()\n    }\n}","date":"2023-04-15"}],"tagList":["深度优先搜索","广度优先搜索","图"],"level":"Medium"}},{"problemName":"1043.分隔数组以得到最大和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1043.分隔数组以得到最大和.json","problemData":{"id":"1121","name":"1043.分隔数组以得到最大和","url":"https://leetcode.cn/problems/partition-array-for-maximum-sum","desc":"给你一个整数数组 arr，请你将该数组分隔为长度 最多 为 k 的一些（连续）子数组。分隔完成后，每个子数组的中的所有值都会变为该子数组中的最大值。","solutions":[{"script":"cpp","time":4,"memory":8.3,"desc":"dp[i]表示前i个元素能分割成的最大值。","code":"class Solution {\n    public:\n        int maxSumAfterPartitioning(vector<int>& arr, int k) {\n            int n = arr.size();\n            vector<int> dp(n + 1, 0);\n            int nmax = arr[0];\n            for (int i = 1; i <= k; i++) {\n                nmax = max(nmax, arr[i - 1]);\n                dp[i] = nmax * i;\n            }\n            for (int i = k + 1; i <= n; i++) {\n                nmax = arr[i - 1];\n                for (int j = i; i - j + 1 <= k; j--) {\n                    nmax = max(nmax, arr[j - 1]);\n                    dp[i] = max(dp[i], dp[j - 1] + nmax * (i - j + 1));\n                }   \n            }\n            return dp[n];\n        }\n    };","date":"2023-04-19"},{"script":"python","time":212,"memory":15.1,"desc":"同上。","code":"class Solution:\n    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        dp = [0] * (n+1)\n        nmax = arr[0]\n        for i in range(1, k+1):\n            nmax = max(nmax, arr[i-1])\n            dp[i] = nmax * i\n        for i in range(k+1, n+1):\n            nmax = arr[i-1]\n            j = i\n            while i-j+1 <= k:\n                nmax = max(nmax, arr[j-1])\n                dp[i] = max(dp[i], dp[j-1]+nmax*(i-j+1))\n                j -= 1\n        return dp[n]","date":"2023-04-19"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn max_sum_after_partitioning(arr: Vec<i32>, k: i32) -> i32 {\n        use std::cmp::max;\n        let n = arr.len();\n        let k = k as usize;\n        let mut dp = vec![0; n + 1];\n        let mut nmax = arr[0];\n        for i in 1..=k {\n            nmax = max(nmax, arr[i - 1]);\n            dp[i] = nmax * (i as i32);\n        }\n        for i in k + 1..=n {\n            nmax = arr[i - 1];\n            let mut j = i;\n            while i - j + 1 <= k {\n                nmax = max(nmax, arr[j - 1]);\n                dp[i] = max(dp[i], dp[j - 1] + nmax * (i - j + 1) as i32);\n                j -= 1\n            }\n        }\n        dp[n]\n    }\n}","date":"2023-04-19"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"1044.最长重复子串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1044.最长重复子串.json","problemData":{"id":"1122","name":"1044.最长重复子串","url":"https://leetcode.cn/problems/longest-duplicate-substring","desc":"返回 任意一个 可能具有最长长度的重复子串。如果 s 不含重复子串，那么答案为 \"\" 。","solutions":[{"date":"2021-12-23","time":9236,"memory":60.3,"script":"typescript","desc":"二分答案。","code":"function check(s: string, n: number, num: number): string {\n  let left = 0;\n  let right = num;\n  let str = s.substring(left, right);\n  const set = new Set([str]);\n  while (right < n) {\n    str = s.substring(++left, ++right);\n    if (set.has(str)) return str;\n    set.add(str);\n  }\n  return '';\n}\nfunction longestDupSubstring(s: string): string {\n  const n = s.length;\n  let left = 0;\n  let right = n;\n  let ans = '';\n  while (left < right) {\n    const mid = (left + right + 1) >> 1;\n    const str = check(s, n, mid);\n    if (str === '') right = mid - 1;\n    else {\n      left = mid;\n      ans = str;\n    }\n  }\n  return ans;\n}"}],"tagList":["字符串","二分查找","后缀数组","滑动窗口","哈希函数","滚动哈希"],"level":"Hard"}},{"problemName":"1046.最后一块石头的重量.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1046.最后一块石头的重量.json","problemData":{"id":"1127","name":"1046.最后一块石头的重量","url":"https://leetcode.cn/problems/last-stone-weight","desc":"有一堆石头，每块石头的重量都是正整数。最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。","solutions":[{"date":"2020-12-30","time":104,"memory":40,"script":"typescript","desc":"构建堆。","code":"var lastStoneWeight = function (stones) {\n  const pq = new MaxPriorityQueue();\n  for (const stone of stones) {\n    pq.enqueue('x', stone);\n  }\n  while (pq.size() > 1) {\n    const a = pq.dequeue()['priority'];\n    const b = pq.dequeue()['priority'];\n    if (a > b) {\n      pq.enqueue('x', a - b);\n    }\n  }\n  return pq.isEmpty() ? 0 : pq.dequeue()['priority'];\n};"},{"date":"2021-04-11","time":92,"memory":39.1,"script":"typescript","desc":"构建堆。","code":"class Heap<T = number> {\n  private arr: T[] = [];\n  get isEmpty() {\n    return this.size === 0;\n  }\n  get size() {\n    return this.arr.length;\n  }\n  get top() {\n    return this.arr[0];\n  }\n  constructor(private compare: (t1: T, t2: T) => number) {}\n  add(num: T): void {\n    this.arr.push(num);\n    this.shiftUp(this.size - 1);\n  }\n  remove(): T {\n    const num = this.arr.shift()!;\n    if (this.size) {\n      this.arr.unshift(this.arr.pop()!);\n      this.shiftDown(0);\n    }\n    return num;\n  }\n  private shiftUp(index: number): void {\n    if (index === 0) return;\n    const parentIndex = (index - 1) >> 1;\n    if (this.compare(this.arr[index], this.arr[parentIndex]) > 0) {\n      [this.arr[index], this.arr[parentIndex]] = [this.arr[parentIndex], this.arr[index]];\n      this.shiftUp(parentIndex);\n    }\n  }\n  private shiftDown(index: number): void {\n    let childrenIndex = index * 2 + 1;\n    if (childrenIndex > this.size - 1) return;\n    if (\n      childrenIndex + 1 <= this.size - 1 &&\n      this.compare(this.arr[childrenIndex + 1], this.arr[childrenIndex]) > 0\n    ) {\n      childrenIndex++;\n    }\n    if (this.compare(this.arr[childrenIndex], this.arr[index]) > 0) {\n      [this.arr[childrenIndex], this.arr[index]] = [this.arr[index], this.arr[childrenIndex]];\n      this.shiftDown(childrenIndex);\n    }\n  }\n  *[Symbol.iterator](): IterableIterator<T> {\n    for (const t of this.arr) {\n      yield t;\n    }\n  }\n}\nfunction lastStoneWeight(stones: number[]): number {\n  const heap = new Heap((t1, t2) => t1 - t2);\n  stones.forEach(v => heap.add(v));\n  while (heap.size > 1) {\n    const s1 = heap.remove();\n    const s2 = heap.remove();\n    if (s1 === s2) continue;\n    heap.add(Math.abs(s1 - s2));\n  }\n  return heap.size === 0 ? 0 : heap.top;\n}"}],"tagList":["数组","堆（优先队列）"],"level":"Easy"}},{"problemName":"1047.删除字符串中的所有相邻重复项.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1047.删除字符串中的所有相邻重复项.json","problemData":{"id":"1128","name":"1047.删除字符串中的所有相邻重复项","url":"https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string","desc":"给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。","solutions":[{"date":"2021-03-09","time":128,"memory":45.9,"script":"typescript","desc":"栈。","code":"function removeDuplicates(S: string): string {\n  const stack: string[] = [];\n  for (const c of S) {\n    stack.length === 0\n      ? stack.push(c)\n      : c === stack[stack.length - 1]\n      ? stack.pop()\n      : stack.push(c);\n  }\n  return stack.join('');\n}"}],"tagList":["栈","字符串"],"level":"Easy"}},{"problemName":"1048.最长字符串链.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1048.最长字符串链.json","problemData":{"id":"1129","name":"1048.最长字符串链","url":"https://leetcode.cn/problems/longest-string-chain","desc":"从给定单词列表 words 中选择单词组成词链，返回 词链的 最长可能长度 。","solutions":[{"script":"cpp","time":96,"memory":12.8,"desc":"遍历。","code":"class Solution {\npublic:\n    bool cmp(string &s1, string &s2, int i1 = 0, int i2 = 0, int err = 1) {\n        if (i1 == s1.size()) return i2 + err == s2.size();\n        if (i2 == s2.size()) return i1 + err == s1.size();\n        if (s1[i1] == s2[i2]) return cmp(s1, s2, i1 + 1, i2 + 1, err);\n        if (err == 0) return false;\n        return cmp(s1, s2, i1 + 1, i2, err - 1) || cmp(s1, s2, i1, i2 + 1, err - 1);\n    }\n    int longestStrChain(vector<string>& words) {\n        sort(words.begin(), words.end(), [&](auto &a, auto &b) { return a.size() < b.size(); });\n        int n = words.size(), res = 1;\n        vector<int> dp(n, 1);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (words[j].size() == words[i].size()) break;\n                if (cmp(words[i], words[j])) dp[i] = max(dp[i], dp[j] + 1);\n            }\n            res = max(res, dp[i]);\n        }\n        return res;\n    }\n};","date":"2023-04-27"},{"script":"python","time":1836,"memory":15.2,"desc":"同上。","code":"def cmp(s1: str, s2: str, i1: int, i2: int, err: int):\n    if i1 == len(s1):\n        return i2 + err == len(s2)\n    if i2 == len(s2):\n        return i1 + err == len(s1)\n    if s1[i1] == s2[i2]:\n        return cmp(s1, s2, i1 + 1, i2 + 1, err)\n    if err == 0:\n        return False\n    return cmp(s1, s2, i1 + 1, i2, err - 1) or cmp(s1, s2, i1, i2 + 1, err - 1)\n\n\nclass Solution:\n    def longestStrChain(self, words: List[str]) -> int:\n        words.sort(key=lambda v: len(v))\n        n = len(words)\n        res = 1\n        dp = [1] * n\n        for i in range(n):\n            for j in range(i):\n                if len(words[j]) == len(words[i]):\n                    break\n                if cmp(words[i], words[j], 0, 0, 1):\n                    dp[i] = max(dp[i], dp[j] + 1)\n            res = max(res, dp[i])\n        return res","date":"2023-04-27"},{"script":"rust","time":28,"memory":2.1,"desc":"同上。","code":"fn cmp(s1: &[u8], s2: &[u8], i1: usize, i2: usize, err: usize) -> bool {\n    if i1 == s1.len() {\n        i2 + err == s2.len()\n    } else if i2 == s2.len() {\n        i1 + err == s1.len()\n    } else if s1[i1] == s2[i2] {\n        cmp(s1, s2, i1 + 1, i2 + 1, err)\n    } else if err == 0 {\n        false\n    } else {\n        cmp(s1, s2, i1 + 1, i2, err - 1) || cmp(s1, s2, i1, i2 + 1, err - 1)\n    }\n}\nimpl Solution {\n    pub fn longest_str_chain(mut words: Vec<String>) -> i32 {\n        words.sort_by_key(|v| v.len());\n        let n = words.len();\n        let mut res = 1;\n        let mut dp = vec![1; n];\n        for i in 0..n {\n            for j in 0..i {\n                if words[i].len() == words[j].len() {\n                    break;\n                }\n                let s1 = words[i].as_bytes();\n                if cmp(words[i].as_bytes(), words[j].as_bytes(), 0, 0, 1) {\n                    dp[i] = dp[i].max(dp[j] + 1);\n                }\n            }\n            res = res.max(dp[i]);\n        }\n        res as i32\n    }\n}","date":"2023-04-27"}],"tagList":["数组","哈希表","双指针","字符串","动态规划","排序"],"level":"Medium"}},{"problemName":"1049.最后一块石头的重量II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1049.最后一块石头的重量II.json","problemData":{"id":"1130","name":"1049.最后一块石头的重量II","url":"https://leetcode.cn/problems/last-stone-weight-ii","desc":"有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。","solutions":[{"date":"2021-06-08","time":92,"memory":41.1,"script":"typescript","desc":"sum-2\\*neg,neg 尽可能接近 sum。","code":"function lastStoneWeightII(stones: number[]): number {\n  const sum = stones.reduce((total, cur) => total + cur, 0);\n  const len = stones.length;\n  const half = sum >> 1;\n  const dp = new Array(len + 1).fill(0).map(_ => new Array(half + 1).fill(false));\n  dp[0][0] = true;\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j <= half; j++) {\n      if (stones[i] > j) dp[i + 1][j] = dp[i][j];\n      else dp[i + 1][j] = dp[i][j] || dp[i][j - stones[i]];\n    }\n  }\n  for (let j = half; j >= 0; j--) if (dp[len][j]) return sum - 2 * j;\n  return 0;\n}"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"1051.高度检查器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1051.高度检查器.json","problemData":{"id":"1137","name":"1051.高度检查器","url":"https://leetcode.cn/problems/height-checker","desc":"返回满足 heights[i] != expected[i] 的 下标数量 。","solutions":[{"date":"2022-03-27","time":0,"memory":7.9,"script":"cpp","desc":"排序后比较。","code":"class Solution {\n   public:\n    int heightChecker(vector<int>& heights) {\n        vector<int> sorted(heights.begin(), heights.end());\n        sort(sorted.begin(), sorted.end());\n        int ans = 0;\n        for (int i = 0; i < heights.size(); i++) {\n            if (sorted[i] != heights[i]) ans++;\n        }\n        return ans;\n    }\n};"},{"date":"2022-06-13","time":4,"memory":7.9,"script":"cpp","desc":"排序后比较。","code":"class Solution {\n   public:\n    int heightChecker(vector<int>& heights) {\n        int n = heights.size();\n        vector<int> list(n);\n        for (int i = 0; i < n; i++) list[i] = heights[i];\n        sort(list.begin(), list.end());\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (list[i] != heights[i]) ans++;\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","计数排序","排序"],"level":"Easy"}},{"problemName":"1052.爱生气的书店老板.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1052.爱生气的书店老板.json","problemData":{"id":"1138","name":"1052.爱生气的书店老板","url":"https://leetcode.cn/problems/grumpy-bookstore-owner","desc":"今天，书店老板有一家店打算试营业  customers.length  分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。请你返回这一天营业下来，最多有多少客户能够感到满意的数量。","solutions":[{"date":"2021-02-23","time":104,"memory":44.3,"script":"typescript","desc":"读取范围内生气的值的最大值。","code":"function maxSatisfied(customers: number[], grumpy: number[], X: number): number {\n  const _sum = (arr: number[]) => arr.reduce((total, cur) => total + cur, 0);\n  if (X === 0) return _sum(customers.filter((_, i) => grumpy[i]));\n  if (grumpy.every(v => !v)) return _sum(customers);\n  const len = customers.length;\n  let l = 0;\n  let r = X - 1;\n  let sum = _sum(customers.slice(0, X).filter((_, i) => grumpy[i]));\n  let maxSum = sum;\n  while (r < len - 1) {\n    if (grumpy[++r]) sum += customers[r];\n    if (grumpy[l]) sum -= customers[l];\n    l++;\n    maxSum = Math.max(maxSum, sum);\n  }\n  return maxSum + _sum(customers.filter((_, i) => !grumpy[i]));\n}"},{"script":"python","time":58,"memory":18.13,"desc":"滑动窗口。","code":"class Solution:\n    def maxSatisfied(self, customers: List[int], grumpy: List[int], minutes: int) -> int:\n        n = len(customers)\n        res = cur = sum(customers[i] for i in range(n) if not grumpy[i] or i < minutes)\n        for i in range(minutes, n):\n            if grumpy[i - minutes]: cur -= customers[i - minutes]\n            if grumpy[i]: cur += customers[i]\n            res = max(res, cur)\n        return res","date":"2024-04-23"}],"tagList":["数组","滑动窗口"],"level":"Medium"}},{"problemName":"1053.交换一次的先前排列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1053.交换一次的先前排列.json","problemData":{"id":"1139","name":"1053.交换一次的先前排列","url":"https://leetcode.cn/problems/previous-permutation-with-one-swap","desc":"给你一个正整数数组 arr（可能存在重复的元素），请你返回可在 一次交换（交换两数字 arr[i] 和 arr[j] 的位置）后得到的、按字典序排列小于 arr 的最大排列。","solutions":[{"script":"cpp","time":28,"memory":24.1,"desc":"找出末尾第一个出现的逆序。","code":"class Solution {\npublic:\n    vector<int> prevPermOpt1(vector<int>& arr) {\n        map<int, int> m;\n        m[10005] = arr.size();\n        for (int i = arr.size() - 1; i >= 0; i--) {\n            auto it = m.lower_bound(arr[i]);\n            if (m.size() > 1 && it != m.begin()) {\n                swap(arr[i], arr[(*(--it)).second]);\n                break;\n            }\n            m[val] = i;\n        }\n        return arr;\n    }\n};","date":"2023-04-03"}],"tagList":["贪心","数组"],"level":"Medium"}},{"problemName":"1054.距离相等的条形码.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1054.距离相等的条形码.json","problemData":{"id":"1140","name":"1054.距离相等的条形码","url":"https://leetcode.cn/problems/distant-barcodes","desc":"在一个仓库里，有一排条形码，其中第 i 个条形码为 barcodes[i]。请你重新排列这些条形码，使其中任意两个相邻的条形码不能相等。 你可以返回任何满足该要求的答案，此题保证存在答案。","solutions":[{"script":"cpp","time":76,"memory":42.9,"desc":"堆存储所有的值，每次拿出剩余次数最多的两个值塞入。","code":"#define X first\n#define Y second\nclass Solution {\npublic:\n    typedef pair<int, int> pii;\n    vector<int> rearrangeBarcodes(vector<int>& barcodes) {\n        unordered_map<int, int> m;\n        for (auto &num : barcodes) m[num]++;\n        auto cmp = [&](pii x, pii y) -> bool { return x.second < y.second; };\n        priority_queue<pii, vector<pii>, decltype(cmp)> q(cmp);\n        for (auto &item : m) q.push(item);\n        vector<int> res;\n        while (q.size() >= 2) {\n            auto item1 = q.top(); q.pop();\n            auto item2 = q.top(); q.pop();\n            if (--item1.second > 0) q.push(item1);\n            if (--item2.second > 0) q.push(item2);\n            res.push_back(item1.first);\n            res.push_back(item2.first);\n        }\n        if (q.size()) res.push_back(q.top().first);\n        return res;\n    }\n};","date":"2023-05-14"},{"script":"python","time":260,"memory":18.9,"desc":"同上。","code":"class Node:\n    def __init__(self, k: int, v: int):\n        self.k = k\n        self.v = v\n\n    def __lt__(self, o: 'Node') -> bool:\n        return self.v > o.v\n\n\nclass Solution:\n    def rearrangeBarcodes(self, barcodes: List[int]) -> List[int]:\n        q = []\n        m = Counter()\n        for num in barcodes:\n            m[num] += 1\n        for k, v in m.items():\n            heappush(q, Node(k, v))\n        res = []\n        while len(q) >= 2:\n            item1 = heappop(q)\n            item2 = heappop(q)\n            item1.v -= 1\n            if item1.v > 0:\n                heappush(q, item1)\n            item2.v -= 1\n            if item2.v > 0:\n                heappush(q, item2)\n            res.append(item1.k)\n            res.append(item2.k)\n        if len(q):\n            res.append(q[0].k)\n        return res","date":"2023-05-14"},{"script":"rust","time":24,"memory":2.2,"desc":"同上。","code":"#[derive(Clone, PartialEq, Eq, Ord)]\nstruct Node(i32, i32);\nimpl Node {\n    fn new(k: i32, v: i32) -> Self {\n        Node(k, v)\n    }\n}\nimpl PartialOrd for Node {\n    fn partial_cmp(&self, o: &Self) -> Option<std::cmp::Ordering> {\n        self.1.partial_cmp(&o.1)\n    }\n}\nimpl Solution {\n    pub fn rearrange_barcodes(barcodes: Vec<i32>) -> Vec<i32> {\n        let mut q = std::collections::BinaryHeap::<Node>::new();\n        let mut m = std::collections::HashMap::<i32, i32>::new();\n        for num in barcodes {\n            *m.entry(num).or_insert(0) += 1;\n        }\n        for (k, v) in m {\n            q.push(Node::new(k, v));\n        }\n        let mut res = vec![];\n        while q.len() >= 2 {\n            let mut item1 = q.pop().unwrap();\n            let mut item2 = q.pop().unwrap();\n            res.push(item1.0);\n            res.push(item2.0);\n            item1.1 -= 1;\n            item2.1 -= 1;\n            if item1.1 > 0 {\n                q.push(item1);\n            }\n            if item2.1 > 0 {\n                q.push(item2);\n            }\n        }\n        if !q.is_empty() {\n            res.push(q.peek().unwrap().0);\n        }\n        res\n    }\n}","date":"2023-05-14"}],"tagList":["贪心","数组","哈希表","计数","排序","堆（优先队列）"],"level":"Medium"}},{"problemName":"1071.字符串的最大公因子.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1071.字符串的最大公因子.json","problemData":{"id":"1146","name":"1071.字符串的最大公因子","url":"https://leetcode.cn/problems/greatest-common-divisor-of-strings","desc":"返回最长字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。","solutions":[{"date":"2021-12-04","time":80,"memory":39.4,"script":"typescript","desc":"算出质数位置进行阶乘。","code":"function gcd(a: number, b: number) {\n  if (!b) return a;\n  return gcd(b, a % b);\n}\nfunction gcdOfStrings(str1: string, str2: string): string {\n  if (str1 + str2 !== str2 + str1) return '';\n  return str1.substr(0, gcd(str1.length, str2.length));\n}"}],"tagList":["数学","字符串"],"level":"Easy"}},{"problemName":"1072.按列翻转得到最大值等行数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1072.按列翻转得到最大值等行数.json","problemData":{"id":"1147","name":"1072.按列翻转得到最大值等行数","url":"https://leetcode.cn/problems/flip-columns-for-maximum-number-of-equal-rows","desc":"给定 m x n 矩阵 matrix 。你可以从中选出任意数量的列并翻转其上的 每个 单元格。（即翻转后，单元格的值从 0 变成 1，或者从 1 变为 0 。）返回 经过一些翻转后，行与行之间所有值都相等的最大行数 。","solutions":[{"script":"cpp","time":352,"memory":69,"desc":"按照行首的值进行反转。","code":"class Solution {\npublic:\n    int maxEqualRowsAfterFlips(vector<vector<int>>& matrix) {\n        unordered_map<string, int> m;\n        for (auto &row : matrix) {\n            string s = \"\";\n            for (auto &v : row) {\n                s += to_string(v ^ row[0]);\n            }\n            m[s]++;\n        }\n        int res = 0;\n        for (auto &item : m) {\n            res = max(res, item.second);\n        }\n        return res;\n    }\n};","date":"2023-05-15"},{"script":"python","time":248,"memory":18.6,"desc":"同上。","code":"class Solution:\n    def maxEqualRowsAfterFlips(self, matrix: List[List[int]]) -> int:\n        m = Counter()\n        for row in matrix:\n            s = \"\"\n            for v in row:\n                s += str(v ^ row[0])\n            m[s] += 1\n        res = 0\n        for v in m.values():\n            res = max(res, v)\n        return res","date":"2023-05-15"},{"script":"rust","time":28,"memory":3.2,"desc":"同上。","code":"impl Solution {\n    pub fn max_equal_rows_after_flips(matrix: Vec<Vec<i32>>) -> i32 {\n        let mut m = std::collections::HashMap::<String, i32>::new();\n        for row in matrix {\n            let mut s = String::new();\n            for v in &row {\n                s.push(((*v ^ row[0]) as u8 + b'0') as char);\n            }\n            *m.entry(s).or_insert(0) += 1;\n        }\n        let mut res = 0;\n        for (_, v) in m.into_iter() {\n            res = res.max(v);\n        }\n        res\n    }\n}","date":"2023-05-15"}],"tagList":["数组","哈希表","矩阵"],"level":"Medium"}},{"problemName":"1073.负二进制数相加.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1073.负二进制数相加.json","problemData":{"id":"1148","name":"1073.负二进制数相加","url":"https://leetcode.cn/problems/adding-two-negabinary-numbers","desc":"给出基数为 -2 的两个数 arr1 和 arr2，返回两数相加的结果。","solutions":[{"script":"cpp","time":8,"memory":19.1,"desc":"统一两个数组，如果都1，那可以抵消下一位的1，如果该位需要增加1，可以在该位加1，且下一位加1。","code":"class Solution {\npublic:\n    vector<int> addNegabinary(vector<int>& arr1, vector<int>& arr2) {\n        reverse(arr1.begin(), arr1.end());\n        reverse(arr2.begin(), arr2.end());\n        for (int i = 0; i < max(arr1.size(), arr2.size()); i++) {\n            if (i == arr1.size()) arr1.push_back(0);\n            if (i == arr2.size()) arr2.push_back(0);\n        }\n        vector<int> res;\n        for (int i = 0, add = 0; i < arr1.size(); i++) {\n            switch (arr1[i] + arr2[i] + add) {\n                case -1: res.push_back(1); add = 1; break;\n                case 0: res.push_back(0); add = 0; break;\n                case 1: res.push_back(1); add = 0; break;\n                case 2: res.push_back(0); add = -1; break;\n                case 3: res.push_back(1); add = -1; break;\n            }\n            if (i == arr1.size() - 1 && add != 0) arr1.push_back(0), arr2.push_back(0);\n        }\n        while (res.size() > 1 && res.back() == 0) res.pop_back();\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};","date":"2023-05-18"},{"script":"python","time":48,"memory":16.3,"desc":"同上。","code":"class Solution:\n    def addNegabinary(self, arr1: List[int], arr2: List[int]) -> List[int]:\n        arr1.reverse()\n        arr2.reverse()\n        print(arr1, arr2)\n        for i in range(max(len(arr1), len(arr2))):\n            if i == len(arr1):\n                arr1.append(0)\n            if i == len(arr2):\n                arr2.append(0)\n        res = []\n        i = add = 0\n        while i < len(arr1):\n            match arr1[i] + arr2[i] + add:\n                case -1:\n                    res.append(1)\n                    add = 1\n                case 0:\n                    res.append(0)\n                    add = 0\n                case 1:\n                    res.append(1)\n                    add = 0\n                case 2:\n                    res.append(0)\n                    add = -1\n                case 3:\n                    res.append(1)\n                    add = -1\n            if i == len(arr1) - 1 and add != 0:\n                arr1.append(0)\n                arr2.append(0)\n            i += 1\n        while len(res) > 1 and res[-1] == 0:\n            res.pop()\n        res.reverse()\n        return res","date":"2023-05-18"},{"script":"rust","time":0,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn add_negabinary(mut arr1: Vec<i32>, mut arr2: Vec<i32>) -> Vec<i32> {\n        arr1.reverse();\n        arr2.reverse();\n        for i in 0..arr1.len().max(arr2.len()) {\n            if i == arr1.len() {\n                arr1.push(0);\n            }\n            if i == arr2.len() {\n                arr2.push(0);\n            }\n        }\n        let mut res = vec![];\n        let (mut i, mut add) = (0, 0);\n        while i < arr1.len() {\n            match arr1[i] + arr2[i] + add {\n                -1 => {\n                    res.push(1);\n                    add = 1;\n                }\n                0 => {\n                    res.push(0);\n                    add = 0;\n                }\n                1 => {\n                    res.push(1);\n                    add = 0;\n                }\n                2 => {\n                    res.push(0);\n                    add = -1;\n                }\n                3 => {\n                    res.push(1);\n                    add = -1;\n                }\n                _ => {}\n            }\n            if i == arr1.len() - 1 && add != 0 {\n                arr1.push(0);\n                arr2.push(0);\n            }\n            i += 1;\n        }\n        while res.len() > 1 && *res.last().unwrap() == 0 {\n            res.pop();\n        }\n        res.reverse();\n        res\n    }\n}\n","date":"2023-05-18"}],"tagList":["数组","数学"],"level":"Medium"}},{"problemName":"1074.元素和为目标值的子矩阵数量.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1074.元素和为目标值的子矩阵数量.json","problemData":{"id":"1145","name":"1074.元素和为目标值的子矩阵数量","url":"https://leetcode.cn/problems/number-of-submatrices-that-sum-to-target","desc":"给出矩阵 matrix 和目标值 target，返回元素总和等于目标值的非空子矩阵的数量。","solutions":[{"date":"2021-05-29","time":500,"memory":42.3,"script":"typescript","desc":"暴力循环。","code":"function numSubmatrixSumTarget(matrix: number[][], target: number): number {\n  const rowLen = matrix.length;\n  const colLen = matrix[0].length;\n  const prefixSumList: number[][] = new Array(rowLen + 1)\n    .fill(0)\n    .map(_ => new Array(colLen + 1).fill(0));\n  for (let row = 0; row < rowLen; row++) {\n    for (let col = 0; col < colLen; col++) {\n      prefixSumList[row + 1][col + 1] =\n        prefixSumList[row + 1][col] +\n        prefixSumList[row][col + 1] -\n        prefixSumList[row][col] +\n        matrix[row][col];\n    }\n  }\n  let ans = 0;\n  for (let endRow = 0; endRow < rowLen; endRow++) {\n    for (let endCol = 0; endCol < colLen; endCol++) {\n      for (let startRow = 0; startRow <= endRow; startRow++) {\n        for (let startCol = 0; startCol <= endCol; startCol++) {\n          if (\n            prefixSumList[endRow + 1][endCol + 1] -\n              prefixSumList[endRow + 1][startCol] -\n              prefixSumList[startRow][endCol + 1] +\n              prefixSumList[startRow][startCol] ===\n            target\n          ) {\n            ans++;\n          }\n        }\n      }\n    }\n  }\n  return ans;\n}"}],"tagList":["数组","哈希表","矩阵","前缀和"],"level":"Hard"}},{"problemName":"1078.Bigram分词.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1078.Bigram分词.json","problemData":{"id":"1156","name":"1078.Bigram分词","url":"https://leetcode.cn/problems/occurrences-after-bigram","desc":"对于每种这样的情况，将第三个词 \"third\" 添加到答案中，并返回答案。","solutions":[{"date":"2021-12-26","time":0,"memory":6.5,"script":"cpp","desc":"分割字符串。","code":"class Solution {\n   public:\n    vector<string> split(string text) {\n        vector<string> ans;\n        for (int i = 0; i < text.size(); i++) {\n            int end = i;\n            while (end < text.size() && text[end] != ' ') end++;\n            ans.push_back(text.substr(i, end - i));\n            i = end;\n        }\n        return ans;\n    }\n    vector<string> findOcurrences(string text, string first, string second) {\n        vector<string> ans;\n        vector<string> list = split(text);\n        for (int i = 0; i < list.size() - 2; i++) {\n            string str = list[i];\n            if (str == first && list[i + 1] == second) {\n                ans.push_back(list[i + 2]);\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"1079.活字印刷.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1079.活字印刷.json","problemData":{"id":"1160","name":"1079.活字印刷","url":"https://leetcode.cn/problems/letter-tile-possibilities","desc":"你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。","solutions":[{"script":"cpp","time":144,"memory":22.7,"desc":"全排列。","code":"class Solution {\npublic:\n    int numTilePossibilities(string tiles) {\n        unordered_set<string> s;\n        unordered_set<int> idxs;\n        function<void(string)> dfs = [&](string cur) {\n            s.insert(cur);\n            if (cur.size() == tiles.size()) return;\n            for (int i = 0; i < tiles.size(); i++) {\n                if (idxs.count(i)) continue;\n                idxs.insert(i);\n                dfs(cur + tiles[i]);\n                idxs.erase(i);\n            }\n        };\n        dfs(\"\");\n        return s.size() - 1;\n    }\n};","date":"2023-05-19"},{"script":"python","time":204,"memory":24.8,"desc":"同上。","code":"class Solution:\n    def numTilePossibilities(self, tiles: str) -> int:\n        s = set()\n        idxs = set()\n\n        def dfs(cur: str):\n            s.add(cur)\n            if len(cur) == len(tiles):\n                return\n            for i in range(len(tiles)):\n                if i in idxs:\n                    continue\n                idxs.add(i)\n                dfs(cur + tiles[i])\n                idxs.remove(i)\n        dfs('')\n        return len(s) - 1","date":"2023-05-19"},{"script":"rust","time":40,"memory":3,"desc":"同上。","code":"impl Solution {\n    pub fn num_tile_possibilities(tiles: String) -> i32 {\n        use std::collections::HashSet;\n        let tiles = tiles.as_bytes().iter().map(|v| *v).collect::<Vec<u8>>();\n        let mut s = HashSet::<String>::new();\n        let mut idxs = HashSet::<usize>::new();\n        fn dfs(\n            s: &mut HashSet<String>,\n            idxs: &mut HashSet<usize>,\n            tiles: &Vec<u8>,\n            cur: &mut Vec<u8>,\n        ) {\n            s.insert(String::from_utf8(cur.clone()).unwrap());\n            if cur.len() != tiles.len() {\n                for i in 0..tiles.len() {\n                    if !idxs.contains(&i) {\n                        idxs.insert(i);\n                        cur.push(tiles[i]);\n                        dfs(s, idxs, tiles, cur);\n                        cur.pop();\n                        idxs.remove(&i);\n                    }\n                }\n            }\n        }\n        let mut cur: Vec<u8> = vec![];\n        dfs(&mut s, &mut idxs, &tiles, &mut cur);\n        (s.len() - 1) as i32\n    }\n}","date":"2023-05-19"}],"tagList":["哈希表","字符串","回溯","计数"],"level":"Medium"}},{"problemName":"1080.根到叶路径上的不足节点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1080.根到叶路径上的不足节点.json","problemData":{"id":"1157","name":"1080.根到叶路径上的不足节点","url":"https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths","desc":"给你二叉树的根节点 root 和一个整数 limit ，请你同时删除树中所有 不足节点 ，并返回最终二叉树的根节点。","solutions":[{"script":"cpp","time":40,"memory":32.7,"desc":"dfs判断下一层节点是否满足。","code":"class Solution {\npublic:\n    TreeNode* sufficientSubset(TreeNode* root, int limit) {\n        return dfs(root, limit, 0) ? root : nullptr;\n    }\n    bool dfs(TreeNode *node, int limit, int sum) {\n        if (!node) return true;\n        sum += node->val;\n        auto l = dfs(node->left, limit, sum), r = dfs(node->right, limit, sum);\n        if (!node->left && !node->right && sum < limit ||\n            !node->left && !r ||\n            !node->right && !l ||\n            !l && !r) return false;\n        if (!l) node->left = nullptr;\n        if (!r) node->right = nullptr;\n        return true;\n    }\n};","date":"2023-05-22"},{"script":"python","time":84,"memory":17.9,"desc":"同上。","code":"def dfs(node: Optional[TreeNode], limit: int, sum: int):\n    if node == None:\n        return True\n    sum += node.val\n    l, r = dfs(node.left, limit, sum), dfs(node.right, limit, sum)\n    if (not node.left and not node.right and sum < limit) or (not node.left and not r) or (not node.right and not l) or (not l and not r):\n        return False\n    if not l:\n        node.left = None\n    if not r:\n        node.right = None\n    return True\n\n\nclass Solution:\n    def sufficientSubset(self, root: Optional[TreeNode], limit: int) -> Optional[TreeNode]:\n        return root if dfs(root, limit, 0) else None","date":"2023-05-22"},{"script":"rust","time":8,"memory":2.5,"desc":"同上。","code":"use std::cell::RefCell;\nuse std::rc::Rc;\nfn dfs(node: &mut Option<Rc<RefCell<TreeNode>>>, limit: i32, mut sum: i32) -> bool {\n    match node {\n        None => true,\n        Some(ref node) => {\n            let mut nodeRef = node.as_ref().borrow_mut();\n            sum += nodeRef.val;\n            let l = dfs(&mut nodeRef.left, limit, sum);\n            let r = dfs(&mut nodeRef.right, limit, sum);\n            if nodeRef.left.is_none() && nodeRef.right.is_none() && sum < limit\n                || nodeRef.left.is_none() && !r\n                || nodeRef.right.is_none() && !l\n                || !l && !r\n            {\n                false\n            } else {\n                if !l {\n                    nodeRef.left = None;\n                }\n                if !r {\n                    nodeRef.right = None;\n                }\n                true\n            }\n        }\n    }\n}\nimpl Solution {\n    pub fn sufficient_subset(\n        mut root: Option<Rc<RefCell<TreeNode>>>,\n        limit: i32,\n    ) -> Option<Rc<RefCell<TreeNode>>> {\n        if dfs(&mut root, limit, 0) {\n            root\n        } else {\n            None\n        }\n    }\n}","date":"2023-05-22"}],"tagList":["树","深度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"1081.不同字符的最小子序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1081.不同字符的最小子序列.json","problemData":{"id":"1159","name":"1081.不同字符的最小子序列","url":"https://leetcode.cn/problems/smallest-subsequence-of-distinct-characters","desc":"返回 s 字典序最小的子序列，该子序列包含 s 的所有不同字符，且只包含一次。","solutions":[{"date":"2021-07-30","time":176,"memory":46.1,"script":"typescript","desc":"单调栈。","code":"function smallestSubsequence(s: string): string {\n  const map: Record<string, number> = {};\n  for (const c of s) map[c] = (map[c] ?? 0) + 1;\n  const stack: string[] = [];\n  const set = new Set<string>();\n  const toNum = (c: string) => c.codePointAt(0)! - 'a'.codePointAt(0)!;\n  for (const c of s) {\n    if (set.has(c)) {\n      map[c]--;\n      continue;\n    }\n    while (\n      stack.length &&\n      toNum(stack[stack.length - 1]) > toNum(c) &&\n      map[stack[stack.length - 1]] > 0\n    ) {\n      console.log(set);\n      set.delete(stack.pop()!);\n    }\n    stack.push(c);\n    set.add(c);\n    map[c]--;\n  }\n  return stack.join('');\n}"}],"tagList":["栈","贪心","字符串","单调栈"],"level":"Medium"}},{"problemName":"1089.复写零.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1089.复写零.json","problemData":{"id":"1168","name":"1089.复写零","url":"https://leetcode.cn/problems/duplicate-zeros","desc":"给你一个长度固定的整数数组 arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。","solutions":[{"date":"2022-03-27","time":76,"memory":43.9,"script":"typescript","desc":"统计 0 的下标。","code":"function duplicateZeros(arr: number[]): void {\n  const list = new Array(arr.length)\n    .fill(0)\n    .map((_, i) => i)\n    .filter(v => arr[v] === 0)\n    .reverse();\n  for (const idx of list) {\n    arr.splice(idx, 0, 0);\n    arr.pop();\n  }\n}"},{"date":"2022-06-17","time":4,"memory":9.3,"script":"cpp","desc":"从后往前遍历。","code":"class Solution {\n   public:\n    void duplicateZeros(vector<int>& arr) {\n        int n = arr.size(), p = n - 1;\n        auto setNum = [&](int i, int p) -> void {\n            if (p < n) arr[p] = arr[i];\n        };\n        for (int i = 0; i < n; i++) {\n            if (arr[i] == 0) p++;\n        }\n        for (int i = n - 1; i >= 0; i--, p--) {\n            if (arr[i] == 0) {\n                setNum(i, p--);\n                setNum(i, p);\n            } else {\n                setNum(i, p);\n            }\n        }\n    }\n};"}],"tagList":["数组","双指针"],"level":"Easy"}},{"problemName":"1090.受标签影响的最大值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1090.受标签影响的最大值.json","problemData":{"id":"1169","name":"1090.受标签影响的最大值","url":"https://leetcode.cn/problems/largest-values-from-labels","desc":"返回子集 s 的最大 分数 。","solutions":[{"script":"cpp","time":44,"memory":22.2,"desc":"利用堆找出最大的值贪心塞入。","code":"class Solution {\npublic:\n    int largestValsFromLabels(vector<int>& values, vector<int>& labels, int numWanted, int useLimit) {\n        unordered_map<int, vector<int>> m;\n        unordered_map<int, int> mcnt;\n        int n = values.size();\n        for (int i = 0; i < n; i++) m[labels[i]].push_back(values[i]);\n        for (auto &item : m) sort(item.second.begin(), item.second.end());\n        auto cmp = [&](int x, int y) -> bool { return m[x].back() < m[y].back(); };\n        priority_queue<int, vector<int>, decltype(cmp)> q(cmp);\n        for (auto &item : m) q.push(item.first);\n        int res = 0;\n        for (int i = 0; i < numWanted && q.size(); i++) {\n            int idx = q.top();\n            q.pop();\n            res += m[idx].back();\n            m[idx].pop_back();\n            if (++mcnt[idx] < useLimit && m[idx].size()) q.push(idx);\n        }\n        return res;\n    }\n};","date":"2023-05-23"},{"script":"cpp","time":52,"memory":19.3,"desc":"排序后从后往前遍历。","code":"class Solution {\npublic:\n    int largestValsFromLabels(vector<int>& values, vector<int>& labels, int numWanted, int useLimit) {\n        int n = values.size();\n        vector<int> list;\n        for (int i = 0; i < n; i++) list.push_back(i);\n        sort(list.begin(), list.end(), [&](auto &i1, auto &i2) {\n            return values[i1] < values[i2];\n        });\n        unordered_map<int, int> m;\n        int res = 0;\n        for (int i = n - 1, cnt = 0; i >= 0 && cnt < numWanted; i--) {\n            if (m[labels[list[i]]] == useLimit) continue;\n            m[labels[list[i]]] += 1;\n            res += values[list[i]];\n            cnt += 1;\n        }\n        return res;\n    }\n};","date":"2023-05-23"},{"script":"python","time":60,"memory":19.8,"desc":"同上。","code":"class Solution:\n    def largestValsFromLabels(self, values: List[int], labels: List[int], numWanted: int, useLimit: int) -> int:\n        n = len(values)\n        list = [i for i in range(n)]\n        list.sort(key=lambda i: values[i])\n        m = Counter()\n        res = 0\n        cnt = 0\n        for i in range(n-1, -1, -1):\n            if cnt >= numWanted:\n                break\n            if m[labels[list[i]]] == useLimit:\n                continue\n            m[labels[list[i]]] += 1\n            res += values[list[i]]\n            cnt += 1\n        return res","date":"2023-05-23"},{"script":"rust","time":4,"memory":2.6,"desc":"同上。","code":"impl Solution {\npub fn largest_vals_from_labels(\n    values: Vec<i32>,\n    labels: Vec<i32>,\n    num_wanted: i32,\n    use_limit: i32,\n) -> i32 {\n    let n = values.len();\n    let mut list = vec![];\n    for i in 0..n {\n        list.push(i);\n    }\n    list.sort_by_key(|i| values[*i]);\n    let mut m = std::collections::HashMap::<i32, i32>::new();\n    let mut res = 0;\n    let mut cnt = 0;\n    for i in (0..n).rev() {\n        if cnt >= num_wanted {\n            break;\n        }\n        let item = m.entry(labels[list[i]]).or_insert(0);\n        if *item < use_limit {\n            *item += 1;\n            res += values[list[i]];\n            cnt += 1;\n        }\n    }\n    res\n}\n}","date":"2023-05-23"}],"tagList":["贪心","数组","哈希表","计数","排序"],"level":"Medium"}},{"problemName":"1091.二进制矩阵中的最短路径.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1091.二进制矩阵中的最短路径.json","problemData":{"id":"1171","name":"1091.二进制矩阵中的最短路径","url":"https://leetcode.cn/problems/shortest-path-in-binary-matrix","desc":"给你一个 n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。","solutions":[{"date":"2021-07-25","time":92,"memory":43.9,"script":"typescript","desc":"bfs。","code":"function movingCount(m: number, n: number, k: number): number {\n  const queue: [number, number, number][] = [[0, 0, 1]];\n  const format = (row: number, col: number) => `${row}::${col}`;\n  const set = new Set(queue.map(([row, col]) => format(row, col)));\n  let ans = 1;\n  const add = (row: number, col: number, count: number) => {\n    const str = format(row, col);\n    if (set.has(str)) return;\n    set.add(str);\n    const data: [number, number, number] = [row, col, count];\n    let num = 0;\n    while (row) {\n      num += row % 10;\n      row = ~~(row / 10);\n    }\n    while (col) {\n      num += col % 10;\n      col = ~~(col / 10);\n    }\n    if (num > k) return;\n    queue.push(data);\n    ans++;\n  };\n  while (queue.length) {\n    const [row, col, count] = queue.shift()!;\n    if (row) if (row > 0) add(row - 1, col, count + 1);\n    if (col > 0) add(row, col - 1, count + 1);\n    if (row < n - 1) add(row + 1, col, count + 1);\n    if (col < m - 1) add(row, col + 1, count + 1);\n  }\n  return ans;\n}"},{"script":"cpp","time":68,"memory":19.2,"desc":"bfs。","code":"#define X first\n#define Y second\n#define pii pair<int, int>\n\nvector<vector<int>> dirs2 = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};\n\nclass Solution {\n    public:\n    int shortestPathBinaryMatrix(vector<vector<int>> &grid) {\n        if (grid[0][0] == 1) return -1;\n        queue<pii> q;\n        q.push(make_pair(0, 0));\n        int n = grid.size(), size = 1, step = 1;\n        vector<vector<bool>> used(n, vector<bool>(n, false));\n        while (q.size()) {\n            auto cur = q.front();\n            q.pop();\n            if (cur.X == n - 1 && cur.Y == n - 1) return step;\n            for (auto &dir : dirs2) {\n                int nx = cur.X + dir[0], ny = cur.Y + dir[1];\n                if (nx >= 0 && nx < n && ny >= 0 && ny < n && grid[nx][ny] == 0 && !used[nx][ny]) {\n                    used[nx][ny] = true;\n                    q.push(make_pair(nx, ny));\n                }\n            }\n            if (--size == 0) {\n                size = q.size();\n                step += 1;\n            }\n        }\n        return -1;\n    }\n};","date":"2023-05-26"},{"script":"python","time":256,"memory":16.6,"desc":"同上。","code":"dirs2 = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n    class Solution:\n        def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:\n            if grid[0][0] == 1:\n                return -1\n            q = deque()\n            q.append((0, 0))\n            n = len(grid)\n            step = size = 1\n            used = [[False for _ in range(n)] for _ in range(n)]\n            while len(q):\n                (x, y) = q.popleft()\n                if x == n - 1 and y == n - 1:\n                    return step\n                for dir in dirs2:\n                    nx = x + dir[0]\n                    ny = y + dir[1]\n                    if nx >= 0 and nx < n and ny >= 0 and ny < n and grid[nx][ny] == 0 and not used[nx][ny]:\n                        used[nx][ny] = True\n                        q.append((nx, ny))\n                size -= 1\n                if size == 0:\n                    size = len(q)\n                    step += 1\n            return -1","date":"2023-05-26"},{"script":"rust","time":16,"memory":2.1,"desc":"同上。","code":"pub const dirs2: [[i32; 2]; 8] = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];\nimpl Solution {\n    pub fn shortest_path_binary_matrix(grid: Vec<Vec<i32>>) -> i32 {\n        if grid[0][0] == 1 {\n            -1\n        } else {\n            let mut q = std::collections::VecDeque::<(i32, i32)>::new();\n            q.push_back((0, 0));\n            let n = grid.len() as i32;\n            let mut size = 1;\n            let mut step = 1;\n            let mut used = vec![vec![false; n as usize]; n as usize];\n            while let Some((x, y)) = q.pop_front() {\n                if x == n - 1 && y == n - 1 {\n                    return step;\n                }\n                for dir in dirs2 {\n                    let nx = x + dir[0];\n                    let ny = y + dir[1];\n                    if nx >= 0\n                        && nx < n\n                        && ny >= 0\n                        && ny < n\n                        && grid[nx as usize][ny as usize] == 0\n                        && !used[nx as usize][ny as usize]\n                    {\n                        used[nx as usize][ny as usize] = true;\n                        q.push_back((nx, ny));\n                    }\n                }\n                size -= 1;\n                if size == 0 {\n                    size = q.len();\n                    step += 1;\n                }\n            }\n            -1\n        }\n    }\n}","date":"2023-05-26"}],"tagList":["广度优先搜索","数组","矩阵"],"level":"Medium"}},{"problemName":"1092.最短公共超序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1092.最短公共超序列.json","problemData":{"id":"1170","name":"1092.最短公共超序列","url":"https://leetcode.cn/problems/shortest-common-supersequence","desc":"给出两个字符串 str1 和 str2，返回同时以 str1 和 str2 作为子序列的最短字符串。如果答案不止一个，则可以返回满足条件的任意一个答案。","solutions":[{"script":"cpp","time":24,"memory":12.7,"desc":"dp[i][j]=str1前i个字符匹配str2前j个字符的最短长度，再从后往前遍历求出路径字符串。","code":"class Solution {\npublic:\n    string shortestCommonSupersequence(string str1, string str2) {\n        int n1 = str1.size(), n2 = str2.size();\n        vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1));\n        for (int i = 0; i < n1; i++) dp[i][0] = i;\n        for (int j = 0; j < n2; j++) dp[0][j] = j;\n        for (int i = 1; i <= n1; i++) {\n            for (int j = 1; j <= n2; j++) {\n                if (str1[i - 1] == str2[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1;\n                }\n            }\n        }\n        string res = \"\";\n        int i = n1, j = n2;\n        while (i > 0 && j > 0) {\n            if (str1[i - 1] == str2[j - 1]) {\n                res += str1[i - 1];\n                i -= 1;\n                j -= 1;\n            } else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n                    res += str1[i - 1];\n                    i -= 1;\n                } else {\n                    res += str2[j - 1];\n                    j -= 1;\n                }\n            }\n        }\n        reverse(res.begin(), res.end());\n        return str1.substr(0, i) + str2.substr(0, j) + res;\n    }\n};","date":"2023-03-28"},{"script":"python","time":320,"memory":59.1,"desc":"同上。","code":"class Solution:\n    def shortestCommonSupersequence(self, str1: str, str2: str) -> str:\n        n1, n2 = len(str1), len(str2)\n        dp = [[0] * (n2 + 1) for _ in range(n1 + 1)]\n        for i in range(n1):\n            dp[i][0] = i\n        for j in range(n2):\n            dp[0][j] = j\n        for i in range(1, n1+1):\n            for j in range(1, n2+1):\n                if str1[i - 1] == str2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1\n        res = \"\"\n        i, j = n1, n2\n        while i > 0 and j > 0:\n            if str1[i - 1] == str2[j - 1]:\n                res += str1[i - 1]\n                i -= 1\n                j -= 1\n            else:\n                if dp[i - 1][j] < dp[i][j - 1]:\n                    res += str1[i - 1]\n                    i -= 1\n                else:\n                    res += str2[j - 1]\n                    j -= 1\n        res = res[::-1]\n        return str1[0:i] + str2[0:j] + res","date":"2023-03-28"},{"script":"rust","time":4,"memory":9.5,"desc":"同上。","code":"impl Solution {\n    pub fn shortest_common_supersequence(str1: String, str2: String) -> String {\n        let (str1, str2) = (\n            str1.chars().collect::<Vec<char>>(),\n            str2.chars().collect::<Vec<char>>(),\n        );\n        let (n1, n2) = (str1.len(), str2.len());\n        let mut dp = vec![vec![0; n2 + 1]; n1 + 1];\n        for i in 0..n1 {\n            dp[i][0] = i;\n        }\n        for j in 0..n2 {\n            dp[0][j] = j;\n        }\n        for i in 1..=n1 {\n            for j in 1..=n2 {\n                if str1[i - 1] == str2[j - 1] {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = dp[i - 1][j].min(dp[i][j - 1]) + 1;\n                }\n            }\n        }\n        let mut s = vec![];\n        let (mut i, mut j) = (n1, n2);\n        while i > 0 && j > 0 {\n            if str1[i - 1] == str2[j - 1] {\n                s.push(*&str1[i - 1]);\n                i -= 1;\n                j -= 1;\n            } else {\n                if dp[i - 1][j] < dp[i][j - 1] {\n                    s.push(*&str1[i - 1]);\n                    i -= 1;\n                } else {\n                    s.push(*&str2[j - 1]);\n                    j -= 1;\n                }\n            }\n        }\n        s = s.into_iter().rev().collect();\n        String::from_utf8(\n            [&str1[0..i], &str2[0..j], &s[..]]\n                .concat()\n                .into_iter()\n                .map(|v| v as u8)\n                .collect::<Vec<u8>>(),\n        )\n        .unwrap()\n    }\n}","date":"2023-03-28"}],"tagList":["字符串","动态规划"],"level":"Hard"}},{"problemName":"1093.大样本统计.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1093.大样本统计.json","problemData":{"id":"1183","name":"1093.大样本统计","url":"https://leetcode.cn/problems/statistics-from-a-large-sample","desc":"以浮点数数组的形式返回样本的统计信息 [minimum, maximum, mean, median, mode] 。","solutions":[{"script":"cpp","time":4,"memory":8,"desc":"遍历。","code":"class Solution {\npublic:\n    typedef long long ll;\n    vector<double> sampleStats(vector<int>& count) {\n        ll n = count.size(), sum = 0, minimum = n - 1, maximum = 0, cnt = 0, mode = 0, mode_cnt = 0;\n        for (ll i = 0; i < n; i++) {\n            sum += count[i] * i;\n            cnt += count[i];\n            if (count[i]) {\n                minimum = min(minimum, i);\n                maximum = max(maximum, i);\n            }\n            if (count[i] > mode_cnt) {\n                mode = i;\n                mode_cnt = count[i];\n            }\n        }\n        double mean = 1.0 * sum / cnt, num1 = -1, num2 = -1;\n        ll imid1 = cnt / 2, imid2 = (cnt - 1) / 2;\n        for (ll i = 0; i < n && (num1 == -1 || num2 == -1); i++) {\n            ll c = count[i];\n            if (num1 == -1 && imid1 - c < 0) num1 = i;\n            if (num2 == -1 && imid2 - c < 0) num2 = i;\n            imid1 -= c;\n            imid2 -= c;\n        }\n        return vector<double>{ (double)minimum, (double)maximum, mean, (num1 + num2) / 2, (double)mode};\n    }\n};","date":"2023-05-27"},{"script":"python","time":44,"memory":16.1,"desc":"同上。","code":"class Solution:\n    def sampleStats(self, count: List[int]) -> List[float]:\n        n = len(count)\n        minimum = n - 1\n        maximum = sum = cnt = mode = mode_cnt = 0\n        for i in range(n):\n            sum += count[i] * i\n            cnt += count[i]\n            if count[i]:\n                minimum = min(minimum, i)\n                maximum = max(maximum, i)\n            if count[i] > mode_cnt:\n                mode = i\n                mode_cnt = count[i]\n        mean = sum / cnt\n        num1 = num2 = -1\n        imid1 = cnt // 2\n        imid2 = (cnt - 1) // 2\n        icur = 0\n        for i in range(n):\n            c = count[i]\n            if num1 == -1 and imid1 - c < 0:\n                num1 = i\n            if num2 == -1 and imid2 - c < 0:\n                num2 = i\n            imid1 -= c\n            imid2 -= c\n        return [minimum, maximum, mean, (num1+num2)/2, mode]\n","date":"2023-05-27"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn sample_stats(count: Vec<i32>) -> Vec<f64> {\n        use std::cmp::{max, min};\n        let (n, mut sum, mut minimum, mut maximum, mut cnt, mut mode, mut mode_cnt) =\n            (count.len(), 0usize, 0usize, 0usize, 0usize, 0usize, 0usize);\n        minimum = n - 1;\n        for i in 0..n {\n            let c = count[i] as usize;\n            sum += c * i;\n            cnt += c;\n            if c != 0 {\n                minimum = min(minimum, i);\n                maximum = max(maximum, i);\n            }\n            if c > mode_cnt {\n                mode = i;\n                mode_cnt = c;\n            }\n        }\n        let mean = (sum as f64) / (cnt as f64);\n        let (mut num1, mut num2) = (-1f64, -1f64);\n        let (mut imid1, mut imid2) = ((cnt as f64) / 2.0, ((cnt - 1) as f64) / 2.0);\n        for i in 0..n {\n            let c = count[i] as f64;\n            if num1 == -1.0 && imid1 - c < 0.0 {\n                num1 = i as f64;\n            }\n            if num2 == -1.0 && imid2 - c < 0.0 {\n                num2 = i as f64;\n            }\n            imid1 -= c;\n            imid2 -= c;\n        }\n        return vec![\n            minimum as f64,\n            maximum as f64,\n            mean,\n            (num1 + num2) / 2.0,\n            mode as f64,\n        ];\n    }\n}","date":"2023-05-27"}],"tagList":["数组","数学","概率与统计"],"level":"Medium"}},{"problemName":"1094.拼车.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1094.拼车.json","problemData":{"id":"1184","name":"1094.拼车","url":"https://leetcode.cn/problems/car-pooling","desc":"当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false。","solutions":[{"script":"python","time":40,"memory":16.64,"desc":"排序后优先队列计数。","code":"class Solution:\n    def carPooling(self, trips: List[List[int]], capacity: int) -> bool:\n        trips.sort(key = lambda o: (o[1], o[2]))\n        size = 0\n        q = []\n        for [num, f, t] in trips:\n            while q and q[0][0] <= f: size -= heappop(q)[1]\n            if size + num > capacity: return False\n            heappush(q, (t, num))\n            size += num\n        return True","date":"2023-12-02"},{"script":"rust","time":0,"memory":2.07,"desc":"同上。","code":"impl Solution {\n    pub fn car_pooling(mut trips: Vec<Vec<i32>>, capacity: i32) -> bool {\n        trips.sort_by_key(|o| o[1]);\n        let mut size = 0;\n        let mut q = std::collections::BinaryHeap::<(i32, i32)>::new();\n        for item in trips {\n            let (num, f, t) = (item[0], item[1], item[2]);\n            while q.len() > 0 && -(*q.peek().unwrap()).0 <= f {\n                size -= q.pop().unwrap().1;\n            }\n            if size + num > capacity {\n                return false;\n            }\n            q.push((-t, num));\n            size += num;\n        }\n        true\n    }\n}","date":"2023-12-02"}],"tagList":["数组","前缀和","排序","模拟","堆（优先队列）"],"level":"Medium"}},{"problemName":"1095.山脉数组中查找目标值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1095.山脉数组中查找目标值.json","problemData":{"id":"1185","name":"1095.山脉数组中查找目标值","url":"https://leetcode.cn/problems/find-in-mountain-array","desc":"给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。","solutions":[{"date":"2020-04-29","time":64,"memory":34.3,"script":"javascript","desc":"二分查找减少次数。","code":"/**\n * // This is the MountainArray's API interface.\n * // You should not implement it, or speculate about its implementation\n * function MountainArray() {\n *     @param {number} index\n *     @return {number}\n *     this.get = function(index) {\n *         ...\n *     };\n *\n *     @return {number}\n *     this.length = function() {\n *         ...\n *     };\n * };\n */\n\n/**\n * @param {number} target\n * @param {MountainArray} mountainArr\n * @return {number}\n */\nvar findInMountainArray = function (target, mountainArr) {\n  const data = new Map();\n  // 递归搜索，初始化为首位下标\n  return search(0, mountainArr.length() - 1);\n  function search(left, right) {\n    // 如果 长度为负则不存在\n    if (left > right) return -1;\n    // 如果下标相等则直接判断该值是否为目标\n    else if (left === right) return getNum(left) === target ? left : -1;\n    const leftNum = getNum(left),\n      rightNum = getNum(right);\n    if (target < leftNum && target < rightNum) return -1;\n    const mid = (right + left) >> 1;\n    const midNum = getNum(mid);\n    // 如果左右值直接为目标值则返回\n    if (target === leftNum) return left;\n    if (target === rightNum) return right;\n    // 如果中间值为目标值则再次判断左下标到中间值是否存在更小值\n    if (target === midNum) {\n      if (midNum > leftNum) {\n        let index = search(left, mid - 1);\n        return index === -1 ? mid : index;\n      }\n      return mid;\n    }\n    if (target < leftNum) {\n      // 如果目标值小于左值则判断可能出现的一边坡度\n      if (target < midNum) return search(mid + 1, right);\n      else return search(left, mid - 1);\n    } else if (target < rightNum) {\n      // 如果目标值小于右值则判断可能出现的一边坡度\n      if (target < midNum) return search(left, mid - 1);\n      else return search(mid + 1, right);\n    } else {\n      // 如果目标值大于中值则判断左右值的大小进行划分区域\n      if (target > midNum) {\n        if (leftNum < rightNum) return search(mid + 1, right);\n        else if (leftNum > rightNum) return search(left, mid - 1);\n      }\n      // 否则分段判断\n      let index = search(left, mid - 1);\n      if (index === -1) index = search(mid + 1, right);\n      return index;\n    }\n  }\n  // 获取值，储存在本地data中减少获取次数\n  function getNum(index) {\n    let res = data.get(index);\n    if (res === undefined) {\n      res = mountainArr.get(index);\n      data.set(index, res);\n    }\n    return res;\n  }\n};"}],"tagList":["数组","二分查找","交互"],"level":"Hard"}},{"problemName":"1096.花括号展开II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1001-1100/1096.花括号展开II.json","problemData":{"id":"1188","name":"1096.花括号展开II","url":"https://leetcode.cn/problems/brace-expansion-ii","desc":"给出表示基于给定语法规则的表达式 expression，返回它所表示的所有字符串组成的有序列表。","solutions":[{"script":"cpp","time":12,"memory":10.9,"desc":"递归遍历。","code":"class Solution {\npublic:\n    vector<string> braceExpansionII(string expression) {\n        if (checkSingal(expression)) expression = expression.substr(1, expression.size() - 2);\n        set<string> s;\n        vector<string> items = split(expression);\n        if (items.size() > 1) {\n            for (auto &item : items) {\n                for (auto &res : braceExpansionII(item)) {\n                    s.insert(res);\n                }\n            }\n        } else {\n            string item = items[0];\n            vector<vector<string>> res = analysis(item);\n            dfs(s, res, 0, \"\");\n        }\n        return vector<string>(s.begin(), s.end());\n    }\n    bool checkSingal(string &expression) {\n        if (expression[0] != '{' || expression[expression.size() - 1] != '}') return false;\n        int level = 0, i = 0;\n        for (; i < expression.size(); i++) {\n            if (expression[i] == '{') level++;\n            else if (expression[i] == '}') level--;\n            if (i != expression.size() - 1 && level == 0) return false;\n        }\n        return true;\n    }\n    vector<string> split(string &expression) {\n        vector<string> items;\n        int level = 0, prev = 0, i = 0;\n        for (; i < expression.size(); i++) {\n            if (expression[i] == '{') level++;\n            else if (expression[i] == '}') level--;\n            else if (expression[i] == ',' && level == 0) {\n                items.push_back(expression.substr(prev, i - prev));\n                prev = i + 1;\n            }\n        }\n        items.push_back(expression.substr(prev, i - prev));\n        return items;\n    }\n    vector<vector<string>> analysis(string &item) {\n        vector<vector<string>> res;\n        for (int i = 0; i < item.size(); i++) {\n            if (item[i] != '{') {\n                string s = \"\";\n                s += item[i];\n                vector<string> v;\n                v.push_back(s);\n                res.push_back(v);\n            } else {\n                int prev = i, level = 0;\n                do {\n                    if (item[i] == '{') level++;\n                    else if (item[i] == '}') level--;\n                    if (level != 0) i++;\n                } while (level != 0);\n                res.push_back(braceExpansionII(item.substr(prev, i - prev + 1)));\n            }\n        }\n        return res;\n    }\n    void dfs(set<string> &s, vector<vector<string>> &res, int start, string cur) {\n        if (start == res.size()) {\n            s.insert(cur);\n        } else {\n            for (int i = 0; i < res[start].size(); i++) {\n                dfs(s, res, start + 1, cur + res[start][i]);\n            }\n        }\n    }\n};","date":"2023-03-07"},{"script":"python","time":60,"memory":15.7,"desc":"同上。","code":"from sortedcontainers import SortedSet\nclass Solution:\n\n    def checkSingal(self, expression: str):\n        if expression[0] != '{' or expression[-1] != '}':\n            return False\n        level, i = 0, 0\n        while i < len(expression):\n            if expression[i] == '{':\n                level += 1\n            elif expression[i] == '}':\n                level -= 1\n            if i != len(expression) - 1 and level == 0:\n                return False\n            i += 1\n        return True\n\n    def split(self, expression: str):\n        items = []\n        level = prev = i = 0\n        while i < len(expression):\n            if expression[i] == '{':\n                level += 1\n            elif expression[i] == '}':\n                level -= 1\n            elif expression[i] == ',' and level == 0:\n                items.append(expression[prev:i])\n                prev = i + 1\n            i += 1\n        items.append(expression[prev:])\n        return items\n\n    def analysis(self, item: str):\n        res = []\n        i = 0\n        while i < len(item):\n            if item[i] != '{':\n                res.append([str(item[i])])\n            else:\n                prev, level = i, 0\n                while True:\n                    if item[i] == '{':\n                        level += 1\n                    elif item[i] == '}':\n                        level -= 1\n                    if level == 0:\n                        break\n                    else:\n                        i += 1\n                res.append(self.braceExpansionII(item[prev:i+1]))\n            i += 1\n        return res\n\n    def dfs(self, s: SortedSet, res: List[List[str]], start: int, cur: str):\n        if start == len(res):\n            s.add(cur)\n        else:\n            for i in range(len(res[start])):\n                self.dfs(s, res, start+1, cur+res[start][i])\n\n    def braceExpansionII(self, expression: str) -> List[str]:\n        s = SortedSet()\n        if self.checkSingal(expression):\n            expression = expression[1:-1]\n        items = self.split(expression)\n        if len(items) > 1:\n            for item in items:\n                for res in self.braceExpansionII(item):\n                    s.add(res)\n        else:\n            item = items[0]\n            res = self.analysis(item)\n            self.dfs(s, res, 0, '')\n        return list(s)","date":"2023-03-07"},{"script":"rust","time":4,"memory":2.3,"desc":"同上。","code":"use std::collections::BTreeSet;\nimpl Solution {\n    fn check_signal(expression: &Vec<char>) -> bool {\n        if *expression.first().unwrap() != '{' || *expression.last().unwrap() != '}' {\n            false\n        } else {\n            let mut level = 0;\n            for i in 0..expression.len() {\n                if expression[i] == '{' {\n                    level += 1\n                } else if expression[i] == '}' {\n                    level -= 1\n                }\n                if i != expression.len() - 1 && level == 0 {\n                    return false;\n                }\n            }\n            true\n        }\n    }\n    fn split(expression: &Vec<char>) -> Vec<Vec<char>> {\n        let mut items: Vec<Vec<char>> = vec![];\n        let mut level = 0;\n        let mut prev = 0;\n        let mut i = 0;\n        while i < expression.len() {\n            if expression[i] == '{' {\n                level += 1;\n            } else if expression[i] == '}' {\n                level -= 1;\n            } else if expression[i] == ',' && level == 0 {\n                items.push(\n                    expression[prev..i]\n                        .iter()\n                        .map(|v| *v)\n                        .collect::<Vec<char>>(),\n                );\n                prev = i + 1;\n            }\n            i += 1;\n        }\n        items.push(expression[prev..].iter().map(|v| *v).collect::<Vec<char>>());\n        items\n    }\n    fn analysis(item: &Vec<char>) -> Vec<Vec<Vec<char>>> {\n        let mut res = vec![];\n        let mut i = 0;\n        while i < item.len() {\n            if item[i] != '{' {\n                res.push(vec![vec![item[i]]])\n            } else {\n                let prev = i;\n                let mut level = 0;\n                loop {\n                    if item[i] == '{' {\n                        level += 1;\n                    } else if item[i] == '}' {\n                        level -= 1;\n                    }\n                    if level == 0 {\n                        break;\n                    } else {\n                        i += 1;\n                    }\n                }\n                res.push(Solution::_brace_expansion_ii(\n                    item[prev..i + 1].iter().map(|v| *v).collect::<Vec<char>>(),\n                ))\n            }\n            i += 1;\n        }\n        res\n    }\n    fn dfs(s: &mut BTreeSet<Vec<char>>, res: &Vec<Vec<Vec<char>>>, start: usize, cur: Vec<char>) {\n        if start == res.len() {\n            s.insert(cur);\n        } else {\n            for item in res[start].iter() {\n                let mut next = cur.clone();\n                let mut other = item.clone();\n                next.append(&mut other);\n                Solution::dfs(s, res, start + 1, next);\n            }\n        }\n    }\n    pub fn brace_expansion_ii(expression: String) -> Vec<String> {\n        let expression = expression.chars().collect::<Vec<char>>();\n        Solution::_brace_expansion_ii(expression)\n            .into_iter()\n            .map(|v| {\n                String::from_utf8(v.into_iter().map(|v| v as u8).collect::<Vec<u8>>()).unwrap()\n            })\n            .collect()\n    }\n    fn _brace_expansion_ii(expression: Vec<char>) -> Vec<Vec<char>> {\n        let mut expression = expression;\n        if Solution::check_signal(&expression) {\n            expression.remove(expression.len() - 1);\n            expression.remove(0);\n        }\n        let mut s = BTreeSet::<Vec<char>>::new();\n        let items = Solution::split(&expression);\n        if items.len() > 1 {\n            for item in items {\n                for res in Solution::_brace_expansion_ii(item) {\n                    s.insert(res);\n                }\n            }\n        } else {\n            let res = Solution::analysis(&items[0]);\n            Solution::dfs(&mut s, &res, 0, vec![]);\n        }\n        s.into_iter().collect::<Vec<Vec<char>>>()\n    }\n}","date":"2023-03-07"}],"tagList":["栈","广度优先搜索","字符串","回溯"],"level":"Hard"}}]},{"dirName":"101-200","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\101-200","problems":[{"problemName":"101.对称二叉树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/101.对称二叉树.json","problemData":{"id":"101","name":"101.对称二叉树","url":"https://leetcode.cn/problems/symmetric-tree","desc":"给定一个二叉树，检查它是否是镜像对称的。","solutions":[{"date":"2020-02-22","time":1,"memory":37.7,"script":"java","desc":"遍历。","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n\tpublic boolean isSymmetric(TreeNode root) {\n\t\tif (root == null)\n\t\t\treturn true;\n\t\tDeque<TreeNode> deque = new LinkedList<TreeNode>();\n\t\tdeque.offer(root.left);\n\t\tdeque.offer(root.right);\n\t\twhile (!deque.isEmpty()) {\n\t\t\tTreeNode left = deque.pollFirst();\n\t\t\tTreeNode right = deque.pollLast();\n\t\t\tif (left == null && right == null)\n\t\t\t\tcontinue;\n\t\t\tif (left == null || right == null)\n\t\t\t\treturn false;\n\t\t\tif(left.val!=right.val)return false;\n\t\t\tdeque.offerFirst(left.right);\n\t\t\tdeque.offerFirst(left.left);\n\t\t\tdeque.offerLast(right.left);\n\t\t\tdeque.offerLast(right.right);\n\t\t}\n\t\treturn true;\n\t}\n}"},{"date":"2020-02-22","time":1,"memory":37.9,"script":"java","desc":"递归。","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n\tpublic boolean isSymmetric(TreeNode root) {\n\t\tif (root == null)\n\t\t\treturn true;\n\t\tif (!inIsSymmetric(root.left, root.right))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean inIsSymmetric(TreeNode node1, TreeNode node2) {\n\t\tif (node1 == null && node2 == null)\n\t\t\treturn true;\n\t\tif (node1 == null || node2 == null)\n\t\t\treturn false;\n\t\tif (node1.val != node2.val)\n\t\t\treturn false;\n\t\treturn inIsSymmetric(node1.left, node2.right) && inIsSymmetric(node1.right, node2.left);\n\t}\n}"},{"date":"2020-02-22","time":88,"memory":37,"script":"typescript","desc":"递归。","code":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nvar isSymmetric = function (root: TreeNode | null): boolean {\n  if (root === null) return true;\n  return isSymNode(root.left, root.right);\n  function isSymNode(node1: TreeNode | null, node2: TreeNode | null): boolean {\n    if (node1 === null && node2 === null) return true;\n    if (node1 === null || node2 === null || node1.val !== node2.val) return false;\n    return isSymNode(node1.left, node2.right) && isSymNode(node1.right, node2.left);\n  }\n};"},{"date":"2021-11-27","time":4,"memory":6.5,"script":"c","desc":"递归。","code":"// 校验两个树是否镜像\nbool _isSymmetric(struct TreeNode *node1, struct TreeNode *node2){\n    // 都为NULL就是\n    if (!node1 && !node2) return 1;\n    // 其中一个为NULL或者值不等就不是\n    if (!node1 || !node2 || node1->val != node2->val) return 0;\n    // 否则递归判断：node1的左和node2的右是否镜像、node1的右和node2的左是否镜像\n    return _isSymmetric(node1->left, node2->right) && _isSymmetric(node1->right, node2->left);\n}\nbool isSymmetric(struct TreeNode* root){\n    return _isSymmetric(root->left, root->right);\n}"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉树"],"level":"Easy"}},{"problemName":"102.二叉树的层序遍历.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/102.二叉树的层序遍历.json","problemData":{"id":"102","name":"102.二叉树的层序遍历","url":"https://leetcode.cn/problems/binary-tree-level-order-traversal","desc":"给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。","solutions":[{"date":"2020-02-21","time":2,"memory":39.6,"script":"java","desc":"迭代。","code":"class Solution {\n   \tpublic List<List<Integer>> levelOrder(TreeNode root) {\n\t\tList<List<Integer>> list = new LinkedList<List<Integer>>();\n\t\tif (root == null)\n\t\t\treturn list;\n\t\tList<Integer> tmplist = new LinkedList<Integer>();\n\t\tint size=1;\n\t\tQueue<TreeNode> queue = new LinkedList<>();\n\t\tqueue.offer(root);\n\t\twhile (!queue.isEmpty()) {\n\t\t\tTreeNode node = queue.poll();\n\t\t\ttmplist.add(node.val);\n\t\t\tif(node.left!=null)queue.offer(node.left);\n\t\t\tif(node.right!=null)queue.offer(node.right);\n\t\t\tsize--;\n\t\t\tif(size==0) {\n\t\t\t\tsize=queue.size();\n\t\t\t\tlist.add(tmplist);\n\t\t\t\ttmplist=new LinkedList<Integer>();\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n}"},{"date":"2020-02-21","time":1,"memory":39.3,"script":"java","desc":"递归。","code":"class Solution {\n   \tLinkedList<List<Integer>> list = new LinkedList<List<Integer>>();\n\tpublic List<List<Integer>> levelOrder(TreeNode root) {\n\t\tif (root == null)\n\t\t\treturn list;\n\t\tinLevelOrder(root,0);\n\t\treturn list;\n\t}\n\tpublic void inLevelOrder(TreeNode node,int level){\n\t\tif(list.size()==level) {\n\t\t\tlist.add(new ArrayList<Integer>());\n\t\t}\n\t\tlist.get(level).add(node.val);\n\t\tif(node.left!=null)\n\t\tinLevelOrder(node.left, 1+level);\n\t\tif(node.right!=null)\n\t\tinLevelOrder(node.right, 1+level);\n\t}\n}"},{"date":"2020-02-21","time":72,"memory":34.8,"script":"javascript","desc":"迭代。","code":"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar levelOrder = function (root) {\n  if (root === null) return [];\n  const queue = [root];\n  const res = [[root.val]];\n  let size = 1;\n  while (queue.length !== 0) {\n    const node = queue.shift();\n    if (node.left !== null) queue.push(node.left);\n    if (node.right !== null) queue.push(node.right);\n    if (--size === 0) {\n      if (queue.length !== 0) res.push(queue.map(node => node.val));\n      size = queue.length;\n    }\n  }\n  return res;\n};"},{"date":"2021-11-27","time":8,"memory":7.3,"script":"c","desc":"递归。","code":"#define MAX 2000\nint** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){\n    int **arr = (int **)malloc(sizeof(int) * MAX);\n    *returnSize = 0;\n    *returnColumnSizes = (int *)malloc(sizeof(int) * MAX);\n    if (!root) return arr;\n    // 维护队列储存节点信息\n    struct TreeNode *q[2000];\n    q[0] = root;\n    // 维护队列头尾指针\n    int head = 0, tail = 1;\n    // 维护当前层的元素数量，当前遍历的层级\n    int size = 1, height = 1;\n    arr[0] = (int *)malloc(sizeof(int));\n    arr[0][0] = root->val;\n    (*returnColumnSizes)[0] = 1;\n    while (head != tail) {\n        // 每次出队一个节点\n        struct TreeNode *node = q[head++];\n        // 若左节点不为空则入队\n        if (node->left) q[tail++] = node->left;\n        // 若右节点不为空则入队\n        if (node->right) q[tail++] = node->right;\n        // 若当前层无元素，说明队列里都是下一层的元素\n        if (--size == 0) {\n            size = tail - head;\n            *returnSize += 1;\n            (*returnColumnSizes)[height] = size;\n            arr[height] = (int *)malloc(sizeof(int) * size);\n            for(int i = head; i < tail; i++) arr[height][i - head] = q[i]->val;\n            height++;\n        }\n    }\n    return arr;\n}"},{"script":"python","time":44,"memory":17.13,"desc":"bfs。","code":"class Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if not root: return []\n        q = deque() \n        q.append(root)\n        size = 1\n        ans = [[root.val]]\n        while q:\n            node = q.popleft()\n            if node.left: q.append(node.left)\n            if node.right: q.append(node.right)\n            size -= 1\n            if size == 0:\n                size = len(q)\n                if q: ans.append([node.val for node in q])\n        return ans","date":"2024-02-14"}],"tagList":["树","广度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"103.二叉树的锯齿形层序遍历.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/103.二叉树的锯齿形层序遍历.json","problemData":{"id":"103","name":"103.二叉树的锯齿形层序遍历","url":"https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal","desc":"给定一个二叉树，返回其节点值的锯齿形层次遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。","solutions":[{"date":"2020-04-26","time":76,"memory":34.1,"script":"javascript","desc":"判断高度为偶数时倒序","code":"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[][]}\n */\nvar zigzagLevelOrder = function (root) {\n  if (root === null) return [];\n  const res = [];\n  const queue = [root];\n  let height = 1;\n  const pushNode = () => {\n    let valArr = [];\n    for (const node of queue) valArr.push(node.val);\n    if (height % 2 === 0) res.push(valArr.reverse());\n    else res.push(valArr);\n  };\n  pushNode();\n  let size = 1;\n  while (queue.length !== 0) {\n    const node = queue.shift();\n    if (node.left !== null) queue.push(node.left);\n    if (node.right !== null) queue.push(node.right);\n    if (--size === 0) {\n      height++;\n      size = queue.length;\n      if (queue.length !== 0) pushNode();\n    }\n  }\n  return res;\n};"},{"date":"2021-11-28","time":0,"memory":7.1,"script":"c","desc":"修改层序遍历，偶数层倒序。","code":"#define MAX 2000\nint** zigzagLevelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){\n    int **arr = (int **)malloc(sizeof(int) * MAX);\n    *returnSize = 0;\n    *returnColumnSizes = (int *)malloc(sizeof(int) * MAX);\n    if (!root) return arr;\n    // 维护队列储存节点信息\n    struct TreeNode *q[2000];\n    q[0] = root;\n    // 维护队列头尾指针\n    int head = 0, tail = 1;\n    // 维护当前层的元素数量，当前遍历的层级\n    int size = 1, height = 1, order = -1;\n    arr[0] = (int *)malloc(sizeof(int));\n    arr[0][0] = root->val;\n    (*returnColumnSizes)[0] = 1;\n    while (head != tail) {\n        // 每次出队一个节点\n        struct TreeNode *node = q[head++];\n        // 若左节点不为空则入队\n        if (node->left) q[tail++] = node->left;\n        // 若右节点不为空则入队\n        if (node->right) q[tail++] = node->right;\n        // 若当前层无元素，说明队列里都是下一层的元素\n        if (--size == 0) {\n            size = tail - head;\n            *returnSize += 1;\n            (*returnColumnSizes)[height] = size;\n            arr[height] = (int *)malloc(sizeof(int) * size);\n            if (order == 1) for(int i = head; i < tail; i++) arr[height][i - head] = q[i]->val;\n            else for(int i = tail - 1; i >= head; i--) arr[height][tail - 1 - i] = q[i]->val;\n            order *= -1;\n            ++height;\n        }\n    }\n    return arr;\n}"},{"script":"python","time":40,"memory":16.66,"desc":"bfs。","code":"class Solution:\n    def zigzagLevelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if not root: return []\n        q = deque() \n        q.append(root)\n        size = 1\n        ans = [[root.val]]\n        while q:\n            node = q.popleft()\n            if node.left: q.append(node.left)\n            if node.right: q.append(node.right)\n            size -= 1\n            if size == 0:\n                size = len(q)\n                if q: ans.append([node.val for node in q])\n        for i in range(1, len(ans), 2):\n            ans[i] = ans[i][::-1]\n        return ans","date":"2024-02-16"}],"tagList":["树","广度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"104.二叉树的最大深度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/104.二叉树的最大深度.json","problemData":{"id":"104","name":"104.二叉树的最大深度","url":"https://leetcode.cn/problems/maximum-depth-of-binary-tree","desc":"给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。","solutions":[{"date":"2020-02-21","time":0,"memory":38.8,"script":"java","desc":"递归。","code":"class Solution {\n\tpublic int maxDepth(TreeNode root) {\n\t\treturn height(root);\n\t}\n\tpublic int height(TreeNode node) {\n\t\tif (node == null)\n\t\t\treturn 0;\n\t\treturn 1 + Math.max(height(node.left), height(node.right));\n\t}\n}"},{"date":"2020-02-21","time":0,"memory":39.4,"script":"java","desc":"迭代。","code":"class Solution {\n\tpublic int maxDepth(TreeNode root) {\n\t\tif (root == null)\n\t\t\treturn 0;\n\t\tQueue<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tint height = 0;\n\t\tint size = 1;\n\t\tqueue.offer(root);\n\t\twhile (!queue.isEmpty()) {\n\t\t\tTreeNode node = queue.poll();\n\t\t\tif (node.left != null)\n\t\t\t\tqueue.offer(node.left);\n\t\t\tif (node.right != null)\n\t\t\t\tqueue.offer(node.right);\n\t\t\tif (--size == 0) {\n\t\t\t\tsize = queue.size();\n\t\t\t\theight++;\n\t\t\t}\n\t\t}\n\t\treturn height;\n\t}\n}"},{"date":"2020-07-28","time":88,"memory":40.6,"script":"typescript","desc":"递归判断。","code":"function maxDepth(root: TreeNode | null): number {\n  const _h = (node: TreeNode | null): number =>\n    node === null ? 0 : Math.max(_h(node.left), _h(node.right)) + 1;\n  return _h(root);\n}"},{"date":"2021-11-28","time":4,"memory":7.7,"script":"c","desc":"递归遍历每层左右子树加一。","code":"int maxDepth(struct TreeNode* root){\n    // 如果为NULL就是0\n    if (!root) return 0;\n    // 否则判断左右子树的最大深度 + 1\n    return fmax(maxDepth (root->left), maxDepth(root->right)) + 1;\n}"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉树"],"level":"Easy"}},{"problemName":"105.从前序与中序遍历序列构造二叉树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/105.从前序与中序遍历序列构造二叉树.json","problemData":{"id":"105","name":"105.从前序与中序遍历序列构造二叉树","url":"https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal","desc":"根据一棵树的前序遍历与中序遍历构造二叉树。","solutions":[{"date":"2020-02-21","time":26,"memory":76.4,"script":"java","desc":"使用递归，通过切割数组进行遍历左右节点。","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n\tpublic TreeNode buildTree(int[] preorder, int[] inorder) {\n        if(preorder.length==0)return null;\n\t\tint center = preorder[0];\n\t\tTreeNode node = new TreeNode(center);\n\t\tint index=indexOf(inorder, center);\n\t\tint left = index-0,right=inorder.length-1-index;\n\t\tif(left!=0) {\n\t\t\tnode.left=buildTree(split(preorder,1,left), subString(inorder, 0,index));\n\t\t}\n\t\tif(right!=0) {\n\t\t\tnode.right=buildTree(subString(preorder,1+left), subString(inorder, index+1));\n\t\t}\n\t\treturn node;\n\n\t}\n\tpublic int[] split(int[] arr,int start,int length) {\n\t\tint[] newArr = new int[length];\n\t\tfor(int i=0;i<length;i++) {\n\t\t\tnewArr[i]=arr[start];\n\t\t\tstart++;\n\t\t}\n\t\treturn newArr;\n\t}\n\tpublic int indexOf(int[] arr, int num) {\n\t\tfor (int i = 0, len = arr.length; i < len; i++) {\n\t\t\tif (arr[i] == num)\n\t\t\t\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic int[] subString(int[] arr, int start) {\n\t\treturn subString(arr, start, arr.length);\n\t}\n\n\tpublic int[] subString(int[] arr, int start, int end) {\n\t\tint length = end - start;\n\t\tint[] newArr = new int[length];\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tnewArr[i] = arr[start];\n\t\t\tstart++;\n\t\t}\n\t\treturn newArr;\n\t}\n\n}"},{"script":"python","time":137,"memory":86.3,"desc":"dfs。","code":"class Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        if not preorder: return None\n        index = inorder.index(preorder[0])\n        return TreeNode(\n            preorder[0], \n            self.buildTree(preorder[1:index + 1], inorder[:index]),\n            self.buildTree(preorder[index + 1:], inorder[index + 1:])\n        )","date":"2024-02-20"}],"tagList":["树","数组","哈希表","分治","二叉树"],"level":"Medium"}},{"problemName":"106.从中序与后序遍历序列构造二叉树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/106.从中序与后序遍历序列构造二叉树.json","problemData":{"id":"106","name":"106.从中序与后序遍历序列构造二叉树","url":"https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal","desc":"根据一棵树的中序遍历与后序遍历构造二叉树。","solutions":[{"date":"2020-02-21","time":18,"memory":75.9,"script":"java","desc":"层序遍历，利用链表每次在头结点添加。","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n\t\tif (inorder.length == 0)\n\t\t\treturn null;\n\t\tint center = postorder[postorder.length - 1];\n\t\tTreeNode node = new TreeNode(center);\n\t\tint index = indexOf(inorder, center);\n\t\tint left = index - 0, right = inorder.length - 1 - index;\n\t\tif (left != 0) {\n\t\t\tnode.left = buildTree(subString(inorder, 0, index), split(postorder, 0, left));\n\t\t}\n\t\tif (right != 0) {\n\t\t\tnode.right = buildTree(subString(inorder, index + 1), split(postorder, 0 + left, right));\n\t\t}\n\t\treturn node;\n\n\t}\n\n\tpublic int[] split(int[] arr, int start, int length) {\n\t\tint[] newArr = new int[length];\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tnewArr[i] = arr[start];\n\t\t\tstart++;\n\t\t}\n\t\treturn newArr;\n\t}\n\n\tpublic int indexOf(int[] arr, int num) {\n\t\tfor (int i = 0, len = arr.length; i < len; i++) {\n\t\t\tif (arr[i] == num)\n\t\t\t\treturn i;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic int[] subString(int[] arr, int start) {\n\t\treturn subString(arr, start, arr.length);\n\t}\n\n\tpublic int[] subString(int[] arr, int start, int end) {\n\t\tint length = end - start;\n\t\tint[] newArr = new int[length];\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tnewArr[i] = arr[start];\n\t\t\tstart++;\n\t\t}\n\t\treturn newArr;\n\t}\n}"},{"date":"2020-09-25","time":196,"memory":111.2,"script":"typescript","desc":"递归。","code":"function buildTree(inorder: number[], postorder: number[]): TreeNode | null {\n  if (inorder.length === 0 && postorder.length === 0) return null;\n  const val = postorder[postorder.length - 1];\n  const inorderIndex = inorder.indexOf(val);\n  const lInorder = inorder.slice(0, inorderIndex);\n  const rInorder = inorder.slice(inorderIndex + 1);\n  const lPostorder = postorder.slice(0, lInorder.length);\n  const rPostorder = postorder.slice(lInorder.length, postorder.length - 1);\n  return new TreeNode(val, buildTree(lInorder, lPostorder), buildTree(rInorder, rPostorder));\n}"},{"script":"python","time":136,"memory":86.83,"desc":"dfs。","code":"class Solution:\n    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        if not postorder: return None\n        index = inorder.index(postorder[-1])\n        return TreeNode(\n            postorder[-1],\n            self.buildTree(inorder[:index], postorder[:index]),\n            self.buildTree(inorder[index + 1:], postorder[index:-1])\n        )","date":"2024-02-21"}],"tagList":["树","数组","哈希表","分治","二叉树"],"level":"Medium"}},{"problemName":"107.二叉树的层序遍历II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/107.二叉树的层序遍历II.json","problemData":{"id":"107","name":"107.二叉树的层序遍历II","url":"https://leetcode.cn/problems/binary-tree-level-order-traversal-ii","desc":"给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）。","solutions":[{"date":"2020-02-21","time":2,"memory":39.1,"script":"java","desc":"层序遍历，利用链表每次在头结点添加。","code":"class Solution {\n\tLinkedList<List<Integer>> list = new LinkedList<List<Integer>>();\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        if(root==null)return list;\n        levelOrder(root, 0);\n        return list;\n    }\n    public void levelOrder(TreeNode node,int level) {\n    \tif(list.size()==level)list.addFirst(new ArrayList<Integer>());\n    \tlist.get(list.size()-level-1).add(node.val);\n    \tif(node.left!=null)levelOrder(node.left,1+ level);\n    \tif(node.right!=null)levelOrder(node.right,1+ level);\n    }\n}"},{"date":"2020-09-06","time":76,"memory":39.8,"script":"typescript","desc":"层序遍历。","code":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nfunction levelOrderBottom(root: TreeNode | null): number[][] {\n  if (root === null) return [];\n  const ans: number[][] = [[root.val]];\n  let size = 1;\n  const queue = [root];\n  while (queue.length !== 0) {\n    const node = queue.shift()!;\n    if (node.left) queue.push(node.left);\n    if (node.right) queue.push(node.right);\n    if (--size === 0) {\n      size = queue.length;\n      ans.push(queue.map(node => node.val));\n    }\n  }\n  ans.pop();\n  return ans.reverse();\n}"},{"script":"python","time":44,"memory":16.62,"desc":"bfs。","code":"class Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        if not root: return []\n        q = deque() \n        q.append(root)\n        size = 1\n        ans = [[root.val]]\n        while q:\n            node = q.popleft()\n            if node.left: q.append(node.left)\n            if node.right: q.append(node.right)\n            size -= 1\n            if size == 0:\n                size = len(q)\n                if q: ans.append([node.val for node in q])\n        return ans[::-1]","date":"2024-02-15"}],"tagList":["树","广度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"108.将有序数组转换为二叉搜索树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/108.将有序数组转换为二叉搜索树.json","problemData":{"id":"108","name":"108.将有序数组转换为二叉搜索树","url":"https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree","desc":"将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。","solutions":[{"date":"2020-02-24","time":1,"memory":41.3,"script":"java","desc":"递归，每次取中间点为二叉树节点，前后为左子树和右子树。","code":"class Solution {\n\tpublic TreeNode sortedArrayToBST(int[] nums) {\n\t\tint len = nums.length;\n\t\tif (len == 0)\n\t\t\treturn null;\n\t\telse if (len == 1)\n\t\t\treturn new TreeNode(nums[0]);\n\t\tint mid = len / 2;\n\t\tTreeNode node = new TreeNode(nums[mid]);\n\t\tnode.left = sortedArrayToBST(Arrays.copyOfRange(nums, 0, mid));\n\t\tnode.right = sortedArrayToBST(Arrays.copyOfRange(nums,mid+1,len));\n\t\treturn node;\n\t}\n}"},{"date":"2020-07-03","time":116,"memory":39.6,"script":"typescript","desc":"每次取中点进行左右分离生成节点。","code":"function sortedArrayToBST(nums: number[]): TreeNode | null {\n  function getNode(l: number, r: number): TreeNode | null {\n    if (l > r) return null;\n    else if (l === r) return new TreeNode(nums[l]);\n    else {\n      const mid = (r + l) >> 1;\n      const node = new TreeNode(nums[mid]);\n      node.left = getNode(l, mid - 1);\n      node.right = getNode(mid + 1, r);\n      return node;\n    }\n  }\n  return getNode(0, nums.length - 1);\n}"},{"date":"2021-08-07","time":96,"memory":41.5,"script":"typescript","desc":"依次取中值插入。","code":"function sortedArrayToBST(nums: number[]): TreeNode | null {\n  return build(nums);\n  function build(list: number[]): TreeNode | null {\n    if (list.length === 0) return null;\n    const mid = (0 + list.length - 1) >> 1;\n    const node = new TreeNode(list[mid]);\n    node.left = build(list.slice(0, mid));\n    node.right = build(list.slice(mid + 1));\n    return node;\n  }\n}"}],"tagList":["树","二叉搜索树","数组","分治","二叉树"],"level":"Easy"}},{"problemName":"109.有序链表转换二叉搜索树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/109.有序链表转换二叉搜索树.json","problemData":{"id":"109","name":"109.有序链表转换二叉搜索树","url":"https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree","desc":"给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。","solutions":[{"date":"2020-08-18","time":96,"memory":46.7,"script":"typescript","desc":"通过有序数组进行深度遍历。","code":"function sortedListToBST(head: ListNode | null): TreeNode | null {\n  if (head === null) return null;\n  const arr: number[] = [];\n  while (head !== null) {\n    arr.push(head.val);\n    head = head.next;\n  }\n  return toBST(arr);\n  function toBST(array: number[]): TreeNode | null {\n    const len = array.length;\n    if (len === 0) return null;\n    const mid = len >> 1;\n    const node = new TreeNode(\n      array[mid],\n      toBST(array.slice(0, mid)),\n      toBST(array.slice(mid + 1, len))\n    );\n    return node;\n  }\n}"}],"tagList":["树","二叉搜索树","链表","分治","二叉树"],"level":"Medium"}},{"problemName":"110.平衡二叉树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/110.平衡二叉树.json","problemData":{"id":"110","name":"110.平衡二叉树","url":"https://leetcode.cn/problems/balanced-binary-tree","desc":"给定一个二叉树，判断它是否是高度平衡的二叉树。","solutions":[{"date":"2020-08-17","time":112,"memory":44.4,"script":"typescript","desc":"计算子树是否平衡，以及该树是否平衡。","code":"const map = new Map<TreeNode, number>();\nfunction isBalanced(root: TreeNode | null): boolean {\n  if (root === null) return true;\n  const h = (node: TreeNode | null): number => {\n    if (node === null) return 0;\n    if (map.has(node)) return map.get(node)!;\n    const height = 1 + Math.max(h(node.left), h(node.right));\n    map.set(node, height);\n    return height;\n  };\n  return (\n    isBalanced(root.left) && isBalanced(root.right) && Math.abs(h(root.left) - h(root.right)) <= 1\n  );\n}"},{"date":"2021-11-27","time":4,"memory":8.7,"script":"c","desc":"递归。","code":"// 判断节点是否平衡,不平衡返回-1,平衡返回高度\nint _isBalanced(struct TreeNode *node) {\n    if (!node) return 0;\n    int l = _isBalanced(node->left), r = _isBalanced(node->right);\n    if (l == -1 || r == -1) return -1;\n    if (abs(l - r) <= 1) return (l > r ? l : r) + 1;\n    return -1;\n}\nbool isBalanced(struct TreeNode* root){\n    return _isBalanced(root) > -1;\n}"}],"tagList":["树","深度优先搜索","二叉树"],"level":"Easy"}},{"problemName":"111.二叉树的最小深度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/111.二叉树的最小深度.json","problemData":{"id":"111","name":"111.二叉树的最小深度","url":"https://leetcode.cn/problems/minimum-depth-of-binary-tree","desc":"给定一个二叉树，找出其最小深度。","solutions":[{"date":"2020-08-21","time":92,"memory":42.3,"script":"typescript","desc":"深度优先。","code":"function minDepth(root: TreeNode | null): number {\n  if (root === null) return 0;\n  else if (root.left === null && root.right === null) return 1;\n  else {\n    let minD = Infinity;\n    if (root.left) minD = Math.min(minDepth(root.left), minD);\n    if (root.right) minD = Math.min(minDepth(root.right), minD);\n    return minD + 1;\n  }\n}"},{"date":"2020-08-21","time":88,"memory":41.6,"script":"typescript","desc":"广度优先。","code":"function minDepth(root: TreeNode | null): number {\n  if (root === null) return 0;\n  const queue: TreeNode[] = [root];\n  let height = 1;\n  let size = 1;\n  while (queue.length !== 0) {\n    const node = queue.shift() as TreeNode;\n    if (node.left === null && node.right === null) return height;\n    if (node.left !== null) queue.push(node.left);\n    if (node.right !== null) queue.push(node.right);\n    if (--size === 0) {\n      height++;\n      size = queue.length;\n    }\n  }\n  return 0;\n}"},{"date":"2021-11-27","time":132,"memory":73.8,"script":"c","desc":"递归。","code":"// 递归遍历每个节点\nvoid inorder(struct TreeNode *root, int level, int *min){\n    if (!root) return ;\n    // 如果是叶子且层级比较小则赋值\n    if (!root->left && !root->right) {\n        if (*min > level) *min = level;\n        return ;\n    }\n    inorder(root->left, level + 1, min);\n    inorder(root->right, level + 1, min);\n}\nint minDepth(struct TreeNode* root){\n    if (!root) return 0;\n    int min = 10000;\n    inorder(root, 1, &min);\n    return min;\n}"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉树"],"level":"Easy"}},{"problemName":"112.路径总和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/112.路径总和.json","problemData":{"id":"112","name":"112.路径总和","url":"https://leetcode.cn/problems/path-sum","desc":"给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。","solutions":[{"date":"2020-07-07","time":88,"memory":38.2,"script":"typescript","desc":"深度递归遍历即可。","code":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nfunction hasPathSum(root: TreeNode | null, sum: number): boolean {\n  if (root === null) return false;\n  const val = root.val;\n  if (val === sum && root.left === null && root.right === null) return true;\n  else return hasPathSum(root.left, sum - val) || hasPathSum(root.right, sum - val);\n}"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉树"],"level":"Easy"}},{"problemName":"113.路径总和II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/113.路径总和II.json","problemData":{"id":"113","name":"113.路径总和II","url":"https://leetcode.cn/problems/path-sum-ii","desc":"给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。","solutions":[{"date":"2020-09-26","time":124,"memory":47.1,"script":"typescript","desc":"递归调用。","code":"function pathSum(root: TreeNode | null, sum: number): number[][] {\n  if (root === null) return [];\n  const val = root.val;\n  if (val === sum && root.left === null && root.right === null) return [[val]];\n  const nextSum = sum - val;\n  const ans: number[][] = [];\n  ans.push(...pathSum(root.left, nextSum).map(v => [val, ...v]));\n  ans.push(...pathSum(root.right, nextSum).map(v => [val, ...v]));\n  return ans;\n}"}],"tagList":["树","深度优先搜索","回溯","二叉树"],"level":"Medium"}},{"problemName":"114.二叉树展开为链表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/114.二叉树展开为链表.json","problemData":{"id":"114","name":"114.二叉树展开为链表","url":"https://leetcode.cn/problems/flatten-binary-tree-to-linked-list","desc":"给定一个二叉树，原地将它展开为链表。","solutions":[{"date":"2020-02-21","time":1,"memory":38.2,"script":"java","desc":"使用前序遍历，再把遍历后的结果重新赋值到 right 上。","code":"class Solution {\n    LinkedList<TreeNode> list = new LinkedList<>();\n\tpublic void flatten(TreeNode root) {\n\t\tif (root == null||(root.left == null && root.right == null))\n\t\t\treturn;\n\t\tpreorder(root);\n\t\tTreeNode cur = root;\n\t\tfor (int i = 0, len = list.size(); i < len; i++) {\n\t\t\tcur.right = list.remove(0);\n\t\t\tcur = cur.right;\n\t\t}\n\t}\n\tpublic void preorder(TreeNode node) {\n\t\tlist.add(node);\n\t\tif (node.left != null)\n\t\t\tpreorder(node.left);\n\t\tif (node.right != null)\n\t\t\tpreorder(node.right);\n\t\tnode.left = null;\n\t\tnode.right = null;\n\t}\n}"},{"date":"2020-08-02","time":120,"memory":40,"script":"typescript","desc":"前序遍历。","code":"function flatten(root: TreeNode | null): void {\n  if (root === null || (root.left === null && root.right === null)) return;\n  const list: TreeNode[] = [];\n  _preorder(root);\n  let node: TreeNode = root;\n  for (let i = 1, l = list.length; i < l; i++) {\n    const v = list[i];\n    node.left = null;\n    node.right = list[i];\n    node = v;\n    if (i === l - 1) {\n      node.left = node.right = null;\n    }\n  }\n  function _preorder(node: TreeNode | null): void {\n    if (node === null) return;\n    list.push(node);\n    node.left !== null && _preorder(node.left);\n    node.right !== null && _preorder(node.right);\n  }\n}"}],"tagList":["栈","树","深度优先搜索","链表","二叉树"],"level":"Medium"}},{"problemName":"115.不同的子序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/115.不同的子序列.json","problemData":{"id":"115","name":"115.不同的子序列","url":"https://leetcode.cn/problems/distinct-subsequences","desc":"给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。","solutions":[{"date":"2021-03-17","time":100,"memory":41.6,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/distinct-subsequences/solution/bu-tong-de-zi-xu-lie-by-leetcode-solutio-urw3/)。","code":"function generateMatrix(n: number): number[][] {\n        const ans: number[][] = new Array(n).fill(0).map(_ => new Array(n));\n        let num = 1;\n        dfs(0, n - 1);\n        retfunction numDistinct(s: string, t: string): number {\n          const sLen = s.length;\n          const tLen = t.length;\n          if (sLen < tLen) return 0;\n          const dp = new Array(sLen + 1).fill(0).map(_ => new Array(tLen + 1).fill(0));\n          for (let i = 0; i <= sLen; i++) dp[i][tLen] = 1;\n          for (let i = sLen - 1; i >= 0; i--) {\n            for (let j = tLen - 1; j >= 0; j--) {\n              if (s[i] === t[j]) {\n                dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j];\n              } else {\n                dp[i][j] = dp[i + 1][j];\n              }\n            }\n          }\n          return dp[0][0];\n        }"}],"tagList":["字符串","动态规划"],"level":"Hard"}},{"problemName":"116.填充每个节点的下一个右侧节点指针.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/116.填充每个节点的下一个右侧节点指针.json","problemData":{"id":"116","name":"116.填充每个节点的下一个右侧节点指针","url":"https://leetcode.cn/problems/populating-next-right-pointers-in-each-node","desc":"给定一个完美二叉树，填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。","solutions":[{"date":"2020-10-15","time":108,"memory":45.3,"script":"typescript","desc":"层序遍历。","code":"function connect(root: Node | null): Node | null {\n  if (root === null) return null;\n  const queue = [root];\n  let size = 1;\n  while (queue.length !== 0) {\n    const node = queue.shift()!;\n    node.left && queue.push(node.left);\n    node.right && queue.push(node.right);\n    if (--size === 0) size = queue.length;\n    else node.next = queue[0];\n  }\n  return root;\n}"}],"tagList":["树","深度优先搜索","广度优先搜索","链表","二叉树"],"level":"Medium"}},{"problemName":"117.填充每个节点的下一个右侧节点指针II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/117.填充每个节点的下一个右侧节点指针II.json","problemData":{"id":"117","name":"117.填充每个节点的下一个右侧节点指针II","url":"https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii","desc":"给定一个二叉树，填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。","solutions":[{"date":"2020-09-28","time":120,"memory":42.8,"script":"javascript","desc":"层序遍历。","code":"var connect = function (root) {\n  if (root === null) return root;\n  const queue = [root];\n  let size = 1;\n  while (queue.length !== 0) {\n    const node = queue.shift();\n    node.left && queue.push(node.left);\n    node.right && queue.push(node.right);\n    if (--size === 0) {\n      node.next = null;\n      size = queue.length;\n    } else {\n      node.next = queue[0];\n    }\n  }\n  return root;\n};"},{"date":"2021-08-14","time":96,"memory":43.6,"script":"typescript","desc":"层序遍历。","code":"function connect(root: Node | null): Node | null {\n  if (root === null) return null;\n  const q: Node[] = [root];\n  let size = 1;\n  while (q.length) {\n    const node = q.shift()!;\n    node.left && q.push(node.left);\n    node.right && q.push(node.right);\n    if (--size === 0) {\n      size = q.length;\n      for (let i = 0; i < size; i++) {\n        q[i].next = i === size - 1 ? null : q[i + 1];\n      }\n    }\n  }\n  return root;\n}"},{"script":"python","time":56,"memory":17.01,"desc":"层序遍历。","code":"class Solution:\n    def connect(self, root: 'Node') -> 'Node':\n        if not root: return root\n        q = deque([root])\n        size = 1\n        while q:\n            cur = q.popleft()\n            size -= 1\n            if cur.left: \n                if size != len(q): q[-1].next = cur.left\n                q.append(cur.left)\n            if cur.right: \n                if size != len(q): q[-1].next = cur.right\n                q.append(cur.right)\n            if size == 0: size = len(q)\n        return root","date":"2023-11-03"},{"script":"python","time":40,"memory":15.66,"desc":"层序遍历中同时记录next。","code":"class Solution:\n    def connect(self, root: 'Node') -> 'Node':\n        if not root: return root\n        head = root\n        p = head\n        next_head = None\n        while p:\n            if p.left:\n                if not next_head:\n                    next_head = p.left\n                    head = p.left\n                else:\n                    next_head.next = p.left\n                    next_head = next_head.next\n            if p.right:\n                if not next_head:\n                    next_head = p.right\n                    head = p.right\n                else:\n                    next_head.next = p.right\n                    next_head = next_head.next\n            p = p.next\n            if not p:\n                p = head\n                head = None\n                next_head = None\n        return root","date":"2023-11-03"},{"script":"cpp","time":8,"memory":16.93,"desc":"层序遍历中同时记录next。","code":"class Solution {\npublic:\n    Node* connect(Node* root) {\n        if (!root) return root;\n        Node *head = root, *p = head, *next_head = nullptr;\n        while (p) {\n            if (p->left) {\n                if (!next_head) head = next_head = p->left;\n                else next_head = next_head->next = p->left;\n            }\n            if (p->right) {\n                if (!next_head) head = next_head = p->right;\n                else next_head = next_head->next = p->right;\n            }\n            p = p->next;\n            if (!p) p = head, head = next_head = nullptr;\n        }\n        return root;\n    }\n};","date":"2023-11-03"}],"tagList":["树","深度优先搜索","广度优先搜索","链表","二叉树"],"level":"Medium"}},{"problemName":"118.杨辉三角.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/118.杨辉三角.json","problemData":{"id":"118","name":"118.杨辉三角","url":"https://leetcode.cn/problems/pascals-triangle","desc":"给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。","solutions":[{"date":"2020-12-06","time":88,"memory":40.1,"script":"typescript","desc":"迭代遍历。","code":"function generate(numRows: number): number[][] {\n  if (numRows === 0) return [];\n  const ans: number[][] = [[1]];\n  for (let i = 2; i <= numRows; i++) {\n    const last = ans[ans.length - 1];\n    const arr = [];\n    for (let j = 0, l = last.length - 1; j < l; j++) {\n      arr.push(last[j] + last[j + 1]);\n    }\n    arr.unshift(1);\n    arr.push(1);\n    ans.push(arr);\n  }\n  return ans;\n}"},{"date":"2021-12-21","time":0,"memory":6.3,"script":"cpp","desc":"从后往前遍历。","code":"class Solution {\n   public:\n    vector<vector<int>> generate(int numRows) {\n        vector<vector<int>> ans(numRows, vector<int>());\n        ans[0].push_back(1);\n        for (int i = 1; i < numRows; i++) {\n            ans[i].push_back(1);\n            for (int j = 1; j < i; j++) {\n                ans[i].push_back(ans[i - 1][j] + ans[i - 1][j - 1]);\n            }\n            ans[i].push_back(1);\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","动态规划"],"level":"Easy"}},{"problemName":"119.杨辉三角II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/119.杨辉三角II.json","problemData":{"id":"119","name":"119.杨辉三角II","url":"https://leetcode.cn/problems/pascals-triangle-ii","desc":"给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。","solutions":[{"date":"2021-02-12","time":88,"memory":40.5,"script":"typescript","desc":"遍历所有值进行储存。","code":"function getRow(rowIndex: number): number[] {\n  const cache: number[][] = [[1], [1, 1]];\n  for (let i = 2; i <= 33; i++) {\n    const arr = [1];\n    const prev = cache[i - 1];\n    for (let j = 0, l = prev.length; j < l - 1; j++) {\n      arr.push(prev[j] + prev[j + 1]);\n    }\n    arr.push(1);\n    cache.push(arr);\n  }\n  return cache[rowIndex];\n}"},{"date":"2021-02-12","time":88,"memory":40.5,"script":"typescript","desc":"优化题解 1。","code":"const cache = [[1],[1,1],...]\n      function getRow(rowIndex: number): number[] {\n        return cache[rowIndex];\n      }"},{"date":"2021-02-12","time":84,"memory":40.1,"script":"typescript","desc":"利用 1 个数组进行覆盖。","code":"function getRow(rowIndex: number): number[] {\n  if (rowIndex === 0) return [1];\n  const arr = [1, 1];\n  if (rowIndex === 1) return arr;\n  for (let i = 2; i <= rowIndex; i++) {\n    for (let j = 0, l = arr.length; j < l - 1; j++) {\n      arr[j] = arr[j] + arr[j + 1];\n    }\n    arr.unshift(1);\n    arr.splice(arr.length - 1, 1, 1);\n  }\n  return arr;\n}"},{"date":"2021-09-04","time":88,"memory":39.2,"script":"typescript","desc":"动态规划。","code":"function getRow(rowIndex: number): number[] {\n  const list: number[][] = new Array(2).fill(0).map(_ => []);\n  list[0].push(1);\n  list[1].push(1, 1);\n  for (let i = 2; i <= rowIndex; i++) {\n    const idx = i % 2;\n    const prevIdx = idx ^ 1;\n    list[idx].length = 0;\n    list[idx].push(1);\n    for (let j = 1; j <= i - 1; j++) list[idx].push(list[prevIdx][j] + list[prevIdx][j - 1]);\n    list[idx].push(1);\n  }\n  return list[rowIndex % 2];\n}"}],"tagList":["数组","动态规划"],"level":"Easy"}},{"problemName":"120.三角形最小路径和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/120.三角形最小路径和.json","problemData":{"id":"120","name":"120.三角形最小路径和","url":"https://leetcode.cn/problems/triangle","desc":"给定一个三角形，找出自顶向下的最小路径和。","solutions":[{"date":"2020-07-14","time":64,"memory":36.8,"script":"typescript","desc":"逆向推导[0][0],dp[i][j]=i 行 j 列时的最小步数。","code":"function minimumTotal(triangle: number[][]): number {\n  const len = triangle.length;\n  const ans: number[][] = new Array(len + 1);\n  ans[len] = new Array(len + 1).fill(0);\n  for (let i = len - 1; i >= 0; i--) {\n    const arr: number[] = [];\n    for (let j = 0, l = triangle[i].length; j < l; j++) {\n      arr[j] = Math.min(ans[i + 1][j], ans[i + 1][j + 1]) + triangle[i][j];\n    }\n    ans[i] = arr;\n  }\n  return ans[0][0];\n}"},{"date":"2020-07-14","time":76,"memory":37,"script":"typescript","desc":"根据题解 1，利用滑动数组来节省空间。","code":"function minimumTotal(triangle: number[][]): number {\n  const len = triangle.length;\n  const ans: number[][] = new Array(2);\n  ans[len % 2] = new Array(len + 1).fill(0);\n  for (let i = len - 1; i >= 0; i--) {\n    const arr: number[] = [];\n    for (let j = 0, l = triangle[i].length; j < l; j++) {\n      arr[j] = Math.min(ans[(i + 1) % 2][j], ans[(i + 1) % 2][j + 1]) + triangle[i][j];\n    }\n    ans[i % 2] = arr;\n  }\n  return ans[0][0];\n}"},{"date":"2021-09-03","time":80,"memory":39.7,"script":"typescript","desc":"动态规划。","code":"function minimumTotal(triangle: number[][]): number {\n  const n = triangle.length;\n  for (let i = n - 2; i >= 0; i--)\n    for (let j = 0; j <= i; j++)\n      triangle[i][j] += Math.min(triangle[i + 1][j], triangle[i + 1][j + 1]);\n  return triangle[0][0];\n}"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"121.买卖股票的最佳时机.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/121.买卖股票的最佳时机.json","problemData":{"id":"121","name":"121.买卖股票的最佳时机","url":"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock","desc":"给定一个数组 prices ，它的第  i 个元素  prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。","solutions":[{"date":"2022-03-14","time":100,"memory":91,"script":"cpp","desc":"考虑到只能交易一次，每遍历到一个值与前面的最小值进行比较。","code":"class Solution {\n   public:\n    int maxProfit(vector<int> &prices) {\n        int nmin = prices[0], ans = 0;\n        for (int i = 1; i < prices.size(); i++) {\n            ans = max(ans, prices[i] - nmin);\n            nmin = min(nmin, prices[i]);\n        }\n        return ans;\n    }\n};"},{"script":"python","time":224,"memory":25.9,"desc":"同上。","code":"class Solution:\n            def maxProfit(self, prices: List[int]) -> int:\n                prev = prices[0]\n                res = 0\n                for i in range(1, len(prices)):\n                    res = max(res, prices[i] - prev)\n                    prev = min(prev, prices[i])\n                return res\n","date":"2023-10-01"}],"tagList":["数组","动态规划"],"level":"Easy"}},{"problemName":"122.买卖股票的最佳时机II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/122.买卖股票的最佳时机II.json","problemData":{"id":"122","name":"122.买卖股票的最佳时机II","url":"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii","desc":"给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。","solutions":[{"date":"2020-11-08","time":84,"memory":40.2,"script":"typescript","desc":"动态规划。","code":"function maxProfit(prices: number[]): number {\n  const len = prices.length;\n  let dp0 = 0,\n    dp1 = -prices[0];\n  for (let i = 1; i < len; i++) {\n    dp0 = Math.max(dp0, dp1 + prices[i]);\n    dp1 = Math.max(dp1, dp0 - prices[i]);\n  }\n  return dp0;\n}"},{"date":"2021-09-04","time":84,"memory":41.2,"script":"typescript","desc":"前缀和，减去前面前缀和的最小值。","code":"function maxProfit(prices: number[]): number {\n  const n = prices.length;\n  /**\n   *  0 : 买\n   *  1 : 卖\n   */\n  const dp = new Array(n).fill(0).map(_ => new Array(2).fill(0));\n  dp[0][0] = -prices[0];\n  for (let i = 1; i < n; i++) {\n    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);\n    dp[i][1] = Math.max(dp[i - 1][0] + prices[i], dp[i - 1][1]);\n  }\n  return dp[n - 1][1];\n}"},{"date":"2021-09-04","time":76,"memory":40.1,"script":"typescript","desc":"统计每个上升区间。","code":"function maxProfit(prices: number[]): number {\n  let ans = 0;\n  for (let i = 1; i < prices.length; i++)\n    if (prices[i] > prices[i - 1]) ans += prices[i] - prices[i - 1];\n  return ans;\n}"}],"tagList":["贪心","数组","动态规划"],"level":"Medium"}},{"problemName":"123.买卖股票的最佳时机III.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/123.买卖股票的最佳时机III.json","problemData":{"id":"123","name":"123.买卖股票的最佳时机III","url":"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii","desc":"给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。","solutions":[{"date":"2021-01-09","time":1028,"memory":85.4,"script":"typescript","desc":"动态规划计算每个状态。","code":"function maxProfit(prices: number[]): number {\n  const len = prices.length;\n  if (len < 2) return 0;\n  // 0 手上没，1 手上有\n  // 0 完成0次交易 1 完成1次交易 2 完成两次交易\n  const dp: number[][][] = new Array(len)\n    .fill(0)\n    .map(_ => new Array(2).fill(0).map(_ => new Array(3).fill(-Infinity)));\n  [dp[0][0][0], dp[0][1][0]] = [0, -prices[0]];\n  for (let i = 1; i < len; i++) {\n    dp[i][0][0] = dp[i - 1][0][0];\n    dp[i][0][1] = Math.max(prices[i] + dp[i - 1][1][0], dp[i - 1][0][1]);\n    dp[i][0][2] = i >= 3 ? Math.max(prices[i] + dp[i - 1][1][1], dp[i - 1][0][2]) : 0;\n    dp[i][1][0] = Math.max(dp[i - 1][1][0], -prices[i]);\n    dp[i][1][1] = Math.max(dp[i - 1][1][1], dp[i - 1][0][1] - prices[i]);\n    dp[i][1][2] = 0;\n  }\n  return Math.max(dp[len - 1][0][2], dp[len - 1][0][1]);\n}"},{"date":"2021-01-09","time":984,"memory":86.9,"script":"typescript","desc":"优化题解 1。","code":"function maxProfit(prices: number[]): number {\n  const len = prices.length;\n  if (len < 2) return 0;\n  // 0 手上没，1 手上有\n  // 0 完成0次交易 1 完成1次交易 2 完成两次交易\n  const dp: number[][][] = new Array(len)\n    .fill(0)\n    .map(_ => new Array(2).fill(0).map(_ => new Array(3).fill(-Infinity)));\n  [dp[0][0][0], dp[0][1][0]] = [0, -prices[0]];\n  for (let i = 1; i < len; i++) {\n    const prev = dp[i - 1];\n    const prev0 = prev[0];\n    const prev1 = prev[1];\n    const price = prices[i];\n    [dp[i][0][1], dp[i][0][2], dp[i][1][0], dp[i][1][1]] = [\n      Math.max(price + prev1[0], prev0[1]),\n      i >= 3 ? Math.max(price + prev1[1], prev0[2]) : 0,\n      Math.max(prev1[0], -price),\n      Math.max(prev1[1], prev0[1] - price),\n    ];\n  }\n  return Math.max(dp[len - 1][0][2], dp[len - 1][0][1]);\n}"},{"date":"2021-01-09","time":1008,"memory":82.7,"script":"typescript","desc":"优化题解 1。","code":"function maxProfit(prices: number[]): number {\n  const len = prices.length;\n  if (len < 2) return 0;\n  // 0 手上没，1 手上有\n  // 0 完成0次交易 1 完成1次交易 2 完成两次交易\n  const dp: number[][][] = new Array(len)\n    .fill(0)\n    .map(_ => new Array(2).fill(0).map(_ => new Array(3).fill(-Infinity)));\n  [dp[0][0][0], dp[0][1][0]] = [0, -prices[0]];\n  let [dp01, dp02, dp10, dp11] = [-Infinity, -Infinity, -prices[0], -Infinity];\n  for (let i = 1; i < len; i++) {\n    const price = prices[i];\n    [dp01, dp02, dp10, dp11] = [\n      Math.max(price + dp10, dp01),\n      i >= 3 ? Math.max(price + dp11, dp02) : 0,\n      Math.max(dp10, -price),\n      Math.max(dp11, dp01 - price),\n    ];\n  }\n  return Math.max(dp01, dp02);\n}\n// 6\nconsole.log(maxProfit([3, 3, 5, 0, 0, 3, 1, 4]));\n// 4\nconsole.log(maxProfit([1, 2, 3, 4, 5]));\n// 0\nconsole.log(maxProfit([2, 1, 4]));"},{"script":"python","time":1924,"memory":80.1,"desc":"dp[i][j][k]表示i天j笔手上有无。","code":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        # [i][j][k] i天j笔手上有无\n        dp = [[[-inf for _ in range(2)] for _ in range(3)] for _ in range(n)]\n        num0 = dp[0][0][0] = 0\n        num1 = dp[0][0][1] = -prices[0]\n        res = 0\n        num2 = num3 = -inf\n        for i in range(1, n):\n            dp[i][0][0] = dp[i - 1][0][0]\n            dp[i][0][1] = num0 - prices[i]\n            dp[i][1][0] = num1 + prices[i]\n            dp[i][1][1] = num2 - prices[i]\n            dp[i][2][0] = num3 + prices[i]\n            num0 = max(num0, dp[i][0][0])\n            num1 = max(num1, dp[i][0][1])\n            num2 = max(num2, dp[i][1][0])\n            num3 = max(num3, dp[i][1][1])\n            res = max(res, dp[i][1][0], dp[i][2][0])\n        return res\n","date":"2023-10-03"}],"tagList":["数组","动态规划"],"level":"Hard"}},{"problemName":"124.二叉树中的最大路径和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/124.二叉树中的最大路径和.json","problemData":{"id":"124","name":"124.二叉树中的最大路径和","url":"https://leetcode.cn/problems/binary-tree-maximum-path-sum","desc":"给定一个非空二叉树，返回其最大路径和。","solutions":[{"date":"2020-06-21","time":88,"memory":46.4,"script":"typescript","desc":"递归调用判断部分和与单链和。","code":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     val: number\n *     left: TreeNode | null\n *     right: TreeNode | null\n *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.left = (left===undefined ? null : left)\n *         this.right = (right===undefined ? null : right)\n *     }\n * }\n */\nfunction maxPathSum(root: TreeNode | null): number {\n  const [link, part] = sum(root);\n  return Math.max(link, part);\n  function sum(node: TreeNode | null): [number, number] {\n    if (node === null) return [0, -Infinity];\n    const [linkSumL, partSumL] = sum(node.left);\n    const [linkSumR, partSumR] = sum(node.right);\n    const partSum = Math.max(\n      node.val,\n      node.val + linkSumL + linkSumR,\n      node.val + linkSumL,\n      node.val + linkSumR,\n      partSumL,\n      partSumR\n    );\n    const linkSum = Math.max(linkSumL, linkSumR, 0) + node.val;\n    return [linkSum, partSum];\n  }\n}"}],"tagList":["树","深度优先搜索","动态规划","二叉树"],"level":"Hard"}},{"problemName":"125.验证回文串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/125.验证回文串.json","problemData":{"id":"125","name":"125.验证回文串","url":"https://leetcode.cn/problems/valid-palindrome","desc":"我们从二叉树的根节点 root  开始进行深度优先搜索。在遍历中的每个节点处，我们输出  D  条短划线（其中  D  是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。如果节点只有一个子节点，那么保证该子节点为左子节点。给出遍历输出  S，还原树并返回其根节点  root。","solutions":[{"date":"2020-06-19","time":96,"memory":46.8,"script":"typescript","desc":"利用字符串转数组后过滤获取所需字符进行判断。","code":"function isPalindrome(s: string): boolean {\n  const arr = s\n    .toLowerCase()\n    .split('')\n    .filter(v => /d|w/.test(v));\n  return arr.join('') === arr.reverse().join('');\n}"},{"date":"2022-02-18","time":8,"memory":7,"script":"cpp","desc":"双指针遍历。","code":"class Solution {\n   public:\n    bool isPalindrome(string s) {\n        if (s == \" \") return 1;\n        int l = 0, r = s.size() - 1;\n        char lc, rc;\n        while (l < r) {\n            do {\n                lc = tolower(s[l++]);\n            } while (l < s.size() && !isdigit(lc) && !isalpha(lc));\n            do {\n                rc = tolower(s[r--]);\n            } while (r >= 0 && !isdigit(rc) && !isalpha(rc));\n            if (l < s.size() && r >= 0 && lc != rc) return 0;\n        }\n        return 1;\n    }\n};"}],"tagList":["双指针","字符串"],"level":"Easy"}},{"problemName":"128.最长连续序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/128.最长连续序列.json","problemData":{"id":"128","name":"128.最长连续序列","url":"https://leetcode.cn/problems/longest-consecutive-sequence","desc":"给定一个未排序的整数数组，找出最长连续序列的长度。","solutions":[{"date":"2020-06-06","time":84,"memory":37.8,"script":"typescript","desc":"排序去重遍历。","code":"function longestConsecutive(nums: number[]): number {\n  if (nums.length === 0) return 0;\n  nums = [...new Set(nums)].sort((a, b) => a - b);\n  let max = 1;\n  let nowMax = 1;\n  let preNum = nums[0];\n  for (const num of nums) {\n    if (num === preNum + 1) {\n      nowMax++;\n    } else {\n      max = nowMax > max ? nowMax : max;\n      nowMax = 1;\n    }\n    preNum = num;\n  }\n  return max > nowMax ? max : nowMax;\n}"},{"date":"2020-06-06","time":76,"memory":37.2,"script":"typescript","desc":"用哈希表进行 O(1)的查找，即最慢查找速度 O(n)。","code":"function longestConsecutive(nums: number[]): number {\n  if (nums.length === 0) return 0;\n  const set = new Set(nums);\n  let max = 1;\n  for (let num of set) {\n    if (!set.has(num - 1)) {\n      let nowMax = 1;\n      while (set.has(++num)) nowMax++;\n      max = nowMax > max ? nowMax : max;\n    }\n  }\n  return max;\n}"},{"date":"2021-04-30","time":192,"memory":53.8,"script":"typescript","desc":"并查集。","code":"class UnionFind {\n  elements: number[];\n  constructor(public size: number) {\n    this.elements = new Array(size).fill(0).map((_, i) => i);\n  }\n  same(v1: number, v2: number): boolean {\n    return this.find(v1) === this.find(v2);\n  }\n  find(v: number): number {\n    return v === this.elements[v] ? v : (this.elements[v] = this.find(this.elements[v]));\n  }\n  union(v1: number, v2: number): void {\n    const e1 = this.find(v1);\n    const e2 = this.find(v2);\n    if (e1 !== e2) {\n      this.elements[e1] = e2;\n      this.size--;\n    }\n  }\n}\nfunction longestConsecutive(nums: number[]): number {\n  nums = [...new Set(nums)];\n  const len = nums.length;\n  if (len === 0) return 0;\n  const uf = new UnionFind(len);\n  const map = new Map(nums.map((v, i) => [v, i]));\n  const ansMap = new Map<number, number>();\n  for (let i = 0; i < len; i++) {\n    const num = nums[i];\n    const num_minus = map.get(num - 1);\n    if (num_minus) {\n      uf.union(i, num_minus);\n      const index = uf.find(i);\n      ansMap.set(index, (ansMap.get(index) ?? 0) + 1);\n    }\n    const num_add = map.get(num + 1);\n    if (num_add) {\n      uf.union(i, num_add);\n      const index = uf.find(i);\n      ansMap.set(index, (ansMap.get(index) ?? 0) + 1);\n    }\n  }\n  const cache: Record<number, number> = {};\n  for (let i = 0; i < len; i++) {\n    const num = uf.find(i);\n    cache[num] = (cache[num] ?? 0) + 1;\n  }\n  return [...Object.entries(cache)].sort(([, c1], [, c2]) => c2 - c1)[0][1];\n}"}],"tagList":["并查集","数组","哈希表"],"level":"Medium"}},{"problemName":"129.求根节点到叶节点数字之和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/129.求根节点到叶节点数字之和.json","problemData":{"id":"129","name":"129.求根节点到叶节点数字之和","url":"https://leetcode.cn/problems/sum-root-to-leaf-numbers","desc":"计算从根到叶子节点生成的所有数字之和。","solutions":[{"date":"2020-10-29","time":112,"memory":42.6,"script":"typescript","desc":"递归整合数组，深度优先。","code":"function sumNumbers(root: TreeNode | null): number {\n  if (root === null) return 0;\n  return find(root).reduce((total, cur) => total + Number(cur.join('')), 0);\n  function find(root: TreeNode): number[][] {\n    const val = root.val;\n    const ans: number[][] = [];\n    if (root.left === null && root.right === null) {\n      ans.push([val]);\n    }\n    if (root.left !== null) {\n      ans.push(...find(root.left).map(v => [val, ...v]));\n    }\n    if (root.right !== null) {\n      ans.push(...find(root.right).map(v => [val, ...v]));\n    }\n    return ans;\n  }\n}"}],"tagList":["树","深度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"130.被围绕的区域.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/130.被围绕的区域.json","problemData":{"id":"130","name":"130.被围绕的区域","url":"https://leetcode.cn/problems/surrounded-regions","desc":"给定一个二维的矩阵，包含 'X' 和 'O'（字母 O）。找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。","solutions":[{"date":"2020-08-11","time":132,"memory":41,"script":"typescript","desc":"从边缘开始找，进行深度优先搜索。","code":"function solve(board: string[][]): void {\n  const row = board.length;\n  if (row === 0) return;\n  const col = board[0].length;\n  const isEdge = (i: number, j: number): boolean =>\n    i === 0 || j === 0 || i === row - 1 || j === col - 1;\n  const check = (i: number, j: number): void => {\n    const tag = board[i][j];\n    if (tag === 'O') {\n      board[i][j] = 'A';\n      dfs(i, j);\n    }\n  };\n  const dfs = (i: number, j: number): void => {\n    // top\n    if (i !== 0 && !isEdge(i - 1, j) && board[i - 1][j] === 'O') {\n      board[i - 1][j] = 'A';\n      dfs(i - 1, j);\n    }\n    // bottom\n    if (i !== row - 1 && !isEdge(i + 1, j) && board[i + 1][j] === 'O') {\n      board[i + 1][j] = 'A';\n      dfs(i + 1, j);\n    }\n    // left\n    if (j !== 0 && !isEdge(i, j - 1) && board[i][j - 1] === 'O') {\n      board[i][j - 1] = 'A';\n      dfs(i, j - 1);\n    }\n    // right\n    if (j !== col - 1 && !isEdge(i, j + 1) && board[i][j + 1] === 'O') {\n      board[i][j + 1] = 'A';\n      dfs(i, j + 1);\n    }\n  };\n  // top bottom\n  for (let j = 0; j < col; j++) {\n    check(0, j);\n    check(row - 1, j);\n  }\n  // left right\n  for (let i = 0; i < row; i++) {\n    check(i, 0);\n    check(i, col - 1);\n  }\n  for (let i = 0; i < row; i++) {\n    for (let j = 0; j < col; j++) {\n      const tag = board[i][j];\n      if (tag === 'O') board[i][j] = 'X';\n      else if (tag === 'A') board[i][j] = 'O';\n    }\n  }\n}"},{"date":"2021-07-25","time":96,"memory":42.9,"script":"typescript","desc":"dfs。","code":"function solve(board: string[][]): void {\n  const n = board.length;\n  const m = board[0].length;\n  for (let i = 0; i < n; i++) {\n    dfs(i, 0);\n    dfs(i, m - 1);\n  }\n  for (let i = 0; i < m; i++) {\n    dfs(0, i);\n    dfs(n - 1, i);\n  }\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (board[i][j] === 'O') board[i][j] = 'X';\n      if (board[i][j] === 'A') board[i][j] = 'O';\n    }\n  }\n  function dfs(row: number, col: number): void {\n    if (board[row][col] !== 'O') return;\n    board[row][col] = 'A';\n    if (row > 0) dfs(row - 1, col);\n    if (col > 0) dfs(row, col - 1);\n    if (row < n - 1) dfs(row + 1, col);\n    if (col < m - 1) dfs(row, col + 1);\n  }\n}"}],"tagList":["深度优先搜索","广度优先搜索","并查集","数组","矩阵"],"level":"Medium"}},{"problemName":"131.分割回文串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/131.分割回文串.json","problemData":{"id":"131","name":"131.分割回文串","url":"https://leetcode.cn/problems/palindrome-partitioning","desc":"给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。","solutions":[{"date":"2021-03-07","time":372,"memory":67.8,"script":"typescript","desc":"递归判断。","code":"const map: Record<string, boolean> = {};\nfunction isPalindrome(s: string) {\n  if (map[s]) return map[s];\n  const len = s.length;\n  if (len === 1) return (map[s] = true);\n  for (let i = 0; i < len / 2; i++) {\n    if (s[i] !== s[len - i - 1]) {\n      return (map[s] = false);\n    }\n  }\n  return (map[s] = true);\n}\nfunction partition(s: string): string[][] {\n  const ans: string[][] = [];\n  const len = s.length;\n  if (len === 1) return [[s]];\n  for (let i = 0; i < len; i++) {\n    const str = s.substring(0, i + 1);\n    if (isPalindrome(str)) {\n      i === len - 1\n        ? ans.push([s])\n        : ans.push(...partition(s.substring(i + 1)).map(arr => [str, ...arr]));\n    }\n  }\n  return ans;\n}"},{"date":"2021-03-08","time":288,"memory":60.4,"script":"typescript","desc":"利用动态规划计算所有值，再利用回溯收集。","code":"function partition(s: string): string[][] {\n  const len = s.length;\n  const f = new Array(len).fill(0).map(() => new Array(len).fill(true));\n  for (let i = len - 1; i >= 0; --i) {\n    for (let j = i + 1; j < len; ++j) {\n      f[i][j] = s[i] === s[j] && f[i + 1][j - 1];\n    }\n  }\n  const ans: string[][] = [];\n  const arr: string[] = [];\n  const dfs = (startIndex: number) => {\n    if (startIndex === len) {\n      ans.push([...arr]);\n    } else {\n      for (let i = startIndex; i < len; i++) {\n        if (f[startIndex][i]) {\n          const str = s.substring(startIndex, i + 1);\n          arr.push(str);\n          dfs(i + 1);\n          arr.pop();\n        }\n      }\n    }\n  };\n  dfs(0);\n  return ans;\n}"}],"tagList":["字符串","动态规划","回溯"],"level":"Medium"}},{"problemName":"132.分割回文串II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/132.分割回文串II.json","problemData":{"id":"132","name":"132.分割回文串II","url":"https://leetcode.cn/problems/palindrome-partitioning-ii","desc":"给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。返回符合要求的 最少分割次数 。","solutions":[{"date":"2021-03-08","time":160,"memory":57.68,"script":"typescript","desc":"动态规划。","code":"function minCut(s: string): number {\n  const len = s.length;\n  if (len <= 1) return 0;\n  const f = new Array(len).fill(0).map(() => new Array(len).fill(true));\n  for (let i = len - 1; i >= 0; --i) {\n    for (let j = i + 1; j < len; ++j) {\n      f[i][j] = s[i] === s[j] && f[i + 1][j - 1];\n    }\n  }\n  const dp: number[] = new Array(len).fill(Infinity);\n  for (let i = 0; i < len; i++) {\n    if (f[0][i]) {\n      dp[i] = 0;\n    } else {\n      for (let j = 0; j < i; j++) {\n        if (f[j + 1][i]) {\n          dp[i] = Math.min(dp[i], dp[j] + 1);\n        }\n      }\n    }\n  }\n  return dp[len - 1];\n}"},{"date":"2021-12-12","time":220,"memory":76.6,"script":"typescript","desc":"先统计所有的以 i 开头 j 结尾的回文字符串，进行动态规划遍历。","code":"function getArr(s: string) {\n  const n = s.length;\n  const ans = new Array(n).fill(0).map(_ => new Array(n).fill(false));\n  const load = (l: number, r: number) => {\n    while (l >= 0 && r < n && s[l] === s[r]) ans[l--][r++] = true;\n  };\n  for (let i = 0; i < n; i++) {\n    load(i, i);\n    if (i < n - 1) load(i, i + 1);\n  }\n  return ans;\n}\nfunction minCut(s: string): number {\n  const n = s.length;\n  const arr = getArr(s);\n  const dp = new Array(n).fill(0).map((_, i) => i);\n  for (let i = 0; i < n; i++) {\n    if (arr[0][i]) {\n      dp[i] = 0;\n      continue;\n    }\n    for (let j = 0; j + 1 <= i; j++) {\n      if (!arr[j + 1][i]) continue;\n      dp[i] = Math.min(dp[i], dp[j] + 1);\n    }\n  }\n  return dp[n - 1];\n}"}],"tagList":["字符串","动态规划"],"level":"Hard"}},{"problemName":"133.克隆图.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/133.克隆图.json","problemData":{"id":"133","name":"133.克隆图","url":"https://leetcode.cn/problems/clone-graph","desc":"给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。","solutions":[{"date":"2020-08-12","time":104,"memory":40.1,"script":"typescript","desc":"深度克隆。","code":"/**\n * // Definition for a Node.\n * function Node(val, neighbors) {\n *    this.val = val === undefined ? 0 : val;\n *    this.neighbors = neighbors === undefined ? [] : neighbors;\n * };\n */\n/**\n * @param {Node} node\n * @return {Node}\n */\nvar cloneGraph = function (node) {\n  if (node === null) return null;\n  const cloned = new Map();\n  return clone(node);\n  function clone(node) {\n    const val = node.val;\n    if (cloned.has(val)) return cloned.get(val);\n    const newNode = new Node(val);\n    cloned.set(val, newNode);\n    newNode.neighbors = node.neighbors.map(v => clone(v));\n    return newNode;\n  }\n};"},{"date":"2021-10-25","time":80,"memory":39.9,"script":"typescript","desc":"dfs。","code":"function cloneGraph(node: Node | null): Node | null {\n  if (node === null) return null;\n  const map = new Map<number, Node>();\n  dfs(node);\n  return map.get(node.val)!;\n  function dfs(node: Node | null): void {\n    if (node === null || map.has(node.val)) return;\n    const cloneNode = new Node(node.val);\n    map.set(node.val, cloneNode);\n    node.neighbors.forEach(neighbor => {\n      dfs(neighbor);\n      cloneNode.neighbors.push(map.get(neighbor.val)!);\n    });\n  }\n}"}],"tagList":["深度优先搜索","广度优先搜索","图","哈希表"],"level":"Medium"}},{"problemName":"134.加油站.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/134.加油站.json","problemData":{"id":"134","name":"134.加油站","url":"https://leetcode.cn/problems/gas-station","desc":"在一条环路上有  N  个加油站，其中第  i  个加油站有汽油  gas[i]  升。你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1  个加油站需要消耗汽油  cost[i]  升。你从其中的一个加油站出发，开始时油箱为空。如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。","solutions":[{"date":"2020-11-18","time":272,"memory":40.9,"script":"typescript","desc":"选取首点进行遍历计算。","code":"function canCompleteCircuit(gas: number[], cost: number[]): number {\n  const len = gas.length;\n  const starts: number[] = [];\n  for (let i = 0; i < len; i++) {\n    gas[i] >= cost[i] && starts.push(i);\n  }\n  for (const start of starts) {\n    let arg = gas[start] - cost[start];\n    let i = (start + 1) % len;\n    while (i !== start) {\n      arg += gas[i] - cost[i];\n      if (arg < 0) break;\n      i = (i + 1) % len;\n    }\n    if (i === start) return i;\n  }\n  return -1;\n}"}],"tagList":["贪心","数组"],"level":"Medium"}},{"problemName":"135.分发糖果.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/135.分发糖果.json","problemData":{"id":"135","name":"135.分发糖果","url":"https://leetcode.cn/problems/candy","desc":"老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。那么这样下来，老师至少需要准备多少颗糖果呢？。","solutions":[{"date":"2020-12-24","time":88,"memory":43.2,"script":"typescript","desc":"两次遍历取最大值。","code":"function candy(ratings: number[]): number {\n  const left: number[] = [];\n  const len = ratings.length;\n  for (let i = 0; i < len; i++) {\n    if (i === 0 || ratings[i - 1] >= ratings[i]) {\n      left[i] = 1;\n    } else {\n      left[i] = left[i - 1] + 1;\n    }\n  }\n  let right = 1;\n  let ans = 0;\n  for (let i = len - 1; i >= 0; i--) {\n    if (i === len - 1 || ratings[i + 1] >= ratings[i]) {\n      right = 1;\n    } else {\n      right++;\n    }\n    ans += Math.max(right, left[i]);\n  }\n  return ans;\n}"},{"date":"2021-07-21","time":104,"memory":42.7,"script":"typescript","desc":"从左往右遍历一遍，从右往左遍历一遍，取最大值。","code":"function candy(ratings: number[]): number {\n  const n = ratings.length;\n  const l = new Array(n).fill(1);\n  const r = new Array(n).fill(1);\n  for (let i = 1; i < n; i++) {\n    if (ratings[i] > ratings[i - 1]) l[i] = l[i - 1] + 1;\n  }\n  for (let i = n - 2; i >= 0; i--) {\n    if (ratings[i] > ratings[i + 1]) r[i] = r[i + 1] + 1;\n  }\n  let ans = 0;\n  for (let i = 0; i < n; i++) ans += Math.max(l[i], r[i]);\n  return ans;\n}"}],"tagList":["贪心","数组"],"level":"Hard"}},{"problemName":"136.只出现一次的数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/136.只出现一次的数字.json","problemData":{"id":"136","name":"136.只出现一次的数字","url":"https://leetcode.cn/problems/single-number","desc":"给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。","solutions":[{"date":"2020-05-14","time":72,"memory":36.7,"script":"javascript","desc":"累加，利用异或消除重复。","code":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNumber = function (nums) {\n  if (nums.length === 0) return 0;\n  let res = nums.shift();\n  for (const num of nums) res ^= num;\n  return res;\n};"},{"date":"2020-05-14","time":60,"memory":35.1,"script":"javascript","desc":"根据题解 1，利用 reduce 可单行解决。","code":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar singleNumber = nums => nums.reduce((total, curV) => total ^ curV, 0);"},{"date":"2021-12-21","time":16,"memory":16.4,"script":"cpp","desc":"异或。","code":"class Solution {\n   public:\n    int singleNumber(vector<int>& nums) {\n        int ans = 0;\n        for (int i = 0; i < nums.size(); i++) ans ^= nums[i];\n        return ans;\n    }\n};"},{"script":"python","time":36,"memory":17.67,"desc":"异或排除重复数字。","code":"class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        return reduce(lambda a, b: a ^ b, nums, 0)","date":"2023-10-14"}],"tagList":["位运算","数组"],"level":"Easy"}},{"problemName":"137.只出现一次的数字II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/137.只出现一次的数字II.json","problemData":{"id":"137","name":"137.只出现一次的数字II","url":"https://leetcode.cn/problems/single-number-ii","desc":"给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。","solutions":[{"date":"2021-04-30","time":96,"memory":40.1,"script":"typescript","desc":"排序后判断数量。","code":"function singleNumber(nums: number[]): number {\n  const len = nums.length;\n  nums.sort((a, b) => a - b);\n  let i = 0;\n  while (i < len - 1) {\n    if (nums[i] === nums[i + 1]) i += 3;\n    else break;\n  }\n  return nums[i];\n}"},{"date":"2021-04-30","time":76,"memory":40.4,"script":"typescript","desc":"利用 map 储存。","code":"function singleNumber(nums: number[]): number {\n  return [\n    ...nums\n      .reduce((map, v) => {\n        map.set(v, (map.get(v) ?? 0) + 1);\n        return map;\n      }, new Map<number, number>())\n      .entries(),\n  ].filter(([, v]) => v === 1)[0][0];\n}"},{"script":"python","time":92,"memory":17.8,"desc":"统计每一个位置上1的个数。","code":"import ctypes\n\n    class Solution:\n        def singleNumber(self, nums: List[int]) -> int:\n            return ctypes.c_int32(reduce(\n                lambda res, i: res | (1 if sum((num >> i) & 1 for num in nums) % 3 != 0 else 0) << i, \n                [i for i in range(0, 32)],\n                0\n            )).value","date":"2023-10-15"}],"tagList":["位运算","数组"],"level":"Medium"}},{"problemName":"138.随机链表的复制.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/138.随机链表的复制.json","problemData":{"id":"138","name":"138.随机链表的复制","url":"https://leetcode.cn/problems/copy-list-with-random-pointer","desc":"给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。返回复制链表的头节点。","solutions":[{"date":"2021-03-14","time":96,"memory":39.5,"script":"typescript","desc":"先克隆一份再进行拆除。","code":"function copyRandomList(head: Node | null): Node | null {\n  if (head === null) return null;\n  let p: Node | null = head;\n  while (p !== null) {\n    p.next = new Node(p.val, p.next, p.random);\n    p = p.next.next;\n  }\n  p = head.next;\n  while (p) {\n    if (p.random) p.random = p.random!.next;\n    p = p.next?.next ?? null;\n  }\n  const newHead: Node | null = head.next;\n  p = head;\n  while (p) {\n    const q: Node = p.next!;\n    p.next = q.next;\n    q.next = q.next?.next ?? null;\n    p = p.next;\n  }\n  return newHead;\n}"},{"date":"2021-07-22","time":104,"memory":39.7,"script":"typescript","desc":"节点复制。","code":"function copyRandomList(head: Node | null): Node | null {\n  if (head === null) return null;\n  let p: Node | null = head;\n  while (p) {\n    const next = p.next;\n    const newNode = new Node(p.val, next);\n    p.next = newNode;\n    p = next;\n  }\n  p = head;\n  while (p) {\n    const newNode = p.next;\n    newNode!.random = p.random?.next ?? null;\n    p = p.next!.next;\n  }\n  p = head;\n  const ans = head.next;\n  while (p) {\n    const next = p.next?.next ?? null;\n    const newNode = p.next!;\n    newNode.next = next?.next ?? null;\n    p.next = next;\n    p = next;\n  }\n  return ans;\n}"}],"tagList":["哈希表","链表"],"level":"Medium"}},{"problemName":"139.单词拆分.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/139.单词拆分.json","problemData":{"id":"139","name":"139.单词拆分","url":"https://leetcode.cn/problems/word-break","desc":"给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。","solutions":[{"date":"2020-06-25","time":96,"memory":38,"script":"typescript","desc":"dp[i]=dp[j]&&set.has(j,i-j)。","code":"function wordBreak(s: string, wordDict: string[]): boolean {\n  const len = s.length;\n  const wordSet = new Set(wordDict);\n  const dp = [true];\n  for (let i = 1; i <= len; i++)\n    for (let j = 0; j < i; j++)\n      if (dp[j] && wordSet.has(s.substr(j, i - j))) {\n        dp[i] = true;\n        break;\n      }\n  return dp[len] ? dp[len] : false;\n}"}],"tagList":["字典树","记忆化搜索","数组","哈希表","字符串","动态规划"],"level":"Medium"}},{"problemName":"141.环形链表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/141.环形链表.json","problemData":{"id":"141","name":"141.环形链表","url":"https://leetcode.cn/problems/linked-list-cycle","desc":"给定一个链表，判断链表中是否有环。","solutions":[{"date":"2020-02-13","time":0,"memory":47,"script":"java","desc":"使用快慢指针，若快指针与慢指针指向一个节点则存在。","code":"public class Solution {\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null)\n\t\t\treturn false;\n\t\tListNode slow = head;\n\t\tListNode fast = head.next;\n\t\twhile (fast != null && fast.next != null) {\n\t\t\tif (slow == fast)\n\t\t\t\treturn true;\n\t\t\tslow = slow.next;\n\t\t\tfast = fast.next.next;\n\t\t}\n\t\treturn false;\n    }\n}"},{"date":"2020-10-09","time":96,"memory":40,"script":"typescript","desc":"双指针。","code":"/**\n * @param {ListNode} head\n * @return {boolean}\n */\nvar hasCycle = function (head) {\n  let p1 = head;\n  let p2 = head;\n  while (p2?.next) {\n    p1 = p1.next;\n    p2 = p2.next.next;\n    if (p1 === p2) return true;\n  }\n  return false;\n};"},{"date":"2021-03-06","time":92,"memory":40.4,"script":"typescript","desc":"快慢指针。","code":"function hasCycle(head: ListNode | null): boolean {\n  if (head === null || head.next === null) return false;\n  let fast: ListNode | null = head.next;\n  let slow: ListNode | null = head;\n  while (fast !== slow && fast !== null && fast.next !== null) {\n    fast = fast.next.next;\n    slow = slow!.next;\n  }\n  return fast === slow;\n}"},{"date":"2021-11-19","time":12,"memory":7.7,"script":"c","desc":"快慢指针。","code":"bool hasCycle(struct ListNode *head) {\n    if(!head) return 0;\n    struct ListNode *slow = head;\n    struct ListNode *fast = head->next;\n    while (fast && fast->next && fast != slow) fast = fast->next->next, slow = slow->next;\n    return fast == slow;\n}"},{"date":"2022-03-03","time":8,"memory":8,"script":"cpp","desc":"双指针。","code":"class Solution {\n   public:\n    bool hasCycle(ListNode *head) {\n        if (!head) return false;\n        ListNode *fast = head->next, *slow = head;\n        while (fast && fast->next && fast != slow) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        return fast && fast->next;\n    }\n};"},{"script":"cpp","time":8,"memory":8,"desc":"快慢指针。","code":"class Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if (!head) return false;\n        ListNode *slow = head, *fast = head;\n        while (fast && fast->next && fast->next != slow) {\n            fast = fast->next->next;\n            slow = slow->next;\n        }\n        return fast && fast->next == slow;\n    }\n};","date":"2023-07-29"},{"script":"python","time":64,"memory":20.2,"desc":"同上。","code":"class Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        if not head:\n            return False\n        slow = fast = head\n        while fast and fast.next and fast.next != slow:\n            fast = fast.next.next\n            slow = slow.next\n        return fast and fast.next == slow","date":"2023-07-29"}],"tagList":["哈希表","链表","双指针"],"level":"Easy"}},{"problemName":"142.环形链表II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/142.环形链表II.json","problemData":{"id":"142","name":"142.环形链表II","url":"https://leetcode.cn/problems/linked-list-cycle-ii","desc":"给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。","solutions":[{"date":"2020-10-10","time":120,"memory":41.4,"script":"typescript","desc":"利用 set 去重。","code":"function detectCycle(head: ListNode | null): ListNode | null {\n  if (head === null || head.next === null) return null;\n  const set = new Set<ListNode>([head]);\n  let temp = head;\n  while (temp.next !== null) {\n    if (set.has(temp.next)) return temp.next;\n    set.add(temp.next);\n    temp = temp.next;\n  }\n  return null;\n}"},{"date":"2020-10-10","time":100,"memory":40.9,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode-solution/)。","code":"function detectCycle(head: ListNode | null): ListNode | null {\n  if (head === null) return null;\n  let f: ListNode | null = head;\n  let s: ListNode | null = head;\n  while (f !== null && f.next !== null) {\n    f = f.next.next;\n    s = s.next!;\n    if (f === s) {\n      let h: ListNode | null = head;\n      while (h !== s) {\n        h = h.next!;\n        s = s.next!;\n      }\n      return h;\n    }\n  }\n  return null;\n}"},{"date":"2021-03-06","time":104,"memory":40.8,"script":"typescript","desc":"快慢指针。","code":"function detectCycle(head: ListNode | null): ListNode | null {\n  if (head === null || head.next === null) return null;\n  let fast: ListNode | null = head;\n  let slow: ListNode | null = head;\n  while (fast !== null && fast.next !== null) {\n    fast = fast!.next!.next;\n    slow = slow!.next;\n    if (fast === slow) break;\n  }\n  if (fast !== slow) return null;\n  slow = head;\n  while (fast !== slow) {\n    fast = fast!.next;\n    slow = slow!.next;\n  }\n  return slow;\n}"},{"date":"2022-03-03","time":8,"memory":7.3,"script":"cpp","desc":"双指针， 快指针跑了 a+b+c+b 时，慢指针跑了 a+b。","code":"class Solution {\n   public:\n    ListNode *detectCycle(ListNode *head) {\n        if (!head) return NULL;\n        ListNode *fast = head, *slow = head;\n        while (fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n            if (fast == slow) break;\n        }\n        if (!(fast && fast->next)) return NULL;\n        slow = head;\n        while (slow != fast) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n        return slow;\n    }\n};"},{"script":"python","time":52,"memory":20.1,"desc":"同上。","code":"class Solution:\n    def detectCycle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        slow = fast = head\n        while fast and fast.next and fast.next != slow:\n            slow = slow.next\n            fast = fast.next.next\n        if not fast or not fast.next:\n            return None\n        slow = head\n        fast = fast.next.next\n        while fast != slow:\n            fast = fast.next\n            slow = slow.next\n        return slow","date":"2023-07-30"}],"tagList":["哈希表","链表","双指针"],"level":"Medium"}},{"problemName":"143.重排链表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/143.重排链表.json","problemData":{"id":"143","name":"143.重排链表","url":"https://leetcode.cn/problems/reorder-list","desc":"给定一个单链表 L：L0→L1→…→Ln-1→Ln ，将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…。","solutions":[{"date":"2020-10-20","time":208,"memory":47,"script":"typescript","desc":"利用队列前后取值进行重新赋值 next。","code":"function reorderList(head: ListNode | null): void {\n  if (head === null) return;\n  const queue: ListNode[] = [];\n  let temp: ListNode | null = head;\n  while (temp !== null) {\n    queue.push(temp);\n    temp = temp.next;\n  }\n  queue.shift();\n  let tag = true;\n  temp = head;\n  while (queue.length !== 0) {\n    temp.next = (tag = !tag) ? queue.shift()! : queue.pop()!;\n    temp = temp!.next;\n  }\n  temp.next = null;\n}"},{"script":"cpp","time":40,"memory":17.2,"desc":"找到中点，翻转后半部分，合并。","code":"class Solution {\npublic:\n    void reorderList(ListNode* head) {\n        // mid\n        ListNode *slow = head, *fast = head;\n        while (fast && fast->next) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n        // reverse\n        ListNode *last = slow->next;\n        if (!last) return;\n        while (last->next) {\n            ListNode *tmp = last->next;\n            last->next = tmp->next;\n            tmp->next = slow->next;\n            slow->next = tmp;\n        }\n        // merge\n        ListNode *l1 = head, *l2 = slow->next;\n        while (l1 && l2) {\n            ListNode *tmp1 = l1->next, *tmp2 = l2->next;\n            l1->next = l2;\n            l2->next = tmp1;\n            l1 = tmp1;\n            l2 = tmp2;\n        }\n        // last node\n        slow->next = nullptr;\n    }\n};","date":"2023-07-31"},{"script":"python","time":76,"memory":24.5,"desc":"同上。","code":"class Solution:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        last = slow.next\n        if not last:\n            return\n        while last.next:\n            tmp = last.next\n            last.next = tmp.next\n            tmp.next = slow.next\n            slow.next = tmp\n\n        l1 = head\n        l2 = slow.next\n        while l1 and l2:\n            tmp1 = l1.next\n            tmp2 = l2.next\n            l1.next = l2\n            l2.next = tmp1\n            l1 = tmp1\n            l2 = tmp2\n        slow.next = None","date":"2023-07-31"}],"tagList":["栈","递归","链表","双指针"],"level":"Medium"}},{"problemName":"144.二叉树的前序遍历.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/144.二叉树的前序遍历.json","problemData":{"id":"144","name":"144.二叉树的前序遍历","url":"https://leetcode.cn/problems/binary-tree-preorder-traversal","desc":"给定一个二叉树，返回它的前序遍历。","solutions":[{"date":"2020-02-21","time":0,"memory":37.8,"script":"java","desc":"递归。","code":"class Solution {\n\tpublic List<Integer> preorderTraversal(TreeNode root) {\n\t\tList<Integer> list = new LinkedList<Integer>();\n\t\tif (root == null)\n\t\t\treturn list;\n\t\tpreorder(root, list);\n\t\treturn list;\n\t}\n\n\tpublic void preorder(TreeNode node, List<Integer> list) {\n\t\tlist.add(node.val);\n\t\tif (node.left != null)\n\t\t\tpreorder(node.left,list);\n\t\tif (node.right != null)\n\t\t\tpreorder(node.right,list);\n\t}\n}"},{"date":"2020-02-21","time":1,"memory":38.2,"script":"java","desc":"迭代。","code":"class Solution {\n\tpublic List<Integer> preorderTraversal(TreeNode root) {\n\t\tList<Integer> list = new LinkedList<Integer>();\n\t\tif (root == null)\n\t\t\treturn list;\n\t\tStack<TreeNode> stack = new Stack<TreeNode>();\n\t\tstack.push(root);\n\t\twhile (!stack.isEmpty()) {\n\t\t\tTreeNode node = stack.pop();\n\t\t\tlist.add(node.val);\n\t\t\tif(node.right!=null)stack.push(node.right);\n\t\t\tif(node.left!=null)stack.push(node.left);\n\t\t}\n\t\treturn list;\n\t}\n}"},{"date":"2020-10-27","time":84,"memory":40.2,"script":"typescript","desc":"递归。","code":"function preorderTraversal(root: TreeNode | null): number[] {\n  const ans: number[] = [];\n  preorder(root);\n  return ans;\n  function preorder(root: TreeNode | null) {\n    if (root === null) return;\n    ans.push(root.val);\n    preorder(root.left);\n    preorder(root.right);\n  }\n}"},{"date":"2020-10-27","time":80,"memory":40.3,"script":"typescript","desc":"迭代。","code":"function preorderTraversal(root: TreeNode | null): number[] {\n  const ans: number[] = [];\n  if (root === null) return ans;\n  const stack: TreeNode[] = [root];\n  while (stack.length !== 0) {\n    const node = stack.pop()!;\n    ans.push(node.val);\n    node.right && stack.push(node.right);\n    node.left && stack.push(node.left);\n  }\n  return ans;\n}"},{"date":"2021-11-27","time":0,"memory":5.7,"script":"c","desc":"递归。","code":"// 先计算当前节点，再递归左，再递归右\nvoid preorder(struct TreeNode *root, int *arr, int *idx){\n    if (!root) return ;\n    arr[(*idx)++] = root->val;\n    preorder(root->left, arr, idx);\n    preorder(root->right, arr, idx);\n}\nint* preorderTraversal(struct TreeNode* root, int* returnSize){\n    int *arr = (int *)malloc(sizeof(int) * 100);\n    *returnSize = 0;\n    preorder(root, arr, returnSize);\n    return arr;\n}"},{"script":"python","time":34,"memory":16.38,"desc":"dfs。","code":"class Solution:\n    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        if not root: return []\n        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)","date":"2024-02-11"}],"tagList":["栈","树","深度优先搜索","二叉树"],"level":"Easy"}},{"problemName":"145.二叉树的后序遍历.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/145.二叉树的后序遍历.json","problemData":{"id":"145","name":"145.二叉树的后序遍历","url":"https://leetcode.cn/problems/binary-tree-postorder-traversal","desc":"给定一个二叉树，返回它的 后序 遍历。","solutions":[{"date":"2020-02-21","time":0,"memory":37.7,"script":"java","desc":"递归。","code":"class Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> list=new LinkedList<Integer>();\n        if(root!=null) {\n        \tpostorder(root, list);\n        }\n        return list;\n    }\n    public void postorder(TreeNode node,List<Integer> list) {\n    \tif(node.left!=null)postorder(node.left, list);\n    \tif(node.right!=null)postorder(node.right, list);\n    \tlist.add(node.val);\n    }\n}"},{"date":"2020-02-21","time":1,"memory":38.1,"script":"java","desc":"迭代。","code":"class Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        LinkedList<Integer> list=new LinkedList<Integer>();\n        if(root==null)return list;\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n        stack.push(root);\n        while(!stack.isEmpty()) {\n        \tTreeNode node = stack.pop();\n        \tlist.addFirst(node.val);\n        \tif(node.left!=null)stack.push(node.left);\n        \tif(node.right!=null)stack.push(node.right);\n        }\n        return list;\n    }\n}"},{"date":"2020-09-29","time":84,"memory":39.6,"script":"typescript","desc":"递归。","code":"function postorderTraversal(root: TreeNode | null): number[] {\n  const ans: number[] = [];\n  postOrder(root);\n  return ans;\n  function postOrder(root: TreeNode | null): void {\n    if (root === null) return;\n    root.left && postOrder(root.left);\n    root.right && postOrder(root.right);\n    ans.push(root.val);\n  }\n}"},{"date":"2020-09-29","time":96,"memory":39.8,"script":"typescript","desc":"迭代遍历。","code":"function postorderTraversal(root: TreeNode | null): number[] {\n  const ans: number[] = [];\n  if (root === null) return [];\n  const used = new Set<TreeNode>();\n  const stack: TreeNode[] = [root];\n  while (stack.length !== 0) {\n    const node = stack.pop()!;\n    if (used.has(node)) ans.push(node.val);\n    else {\n      stack.push(node);\n      node.right && stack.push(node.right);\n      node.left && stack.push(node.left);\n      used.add(node);\n    }\n  }\n  return ans;\n}"},{"date":"2021-03-19","time":100,"memory":39.5,"script":"typescript","desc":"递归遍历。","code":"function postorderTraversal(root: TreeNode | null): number[] {\n  const ans: number[] = [];\n  const preorder = (node: TreeNode | null): void => {\n    if (node === null) return;\n    preorder(node.left);\n    preorder(node.right);\n    ans.push(node.val);\n  };\n  preorder(root);\n  return ans;\n}"},{"date":"2021-11-27","time":0,"memory":5.7,"script":"c","desc":"递归。","code":"// 先递归左，再递归右，再计算当前节点\nvoid order(struct TreeNode *root, int *arr, int *idx){\n    if (!root) return ;\n    order(root->left, arr, idx);\n    order(root->right, arr, idx);\n    arr[(*idx)++] = root->val;\n}\nint* postorderTraversal(struct TreeNode* root, int* returnSize){\n    int *arr = (int *)malloc(sizeof(int) * 100);\n    *returnSize = 0;\n    order(root, arr, returnSize);\n    return arr;\n}"},{"script":"python","time":42,"memory":16.4,"desc":"dfs。","code":"class Solution:\n    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:\n        if not root: return []\n        return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]","date":"2024-02-12"}],"tagList":["栈","树","深度优先搜索","二叉树"],"level":"Easy"}},{"problemName":"146.LRU缓存.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/146.LRU缓存.json","problemData":{"id":"146","name":"146.LRU缓存","url":"https://leetcode.cn/problems/lru-cache","desc":"根据逆波兰表示法，求表达式的值。有效的运算符包括 +, -, \\*, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。","solutions":[{"date":"2020-05-25","time":228,"memory":47.8,"script":"typescript","desc":"利用哈希映射储存键值对，值为链表节点，利用链表的增删控制复杂度 O(1)。","code":"class LinkedNode {\n  public prev: LinkedNode = this;\n  public next: LinkedNode = this;\n  constructor(public key: number, public val: number, prev?: LinkedNode, next?: LinkedNode) {\n    if (prev !== undefined) this.prev = prev;\n    if (next !== undefined) this.next = next;\n  }\n}\nclass LRUCache {\n  cache = new Map<number, LinkedNode>();\n  firstNode: LinkedNode | null = null;\n  get lastNode(): LinkedNode | null {\n    return this.firstNode ? this.firstNode.prev : null;\n  }\n  get size(): number {\n    return this.cache.size;\n  }\n  constructor(public capacity: number) {}\n  get(key: number): number {\n    if (this.capacity === 0) return -1;\n    if (this.firstNode === null) return -1;\n    const node = this.cache.get(key);\n    if (node === undefined) return -1;\n    const { key: k, val: v } = node;\n    this.put(k, v);\n    return v;\n  }\n  put(key: number, value: number): void {\n    if (this.capacity === 0) {\n    } else if (this.firstNode === null || this.lastNode === null) {\n      const node = new LinkedNode(key, value);\n      this.cache.set(key, node);\n      this.firstNode = node;\n    } else if (this.cache.has(key)) {\n      const node: LinkedNode = this.cache.get(key)!;\n      node.val = value;\n      if (node === this.firstNode) this.firstNode = node.next;\n      node.prev.next = node.next;\n      node.next.prev = node.prev;\n      node.prev = this.lastNode;\n      node.next = this.firstNode;\n      this.lastNode.next = node;\n      this.firstNode.prev = node;\n    } else if (this.size < this.capacity) {\n      const node = new LinkedNode(key, value, this.lastNode, this.firstNode);\n      this.cache.set(key, node);\n      this.lastNode.next = node;\n      this.firstNode.prev = node;\n    } else {\n      const delNode = this.firstNode;\n      this.firstNode = delNode.next;\n      this.firstNode.prev = delNode.prev;\n      this.cache.delete(delNode.key);\n      this.put(key, value);\n    }\n  }\n}"},{"script":"python","time":544,"memory":73.81,"desc":"链表。","code":"class Node:\n        def __init__(self, key=0, val: int = 0, prev=None, next=None):\n            self.key = key\n            self.val = val\n            self.prev = prev\n            self.next = next\n    \n        def append(self, prev):\n            next = prev.next\n            prev.next, next.prev, self.prev, self.next = self, self, prev, next\n    \n        def remove(self):\n            if self.prev:\n                self.prev.next, self.next.prev = self.next, self.prev\n    \n    \n    class LRUCache:\n        def __init__(self, capacity: int):\n            self.cache = {}\n            self.capacity = capacity\n            self.size = 0\n            self.head = Node()\n            self.tail = Node()\n            self.head.next = self.tail\n            self.tail.prev = self.head\n    \n        def get(self, key: int) -> int:\n            if key not in self.cache:\n                return -1\n            node = self.cache[key]\n            node.remove()\n            node.append(self.head)\n            return node.val\n    \n        def put(self, key: int, value: int) -> None:\n            if key not in self.cache:\n                self.cache[key] = Node(key, value)\n                self.size += 1\n                if self.size > self.capacity:\n                    self.size -= 1\n                    del self.cache[self.tail.prev.key]\n                    self.tail.prev.remove()\n            node = self.cache[key]\n            node.val = value\n            node.remove()\n            node.append(self.head)","date":"2023-09-24"}],"tagList":["设计","哈希表","链表","双向链表"],"level":"Medium"}},{"problemName":"147.对链表进行插入排序.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/147.对链表进行插入排序.json","problemData":{"id":"147","name":"147.对链表进行插入排序","url":"https://leetcode.cn/problems/insertion-sort-list","desc":"对链表进行插入排序。","solutions":[{"date":"2020-11-20","time":128,"memory":41.5,"script":"typescript","desc":"遍历两次进行插入。","code":"function insertionSortList(head: ListNode | null): ListNode | null {\n  if (head === null) return null;\n  const tempHead = new ListNode(0, head);\n  let last = head;\n  let p = head.next;\n  last.next = null;\n  while (p !== null) {\n    const next = p.next;\n    add(p);\n    p = next;\n  }\n  return tempHead.next;\n  function add(node: ListNode): void {\n    let temp = tempHead;\n    const val = node.val;\n    while (temp.next !== null && temp.next !== last) {\n      if (temp.next.val < val) {\n        temp = temp.next;\n      } else {\n        node.next = temp.next;\n        temp.next = node;\n        return;\n      }\n    }\n    if (temp.next === last) {\n      if (last.val > val) {\n        node.next = temp.next;\n        temp.next = node;\n      } else {\n        last.next = node;\n        node.next = null;\n        last = node;\n      }\n    }\n  }\n}"}],"tagList":["链表","排序"],"level":"Medium"}},{"problemName":"148.排序链表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/148.排序链表.json","problemData":{"id":"148","name":"148.排序链表","url":"https://leetcode.cn/problems/sort-list","desc":"给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。","solutions":[{"date":"2020-11-21","time":156,"memory":53.5,"script":"typescript","desc":"利用内置排序算法。","code":"function sortList(head: ListNode | null): ListNode | null {\n  if (head == null) return null;\n  const arr: ListNode[] = [];\n  let temp: ListNode | null = head;\n  while (temp !== null) {\n    arr.push(temp);\n    temp = temp.next;\n  }\n  const len = arr.length;\n  arr\n    .sort(({ val: val1 }, { val: val2 }) => val1 - val2)\n    .forEach((node, i, arr) => {\n      node.next = arr[i + 1] ?? null;\n    });\n  return arr[0];\n}"},{"date":"2021-05-13","time":164,"memory":56.7,"script":"typescript","desc":"归并思想排序。","code":"function sortList(head: ListNode | null): ListNode | null {\n  if (head === null) return null;\n  const list: ListNode[] = [];\n  let p: ListNode | null = head;\n  while (p !== null) {\n    list.push(p);\n    p = p.next;\n  }\n  const len = list.length;\n  const sort = (start: number, end: number) => {\n    if (end - start < 2) return;\n    const mid = (start + end) >> 1;\n    sort(start, mid);\n    sort(mid, end);\n    merge(start, mid, end);\n  };\n  const merge = (start: number, mid: number, end: number) => {\n    const tempList = list.slice(start, mid);\n    let p1 = 0;\n    let p2 = mid;\n    let i = start;\n    while (p1 < mid - start) {\n      if (p2 >= end || tempList[p1].val <= list[p2].val) {\n        list[i++] = tempList[p1++];\n      } else {\n        list[i++] = list[p2++];\n      }\n    }\n  };\n  sort(0, len);\n  let i = 0;\n  for (; i < len - 1; i++) list[i].next = list[i + 1];\n  list[i].next = null;\n  return list[0];\n}"}],"tagList":["链表","双指针","分治","排序","归并排序"],"level":"Medium"}},{"problemName":"149.直线上最多的点数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/149.直线上最多的点数.json","problemData":{"id":"149","name":"149.直线上最多的点数","url":"https://leetcode.cn/problems/max-points-on-a-line","desc":"给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。","solutions":[{"date":"2021-06-24","time":152,"memory":49.7,"script":"typescript","desc":"储存下标进行判断数量。","code":"function maxPoints(points: number[][]): number {\n  const len = points.length;\n  if (len === 1) return 1;\n  const cacheKB: Record<string, Set<number>> = {};\n  const cacheX: Record<string, Set<number>> = {};\n  for (let i1 = 0; i1 < len; i1++) {\n    const [x1, y1] = points[i1];\n    for (let i2 = i1 + 1; i2 < len; i2++) {\n      const [x2, y2] = points[i2];\n      if (x1 === x2) {\n        let set = cacheX[x1];\n        if (!set) set = cacheX[x1] = new Set();\n        set.add(i1);\n        set.add(i2);\n      } else {\n        const k = (y1 - y2) / (x1 - x2);\n        const b = y1 - k * x1;\n        const str = `k=${k},b=${b}`;\n        let set = cacheKB[str];\n        if (!set) set = cacheKB[str] = new Set();\n        set.add(i1);\n        set.add(i2);\n      }\n    }\n  }\n  return Math.max(\n    ...Object.values(cacheKB).map(v => v.size),\n    ...Object.values(cacheX).map(v => v.size)\n  );\n}"}],"tagList":["几何","数组","哈希表","数学"],"level":"Hard"}},{"problemName":"150.逆波兰表达式求值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/150.逆波兰表达式求值.json","problemData":{"id":"150","name":"150.逆波兰表达式求值","url":"https://leetcode.cn/problems/evaluate-reverse-polish-notation","desc":"根据逆波兰表示法，求表达式的值。有效的运算符包括 +, -, \\*, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。","solutions":[{"date":"2020-02-13","time":20,"memory":46.8,"script":"java","desc":"使用栈，数字压栈，符号出栈。","code":"class Solution {\n    public int evalRPN(String[] tokens) {\n        Stack<String> stack = new Stack<String>();\n\t\tint a, b;\n\t\tfor (String s : tokens) {\n\t\t\tswitch (s) {\n\t\t\tcase \"+\":\n\t\t\t\ta = Integer.parseInt(stack.pop());\n\t\t\t\tb = Integer.parseInt(stack.pop());\n\t\t\t\tstack.push((a + b) + \"\");\n\t\t\t\tbreak;\n\t\t\tcase \"-\":\n\t\t\t\ta = Integer.parseInt(stack.pop());\n\t\t\t\tb = Integer.parseInt(stack.pop());\n\t\t\t\tstack.push((b - a) + \"\");\n\t\t\t\tbreak;\n\t\t\tcase \"*\":\n\t\t\t\ta = Integer.parseInt(stack.pop());\n\t\t\t\tb = Integer.parseInt(stack.pop());\n\t\t\t\tstack.push((a * b) + \"\");\n\t\t\t\tbreak;\n\t\t\tcase \"/\":\n\t\t\t\ta = Integer.parseInt(stack.pop());\n\t\t\t\tb = Integer.parseInt(stack.pop());\n\t\t\t\tstack.push((b / a) + \"\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstack.push(s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn Integer.parseInt(stack.pop());\n    }\n}"},{"date":"2021-03-20","time":724,"memory":48.2,"script":"typescript","desc":"栈。","code":"function evalRPN(tokens: string[]): number {\n  const opMap: Record<string, (num1: number, num2: number) => number> = {\n    '+': (num1, num2) => num1 + num2,\n    '-': (num1, num2) => num1 - num2,\n    '*': (num1, num2) => num1 * num2,\n    '/': (num1, num2) => ~~(num1 / num2),\n  };\n  const stack: number[] = [];\n  for (const token of tokens) {\n    console.log(token, stack);\n    if (token === '+' || token === '-' || token === '*' || token === '/') {\n      const num2 = stack.pop()!;\n      const num1 = stack.pop()!;\n      stack.push(opMap[token](num1, num2));\n    } else {\n      stack.push(Number(token));\n    }\n  }\n  return stack[0];\n}"},{"date":"2021-12-23","time":12,"memory":11.6,"script":"cpp","desc":"栈存储。","code":"class Solution {\n   public:\n    int s2i(string str) {\n        int ans = 0, f = 1;\n        for (int i = 0; i < str.size(); i++) {\n            if (i == 0 && str[i] == '-') {\n                f = -1;\n                continue;\n            }\n            ans = ans * 10 + str[i] - '0';\n        }\n        return ans * f;\n    }\n    int evalRPN(vector<string>& tokens) {\n        stack<int> s;\n        for (auto& str : tokens) {\n            if (str == \"+\" || str == \"-\" || str == \"*\" || str == \"/\") {\n                int num1 = s.top();\n                s.pop();\n                int num2 = s.top();\n                s.pop();\n                int ans;\n                if (str == \"+\")\n                    ans = num2 + num1;\n                else if (str == \"-\")\n                    ans = num2 - num1;\n                else if (str == \"*\")\n                    ans = num2 * num1;\n                else\n                    ans = num2 / num1;\n                s.push(ans);\n            } else {\n                s.push(s2i(str));\n            }\n        }\n        return s.top();\n    }\n};"}],"tagList":["栈","数组","数学"],"level":"Medium"}},{"problemName":"151.反转字符串中的单词.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/151.反转字符串中的单词.json","problemData":{"id":"151","name":"151.反转字符串中的单词","url":"https://leetcode.cn/problems/reverse-words-in-a-string","desc":"给定一个字符串，逐个翻转字符串中的每个单词。","solutions":[{"date":"2020-04-09","time":60,"memory":34.8,"script":"javascript","desc":"删除头尾空格，分割成数组，过滤空，翻转，组合字符串。","code":"/**\n * @param {string} s\n * @return {string}\n */\nvar reverseWords = s =>\n  s\n    .trim()\n    .split(' ')\n    .filter(v => v !== '')\n    .reverse()\n    .join(' ');"}],"tagList":["双指针","字符串"],"level":"Medium"}},{"problemName":"152.乘积最大子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/152.乘积最大子数组.json","problemData":{"id":"152","name":"152.乘积最大子数组","url":"https://leetcode.cn/problems/maximum-product-subarray","desc":"给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。","solutions":[{"date":"2020-05-18","time":72,"memory":36.1,"script":"javascript","desc":"dp[i]=以 i 结尾的最大乘积。","code":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxProduct = function (nums) {\n  const len = nums.length;\n  const zeroNum = nums[0];\n  if (len === 1) return zeroNum;\n  const dpMax = [zeroNum];\n  const dpMin = [zeroNum];\n  let max = zeroNum;\n  for (let i = 1; i < len; i++) {\n    const num = nums[i];\n    const prevMax = dpMax[i - 1] * num;\n    const prevMin = dpMin[i - 1] * num;\n    max = Math.max(\n      max,\n      (dpMax[i] = Math.max(num, prevMax, prevMin)),\n      (dpMin[i] = Math.min(num, prevMax, prevMin))\n    );\n  }\n  return max;\n};"},{"date":"2020-05-18","time":72,"memory":35.2,"script":"javascript","desc":"利用取模把数组大小控制在 2 个数量。","code":"var maxProduct = function (nums) {\n  const len = nums.length;\n  const zeroNum = nums[0];\n  if (len === 1) return zeroNum;\n  const dpMax = [zeroNum];\n  const dpMin = [zeroNum];\n  let max = zeroNum;\n  for (let i = 1; i < len; i++) {\n    const num = nums[i];\n    const prevMax = dpMax[(i - 1) % 2] * num;\n    const prevMin = dpMin[(i - 1) % 2] * num;\n    max = Math.max(\n      max,\n      (dpMax[i % 2] = Math.max(num, prevMax, prevMin)),\n      (dpMin[i % 2] = Math.min(num, prevMax, prevMin))\n    );\n  }\n  return max;\n};"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"153.寻找旋转排序数组中的最小值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/153.寻找旋转排序数组中的最小值.json","problemData":{"id":"153","name":"153.寻找旋转排序数组中的最小值","url":"https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array","desc":"给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。","solutions":[{"date":"2021-04-08","time":92,"memory":39.4,"script":"typescript","desc":"依次检测存在可能的值。","code":"function findMin(nums: number[]): number {\n  const len = nums.length;\n  for (let i = 1; i < len; i++) {\n    if (nums[i] < nums[i - 1]) return nums[i];\n  }\n  return nums[0];\n}"},{"date":"2021-04-08","time":92,"memory":39.4,"script":"typescript","desc":"利用 Math 直接比较。","code":"function findMin(nums: number[]): number {\n  return Math.min.apply({}, nums);\n}"},{"date":"2021-04-08","time":96,"memory":39.4,"script":"typescript","desc":"二分查找。","code":"function findMin(nums: number[]): number {\n  let left = 0;\n  let right = nums.length - 1;\n  while (left < right) {\n    const mid = ~~((left + right) / 2);\n    if (nums[mid] < nums[right]) right = mid;\n    else left = mid + 1;\n  }\n  return nums[left];\n}"}],"tagList":["数组","二分查找"],"level":"Medium"}},{"problemName":"154.寻找旋转排序数组中的最小值II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/154.寻找旋转排序数组中的最小值II.json","problemData":{"id":"154","name":"154.寻找旋转排序数组中的最小值II","url":"https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii","desc":"假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组  [0,1,2,4,5,6,7] 可能变为  [4,5,6,7,0,1,2] )。请找出其中最小的元素。","solutions":[{"date":"2020-07-22","time":84,"memory":38,"script":"typescript","desc":"二分查找。","code":"function findMin(numbers: number[]): number {\n  let last = numbers.length - 1;\n  const firstNum = numbers[0];\n  while (firstNum === numbers[last] && last !== 0) {\n    numbers.pop();\n    last--;\n  }\n  if (firstNum < numbers[last]) return firstNum;\n  else if (last === 0) return firstNum;\n  else return _find(0, last);\n  function _find(l: number, r: number): number {\n    // console.log(`[find],l=${l},r=${r}`);\n    if (l === r) return numbers[l];\n    const mid = (l + r) >> 1;\n    const num = numbers[mid];\n    return num >= firstNum ? _find(mid + 1, r) : _find(l, mid);\n  }\n}"},{"date":"2021-04-09","time":92,"memory":39.4,"script":"typescript","desc":"直接利用 Math。","code":"function findMin(nums: number[]): number {\n  return Math.min.apply({}, nums);\n}"},{"date":"2021-04-09","time":96,"memory":39.4,"script":"typescript","desc":"如果相等时排除右侧端点。","code":"function findMin(nums: number[]): number {\n  let left = 0;\n  let right = nums.length - 1;\n  while (left < right) {\n    const mid = ~~((left + right) / 2);\n    if (nums[mid] < nums[right]) {\n      right = mid;\n    } else if (nums[mid] > nums[right]) {\n      left = mid + 1;\n    } else {\n      right--;\n    }\n  }\n  return nums[left];\n}"}],"tagList":["数组","二分查找"],"level":"Hard"}},{"problemName":"155.最小栈.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/155.最小栈.json","problemData":{"id":"155","name":"155.最小栈","url":"https://leetcode.cn/problems/min-stack","desc":"设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。","solutions":[{"date":"2020-05-12","time":156,"memory":45.6,"script":"javascript","desc":"优化检索为 O1。","code":"/**\n * initialize your data structure here.\n */\nclass MinStack {\n  _arr = [];\n  _min = [];\n  /**\n   * @param {number} x\n   * @return {void}\n   */\n  push(x) {\n    this._arr.push(x);\n    const arrLen = this._arr.length - 1;\n    if (this._min.length === 0) this._min.push(0);\n    else {\n      for (let i = 0, len = this._min.length; i < len; i++) {\n        if (this._arr[this._min[i]] > x) {\n          this._min.splice(i, 0, arrLen);\n          return;\n        }\n      }\n      this._min.push(arrLen);\n    }\n  }\n  /**\n   * @return {void}\n   */\n  pop() {\n    this._min = this._min.filter(arrIndex => arrIndex !== this._arr.length - 1);\n    this._arr.pop();\n  }\n  /**\n   * @return {number}\n   */\n  top() {\n    return this._arr[this._arr.length - 1];\n  }\n  /**\n   * @return {number}\n   */\n  getMin() {\n    return this._arr[this._min[0]];\n  }\n}"},{"date":"2021-07-19","time":112,"memory":46,"script":"typescript","desc":"储存单调栈。","code":"class MinStack {\n  private stack: number[] = [];\n  private get topStack() {\n    return this.stack[this.stack.length - 1];\n  }\n  private minStack: number[] = [];\n  private get topMinStack() {\n    return this.minStack[this.minStack.length - 1];\n  }\n  push(val: number): void {\n    this.stack.push(val);\n    if (this.minStack.length === 0 || this.topMinStack >= val) this.minStack.push(val);\n  }\n  pop(): void {\n    if (this.topStack === this.topMinStack) this.minStack.pop();\n    this.stack.pop();\n  }\n  top(): number {\n    return this.topStack;\n  }\n  getMin(): number {\n    return this.topMinStack;\n  }\n}"}],"tagList":["栈","设计"],"level":"Medium"}},{"problemName":"160.相交链表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/160.相交链表.json","problemData":{"id":"160","name":"160.相交链表","url":"https://leetcode.cn/problems/intersection-of-two-linked-lists","desc":"给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。","solutions":[{"date":"2021-06-04","time":128,"memory":46.9,"script":"typescript","desc":"利用 set 储存。","code":"function getIntersectionNode(headA: ListNode | null, headB: ListNode | null): ListNode | null {\n  if (headA === null || headB === null) return null;\n  const setA = new Set<ListNode>();\n  const setB = new Set<ListNode>();\n  let pA: ListNode | null = headA;\n  let pB: ListNode | null = headB;\n  while (pA !== null && pB !== null) {\n    setA.add(pA);\n    setB.add(pB);\n    if (setB.has(pA)) return pA;\n    if (setA.has(pB)) return pB;\n    pA = pA.next;\n    pB = pB.next;\n  }\n  while (pA !== null) {\n    if (setB.has(pA)) return pA;\n    pA = pA.next;\n  }\n  while (pB !== null) {\n    if (setA.has(pB)) return pB;\n    pB = pB.next;\n  }\n  return null;\n}"},{"date":"2021-11-19","time":36,"memory":13.5,"script":"c","desc":"双指针。","code":"struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\n    struct ListNode *a = headA, *b = headB;\n    while(a != b){\n        a = a ? a->next : headB;\n        b = b ? b->next : headA;\n    }\n    return a;\n}"},{"date":"2021-11-19","time":36,"memory":13.5,"script":"c","desc":"双指针。","code":"struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {\n    struct ListNode *a = headA, *b = headB;\n    while(a != b){\n        a = a ? a->next : headB;\n        b = b ? b->next : headA;\n    }\n    return a;\n}"}],"tagList":["哈希表","链表","双指针"],"level":"Easy"}},{"problemName":"162.寻找峰值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/162.寻找峰值.json","problemData":{"id":"162","name":"162.寻找峰值","url":"https://leetcode.cn/problems/find-peak-element","desc":"给你一个整数数组 nums，找到峰值元素并返回其索引。","solutions":[{"date":"2021-09-15","time":68,"memory":39.6,"script":"javascript","desc":"On 循环。","code":"function findPeakElement(nums: number[]): number {\n  const n = nums.length;\n  if (n === 1) return 0;\n  if (nums[0] > nums[1]) return 0;\n  if (nums[n - 1] > nums[n - 2]) return n - 1;\n  for (let i = 1; i <= n - 1; i++) {\n    if (nums[i] > nums[i - 1] && nums[i] > nums[i + 1]) return i;\n  }\n  return 0;\n}"},{"date":"2021-09-15","time":76,"memory":39.4,"script":"javascript","desc":"二分查找。","code":"function findPeakElement(nums: number[]): number {\n  let l = 0;\n  let r = nums.length - 1;\n  while (l < r) {\n    const mid = (l + r) >> 1;\n    if (nums[mid] > nums[mid + 1]) r = mid;\n    else l = mid + 1;\n  }\n  return l;\n}"},{"script":"python","time":44,"memory":16.06,"desc":"遍历。","code":"class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        n = len(nums)\n        for i in range(1, n - 1):\n            if nums[i - 1] < nums[i] > nums[i + 1]:\n                return i\n        return max((nums[i], i) for i in range(n))[1]","date":"2023-12-18"},{"script":"python","time":40,"memory":16.1,"desc":"二分。","code":"class Solution:\n    def findPeakElement(self, nums: List[int]) -> int:\n        l, r = 0, len(nums) - 1\n        while l < r:\n            m = (l + r) // 2\n            if nums[m] > nums[m + 1]: r = m\n            else: l = m + 1\n        return l","date":"2023-12-18"}],"tagList":["数组","二分查找"],"level":"Medium"}},{"problemName":"164.最大间距.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/164.最大间距.json","problemData":{"id":"164","name":"164.最大间距","url":"https://leetcode.cn/problems/maximum-gap","desc":"给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。","solutions":[{"date":"2020-11-26","time":88,"memory":40.3,"script":"typescript","desc":"排序后遍历。","code":"function maximumGap(nums: number[]): number {\n  if (nums.length < 2) return 0;\n  return nums\n    .sort((a, b) => a - b)\n    .reduce((total, cur, i, arr) => (i === 0 ? total : Math.max(total, cur - arr[i - 1])), 0);\n}"}],"tagList":["数组","桶排序","基数排序","排序"],"level":"Medium"}},{"problemName":"165.比较版本号.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/165.比较版本号.json","problemData":{"id":"165","name":"165.比较版本号","url":"https://leetcode.cn/problems/compare-version-numbers","desc":"给你两个版本号 version1 和 version2 ，请你比较它们。","solutions":[{"date":"2021-09-01","time":76,"memory":39.4,"script":"typescript","desc":"格式化后比较。","code":"function compareVersion(version1: string, version2: string): number {\n  const v1 = version1.split('.').map(v => +v);\n  const v2 = version2.split('.').map(v => +v);\n  const len = Math.max(v1.length, v2.length);\n  while (v1.length < len) v1.push(0);\n  while (v2.length < len) v2.push(0);\n  let i = 0;\n  while (i < len) {\n    if (v1[i] < v2[i]) return -1;\n    if (v1[i] > v2[i]) return 1;\n    i++;\n  }\n  return 0;\n}"}],"tagList":["双指针","字符串"],"level":"Medium"}},{"problemName":"166.分数到小数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/166.分数到小数.json","problemData":{"id":"166","name":"166.分数到小数","url":"https://leetcode.cn/problems/fraction-to-recurring-decimal","desc":"给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。","solutions":[{"date":"2021-10-04","time":72,"memory":39.6,"script":"typescript","desc":"长除法，储存余数。","code":"function fractionToDecimal(numerator: number, denominator: number): string {\n  let flag = '';\n  if (numerator * denominator < 0) flag = '-';\n  numerator = Math.abs(numerator);\n  denominator = Math.abs(denominator);\n  const integer = `${flag}${Math.floor(numerator / denominator)}`;\n  let mod = numerator % denominator;\n  if (mod === 0) return `${integer}`;\n  const map: Record<number, [number, number]> = {};\n  let decimal = '';\n  numerator = mod;\n  while (true) {\n    numerator *= 10;\n    const num = ~~(numerator / denominator);\n    mod = numerator % denominator;\n    if (map[mod] !== undefined && map[mod][0] === num) break;\n    decimal += num;\n    map[mod] = [num, decimal.length - 1];\n    if (mod === 0) break;\n    numerator = mod;\n  }\n  if (mod === 0) return `${integer}.${decimal}`;\n  const [, idx] = map[mod];\n  if (idx === 0) return `${integer}.(${decimal})`;\n  return `${integer}.${decimal.substr(0, idx)}(${decimal.substr(idx)})`;\n}"}],"tagList":["哈希表","数学","字符串"],"level":"Medium"}},{"problemName":"167.两数之和II-输入有序数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/167.两数之和II-输入有序数组.json","problemData":{"id":"167","name":"167.两数之和II-输入有序数组","url":"https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted","desc":"给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。","solutions":[{"date":"2020-07-20","time":108,"memory":38.1,"script":"typescript","desc":"二分查找。","code":"function twoSum(numbers: number[], target: number): number[] {\n  const len = numbers.length;\n  for (let i = 0; i < len; i++) {\n    const index = _find(target - numbers[i], i + 1);\n    if (index !== -1) return [i + 1, index + 1];\n  }\n  return [];\n  function _find(num: number, l: number = 0, r: number = len): number {\n    if (l >= r) return -1;\n    const mid = (l + r) >> 1;\n    const val = numbers[mid];\n    if (val < num) return _find(num, mid + 1, r);\n    else if (val > num) return _find(num, l, mid);\n    else return mid;\n  }\n}"},{"script":"cpp","time":8,"memory":15.2,"desc":"二分。","code":"class Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        int n = numbers.size();\n        for (int i = 0; i < n; i++) {\n            int l = i + 1, r = n;\n            while (l < r) {\n                int m = (l + r) / 2, val = numbers[m] + numbers[i];\n                if (val < target) l = m + 1;\n                else r = m;\n            }\n            if (l != n && numbers[i] + numbers[l] == target) return { i + 1, l + 1};\n        }\n        return {};\n    }\n};","date":"2023-07-08"},{"script":"python","time":112,"memory":17.1,"desc":"同上。","code":"class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        n = len(numbers)\n        for i in range(n):\n            l = i + 1\n            r = n\n            while l < r:\n                m = (l + r) // 2\n                val = numbers[i] + numbers[m]\n                if val < target:\n                    l = m + 1\n                else:\n                    r = m\n            if l != n and numbers[i] + numbers[l] == target:\n                return [i+1, l+1]\n        return []","date":"2023-07-08"},{"script":"rust","time":4,"memory":2.1,"desc":"同上。","code":"impl Solution {\n    pub fn two_sum(numbers: Vec<i32>, target: i32) -> Vec<i32> {\n        let n = numbers.len();\n        for i in 0..n {\n            let mut l = i + 1;\n            let mut r = n;\n            while l < r {\n                let m = (l + r) / 2;\n                let val = numbers[i] + numbers[m];\n                if val < target {\n                    l = m + 1;\n                } else {\n                    r = m;\n                }\n            }\n            if l != n && numbers[i] + numbers[l] == target {\n                return vec![(i as i32) + 1, (l as i32) + 1];\n            }\n        }\n        return vec![];\n    }\n}","date":"2023-07-08"}],"tagList":["数组","双指针","二分查找"],"level":"Medium"}},{"problemName":"168.Excel表列名称.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/168.Excel表列名称.json","problemData":{"id":"168","name":"168.Excel表列名称","url":"https://leetcode.cn/problems/excel-sheet-column-title","desc":"给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。","solutions":[{"date":"2021-06-29","time":96,"memory":39.2,"script":"typescript","desc":"逐个检索。","code":"function convertToTitle(columnNumber: number): string {\n  let ans = '';\n  const getChar = (num: number) => String.fromCodePoint(num + 65);\n  while (columnNumber-- !== 0) {\n    ans = getChar(columnNumber % 26) + ans;\n    columnNumber = ~~(columnNumber / 26);\n  }\n  return ans;\n}"}],"tagList":["数学","字符串"],"level":"Easy"}},{"problemName":"169.多数元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/169.多数元素.json","problemData":{"id":"169","name":"169.多数元素","url":"https://leetcode.cn/problems/majority-element","desc":"给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。","solutions":[{"date":"2022-03-14","time":8,"memory":19,"script":"cpp","desc":"遍历时，储存一个数维护这个数当前的数量。","code":"class Solution {\n   public:\n    int majorityElement(vector<int> &nums) {\n        int num = 0, cnt = 0;\n        for (auto &it : nums) {\n            if (cnt == 0) {\n                num = it;\n                cnt = 1;\n            } else if (num == it) {\n                cnt++;\n            } else {\n                cnt--;\n            }\n        }\n        return num;\n    }\n};"}],"tagList":["数组","哈希表","分治","计数","排序"],"level":"Easy"}},{"problemName":"171.Excel表列序号.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/171.Excel表列序号.json","problemData":{"id":"171","name":"171.Excel表列序号","url":"https://leetcode.cn/problems/excel-sheet-column-number","desc":"给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回该列名称对应的列序号。","solutions":[{"date":"2021-07-30","time":112,"memory":39.4,"script":"typescript","desc":"按照二十六进制计算。","code":"function titleToNumber(columnTitle: string): number {\n  let ans = 0;\n  for (let i = columnTitle.length - 1, bit = 0; i >= 0; i--, bit++) {\n    const num = columnTitle.codePointAt(i)! - 'A'.codePointAt(0)! + 1;\n    ans += num * 26 ** bit;\n  }\n  return ans;\n}"}],"tagList":["数学","字符串"],"level":"Easy"}},{"problemName":"172.阶乘后的零.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/172.阶乘后的零.json","problemData":{"id":"172","name":"172.阶乘后的零","url":"https://leetcode.cn/problems/factorial-trailing-zeroes","desc":"给定一个整数 n，返回 n! 结果尾数中零的数量。","solutions":[{"date":"2021-07-29","time":72,"memory":39.1,"script":"javascript","desc":"只有 2\\*5 才会出现 0，统计出现 5 的次数。","code":"var trailingZeroes = function (n) {\n  let ans = 0;\n  let m = 5;\n  while (n / m) {\n    ans += ~~(n / m);\n    m *= 5;\n  }\n  return ans;\n};"},{"date":"2022-03-25","time":0,"memory":6,"script":"cpp","desc":"统计有几个 5。","code":"class Solution {\n   public:\n    int trailingZeroes(int n) {\n        int ans = 0;\n        for (int cnt = 1; pow(5, cnt) <= n; cnt++) ans += n / pow(5, cnt);\n        return ans;\n    }\n};"}],"tagList":["数学"],"level":"Medium"}},{"problemName":"173.二叉搜索树迭代器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/173.二叉搜索树迭代器.json","problemData":{"id":"173","name":"173.二叉搜索树迭代器","url":"https://leetcode.cn/problems/binary-search-tree-iterator","desc":"实现一个二叉搜索树迭代器。你将使用二叉搜索树的根节点初始化迭代器。","solutions":[{"date":"2020-02-24","time":30,"memory":44.8,"script":"java","desc":"中序遍历后储存到队列里。","code":"class BSTIterator {\n    Queue<Integer> queue = new LinkedList<Integer>();\n    public BSTIterator(TreeNode root) {\n        if(root!=null)\n        inorder(root);\n    }\n    public int next() {\n        return queue.poll();\n    }\n    public boolean hasNext() {\n        return !queue.isEmpty();\n    }\n    public void inorder(TreeNode node) {\n        if (node.left != null)\n            inorder(node.left);\n            queue.add(node.val);\n        if (node.right != null)\n            inorder(node.right);\n    }\n}"},{"date":"2021-03-28","time":144,"memory":49.6,"script":"typescript","desc":"中序遍历存入数组。","code":"class BSTIterator {\n  private arr: number[] = [];\n  constructor(root: TreeNode | null) {\n    this.inorder(root);\n  }\n  next(): number {\n    return this.arr.shift()!;\n  }\n  hasNext(): boolean {\n    return this.arr.length > 0;\n  }\n  private inorder(node: TreeNode | null): void {\n    if (node === null) return;\n    this.inorder(node.left);\n    this.arr.push(node.val);\n    this.inorder(node.right);\n  }\n}"}],"tagList":["栈","树","设计","二叉搜索树","二叉树","迭代器"],"level":"Medium"}},{"problemName":"174.地下城游戏.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/174.地下城游戏.json","problemData":{"id":"174","name":"174.地下城游戏","url":"https://leetcode.cn/problems/dungeon-game","desc":"一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由  M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。","solutions":[{"date":"2020-07-12","time":80,"memory":37.3,"script":"typescript","desc":"dp[i][j]=i,j 坐标时需要的最小生命值，逆向推导 dp[0][0]。","code":"function calculateMinimumHP(dungeon: number[][]): number {\n  const n = dungeon.length;\n  const m = dungeon[0].length;\n  const dp = new Array(n + 1).fill(0).map(_ => new Array(m + 1).fill(Infinity));\n  dp[n][m - 1] = dp[n - 1][m] = 1;\n  for (let i = n - 1; i >= 0; --i) {\n    for (let j = m - 1; j >= 0; --j) {\n      dp[i][j] = Math.max(Math.min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1);\n    }\n  }\n  return dp[0][0];\n}"}],"tagList":["数组","动态规划","矩阵"],"level":"Hard"}},{"problemName":"179.最大数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/179.最大数.json","problemData":{"id":"179","name":"179.最大数","url":"https://leetcode.cn/problems/largest-number","desc":"给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。","solutions":[{"date":"2020-04-22","time":116,"memory":36.4,"script":"javascript","desc":"定义排序规则，先判断最大位，位数不相同又一次判断。","code":"/**\n * @param {number[]} nums\n * @return {string}\n */\nvar largestNumber = function (nums) {\n  let spliltNums = [];\n  for (const num of nums) {\n    spliltNums.push(numSpilt(num));\n  }\n  spliltNums = spliltNums.sort(sortFn);\n  return arrJoin(spliltNums);\n};\nfunction numSpilt(num) {\n  if (num === 0) {\n    return [0];\n  }\n  const splitArr = [];\n  while (num !== 0) {\n    splitArr.push(num % 10);\n    num = Math.floor(num / 10);\n  }\n  return splitArr.reverse();\n}\nfunction arrJoin(arr) {\n  let res = arr.map(value => value.join('')).join('');\n  while (res[0] === '0' && res.length !== 1) {\n    res = res.substr(1);\n  }\n  return res;\n}\nfunction sortFn(num1, num2) {\n  const len1 = num1.length;\n  const len2 = num2.length;\n  let minLen = Math.min(len1, len2);\n  for (let i = 0; i < minLen; i++) {\n    if (num2[i] !== num1[i]) {\n      return num2[i] - num1[i];\n    }\n  }\n  if (len1 === len2) return 0;\n  if (minLen === len1) {\n    const lNum = num2[minLen];\n    for (let i = 0; i < minLen; i++) {\n      const comp = num2[i];\n      if (lNum !== comp) return lNum - comp;\n    }\n    const llNum = num2[minLen + 1];\n    if (num2[minLen + 1] !== lNum) {\n      return llNum - lNum;\n    }\n    return -1;\n  } else {\n    const lNum = num1[minLen];\n    for (let i = 0; i < minLen; i++) {\n      const comp = num1[i];\n      if (lNum !== comp) return comp - lNum;\n    }\n    const llNum = num1[minLen + 1];\n    if (num1[minLen + 1] !== lNum) {\n      return lNum - llNum;\n    }\n    return 1;\n  }\n}"},{"date":"2021-04-12","time":96,"memory":39.2,"script":"typescript","desc":"合并两个字符串进行比较。","code":"function largestNumber(nums: number[]): string {\n  const getCount = (num: number): number => {\n    if (num === 0) return 1;\n    let c = 0;\n    while (num) {\n      num = ~~(num / 10);\n      cpp;\n    }\n    return c;\n  };\n  nums.sort((num1, num2) => {\n    const count1 = getCount(num1);\n    const count2 = getCount(num2);\n    const left = num1 * 10 ** count2 + num2;\n    const right = num2 * 10 ** count1 + num1;\n    return right - left;\n  });\n  return nums[0] === 0 ? '0' : nums.join('');\n}"}],"tagList":["贪心","数组","字符串","排序"],"level":"Medium"}},{"problemName":"187.重复的DNA序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/187.重复的DNA序列.json","problemData":{"id":"187","name":"187.重复的DNA序列","url":"https://leetcode.cn/problems/repeated-dna-sequences","desc":"编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。","solutions":[{"date":"2021-07-24","time":92,"memory":50.4,"script":"typescript","desc":"遍历所欲子串。","code":"function findRepeatedDnaSequences(s: string): string[] {\n  const set = new Set<string>();\n  const ans = new Set<string>();\n  for (let i = 0, l = s.length; i <= l - 10; i++) {\n    const subStr = s.substr(i, 10);\n    if (set.has(subStr)) ans.add(subStr);\n    else set.add(subStr);\n  }\n  return [...ans];\n}"},{"date":"2021-10-08","time":128,"memory":52.1,"script":"typescript","desc":"滑动窗口。","code":"function findRepeatedDnaSequences(s: string): string[] {\n  const set = new Set<string>();\n  const window = s.substr(0, 10).split('');\n  set.add(window.join(''));\n  const ans = new Set<string>();\n  for (let i = 10, l = s.length; i < l; i++) {\n    window.shift();\n    window.push(s[i]);\n    const str = window.join('');\n    if (set.has(str)) ans.add(str);\n    set.add(str);\n  }\n  return [...ans];\n}"},{"date":"2021-10-08","time":80,"memory":50.6,"script":"typescript","desc":"滑动窗口。","code":"function findRepeatedDnaSequences(s: string): string[] {\n  const set = new Set<string>();\n  let str = s.substr(0, 10);\n  set.add(str);\n  const ans = new Set<string>();\n  for (let i = 10, l = s.length; i < l; i++) {\n    str = str.substring(1) + s[i];\n    if (set.has(str)) ans.add(str);\n    set.add(str);\n  }\n  return [...ans];\n}"},{"script":"python","time":80,"memory":28.48,"desc":"哈希存储。","code":"class Solution:\n    def findRepeatedDnaSequences(self, s: str) -> List[str]:\n        res = []\n        m = Counter()\n        for i in range(len(s) - 9):\n            subs = s[i: i + 10]\n            m[subs] += 1\n            if m[subs] == 2: res.append(subs)\n        return res","date":"2023-11-05"}],"tagList":["位运算","哈希表","字符串","滑动窗口","哈希函数","滚动哈希"],"level":"Medium"}},{"problemName":"188.买卖股票的最佳时机IV.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/188.买卖股票的最佳时机IV.json","problemData":{"id":"188","name":"188.买卖股票的最佳时机IV","url":"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv","desc":"设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。","solutions":[{"date":"2020-12-28","script":"typescript","time":120,"memory":44.6,"desc":"dp。","code":"function maxProfit(k: number, prices: number[]): number {\n    const len = prices.length;\n    if (len === 0) return 0;\n    k = Math.min(~~(len / 2), k);\n    const buy = new Array(len).fill(0).map(() => new Array(k + 1).fill(0));\n    const sell = new Array(len).fill(0).map(() => new Array(k + 1).fill(0));\n    [buy[0][0], sell[0][0]] = [-prices[0], 0];\n    for (let i = 1; i <= k; ++i) buy[0][i] = sell[0][i] = -Number.MAX_VALUE;\n    for (let i = 1; i < len; ++i) {\n      const price = prices[i];\n      const prevBuy = buy[i - 1];\n      const prevSell = sell[i - 1];\n      buy[i][0] = Math.max(prevBuy[0], prevSell[0] - price);\n      for (let j = 1; j <= k; ++j) {\n        buy[i][j] = Math.max(prevBuy[j], prevSell[j] - price);\n        sell[i][j] = Math.max(prevSell[j], prevBuy[j - 1] + price);\n      }\n    }\n    return Math.max(...sell[len - 1]);\n}"},{"script":"python","time":256,"memory":31.78,"desc":"dp[i][j][k]表示i天j笔手上有无。","code":"class Solution:\n    def maxProfit(self, k: int, prices: List[int]) -> int:\n        n = len(prices)\n        # [i][j][k] i天j笔手上有无\n        dp = [[[-inf for _ in range(2)] for _ in range(k + 1)] for _ in range(n + 1)]\n        nums = [[-inf for _ in range(2)] for _ in range(k + 1)]\n        res = dp[0][0][0] = dp[0][0][1] = nums[0][0] = 0\n        for i in range(0, n):\n            dp[i][0][0] = 0\n            dp[i][0][1] = -prices[i]\n            for j in range(1, k + 1):\n                dp[i][j][0] = nums[j - 1][1] + prices[i]\n                dp[i][j][1] = nums[j][0] - prices[i]\n                res = max(res, dp[i][j][0])\n            for j in range(0, k + 1):\n                nums[j][0] = max(nums[j][0], dp[i][j][0])\n                nums[j][1] = max(nums[j][1], dp[i][j][1])\n        return res\n","date":"2023-10-04"}],"tagList":["数组","动态规划"],"level":"Hard"}},{"problemName":"189.轮转数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/189.轮转数组.json","problemData":{"id":"189","name":"189.轮转数组","url":"https://leetcode.cn/problems/rotate-array","desc":"给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。","solutions":[{"date":"2021-01-08","time":140,"memory":41,"script":"typescript","desc":"尾部弹出,插入头部。","code":"function rotate(nums: number[], k: number): void {\n  if (nums.length === 0) return;\n  while (k-- !== 0) {\n    nums.unshift(nums.pop()!);\n  }\n}"},{"date":"2021-01-08","time":96,"memory":41,"script":"typescript","desc":"翻转三次数组。","code":"function rotate(nums: number[], k: number): void {\n  const len = nums.length;\n  if (len === 0) return;\n  const reverse = (start: number, end: number) => {\n    while (start < end) {\n      const temp = nums[start];\n      nums[start++] = nums[end];\n      nums[end--] = temp;\n    }\n  };\n  k %= len;\n  reverse(0, len - 1);\n  reverse(0, k - 1);\n  reverse(k, len - 1);\n}"}],"tagList":["数组","数学","双指针"],"level":"Medium"}},{"problemName":"190.颠倒二进制位.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/190.颠倒二进制位.json","problemData":{"id":"190","name":"190.颠倒二进制位","url":"https://leetcode.cn/problems/reverse-bits","desc":"颠倒给定的 32 位无符号整数的二进制位。","solutions":[{"date":"2021-03-29","time":156,"memory":39.5,"script":"typescript","desc":"拆分二进制进行倒置。","code":"function reverseBits(n: number): number {\n  const bits = n.toString(2).split('');\n  while (bits.length < 32) bits.unshift('0');\n  return parseInt(bits.reverse().join(''), 2);\n}"},{"date":"2021-03-29","time":96,"memory":36.5,"script":"typescript","desc":"或运算进行逐一赋值。","code":"function reverseBits(n: number): number {\n  let ans = 0;\n  for (let i = 0; i < 32 && n !== 0; i++) {\n    ans |= (n & 1) << (31 - i);\n    n >>= 1;\n  }\n  return ans >>> 0;\n}"},{"date":"2021-07-30","time":88,"memory":39.6,"script":"typescript","desc":"二进制逐位倒序赋值。","code":"function reverseBits(n: number): number {\n  let ans = 0;\n  for (let i = 0; i < 32 && n > 0; i++) {\n    ans |= (n & 1) << (31 - i);\n    n >>>= 1;\n  }\n  return ans >>> 0;\n}"}],"tagList":["位运算","分治"],"level":"Easy"}},{"problemName":"191.位1的个数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/191.位1的个数.json","problemData":{"id":"191","name":"191.位1的个数","url":"https://leetcode.cn/problems/number-of-1-bits","desc":"编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。","solutions":[{"date":"2021-03-22","time":112,"memory":39.8,"script":"typescript","desc":"拆分字符串进行统计。","code":"function hammingWeight(n: number): number {\n  return n\n    .toString(2)\n    .split('')\n    .filter(v => v === '1').length;\n}"},{"date":"2021-03-22","time":104,"memory":39.7,"script":"typescript","desc":"二进制位移计算。","code":"function hammingWeight(n: number): number {\n  let ans = 0;\n  for (let i = 0; i < 32; i++) ans += n & (1 << i) ? 1 : 0;\n  return ans;\n}"},{"date":"2021-03-22","time":100,"memory":39.4,"script":"typescript","desc":"利用(n&n-1)可以去除末尾 1 的方式进行统计。","code":"function hammingWeight(n: number): number {\n  let ans = 0;\n  while (n) {\n    n &= n - 1;\n    ans++;\n  }\n  return ans;\n}"}],"tagList":["位运算","分治"],"level":"Easy"}},{"problemName":"198.打家劫舍.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/198.打家劫舍.json","problemData":{"id":"198","name":"198.打家劫舍","url":"https://leetcode.cn/problems/house-robber","desc":"你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。","solutions":[{"date":"2020-04-22","time":68,"memory":32.4,"script":"typescript","desc":"dp[i]=Math.max(dp[i-2]+nums[i],dp[i+1]);。","code":"var rob = function (nums: number[]): number {\n  const dp = [0, 0];\n  const len = nums.length;\n  for (let i = 0; i < len; i++) dp[i + 2] = Math.max(dp[i] + nums[i], dp[i + 1]);\n  return dp[len + 1];\n};"},{"date":"2021-09-04","time":68,"memory":39.6,"script":"typescript","desc":"动态规划。","code":"function rob(nums: number[]): number {\n  const n = nums.length;\n  if (n === 1) return nums[0];\n  if (n === 2) return Math.max(...nums);\n  const dp = new Array(n).fill(0);\n  dp[0] = nums[0];\n  dp[1] = nums[1];\n  for (let i = 2; i < n; i++) {\n    for (let j = 0; j < i - 1; j++) {\n      dp[i] = Math.max(dp[i], dp[j] + nums[i], dp[i - 1]);\n    }\n  }\n  return dp[n - 1];\n}"},{"date":"2021-09-04","time":68,"memory":39.3,"script":"typescript","desc":"动态规划。","code":"function rob(nums: number[]): number {\n  const n = nums.length;\n  const dp = new Array(n).fill(0).map(_ => new Array(2).fill(0));\n  dp[0][1] = nums[0];\n  for (let i = 1; i < n; i++) {\n    dp[i][0] = Math.max(...dp[i - 1]);\n    dp[i][1] = dp[i - 1][0] + nums[i];\n  }\n  return Math.max(...dp[n - 1]);\n}"},{"script":"cpp","time":4,"memory":8.1,"desc":"dp记录当前下标下的最大值。","code":"class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size(), res = 0;\n        if (n == 1) return nums[0];\n        vector<int> dp(n, 0);\n        dp[0] = nums[0];\n        dp[1] = max(nums[0], nums[1]);\n        res = max(dp[0], dp[1]);\n        for (int i = 2; i < n; i++) {\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\n            res = max(res, dp[i]);\n        }\n        return res;\n    }\n};","date":"2023-09-16"},{"script":"python","time":32,"memory":16,"desc":"同上。","code":"class Solution:\n    def rob(self, nums: List[int]) -> int:\n        if len(nums) == 1:\n            return nums[0]\n        dp = [0 for _ in nums]\n        dp[0] = nums[0]\n        dp[1] = max(nums[1], nums[0])\n        for i in range(2, len(nums)):\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n        return max(dp)","date":"2023-09-16"},{"script":"rust","time":0,"memory":1.95,"desc":"同上。","code":"impl Solution {\n    pub fn rob(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        if n == 1 {\n            nums[0]\n        } else {\n            let mut dp = vec![0; n];\n            dp[0] = nums[0];\n            dp[1] = nums[1].max(nums[0]);\n            for i in 2..n {\n                dp[i] = dp[i - 1].max(dp[i - 2] + nums[i]);\n            }\n            dp.into_iter().max().unwrap()\n        }\n    }\n}","date":"2023-09-16"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"199.二叉树的右视图.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/199.二叉树的右视图.json","problemData":{"id":"199","name":"199.二叉树的右视图","url":"https://leetcode.cn/problems/binary-tree-right-side-view","desc":"给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。","solutions":[{"date":"2020-04-22","time":112,"memory":34.3,"script":"javascript","desc":"层序遍历当前层遍历完后压栈最后一个元素。","code":"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @return {number[]}\n */\nvar rightSideView = function (root) {\n  if (root === null) return [];\n  const res = [root.val];\n  const queue = [root];\n  let levelSize = 1;\n  while (queue.length !== 0) {\n    const node = queue.shift();\n    // console.log(\"===================\");\n    // console.log(node);\n    if (node.left !== null) queue.push(node.left);\n    if (node.right !== null) queue.push(node.right);\n    if (--levelSize === 0 && queue.length !== 0) {\n      // console.log(\"in\");\n      levelSize = queue.length;\n      res.push(queue[levelSize - 1].val);\n    }\n  }\n  return res;\n};"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"200.岛屿数量.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/101-200/200.岛屿数量.json","problemData":{"id":"200","name":"200.岛屿数量","url":"https://leetcode.cn/problems/number-of-islands","desc":"给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。","solutions":[{"date":"2020-04-20","time":296,"memory":45.2,"script":"javascript","desc":"发现小岛后遍历周围是否有群岛，有群岛一并加入，再把小岛放入数组中，最后数组的数量即小岛个数。","code":"const toSringIsland = (i, j) => `${i}-${j}`;\nclass Island {\n  set = new Set();\n  setIsland(i, j) {\n    this.set.add(toSringIsland(i, j));\n  }\n  hasIsland(i, j) {\n    return this.set.has(toSringIsland(i, j));\n  }\n}\n/**\n * @param {character[][]} grid\n * @return {number}\n */\nvar numIslands = function (grid) {\n  const col = grid.length;\n  const islands = [];\n  function dfs(i, j) {\n    //   console.log(\"==============\");\n    //   console.log(i, j);\n    //   console.log(grid[i][j]);\n    if (grid[i][j] === '0') return;\n    for (const item of islands) {\n      if (item.hasIsland(i, j)) return;\n    }\n    const island = new Island();\n    islands.push(island);\n    const queue = [[i, j]];\n    while (queue.length !== 0) {\n      // console.log(queue);\n      const [i, j] = queue.pop();\n      // console.log(\"while i j\", i, j);\n      // console.log(queue);\n      if (grid[i][j] === '0') continue;\n      if (island.hasIsland(i, j)) continue;\n      else island.setIsland(i, j);\n      if (i < col - 1) queue.push([i + 1, j]);\n      if (j < grid[i].length - 1) queue.push([i, j + 1]);\n      if (i > 0) queue.push([i - 1, j]);\n      if (j > 0) queue.push([i, j - 1]);\n    }\n    // console.log(islands);\n  }\n  for (let i = 0; i < col; i++) {\n    const row = grid[i].length;\n    for (let j = 0; j < row; j++) {\n      dfs(i, j);\n    }\n  }\n  return islands.length;\n};"},{"date":"2021-04-30","time":124,"memory":43,"script":"typescript","desc":"并查集。","code":"class UnionFind {\n  elements: number[];\n  constructor(public size: number) {\n    this.elements = new Array(size).fill(0).map((_, i) => i);\n  }\n  same(v1: number, v2: number): boolean {\n    return this.find(v1) === this.find(v2);\n  }\n  find(v: number): number {\n    return v === this.elements[v] ? v : (this.elements[v] = this.find(this.elements[v]));\n  }\n  union(v1: number, v2: number): void {\n    const e1 = this.find(v1);\n    const e2 = this.find(v2);\n    if (e1 !== e2) {\n      this.elements[e1] = e2;\n      this.size--;\n    }\n  }\n}\nfunction numIslands(grid: string[][]): number {\n  let count = 0;\n  const newGrid: number[][] = grid.map(row => row.map(col => (col === '0' ? -1 : count++)));\n  const rowLen = grid.length;\n  const colLen = grid[0].length;\n  const uf = new UnionFind(count);\n  for (let row = 0; row < rowLen; row++) {\n    for (let col = 0; col < colLen; col++) {\n      const num = newGrid[row][col];\n      if (num === -1) continue;\n      if (row > 0 && newGrid[row - 1][col] !== -1) uf.union(num, newGrid[row - 1][col]);\n      if (col > 0 && newGrid[row][col - 1] !== -1) uf.union(num, newGrid[row][col - 1]);\n      if (row < rowLen - 1 && newGrid[row + 1][col] !== -1) uf.union(num, newGrid[row + 1][col]);\n      if (col < colLen - 1 && newGrid[row][col + 1] !== -1) uf.union(num, newGrid[row][col + 1]);\n    }\n  }\n  return uf.size;\n}"}],"tagList":["深度优先搜索","广度优先搜索","并查集","数组","矩阵"],"level":"Medium"}}]},{"dirName":"1101-1200","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\1101-1200","problems":[{"problemName":"1103.分糖果II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1103.分糖果II.json","problemData":{"id":"1195","name":"1103.分糖果II","url":"https://leetcode.cn/problems/distribute-candies-to-people","desc":"返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。","solutions":[{"date":"2022-03-28","script":"cpp","time":0,"memory":6.32,"desc":"模拟。","code":"class Solution {\npublic:\n    vector<int> distributeCandies(int candies, int num_people) {\n        vector<int> ans(num_people,0);\n        for (int i = 0, cnt = 1; candies > 0; i = (i + 1) % num_people,cnt++) {\n            ans[i] += min(candies, cnt);\n            candies -= cnt;\n        }\n        return ans;\n    }\n};"},{"script":"python","time":37,"memory":16.5,"desc":"模拟。","code":"class Solution:\n    def distributeCandies(self, candies: int, num_people: int) -> List[int]:\n        res = [0] * num_people\n        cur = 1\n        idx = 0\n        while candies:\n            v = min(cur, candies)\n            res[idx] += v\n            candies -= v\n            cur += 1\n            idx = (idx + 1) % num_people\n        return res","date":"2024-06-03"}],"tagList":["数学","模拟"],"level":"Easy"}},{"problemName":"1104.二叉树寻路.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1104.二叉树寻路.json","problemData":{"id":"1194","name":"1104.二叉树寻路","url":"https://leetcode.cn/problems/path-in-zigzag-labelled-binary-tree","desc":"给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的。","solutions":[{"date":"2021-07-29","time":88,"memory":39.6,"script":"typescript","desc":"深度向上遍历。","code":"function pathInZigZagTree(label: number): number[] {\n  const list: number[] = [];\n  let max = 1;\n  while (label >= max) list.push((max <<= 1));\n  const ans: number[] = [];\n  dfs(label);\n  return ans;\n  function find(label: number): {\n    maxLabel: number;\n    prevMin: number;\n  } {\n    for (let i = 0; i < list.length; i++) {\n      if (list[i] > label)\n        return {\n          maxLabel: list[i] - 1,\n          prevMin: list[i - 2] ?? 1,\n        };\n    }\n    return {\n      maxLabel: -1,\n      prevMin: -1,\n    };\n  }\n  function dfs(label: number): void {\n    if (label === 1) {\n      ans.unshift(label);\n      return;\n    }\n    ans.unshift(label);\n    const { maxLabel, prevMin } = find(label);\n    let i = maxLabel;\n    let parent = prevMin;\n    while (i > label) {\n      i--;\n      if ((i & 1) !== 0) parent++;\n    }\n    dfs(parent);\n  }\n}"}],"tagList":["树","数学","二叉树"],"level":"Medium"}},{"problemName":"1105.填充书架.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1105.填充书架.json","problemData":{"id":"1196","name":"1105.填充书架","url":"https://leetcode.cn/problems/filling-bookcase-shelves","desc":"给定一个数组 books ，其中 books[i] = [thicknessi, heighti] 表示第 i 本书的厚度和高度。你也会得到一个整数 shelfWidth 。每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。以这种方式布置书架，返回书架整体可能的最小高度。","solutions":[{"script":"cpp","time":4,"memory":7.9,"desc":"dp[i]表示以i为行末的最大高度。","code":"class Solution {\npublic:\n    int minHeightShelves(vector<vector<int>>& books, int shelfWidth) {\n        int n = books.size();\n        vector<int> dp(n + 1, INT_MAX);\n        dp[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            int sum = 0, h = 0;\n            for (int j = i - 1; j >= 0; j--) {\n                if (sum + books[j][0] > shelfWidth) break;\n                sum += books[j][0];\n                h = max(h, books[j][1]);\n                dp[i] = min(dp[i], dp[j] + h);\n            }\n        }\n        return dp[n];\n    }\n};","date":"2023-04-23"},{"script":"python","time":40,"memory":15.3,"desc":"同上。","code":"class Solution:\n    def minHeightShelves(self, books: List[List[int]], shelfWidth: int) -> int:\n        n = len(books)\n        dp = [inf] * (n + 1)\n        dp[0] = 0\n        for i in range(1, n+1):\n            sum = h = 0\n            for j in range(i-1, -1, -1):\n                if sum + books[j][0] > shelfWidth:\n                    break\n                sum += books[j][0]\n                h = max(h, books[j][1])\n                dp[i] = min(dp[i], dp[j]+h)\n        return dp[n]","date":"2023-04-23"},{"script":"rust","time":0,"memory":2.3,"desc":"同上。","code":"impl Solution {\n    pub fn min_height_shelves(books: Vec<Vec<i32>>, shelf_width: i32) -> i32 {\n        use std::cmp::{max, min};\n        let n = books.len();\n        let mut dp = vec![i32::MAX; n + 1];\n        dp[0] = 0;\n        for i in 1..=n {\n            let mut sum = 0;\n            let mut h = 0;\n            for j in (0..=i - 1).rev() {\n                if sum + books[j][0] > shelf_width {\n                    break;\n                }\n                sum += books[j][0];\n                h = max(h, books[j][1]);\n                dp[i] = min(dp[i], dp[j] + h);\n            }\n        }\n        dp[n]\n    }\n}","date":"2023-04-23"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"1106.解析布尔表达式.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1106.解析布尔表达式.json","problemData":{"id":"1197","name":"1106.解析布尔表达式","url":"https://leetcode.cn/problems/parsing-a-boolean-expression","desc":"给你一个以字符串形式表述的 布尔表达式（boolean） expression，返回该式的运算结果。","solutions":[{"date":"2022-11-05","time":4,"memory":7,"script":"cpp","desc":"递归遍历。","code":"class Solution {\npublic:\n    int n, i;\n    string expression;\n    bool parseBoolExpr(string expression) {\n        this->expression = expression;\n        n = expression.size();\n        i = 0;\n        return _parseBoolExpr();\n    }\n    bool _parseBoolExpr() {\n        if (expression[i] == 't' || expression[i] == 'f') return expression[i++] == 't';\n        return nextBlock();\n    }\n    bool nextBlock() {\n        char op = expression[i];\n        i += 2;\n        bool init = true, cur;\n        while (i < n && expression[i] != ')') {\n            bool load = _parseBoolExpr();\n            if (init) cur = load, init = false;\n            else if (op == '|') cur |= load;\n            else if (op == '&') cur &= load;\n            if (expression[i] == ',') i++;\n        }\n        if (op == '!') cur = !cur;\n        i++;\n        return cur;\n    }\n};"}],"tagList":["栈","递归","字符串"],"level":"Hard"}},{"problemName":"1108.IP地址无效化.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1108.IP地址无效化.json","problemData":{"id":"1205","name":"1108.IP地址无效化","url":"https://leetcode.cn/problems/defanging-an-ip-address","desc":"给你一个有效的 IPv4 地址 address，返回这个 IP 地址的无效化版本。","solutions":[{"date":"2022-03-28","time":0,"memory":5.8,"script":"typescript","desc":"遍历。","code":"class Solution {\n   public:\n    string defangIPaddr(string address) {\n        string ans = \"\";\n        for (auto &ch : address) {\n            if (ch == '.')\n                ans += \"[.]\";\n            else\n                ans += ch;\n        }\n        return ans;\n    }\n};"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"1109.航班预订统计.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1109.航班预订统计.json","problemData":{"id":"1206","name":"1109.航班预订统计","url":"https://leetcode.cn/problems/corporate-flight-bookings","desc":"请你返回一个长度为 n 的数组 answer，其中 answer[i] 是航班 i 上预订的座位总数。","solutions":[{"date":"2021-08-31","time":164,"memory":58.4,"script":"typescript","desc":"差分。","code":"function corpFlightBookings(bookings: number[][], n: number): number[] {\n  const nums = new Array(n).fill(0);\n  for (const [first, last, seats] of bookings) {\n    nums[first - 1] += seats;\n    if (last < n) nums[last] -= seats;\n  }\n  for (let i = 1; i < n; i++) nums[i] += nums[i - 1];\n  return nums;\n}"},{"date":"2021-11-14","time":1544,"memory":58.5,"script":"typescript","desc":"遍历。","code":"function corpFlightBookings(bookings: number[][], n: number): number[] {\n  const ans: number[] = new Array(n).fill(0);\n  for (const [first, last, cnt] of bookings) {\n    for (let i = first; i <= last; i++) ans[i - 1] += cnt;\n  }\n  return ans;\n}"},{"date":"2021-11-14","time":168,"memory":58.4,"script":"typescript","desc":"差分。","code":"function corpFlightBookings(bookings: number[][], n: number): number[] {\n  const ans: number[] = new Array(n).fill(0);\n  for (const [first, last, cnt] of bookings) {\n    ans[first - 1] += cnt;\n    if (last < n) ans[last] -= cnt;\n  }\n  for (let i = 1; i < n; i++) ans[i] += ans[i - 1];\n  return ans;\n}"}],"tagList":["数组","前缀和"],"level":"Medium"}},{"problemName":"1110.删点成林.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1110.删点成林.json","problemData":{"id":"1207","name":"1110.删点成林","url":"https://leetcode.cn/problems/delete-nodes-and-return-forest","desc":"给出二叉树的根节点 root，树上每个节点都有一个不同的值。如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。返回森林中的每棵树。你可以按任意顺序组织答案。","solutions":[{"script":"cpp","time":12,"memory":13.3,"desc":"dfs遍历时，记录父节点是否已经被删除。","code":"class Solution {\npublic:\n    vector<TreeNode*> res;\n    unordered_set<int> s;\n    vector<TreeNode*> delNodes(TreeNode* root, vector<int>& to_delete) {\n        for (auto &v : to_delete) s.insert(v);\n        dfs(root, true);\n        return res;\n    }\n    TreeNode* dfs(TreeNode *node, bool pd) {\n        if (!node) return node;\n        bool del = s.count(node->val);\n        if (!del && pd) res.push_back(node);\n        node->left = dfs(node->left, del);\n        node->right = dfs(node->right, del);\n        if (pd || del) return nullptr;\n        return node;\n    }\n};","date":"2023-05-30"},{"script":"python","time":72,"memory":16.6,"desc":"同上。","code":"class Solution:\n    def delNodes(self, root: Optional[TreeNode], to_delete: List[int]) -> List[TreeNode]:\n        res = []\n        s = set()\n        for v in to_delete:\n            s.add(v)\n\n        def dfs(node: Optional[TreeNode], pd: bool):\n            if node == None:\n                return node\n            d = node.val in s\n            if not d and pd:\n                res.append(node)\n            node.left = dfs(node.left, d)\n            node.right = dfs(node.right, d)\n            return None if pd or d else node\n        dfs(root, True)\n        return res","date":"2023-05-30"},{"script":"rust","time":4,"memory":2.2,"desc":"同上。","code":"use std::cell::RefCell;\nuse std::collections::HashSet;\nuse std::ops::RangeBounds;\nuse std::rc::Rc;\ntype Res = Vec<Option<Rc<RefCell<TreeNode>>>>;\nfn dfs(\n    res: &mut Res,\n    s: &HashSet<i32>,\n    node: &mut Option<Rc<RefCell<TreeNode>>>,\n    pd: bool,\n) -> Option<Rc<RefCell<TreeNode>>> {\n    match node {\n        None => None,\n        Some(ref node) => {\n            let mut nodeRef = node.as_ref().borrow_mut();\n            let d = s.contains(&nodeRef.val);\n            if !d && pd {\n                res.push(Some(node.clone()));\n            }\n            nodeRef.left = dfs(res, s, &mut nodeRef.left, d);\n            nodeRef.right = dfs(res, s, &mut nodeRef.right, d);\n            if pd || d {\n                None\n            } else {\n                Some(node.clone())\n            }\n        }\n    }\n}\n\nimpl Solution {\n    pub fn del_nodes(mut root: Option<Rc<RefCell<TreeNode>>>, to_delete: Vec<i32>) -> Res {\n        let mut s = std::collections::HashSet::<i32>::new();\n        for v in to_delete {\n            s.insert(v);\n        }\n        let mut res: Res = vec![];\n        dfs(&mut res, &s, &mut root, true);\n        res\n    }\n}","date":"2023-05-30"}],"tagList":["树","深度优先搜索","数组","哈希表","二叉树"],"level":"Medium"}},{"problemName":"1111.有效括号的嵌套深度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1111.有效括号的嵌套深度.json","problemData":{"id":"1208","name":"1111.有效括号的嵌套深度","url":"https://leetcode.cn/problems/maximum-nesting-depth-of-two-valid-parentheses-strings","desc":"给你一个「有效括号字符串」 seq，请你将其分成两个不相交的有效括号字符串，A 和 B，并使这两个字符串的深度最小。","solutions":[{"date":"2020-04-09","time":96,"memory":35.6,"script":"javascript","desc":"深度平衡即奇数深度归类一边，偶数深度归类一边。","code":"/**\n * @param {string} seq\n * @return {number[]}\n */\nvar maxDepthAfterSplit = function (seq) {\n  let dep = 0;\n  return seq.split('').map(value => (value === '(' ? ++dep % 2 : dep-- % 2));\n};"}],"tagList":["栈","字符串"],"level":"Medium"}},{"problemName":"1122.数组的相对排序.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1122.数组的相对排序.json","problemData":{"id":"1217","name":"1122.数组的相对排序","url":"https://leetcode.cn/problems/relative-sort-array","desc":"对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。","solutions":[{"date":"2020-11-14","time":88,"memory":40.4,"script":"typescript","desc":"读取 arr2 每个点的下标进行对 arr1 排序。","code":"function relativeSortArray(arr1: number[], arr2: number[]): number[] {\n  const set = new Set(arr2);\n  const argNums = arr1.filter(v => !set.has(v)).sort((a, b) => a - b);\n  const map = new Map(Object.entries(arr2).map(([k, v]) => [v, Number(k)]));\n  arr1 = arr1.filter(v => set.has(v));\n  return arr1.sort((a, b) => map.get(a)! - map.get(b)!).concat(argNums);\n}"}],"tagList":["数组","哈希表","计数排序","排序"],"level":"Easy"}},{"problemName":"1123.最深叶节点的最近公共祖先.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1123.最深叶节点的最近公共祖先.json","problemData":{"id":"1218","name":"1123.最深叶节点的最近公共祖先","url":"https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves","desc":"给你一个有根节点 root 的二叉树，返回它 最深的叶节点的最近公共祖先 。","solutions":[{"script":"python","time":52,"memory":16.27,"desc":"bfs。","code":"class Solution:\n    def lcaDeepestLeaves(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        prevq = []\n        q: deque[TreeNode] = deque()\n        q.append(root)\n        size = 1\n        m: dict[TreeNode, TreeNode] = {}\n        while len(q):\n            cur = q.popleft()\n            prevq.append(cur)\n            if cur.left:\n                m[cur.left] = cur\n                q.append(cur.left)\n            if cur.right:\n                m[cur.right] = cur\n                q.append(cur.right)\n            size -= 1\n            if size == 0:\n                size = len(q)\n                if size:\n                    prevq.clear()\n        while len(set(prevq)) > 1:\n            prevq = [m[item] for item in prevq]\n        return list(set(prevq))[0]","date":"2023-09-06"},{"script":"cpp","time":8,"memory":20.18,"desc":"dfs。","code":"class Solution {\npublic:\n    TreeNode* lcaDeepestLeaves(TreeNode* root) {\n        function<pair<int, TreeNode*>(TreeNode*, int)> dfs = [&](TreeNode *node, int level) -> pair<int, TreeNode*> {\n            pair<int, TreeNode*> res = make_pair(level, node);\n            if (node->left) {\n                res = dfs(node->left, level + 1);\n            }\n            if (node->right) {\n                auto rres = dfs(node->right, level + 1);\n                if (rres.first > res.first) res = rres;\n                else if (rres.first == res.first) res.second = node;\n            }\n            return res;\n        };\n        return dfs(root, 0).second;\n    }\n};","date":"2023-09-06"},{"script":"python","time":52,"memory":16.27,"desc":"同上。","code":"class Solution:\n    def lcaDeepestLeaves(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        def dfs(node: TreeNode, level: int) -> (int, TreeNode):\n            res = (level, node)\n            if node.left:\n                res = dfs(node.left, level + 1)\n            if node.right:\n                right_result = dfs(node.right, level + 1)\n                if right_result[0] > res[0]:\n                    res = right_result\n                elif right_result[0] == res[0]:\n                    res = (res[0], node)\n            return res\n\n        return dfs(root, 0)[1]","date":"2023-09-06"},{"script":"rust","time":0,"memory":2.05,"desc":"同上。","code":"use std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn lca_deepest_leaves(\n        root: Option<Rc<RefCell<TreeNode>>>,\n    ) -> Option<Rc<RefCell<TreeNode>>> {\n        fn dfs(node: Rc<RefCell<TreeNode>>, level: usize) -> (usize, Rc<RefCell<TreeNode>>) {\n            let mut res = (level, node.clone());\n            let node_ref = node.as_ref().borrow();\n            if let Some(ref left) = node_ref.left {\n                res = dfs(left.clone(), level + 1);\n            }\n            if let Some(ref right) = node_ref.right {\n                let rres = dfs(right.clone(), level + 1);\n                if rres.0 > res.0 {\n                    res = rres;\n                } else if rres.0 == res.0 {\n                    res.1 = node.clone();\n                }\n            }\n            res\n        }\n        Some(dfs(root.unwrap().clone(), 0).1)\n    }\n}","date":"2023-09-06"}],"tagList":["树","深度优先搜索","广度优先搜索","哈希表","二叉树"],"level":"Medium"}},{"problemName":"1124.表现良好的最长时间段.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1124.表现良好的最长时间段.json","problemData":{"id":"1219","name":"1124.表现良好的最长时间段","url":"https://leetcode.cn/problems/longest-well-performing-interval","desc":"给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。","solutions":[{"date":"2021-03-20","time":1044,"memory":42.8,"script":"typescript","desc":"前缀和。","code":"function longestWPI(hours: number[]): number {\n  hours = hours.map(v => (v > 8 ? 1 : -1));\n  const len = hours.length;\n  const sums = [0];\n  let sum = 0;\n  hours.forEach(hour => sums.push((sum += hour)));\n  let max = 0;\n  for (let i = 1; i < len + 1; i++) {\n    for (let j = 0; j < i; j++) {\n      if (sums[i] - sums[j] > 0) max = Math.max(max, i - j);\n    }\n  }\n  return max;\n}"},{"script":"cpp","time":32,"memory":23.3,"desc":"单调栈，找出最远最小的值。","code":"class Solution {\npublic:\n    int longestWPI(vector<int>& hours) {\n        int n = hours.size(), ans = 0;\n        for (auto &h : hours) h = h > 8 ? 1 : -1;\n        vector<int> sums(1, 0);\n        for (auto &h : hours) sums.push_back(sums.back() + h);\n        stack<int> s; s.push(0);\n        for (int i = 1; i <= n; i++) {\n            if (sums[s.top()] > sums[i]) s.push(i);\n        }\n        for (int i = n; i >= 1; i--) {\n            while (s.size() && sums[s.top()] < sums[i]) {\n                ans = max(ans, i - s.top());\n                s.pop();\n            }\n        }\n        return ans;\n    }\n};","date":"2023-02-14"},{"script":"python","time":72,"memory":15.7,"desc":"同上。","code":"class Solution:\n    def longestWPI(self, hours: List[int]) -> int:\n        n = len(hours)\n        ans = 0\n        sums = [0]\n        for h in hours:\n            v = -1\n            if (h > 8):\n                v = 1\n            sums.append(sums[-1] + v)\n        s = [0]\n        for i in range(1, n+1):\n            if sums[s[-1]] > sums[i]:\n                s.append(i)\n        for i in range(n, 0, -1):\n            while len(s) and sums[s[-1]] < sums[i]:\n                ans = max(ans, i - s.pop())\n        return ans","date":"2023-02-14"},{"script":"rust","time":12,"memory":2.4,"desc":"同上。","code":"impl Solution {\n    pub fn longest_wpi(hours: Vec<i32>) -> i32 {\n        use std::collections::VecDeque;\n        let n = hours.len();\n        let mut ans = 0;\n        let mut sums = vec![0; 1];\n        for h in hours {\n            let h: i32 = if h > 8 { 1 } else { -1 };\n            sums.push(sums.last().unwrap() + h);\n        }\n        let mut s = VecDeque::<usize>::new();\n        s.push_back(0);\n        for i in 1..=n {\n            if sums[*s.back().unwrap()] > sums[i] {\n                s.push_back(i);\n            }\n        }\n        let mut i = n;\n        while i >= 1 {\n            while !s.is_empty() && sums[*s.back().unwrap()] < sums[i] {\n                ans = ans.max(i as i32 - s.pop_back().unwrap() as i32);\n            }\n            i -= 1;\n        }\n        ans\n    }\n}","date":"2023-02-14"}],"tagList":["栈","数组","哈希表","前缀和","单调栈"],"level":"Medium"}},{"problemName":"1125.最小的必要团队.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1125.最小的必要团队.json","problemData":{"id":"1220","name":"1125.最小的必要团队","url":"https://leetcode.cn/problems/smallest-sufficient-team","desc":"请你返回 任一 规模最小的必要团队，团队成员用人员编号表示。","solutions":[{"script":"cpp","time":52,"memory":19.1,"desc":"遍历。","code":"class Solution {\npublic:\n    vector<int> smallestSufficientTeam(vector<string>& req_skills, vector<vector<string>>& people) {\n        int n = req_skills.size(), m = people.size(), nmask = (1 << n) - 1;\n        unordered_map<string, int> keym;\n        for (int i = 0; i < n; i++) keym[req_skills[i]] = i;\n        vector<vector<int>> dp(1 << n);\n        for (int i = 0; i < m; i++) {\n            int mask = 0;\n            for (auto &key : people[i]) mask |= 1 << keym[key];\n            for (int pmask = 0; pmask <= nmask; pmask++) {\n                int merged = mask | pmask;\n                if (merged == pmask || \n                    pmask && dp[pmask].empty() || \n                    dp[merged].size() && dp[merged].size() <= dp[pmask].size() + 1) continue;\n                dp[merged] = dp[pmask];\n                dp[merged].push_back(i);\n            }\n        }\n        return dp[nmask];\n    }\n};","date":"2023-04-08"},{"script":"python","time":652,"memory":21.4,"desc":"同上。","code":" class Solution:\n    def smallestSufficientTeam(self, req_skills: List[str], people: List[List[str]]) -> List[int]:\n        n, m = len(req_skills), len(people)\n        nmask = (1 << n) - 1\n        keym = {}\n        for i in range(n):\n            keym[req_skills[i]] = i\n        dp = [list() for _ in range(1 << n)]\n        for i in range(m):\n            mask = 0\n            for key in people[i]:\n                mask |= 1 << keym[key]\n            for pmask in range(nmask + 1):\n                merged = mask | pmask\n                if merged == pmask or pmask and len(dp[pmask]) == 0 or len(dp[merged]) and len(dp[merged]) <= len(dp[pmask]) + 1:\n                    continue\n                dp[merged] = dp[pmask] + [i]\n        return dp[nmask]","date":"2023-04-08"},{"script":"rust","time":12,"memory":5.7,"desc":"同上。","code":"impl Solution {\n    pub fn smallest_sufficient_team(req_skills: Vec<String>, people: Vec<Vec<String>>) -> Vec<i32> {\n        use std::collections::HashMap;\n        let (n, m) = (req_skills.len(), people.len());\n        let nmask = (1 << n) - 1;\n        let mut keym = HashMap::<String, usize>::new();\n        let mut i = 0;\n        for key in req_skills {\n            keym.insert(key, i);\n            i += 1;\n        }\n        let mut dp: Vec<Vec<i32>> = vec![vec![]; 1 << n];\n        for i in 0..m {\n            let mut mask = 0;\n            for key in people[i].iter() {\n                mask |= 1 << keym.get(key).unwrap();\n            }\n            for pmask in 0..=nmask {\n                let merged = mask | pmask;\n                if merged == pmask\n                    || pmask > 0 && dp[pmask].is_empty()\n                    || !dp[merged].is_empty() && dp[merged].len() <= dp[pmask].len() + 1\n                {\n                    continue;\n                }\n                dp[merged] = dp[pmask].clone();\n                dp[merged].push(i as i32);\n            }\n        }\n        dp[nmask].clone()\n    }\n}","date":"2023-04-08"}],"tagList":["位运算","数组","动态规划","状态压缩"],"level":"Hard"}},{"problemName":"1128.等价多米诺骨牌对的数量.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1128.等价多米诺骨牌对的数量.json","problemData":{"id":"1227","name":"1128.等价多米诺骨牌对的数量","url":"https://leetcode.cn/problems/number-of-equivalent-domino-pairs","desc":"给你一个由一些多米诺骨牌组成的列表 dominoes。在  0 <= i < j < dominoes.length  的前提下，找出满足  dominoes[i] 和  dominoes[j]  等价的骨牌对 (i, j) 的数量。","solutions":[{"date":"2021-01-26","time":128,"memory":48.9,"script":"typescript","desc":"用哈希表储存结果后进行筛选。","code":"function numEquivDominoPairs(dominoes: number[][]): number {\n  const map: Record<string, number> = {};\n  const format = (n1: number, n2: number) => `${n1}-${n2}`;\n  for (let [n1, n2] of dominoes) {\n    if (n1 > n2) [n1, n2] = [n2, n1];\n    const str = format(n1, n2);\n    map[str] = 1 + (map[str] ?? 0);\n  }\n  return Object.entries(map)\n    .filter(([, v]) => v > 1)\n    .reduce((total, [, count]) => total + (count * (count - 1)) / 2, 0);\n}"}],"tagList":["数组","哈希表","计数"],"level":"Easy"}},{"problemName":"1129.颜色交替的最短路径.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1129.颜色交替的最短路径.json","problemData":{"id":"1229","name":"1129.颜色交替的最短路径","url":"https://leetcode.cn/problems/shortest-path-with-alternating-colors","desc":"返回长度为 n 的数组 answer，其中 answer[X] 是从节点 0 到节点 X 的红色边和蓝色边交替出现的最短路径的长度。","solutions":[{"script":"cpp","time":24,"memory":14.2,"desc":"bfs。","code":"struct Node {\n    vector<int> next[2];\n};\ntypedef pair<int, int> pii;\nclass Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {\n        vector<int> ans(n, -1);\n        ans[0] = 0;\n        vector<vector<bool>> cache(2, vector<bool>(n, false));\n        vector<Node> list(n);\n        for (auto &item : redEdges) list[item[0]].next[0].push_back(item[1]);\n        for (auto &item : blueEdges) list[item[0]].next[1].push_back(item[1]);\n        queue<pii> q;\n        q.push(make_pair(0, -1));\n        int l = 0, size = 1;\n        while (q.size()) {\n            pii cur = q.front();\n            q.pop();\n            for (int i = 0; i < 2; i++) {\n                if (cur.second == i) continue;\n                for (auto &next : list[cur.first].next[i]) {\n                    if (cache[i][next]) continue;\n                    cache[i][next] = true;\n                    if (ans[next] == -1) ans[next] = l + 1;\n                    q.push(make_pair(next, i));\n                }\n            }\n            if (--size == 0) size = q.size(), l++;\n        }\n        return ans;\n    }\n};","date":"2023-02-02"},{"script":"python","time":52,"memory":15.2,"desc":"同上。","code":"from queue import Queue\nclass Node:\n    def __init__(self) -> None:\n        self.next = [[] for _ in range(2)]\nclass Solution:\n    def shortestAlternatingPaths(self, n: int, redEdges: List[List[int]], blueEdges: List[List[int]]) -> List[int]:\n        ans = [-1] * n\n        ans[0] = 0\n        cache = [[False] * n for _ in range(2)]\n        list = [Node() for _ in range(n)]\n        for [v1, v2] in redEdges:\n            list[v1].next[0].append(v2)\n        for [v1, v2] in blueEdges:\n            list[v1].next[1].append(v2)\n        q = Queue()\n        q.put((0, -1))\n        l, size = 0, 1\n        while not q.empty():\n            (node, color) = q.get()\n            size -= 1\n            for i in range(2):\n                if color == i:\n                    continue\n                for val in list[node].next[i]:\n                    if cache[i][val]:\n                        continue\n                    cache[i][val] = True\n                    if ans[val] == -1:\n                        ans[val] = l + 1\n                    q.put((val, i))\n            if size == 0:\n                size = q.qsize()\n                l += 1\n        return ans","date":"2023-02-02"},{"script":"rust","time":4,"memory":2.3,"desc":"同上。","code":"#[derive(Clone)]\nstruct Node {\n    next: Vec<Vec<i32>>,\n}\nimpl Node {\n    fn new() -> Self {\n        Self {\n            next: vec![vec![]; 2],\n        }\n    }\n}\n\nimpl Solution {\n    pub fn shortest_alternating_paths(\n        n: i32,\n        red_edges: Vec<Vec<i32>>,\n        blue_edges: Vec<Vec<i32>>,\n    ) -> Vec<i32> {\n        let n = n as usize;\n        let mut ans = vec![-1; n];\n        ans[0] = 0;\n        let mut cache = vec![vec![false; n]; 2];\n        let mut list = vec![Node::new(); n];\n        for item in red_edges {\n            list[item[0] as usize].next[0].push(item[1]);\n        }\n        for item in blue_edges {\n            list[item[0] as usize].next[1].push(item[1]);\n        }\n        use std::collections::VecDeque;\n        let mut q = VecDeque::<(usize, usize)>::new();\n        q.push_back((0, 2));\n        let (mut l, mut size) = (0, 1);\n        while !q.is_empty() {\n            let (node, color) = q.pop_front().unwrap();\n            for i in 0..2 {\n                if color == i {\n                    continue;\n                }\n                for next in list[node].next[i].iter() {\n                    let next = *next as usize;\n                    if cache[i][next] {\n                        continue;\n                    }\n                    cache[i][next] = true;\n                    if ans[next] == -1 {\n                        ans[next] = l + 1;\n                    }\n                    q.push_back((next, i));\n                }\n            }\n            size -= 1;\n            if size == 0 {\n                size = q.len();\n                l += 1\n            }\n        }\n        ans\n    }\n}","date":"2023-02-02"}],"tagList":["广度优先搜索","图"],"level":"Medium"}},{"problemName":"1130.叶值的最小代价生成树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1130.叶值的最小代价生成树.json","problemData":{"id":"1228","name":"1130.叶值的最小代价生成树","url":"https://leetcode.cn/problems/minimum-cost-tree-from-leaf-values","desc":"在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。","solutions":[{"script":"cpp","time":48,"memory":11.6,"desc":"树形dp，对一个区间去获取他的最大值和最小和。","code":"#define pii pair<int, int>\n#define X first\n#define Y second\nclass Solution {\npublic:\n    unordered_map<int, unordered_map<int, pii>> m;\n    pii dfs(vector<int> &arr, int l, int r) {\n        if (m[l].count(r)) return m[l][r];\n        if (l == r) return m[l][r] = make_pair(arr[l], 0);\n        pii res = make_pair(arr[r], INT_MAX);\n        for (int i = l; i < r; i++) {\n            res.X = max(res.X, arr[i]);\n            auto left = dfs(arr, l, i), right = dfs(arr, i + 1, r);\n            int sum = left.X * right.X + left.Y + right.Y;\n            res.Y = min(res.Y, sum);\n        }\n        return m[l][r] = res;\n    }\n    int mctFromLeafValues(vector<int>& arr) {\n        return dfs(arr, 0, arr.size() - 1).Y;\n    }\n};","date":"2023-05-31"},{"script":"python","time":152,"memory":17.1,"desc":"同上。","code":"class Solution:\n    def mctFromLeafValues(self, arr: List[int]) -> int:\n        @cache\n        def dfs(l: int, r: int) -> List[int]:\n            if l == r: return [arr[l],0]\n            res = [arr[r], inf]\n            for i in range(l,r):\n                res[0] = max(res[0], arr[i])\n                left,right = dfs(l,i),dfs(i+1,r)\n                sum = left[0] * right[0] + left[1] + right[1]\n                res[1] = min(res[1], sum)\n            return res\n        return dfs(0, len(arr) - 1)[1]","date":"2023-05-31"},{"script":"rust","time":48,"memory":2,"desc":"同上。","code":"use std::collections::HashMap;\nfn dfs(\n    m: &mut HashMap<usize, HashMap<usize, (i32, i32)>>,\n    arr: &Vec<i32>,\n    l: usize,\n    r: usize,\n) -> (i32, i32) {\n    if m.entry(l).or_insert(Default::default()).contains_key(&r) {\n        *m.get(&l).unwrap().get(&r).unwrap()\n    } else if l == r {\n        let res = (arr[l], 0);\n        (*m.get_mut(&l).unwrap()).insert(r, res);\n        res\n    } else {\n        let mut res = (arr[r], i32::MAX);\n        for i in l..r {\n            res.0 = res.0.max(arr[i]);\n            let (left, right) = (dfs(m, arr, l, i), dfs(m, arr, i + 1, r));\n            let sum = left.0 * right.0 + left.1 + right.1;\n            res.1 = res.1.min(sum);\n        }\n        (*m.get_mut(&l).unwrap()).insert(r, res);\n        res\n    }\n}\nimpl Solution {\n    pub fn mct_from_leaf_values(arr: Vec<i32>) -> i32 {\n        let mut m = HashMap::<usize, HashMap<usize, (i32, i32)>>::new();\n        dfs(&mut m, &arr, 0, arr.len() - 1).1\n    }\n}","date":"2023-05-31"}],"tagList":["栈","贪心","数组","动态规划","单调栈"],"level":"Medium"}},{"problemName":"1137.第N个泰波那契数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1137.第N个泰波那契数.json","problemData":{"id":"1236","name":"1137.第N个泰波那契数","url":"https://leetcode.cn/problems/n-th-tribonacci-number","desc":"给你整数 n，请返回第 n 个泰波那契数 Tn 的值。","solutions":[{"date":"2021-08-09","time":148,"memory":46.4,"script":"typescript","desc":"遍历数组进行相乘。","code":"function nthSuperUglyNumber(n: number, primes: number[]): number {\n  const len = primes.length;\n  const pos = new Array(len).fill(0);\n  const list: number[] = [1];\n  let val = 1;\n  for (let i = 1; i < n; i++) {\n    val = Math.min(...pos.map((v, i) => list[v] * primes[i]));\n    for (let i = 0; i < len; i++) if (list[pos[i]] * primes[i] === val) pos[i]++;\n    list.push(val);\n  }\n  return val;\n}"}],"tagList":["记忆化搜索","数学","动态规划"],"level":"Easy"}},{"problemName":"1138.字母板上的路径.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1138.字母板上的路径.json","problemData":{"id":"1238","name":"1138.字母板上的路径","url":"https://leetcode.cn/problems/alphabet-board-path","desc":"给你一个下标从 0 开始、长度为 3 的整数数组 amount ，其中 amount[0]、amount[1] 和 amount[2] 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 最少 秒数。","solutions":[{"script":"cpp","time":12,"memory":11.5,"desc":"bfs。","code":"typedef pair<int, int> pii;\nint dirs[4][2] = {\n    {-1, 0}, {1, 0},\n    {0, -1}, {0, 1}, \n};\nstring dir_str = \"UDLR\";\nstruct Node {\n    pii dir;\n    string s; \n    Node(pii dir, string s): dir(dir), s(s) {}\n};\nclass Solution {\npublic:\n    string alphabetBoardPath(string target) {\n        vector<string> list = { \"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\" };\n        vector<pii> idxs(26);\n        for (int i = 0; i < list.size(); i++) for (int j = 0; j < list[i].size(); j++) idxs[list[i][j] - 'a'] = make_pair(i, j);\n        vector<vector<string>> cache(26, vector<string>(26, \"\"));\n        for (int i = 0; i < 26; i++) prebuild(cache, idxs, list, i);\n        string res = \"\";\n        char prev = 'a';\n        for (int i = 0; i < target.size(); i++) {\n            res += cache[prev - 'a'][target[i] - 'a'] + \"!\";\n            prev = target[i];\n        }\n        return res;    \n    }\n\n    void prebuild(vector<vector<string>> &cache, vector<pii> &idxs, vector<string> &list, int idx) {\n        queue<Node> q; \n        q.push(Node(idxs[idx], \"\"));\n        while (q.size()) {\n            Node cur = q.front();\n            q.pop();\n            for (int i = 0; i < 4; i++) {\n                int nrow = cur.dir.first + dirs[i][0], ncol = cur.dir.second + dirs[i][1];\n                if (nrow < 0 || nrow >= list.size() || ncol < 0 || ncol >= list[nrow].size()) continue;\n                if (list[nrow][ncol] - 'a' == idx || cache[idx][list[nrow][ncol] - 'a'] != \"\") continue;\n                string s = cur.s + dir_str[i];\n                q.push(Node(make_pair(nrow, ncol), s));\n                cache[idx][list[nrow][ncol] - 'a'] = s;\n            }\n        }\n    }\n};","date":"2023-02-12"},{"script":"python","time":232,"memory":15.1,"desc":"同上。","code":"from queue import Queue\nclass Solution:\n  def alphabetBoardPath(self, target: str) -> str:\n      dirs = [\n          (-1, 0), (1, 0),\n          (0, -1), (0, 1)\n      ]\n      dir_str = \"UDLR\"\n      l = [\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\n      idxs = [()] * 26\n      for i in range(len(l)):\n          for j in range(len(l[i])):\n              idxs[ord(l[i][j]) - ord('a')] = (i, j)\n      cache = [[\"\"] * 26 for _ in range(26)]\n      def prebuild(idx):\n          q = Queue()\n          q.put((idxs[idx][0], idxs[idx][1], \"\"))\n          while q.qsize():\n              (row,col,s) = q.get()\n              for i in range(4):\n                  nrow = row + dirs[i][0]\n                  ncol = col + dirs[i][1]\n                  if nrow < 0 or nrow >= len(l) or ncol < 0 or ncol >= len(l[nrow]):\n                      continue\n                  if ord(l[nrow][ncol]) - ord('a') == idx or cache[idx][ord(l[nrow][ncol]) - ord('a')] != \"\":\n                      continue\n                  next_s = s + dir_str[i]\n                  q.put((nrow, ncol, next_s))\n                  cache[idx][ord(l[nrow][ncol]) - ord('a')] = next_s\n      for i in range(26):\n          prebuild(i)\n      res = ''\n      prev = 'a'\n      for cur in target:\n          res += cache[ord(prev) - ord('a')][ord(cur) - ord('a')] + \"!\"\n          prev = cur\n      return res","date":"2023-02-12"},{"script":"rust","time":4,"memory":2.3,"desc":"同上。","code":"impl Solution {\n    pub fn alphabet_board_path(target: String) -> String {\n        let dirs: [[i32; 2]; 4] = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n        let dir_str = \"UDLR\".chars().collect::<Vec<char>>();\n        let l = vec![\"abcde\", \"fghij\", \"klmno\", \"pqrst\", \"uvwxy\", \"z\"]\n            .into_iter()\n            .map(|s| s.chars().collect::<Vec<char>>())\n            .collect::<Vec<Vec<char>>>();\n        let mut cache = vec![vec![String::new(); 26]; 26];\n        let mut idxs = vec![(0, 0); 26];\n        for i in 0..l.len() {\n            for j in 0..l[i].len() {\n                idxs[l[i][j] as usize - 'a' as usize] = (i, j)\n            }\n        }\n        let mut prebuild = |idx: usize| {\n            use std::collections::VecDeque;\n            let mut q = VecDeque::<(usize, usize, String)>::new();\n            q.push_back((idxs[idx].0, idxs[idx].1, String::new()));\n            while !q.is_empty() {\n                let (row, col, s) = q.pop_front().unwrap();\n                for i in 0..4 {\n                    let nrow = row as i32 + dirs[i][0];\n                    let ncol = col as i32 + dirs[i][1];\n                    if nrow < 0\n                        || nrow as usize >= l.len()\n                        || ncol < 0\n                        || ncol as usize >= l[nrow as usize].len()\n                    {\n                        continue;\n                    }\n                    let nrow = nrow as usize;\n                    let ncol = ncol as usize;\n                    if l[nrow][ncol] as usize - 'a' as usize == idx\n                        || cache[idx][l[nrow][ncol] as usize - 'a' as usize] != \"\"\n                    {\n                        continue;\n                    }\n                    let mut next_s = s.clone();\n                    next_s.push(dir_str[i]);\n                    q.push_back((nrow, ncol, next_s.clone()));\n                    cache[idx][l[nrow][ncol] as usize - 'a' as usize] = next_s;\n                }\n            }\n        };\n        for i in 0..26 {\n            prebuild(i)\n        }\n\n        let mut res = String::new();\n        let mut prev = 'a';\n        for cur in target.chars() {\n            res.push_str(&cache[prev as usize - 'a' as usize][cur as usize - 'a' as usize]);\n            res.push('!');\n            prev = cur\n        }\n        res\n    }\n}","date":"2023-02-12"}],"tagList":["哈希表","字符串"],"level":"Medium"}},{"problemName":"1139.最大的以1为边界的正方形.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1139.最大的以1为边界的正方形.json","problemData":{"id":"1239","name":"1139.最大的以1为边界的正方形","url":"https://leetcode.cn/problems/largest-1-bordered-square","desc":"给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。","solutions":[{"script":"cpp","time":12,"memory":10.6,"desc":"预处理每个点的最大延长后遍历。","code":"#define MAX 105\nclass Solution {\npublic:\n    int largest1BorderedSquare(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        // 0: l, 1: r, 2 : t, 3: b\n        int cache[MAX][MAX][4] = {0}, cnt;\n        for (int i = 0; i < n; i++) {\n            cnt = 0;\n            for (int j = 0; j < m; j++) {\n                cache[i][j][0] = cnt;\n                cnt = grid[i][j] == 1 ? cnt + 1 : 0;\n            }\n            cnt = 0;\n            for (int j = m - 1; j >= 0; j--) {\n                cache[i][j][1] = cnt;\n                cnt = grid[i][j] == 1 ? cnt + 1 : 0;\n            }\n        }\n        for (int j = 0; j < m; j++) {\n            cnt = 0;\n            for (int i = 0; i < n; i++) {\n                cache[i][j][2] = cnt;\n                cnt = grid[i][j] == 1 ? cnt + 1 : 0;\n            }\n            cnt = 0;\n            for (int i = n - 1; i >= 0; i--) {\n                cache[i][j][3] = cnt;\n                cnt = grid[i][j] == 1 ? cnt + 1 : 0;\n            }\n        }\n\n        cnt = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 0) continue;\n                cnt = max(cnt, 1);\n                for (int k = 1; k <= min(cache[i][j][1], cache[i][j][3]); k++) {\n                    if (cache[i + k][j][1] >= k && cache[i][j + k][3] >= k) cnt = max(cnt, (int)pow(k + 1, 2));\n                }\n            }\n        }\n\n        return cnt;\n    }\n};","date":"2023-02-17"},{"script":"python","time":272,"memory":16.3,"desc":"同上。","code":"class Solution:\n    def largest1BorderedSquare(self, grid: List[List[int]]) -> int:\n        n, m, cnt = len(grid), len(grid[0]), 0\n        MAX = 105\n        cache = [[[0] * 4 for _ in range(MAX)] for _ in range(MAX)]\n        for i in range(n):\n            cnt = 0\n            for j in range(m):\n                cache[i][j][0] = cnt\n                cnt = cnt + 1 if grid[i][j] == 1 else 0\n            cnt = 0\n            for j in range(m - 1, -1, -1):\n                cache[i][j][1] = cnt\n                cnt = cnt + 1 if grid[i][j] == 1 else 0\n        for j in range(m):\n            cnt = 0\n            for i in range(n):\n                cache[i][j][2] = cnt\n                cnt = cnt + 1 if grid[i][j] == 1 else 0\n            cnt = 0\n            for i in range(n - 1, -1, -1):\n                cache[i][j][3] = cnt\n                cnt = cnt + 1 if grid[i][j] == 1 else 0\n        cnt = 0\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 0:\n                    continue\n                cnt = max(cnt, 1)\n                for k in range(1, min(cache[i][j][1], cache[i][j][3]) + 1):\n                    if cache[i + k][j][1] >= k and cache[i][j + k][3] >= k:\n                        cnt = max(cnt, pow(k + 1, 2))\n        return cnt","date":"2023-02-17"},{"script":"rust","time":4,"memory":2.5,"desc":"同上。","code":"impl Solution {\n    pub fn largest1_bordered_square(grid: Vec<Vec<i32>>) -> i32 {\n        const MAX: usize = 105;\n        let n = grid.len();\n        let m = grid[0].len();\n        let mut cnt = 0;\n        let mut cache = [[[0; 4]; MAX]; MAX];\n        for i in 0..n {\n            cnt = 0;\n            for j in 0..m {\n                cache[i][j][0] = cnt;\n                cnt = if grid[i][j] == 1 { cnt + 1 } else { 0 };\n            }\n            cnt = 0;\n            for j in (0..m).rev() {\n                cache[i][j][1] = cnt;\n                cnt = if grid[i][j] == 1 { cnt + 1 } else { 0 };\n            }\n        }\n        for j in 0..m {\n            cnt = 0;\n            for i in 0..n {\n                cache[i][j][2] = cnt;\n                cnt = if grid[i][j] == 1 { cnt + 1 } else { 0 };\n            }\n            cnt = 0;\n            for i in (0..n).rev() {\n                cache[i][j][3] = cnt;\n                cnt = if grid[i][j] == 1 { cnt + 1 } else { 0 };\n            }\n        }\n        cnt = 0;\n        for i in 0..n {\n            for j in 0..m {\n                if grid[i][j] == 0 {\n                    continue;\n                }\n                cnt = cnt.max(1);\n                for k in 1..=cache[i][j][1].min(cache[i][j][3]) {\n                    if cache[i + k][j][1] >= k && cache[i][j + k][3] >= k {\n                        cnt = cnt.max((k + 1).pow(2));\n                    }\n                }\n            }\n        }\n        cnt as i32\n    }\n}","date":"2023-02-17"}],"tagList":["数组","动态规划","矩阵"],"level":"Medium"}},{"problemName":"1140.石子游戏II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1140.石子游戏II.json","problemData":{"id":"1240","name":"1140.石子游戏II","url":"https://leetcode.cn/problems/stone-game-ii","desc":"假设爱丽丝和鲍勃都发挥出最佳水平，返回爱丽丝可以得到的最大数量的石头。","solutions":[{"script":"cpp","time":16,"memory":14.3,"desc":"dp[i][m]=第i轮拾取时m情况下的最大数量。","code":"class Solution {\npublic:\n    int stoneGameII(vector<int>& piles) {\n        int n = piles.size(), sum = 0;\n        vector<vector<int>> dp(n, vector<int>(n + 1));\n        for (int i = n - 1; i >= 0; i--) {\n            sum += piles[i];\n            for (int m = 1; m <= n; m++) {\n                if (i + 2 * m >= n) dp[i][m] = sum;\n                else for (int x = 1; x <= 2 * m; x++) dp[i][m] = max(dp[i][m], sum - dp[i + x][max(m, x)]);\n            }\n        }\n        return dp[0][1];\n    }\n};","date":"2023-02-22"},{"script":"python","time":428,"memory":15.3,"desc":"同上。","code":"class Solution:\n    def stoneGameII(self, piles: List[int]) -> int:\n        n, sumv = len(piles), 0\n        dp = [[0] * (n + 1) for _ in range(n)]\n        for i in range(n - 1, -1, -1):\n            sumv += piles[i]\n            for m in range(1, n + 1):\n                if i + 2 * m >= n:\n                    dp[i][m] = sumv\n                else:\n                    for x in range(1, 2*m+1):\n                        dp[i][m] = max(dp[i][m], sumv - dp[i + x][max(x, m)])\n        return dp[0][1]","date":"2023-02-22"},{"script":"rust","time":4,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn stone_game_ii(piles: Vec<i32>) -> i32 {\n        let n = piles.len();\n        let mut sum = 0;\n        let mut dp = vec![vec![0; n + 1]; n];\n        for i in (0..n).rev() {\n            sum += piles[i];\n            for m in 1..=n {\n                if i + 2 * m >= n {\n                    dp[i][m] = sum\n                } else {\n                    for x in 1..=(2 * m) {\n                        dp[i][m] = dp[i][m].max(sum - dp[i + x][x.max(m)])\n                    }\n                }\n            }\n        }\n        dp[0][1]\n    }\n}","date":"2023-02-22"}],"tagList":["数组","数学","动态规划","博弈","前缀和"],"level":"Medium"}},{"problemName":"1143.最长公共子序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1143.最长公共子序列.json","problemData":{"id":"1250","name":"1143.最长公共子序列","url":"https://leetcode.cn/problems/longest-common-subsequence","desc":"给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。","solutions":[{"date":"2020-05-11","time":92,"memory":57.5,"script":"javascript","desc":"动态规划，递推。","code":"/**\n * @param {string} text1\n * @param {string} text2\n * @return {number}\n */\nvar longestCommonSubsequence = function (text1, text2) {\n  const len1 = text1.length;\n  const len2 = text2.length;\n  const dp = [];\n  for (let i = 0; i <= len1; i++) {\n    dp[i] = [];\n    for (let j = 0; j <= len2; j++) if (i === 0 || j === 0) dp[i][j] = 0;\n  }\n  for (let i = 1; i <= len1; i++)\n    for (let j = 1; j <= len2; j++)\n      if (text1[i - 1] === text2[j - 1]) dp[i][j] = dp[i - 1][j - 1] + 1;\n      else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n  return dp[len1][len2];\n};"},{"date":"2020-05-11","time":76,"memory":35.1,"script":"javascript","desc":"根据题解 1，利用滚动数组优化空间。","code":"/**\n * @param {string} text1\n * @param {string} text2\n * @return {number}\n */\nvar longestCommonSubsequence = function (text1, text2) {\n  const len1 = text1.length;\n  const len2 = text2.length;\n  const dp = [];\n  for (let i = 0; i < 2; i++) {\n    dp[i] = [];\n    for (let j = 0; j <= len2; j++) if (i === 0 || j === 0) dp[i][j] = 0;\n  }\n  for (let i = 1; i <= len1; i++) {\n    const compI = i % 2;\n    const preCompI = (i - 1) % 2;\n    for (let j = 1; j <= len2; j++)\n      if (text1[i - 1] === text2[j - 1]) dp[compI][j] = dp[preCompI][j - 1] + 1;\n      else dp[compI][j] = Math.max(dp[preCompI][j], dp[compI][j - 1]);\n  }\n  return dp[len1 % 2][len2];\n};"},{"date":"2020-05-11","time":64,"memory":35.6,"script":"javascript","desc":"根据题解 2，利用&1 取代%2。","code":"/**\n * @param {string} text1\n * @param {string} text2\n * @return {number}\n */\nvar longestCommonSubsequence = function (text1, text2) {\n  const len1 = text1.length;\n  const len2 = text2.length;\n  const dp = [];\n  for (let i = 0; i < 2; i++) {\n    dp[i] = [];\n    for (let j = 0; j <= len2; j++) if (i === 0 || j === 0) dp[i][j] = 0;\n  }\n  let compI, preCompI;\n  for (let i = 1; i <= len1; i++) {\n    compI = i & 1;\n    preCompI = (i - 1) & 1;\n    for (let j = 1; j <= len2; j++)\n      if (text1[i - 1] === text2[j - 1]) dp[compI][j] = dp[preCompI][j - 1] + 1;\n      else dp[compI][j] = Math.max(dp[preCompI][j], dp[compI][j - 1]);\n  }\n  return dp[len1 & 1][len2];\n};"},{"date":"2020-05-12","time":72,"memory":35.1,"script":"javascript","desc":"根据题解 2，利用一维数组替代二维数组。","code":"/**\n * @param {string} text1\n * @param {string} text2\n * @return {number}\n */\nvar longestCommonSubsequence = function (text1, text2) {\n  const len1 = text1.length;\n  const len2 = text2.length;\n  const dp = new Array(Math.max(len1, len2) + 1).fill(0);\n  let leftTop = 0,\n    replace = 0;\n  for (let i = 1; i <= len1; i++) {\n    for (let j = 1; j <= len2; j++) {\n      replace = text1[i - 1] === text2[j - 1] ? leftTop + 1 : Math.max(dp[j], dp[j - 1]);\n      leftTop = dp[j];\n      dp[j] = replace;\n    }\n    leftTop = dp[0];\n  }\n  return dp[len2];\n};"},{"date":"2021-04-03","time":136,"memory":50.7,"script":"typescript","desc":"动态规划。","code":"function longestCommonSubsequence(text1: string, text2: string): number {\n  const len1 = text1.length;\n  const len2 = text2.length;\n  const dp = new Array(len1 + 1).fill(0).map(_ => new Array(len2 + 1).fill(0));\n  for (let i = 0; i < len1; i++) {\n    for (let j = 0; j < len2; j++) {\n      dp[i + 1][j + 1] =\n        text1[i] === text2[j] ? dp[i][j] + 1 : Math.max(dp[i + 1][j], dp[i][j + 1]);\n    }\n  }\n  return dp[len1][len2];\n}"},{"date":"2021-09-10","time":108,"memory":51.8,"script":"typescript","desc":"动态规划。","code":"function longestCommonSubsequence(text1: string, text2: string): number {\n  const len1 = text1.length;\n  const len2 = text2.length;\n  const dp = new Array(len1 + 1).fill(0).map(_ => new Array(len2 + 1).fill(0));\n  for (let i = 1; i <= len1; i++) {\n    for (let j = 1; j <= len2; j++) {\n      dp[i][j] = Math.max(\n        dp[i - 1][j],\n        dp[i][j - 1],\n        dp[i - 1][j - 1] + (text1[i - 1] === text2[j - 1] ? 1 : 0)\n      );\n    }\n  }\n  return dp[len1][len2];\n}"}],"tagList":["字符串","动态规划"],"level":"Medium"}},{"problemName":"1144.递减元素使数组呈锯齿状.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1144.递减元素使数组呈锯齿状.json","problemData":{"id":"1247","name":"1144.递减元素使数组呈锯齿状","url":"https://leetcode.cn/problems/decrease-elements-to-make-array-zigzag","desc":"返回将数组 nums 转换为锯齿数组所需的最小操作次数。","solutions":[{"script":"cpp","time":0,"memory":7,"desc":"遍历。","code":"class Solution {\npublic:\n    int movesToMakeZigzag(vector<int>& nums) {\n        if (nums.size() == 1) return 0;\n        return min(try1(nums), try2(nums));\n    }\n    int try1(vector<int> &nums) {\n        int res = 0;\n        for (int i = 1; i < nums.size(); i += 2) {\n            int p = nums[i - 1];\n            if (i + 1 < nums.size()) p = min(p, nums[i + 1]);\n            if (nums[i] >= p) res += nums[i] - p + 1;\n        }\n        return res;\n    }\n    int try2(vector<int> &nums) {\n        int res = 0;\n        if (nums[0] >= nums[1]) res += nums[0] - nums[1] + 1;\n        for (int i = 2; i < nums.size(); i += 2) {\n            int p = nums[i - 1];\n            if (i + 1 < nums.size()) p = min(p, nums[i + 1]);\n            if (nums[i] >= p) res += nums[i] - p + 1;\n        }\n        return res;\n    }\n};","date":"2023-02-27"},{"script":"python","time":32,"memory":14.9,"desc":"同上。","code":"class Solution:\n    def movesToMakeZigzag(self, nums: List[int]) -> int:\n        n = len(nums)\n        if n == 1:\n            return 0\n  \n        def try1():\n            res = 0\n            for i in range(1, n, 2):\n                p = nums[i-1]\n                if i+1 < n:\n                    p = min(p, nums[i+1])\n                if nums[i] >= p:\n                    res += nums[i] - p + 1\n            return res\n  \n        def try2():\n            res = 0\n            if nums[0] >= nums[1]:\n                res += nums[0] - nums[1] + 1\n            for i in range(2, n, 2):\n                p = nums[i - 1]\n                if i + 1 < n:\n                    p = min(p, nums[i + 1])\n                if nums[i] >= p:\n                    res += nums[i] - p + 1\n            return res\n        return min(try1(), try2())","date":"2023-02-27"},{"script":"rust","time":0,"memory":1.9,"desc":"同上。","code":"impl Solution {\n    pub fn moves_to_make_zigzag(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        if n == 1 {\n            0\n        } else {\n            let try1 = || {\n                let mut res = 0;\n                let mut i = 1;\n                while i < n {\n                    let mut p = nums[i - 1];\n                    if i + 1 < n {\n                        p = p.min(nums[i + 1]);\n                    }\n                    if nums[i] >= p {\n                        res += nums[i] - p + 1;\n                    }\n                    i += 2;\n                }\n                res\n            };\n            let try2 = || {\n                let mut res = 0;\n                if nums[0] >= nums[1] {\n                    res += nums[0] - nums[1] + 1;\n                }\n                let mut i = 2;\n                while i < n {\n                    let mut p = nums[i - 1];\n                    if i + 1 < n {\n                        p = p.min(nums[i + 1]);\n                    }\n                    if nums[i] >= p {\n                        res += nums[i] - p + 1;\n                    }\n                    i += 2;\n                }\n                res\n            };\n            try1().min(try2())\n        }\n    }\n}","date":"2023-02-27"}],"tagList":["贪心","数组"],"level":"Medium"}},{"problemName":"1145.二叉树着色游戏.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1145.二叉树着色游戏.json","problemData":{"id":"1248","name":"1145.二叉树着色游戏","url":"https://leetcode.cn/problems/binary-tree-coloring-game","desc":"现在，假设你是「二号」玩家，根据所给出的输入，假如存在一个 y 值可以确保你赢得这场游戏，则返回 true ；若无法获胜，就请返回 false 。","solutions":[{"script":"cpp","time":4,"memory":10.9,"desc":"x把树分成三部分，y只可能拦住x的某一条去路才是最大值，计算三个方向可以拦住的最多节点。","code":"struct Node {\n    int cnt, lcnt, rcnt;\n    TreeNode *p;\n    Node(): cnt(0), lcnt(0), rcnt(0), p(nullptr) {}\n};\nclass Solution {\npublic:\n    bool btreeGameWinningMove(TreeNode* root, int n, int x) {\n        vector<Node> list(n + 1);\n        int parent = -1;\n        dfs(list, root, parent, parent, x);\n        bool ans = false;\n        if (parent != -1) ans |= list[root->val].cnt - list[x].cnt > list[x].cnt;\n        if (list[x].p->left) ans |= list[root->val].cnt - list[list[x].p->left->val].cnt < list[list[x].p->left->val].cnt;\n        if (list[x].p->right) ans |= list[root->val].cnt - list[list[x].p->right->val].cnt < list[list[x].p->right->val].cnt;\n        return ans;\n    }\n    int dfs(vector<Node> &list, TreeNode *root, int &parent, int cur_parent, int x) {\n        if (!root) return 0;\n        if (root->val == x) parent = cur_parent;\n        auto &node = list[root->val];\n        node.p = root;\n        node.lcnt = dfs(list, root->left, parent, root->val, x);\n        node.rcnt = dfs(list, root->right, parent, root->val, x);\n        node.cnt = node.lcnt + node.rcnt + 1;\n        return node.cnt;\n    }\n};","date":"2023-02-03"},{"script":"python","time":40,"memory":15.2,"desc":"同上。","code":"class Node:\n    def __init__(self) -> None:\n        self.cnt = self.lcnt = self.rcnt = 0\n        self.p = None\n\nclass Solution:\n    def btreeGameWinningMove(self, root: Optional[TreeNode], n: int, x: int) -> bool:\n        list = [Node() for _ in range(n + 1)]\n        parent = -1\n\n        def dfs(root: Optional[TreeNode], cur_parent: int) -> int:\n            nonlocal parent\n            if root == None:\n                return 0\n            if root.val == x:\n                parent = cur_parent\n            node = list[root.val]\n            node.p = root\n            node.lcnt = dfs(root.left, root.val)\n            node.rcnt = dfs(root.right, root.val)\n            node.cnt = node.lcnt + node.rcnt + 1\n            return node.cnt\n\n        dfs(root, -1)\n        ans = False\n        if parent != -1:\n            ans |= list[root.val].cnt - list[x].cnt > list[x].cnt\n        if list[x].p.left:\n            ans |= list[root.val].cnt -                 list[list[x].p.left.val].cnt < list[list[x].p.left.val].cnt\n        if list[x].p.right:\n            ans |= list[root.val].cnt -                 list[list[x].p.right.val].cnt < list[list[x].p.right.val].cnt\n        return ans","date":"2023-02-03"},{"script":"rust","time":0,"memory":2.2,"desc":"同上。","code":"use std::cell::RefCell;\nuse std::rc::Rc;\n#[derive(Clone)]\nstruct Node {\n    cnt: i32,\n    lcnt: i32,\n    rcnt: i32,\n    p: Option<Rc<RefCell<TreeNode>>>,\n}\nimpl Node {\n    fn new() -> Self {\n        Self {\n            cnt: 0,\n            lcnt: 0,\n            rcnt: 0,\n            p: None,\n        }\n    }\n}\n\nimpl Solution {\n    pub fn btree_game_winning_move(root: Option<Rc<RefCell<TreeNode>>>, n: i32, x: i32) -> bool {\n        let val = root.as_ref().unwrap().as_ref().borrow().val as usize;\n        let x = x as usize;\n        let n = n as usize;\n        let list = vec![Node::new(); n + 1];\n        let mut parent = -1;\n        let (list, _) = Solution::dfs(list, root, &mut parent, -1, x as i32);\n        let mut ans = false;\n        if parent != -1 {\n            ans |= list[val].cnt - list[x].cnt > list[x].cnt;\n        }\n        let child = &list[x].p.as_ref().unwrap().as_ref().borrow().left;\n        if child.is_some() {\n            let lval = child.as_ref().unwrap().as_ref().borrow().val as usize;\n            ans |= list[val].cnt - list[lval].cnt < list[lval].cnt;\n        }\n        let child = &list[x].p.as_ref().unwrap().as_ref().borrow().right;\n        if child.is_some() {\n            let rval = child.as_ref().unwrap().as_ref().borrow().val as usize;\n            ans |= list[val].cnt - list[rval].cnt < list[rval].cnt;\n        }\n        ans\n    }\n    fn dfs(\n        list: Vec<Node>,\n        root: Option<Rc<RefCell<TreeNode>>>,\n        parent: *mut i32,\n        cur_parent: i32,\n        x: i32,\n    ) -> (Vec<Node>, i32) {\n        match root {\n            Some(root) => {\n                let mut list = list;\n                let root_node = root.as_ref().borrow();\n                if root_node.val == x {\n                    unsafe {\n                        *parent = cur_parent;\n                    }\n                }\n                let val = root_node.val as usize;\n                list[val].p = Some(root.clone());\n                let (mut list, cnt) =\n                    Solution::dfs(list, root_node.left.clone(), parent, root_node.val, x);\n                list[val].lcnt = cnt;\n                let (mut list, cnt) =\n                    Solution::dfs(list, root_node.right.clone(), parent, root_node.val, x);\n                list[val].rcnt = cnt;\n                list[val].cnt = list[val].lcnt + list[val].rcnt + 1;\n                let cnt = list[val].cnt;\n                (list, cnt)\n            }\n            None => (list, 0),\n        }\n    }\n}","date":"2023-02-03"}],"tagList":["树","深度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"1146.快照数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1146.快照数组.json","problemData":{"id":"1249","name":"1146.快照数组","url":"https://leetcode.cn/problems/snapshot-array","desc":"实现支持下列接口的「快照数组」- SnapshotArray。","solutions":[{"script":"python","time":424,"memory":42.39,"desc":"仅存储变更。","code":"class SnapshotArray:\n    def __init__(self, length: int):\n        self.next_snap = 0\n        self.list = [[(-1, 0)] for _ in range(length)]\n    def set(self, index: int, val: int) -> None:\n        if self.list[index][-1][0] == self.next_snap:\n            self.list[index][-1] = (self.next_snap, val)\n        else:\n            self.list[index].append((self.next_snap, val))\n    def snap(self) -> int:\n        snap = self.next_snap\n        self.next_snap += 1\n        return snap\n    def get(self, index: int, snap_id: int) -> int:\n        res = bisect_right(self.list[index], (snap_id, 1e10))\n        return self.list[index][res - 1][1]","date":"2024-04-26"}],"tagList":["设计","数组","哈希表","二分查找"],"level":"Medium"}},{"problemName":"1147.段式回文.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1147.段式回文.json","problemData":{"id":"1251","name":"1147.段式回文","url":"https://leetcode.cn/problems/longest-chunked-palindrome-decomposition","desc":"给你一个字符串 text，在确保它满足段式回文的前提下，请你返回 段 的 最大数量 k。","solutions":[{"date":"2021-12-12","time":80,"memory":40.5,"script":"typescript","desc":"dfs 每次读取两头最短相匹配字符数。","code":"function longestDecomposition(text: string): number {\n  const n = text.length;\n  if (n <= 1) return n;\n  let lidx = 1;\n  let lstr = text[0];\n  let ridx = n - 2;\n  let rstr = text[n - 1];\n  while (ridx > lidx && lstr !== rstr) {\n    lstr += text[lidx++];\n    rstr = text[ridx--] + rstr;\n  }\n  if (ridx <= lidx && lstr !== rstr) return 1;\n  return longestDecomposition(text.substring(lidx, ridx + 1)) + 2;\n}"},{"script":"cpp","time":4,"memory":6,"desc":"遍历。","code":"class Solution {\npublic:\n    int longestDecomposition(string text) {\n        int n = text.size(), res = 0;\n        auto check = [&](int i1, int i2, int size) -> bool {\n            while (size--) {\n                if (text[i1++] != text[i2++]) return false;\n            }\n            return true;\n        };\n        for (int i = 0; i <= n / 2; i++) {\n            int f = false;\n            for (int cnt = 1; i + cnt <= n - i; cnt++) {\n                if (check(i, n - i - cnt, cnt)) {\n                    f = true;\n                    if (i == n - i - cnt) res += 1; // 是一个字符串\n                    else res += 2; \n                    i += cnt - 1;\n                    break;\n                }\n            }\n            if (!f) {\n                if ((n - 2 * i) / 2 != 0) res += 1; // 只剩空字符串\n                break;\n            }\n        }\n        return res;\n    }\n};","date":"2023-04-12"},{"script":"python","time":44,"memory":14.8,"desc":"同上。","code":"class Solution:\n    def longestDecomposition(self, text: str) -> int:\n        n = len(text)\n        res = 0\n        def check(i1: int, i2: int, size: int) -> bool:\n            while size:\n                if text[i1] != text[i2]:\n                    return False\n                i1 += 1\n                i2 += 1\n                size -= 1\n            return True\n        i = 0\n        while i <= n // 2:\n            f = False\n            cnt = 1\n            while i + cnt <= n - i:\n                if check(i, n - i - cnt, cnt):\n                    f = True\n                    if i == n - i - cnt:\n                        res += 1\n                    else:\n                        res += 2\n                    i += cnt-1\n                    break\n                cnt += 1\n            if not f:\n                if (n - 2 * i) / 2 != 0:\n                    res += 1\n                break\n            i += 1\n        return res","date":"2023-04-12"},{"script":"rust","time":0,"memory":2.1,"desc":"同上。","code":"impl Solution {\n    pub fn longest_decomposition(text: String) -> i32 {\n        let text = text.chars().collect::<Vec<char>>();\n        let n = text.len();\n        let mut res = 0;\n        let check = |mut i1: usize, mut i2: usize, mut size: usize| -> bool {\n            while size != 0 {\n                if text[i1] != text[i2] {\n                    return false;\n                }\n                i1 += 1;\n                i2 += 1;\n                size -= 1;\n            }\n            true\n        };\n        let mut i = 0;\n        while i <= n / 2 {\n            let mut f = false;\n            let mut cnt = 1;\n            while i + cnt <= n - i {\n                if check(i, n - i - cnt, cnt) {\n                    f = true;\n                    res += if i == n - i - cnt { 1 } else { 2 };\n                    i += cnt - 1;\n                    break;\n                }\n                cnt += 1;\n            }\n            if !f {\n                if (n - 2 * i) / 2 != 0 {\n                    res += 1;\n                }\n                break;\n            }\n            i += 1;\n        }\n        res\n    }\n}","date":"2023-04-12"}],"tagList":["贪心","双指针","字符串","动态规划","哈希函数","滚动哈希"],"level":"Hard"}},{"problemName":"1154.一年中的第几天.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1154.一年中的第几天.json","problemData":{"id":"1260","name":"1154.一年中的第几天","url":"https://leetcode.cn/problems/day-of-the-year","desc":"给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。请你计算并返回该日期是当年的第几天。","solutions":[{"date":"2021-12-21","time":16,"memory":5.8,"script":"cpp","desc":"检测闰年和前面有几个月。","code":"class Solution {\n   public:\n    int monthDay[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    void checkLeapYear(int year) {\n        if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) {\n            monthDay[2] = 29;\n        }\n    }\n    int dayOfYear(string date) {\n        int year = 0, month = 0, day = 0;\n        for (int i = 0; i < 4; i++) year = year * 10 + date[i] - '0';\n        for (int i = 5; i < 7; i++) month = month * 10 + date[i] - '0';\n        for (int i = 8; i < 10; i++) day = day * 10 + date[i] - '0';\n        checkLeapYear(year);\n        // printf(\"year = %d, month = %d, day = %d\", year, month, day);\n        int ans = day;\n        for (int i = 1; i < month; i++) ans += monthDay[i];\n        return ans;\n    }\n};"},{"script":"python","time":48,"memory":17.11,"desc":"直接计算。","code":"def isLeapYear(year: int) -> bool:\n            return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0\n        weeks = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n        \n        class Solution:\n            def dayOfYear(self, date: str) -> int:\n                year, month, day = int(date[:4]), int(date[5:7]), int(date[8:])\n                months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30]\n                if isLeapYear(year): months[1] = 29\n                return sum(months[:month - 1]) + day","date":"2023-12-31"}],"tagList":["数学","字符串"],"level":"Easy"}},{"problemName":"1155.掷骰子等于目标和的方法数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1155.掷骰子等于目标和的方法数.json","problemData":{"id":"1263","name":"1155.掷骰子等于目标和的方法数","url":"https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum","desc":"给定三个整数 n ,  k 和 target ，返回可能的方式(从总共 kn 种方式中)滚动骰子的数量，使正面朝上的数字之和等于 target 。","solutions":[{"script":"python","time":84,"memory":18.8,"desc":"记忆化递归，记录当前序号和剩余目标。","code":"class Solution:\n    def numRollsToTarget(self, n: int, k: int, target: int) -> int:\n        @cache\n        def dfs(idx: int, target: int) -> int:\n            if idx == n: return target == 0\n            return sum(dfs(idx + 1, target - i) for i in range(1, min(k, target) + 1)) % (10 ** 9 + 7)\n        return dfs(0, target)","date":"2023-10-24"}],"tagList":["动态规划"],"level":"Medium"}},{"problemName":"1156.单字符重复子串的最大长度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1156.单字符重复子串的最大长度.json","problemData":{"id":"1261","name":"1156.单字符重复子串的最大长度","url":"https://leetcode.cn/problems/swap-for-longest-repeated-character-substring","desc":"给你一个字符串 text，你只能交换其中两个字符一次或者什么都不做，然后得到一些单字符重复的子串。返回其中最长的子串的长度。","solutions":[{"script":"cpp","time":4,"memory":7.9,"desc":"按字符统计数据。","code":"#define pii pair<int, int>\n#define X first\n#define Y second\nclass Solution {\npublic:\n    int maxRepOpt1(string text) {\n        vector<vector<pii>> m(26);\n        int res = 0, n = text.size();\n        for (int i = 0; i < n; i++) {\n            int start = i;\n            while (i + 1 < n && text[i + 1] == text[start]) i++;\n            m[text[start] - 'a'].push_back(make_pair(start, i));\n            res = max(res, i - start + 1);\n        }\n        for (auto &list : m) {\n            int n = list.size();\n            for (int i = 0; i < n; i++) {\n                if (n != 1) res = max(res, list[i].Y - list[i].X + 2);\n                if (i + 1 < n && list[i].Y + 1 == list[i + 1].X - 1) {\n                    int val = list[i].Y - list[i].X + 1 + list[i + 1].Y - list[i + 1].X + 1;\n                    if (!(i == 0 && i + 2 == n)) val += 1;\n                    res = max(res, val);\n                }\n            }\n        }\n        return res;\n    }\n};","date":"2023-06-03"},{"script":"python","time":100,"memory":18.1,"desc":"同上。","code":"class Solution:\n    def maxRepOpt1(self, text: str) -> int:\n        m = [[] for _ in range(26)]\n        res = 0\n        n = len(text)\n        i = 0\n        while i < n:\n            start = i\n            while i + 1 < n and text[i + 1] == text[start]:\n                i += 1\n            m[ord(text[start]) - ord('a')].append((start, i))\n            res = max(res, i - start + 1)\n            i += 1\n        for list in m:\n            n = len(list)\n            for i in range(n):\n                if n != 1:\n                    res = max(res, list[i][1] - list[i][0] + 2)\n                if i + 1 < n and list[i][1] + 1 == list[i + 1][0] - 1:\n                    val = list[i][1] - list[i][0] + 1 +                         list[i + 1][1] - list[i + 1][0] + 1\n                    if not (i == 0 and i + 2 == n):\n                        val += 1\n                    res = max(res, val)\n        return res","date":"2023-06-03"},{"script":"rust","time":0,"memory":2.3,"desc":"同上。","code":"pub fn str_to_vec(s: &String) -> Vec<char> {\n    s.chars().collect()\n}\nimpl Solution {\n    pub fn max_rep_opt1(text: String) -> i32 {\n        let text = str_to_vec(&text);\n        let mut m = vec![vec![]; 26];\n        let mut res = 0;\n        let mut n = text.len();\n        {\n            let mut i = 0;\n            while i < n {\n                let start = i;\n                while i + 1 < n && text[i + 1] == text[start] {\n                    i += 1;\n                }\n                m[text[start] as usize - 'a' as usize].push((start, i));\n                res = res.max(i - start + 1);\n                i += 1;\n            }\n        }\n        for list in m {\n            let n = list.len();\n            for i in 0..n {\n                if n != 1 {\n                    res = res.max(list[i].1 - list[i].0 + 2);\n                }\n                if i + 1 < n && list[i].1 + 1 == list[i + 1].0 - 1 {\n                    let mut val = list[i].1 - list[i].0 + 1 + list[i + 1].1 - list[i + 1].0 + 1;\n                    if !(i == 0 && i + 2 == n) {\n                        val += 1;\n                    }\n                    res = res.max(val);\n                }\n            }\n        }\n        res as i32\n    }\n}","date":"2023-06-03"}],"tagList":["哈希表","字符串","滑动窗口"],"level":"Medium"}},{"problemName":"1160.拼写单词.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1160.拼写单词.json","problemData":{"id":"1112","name":"1160.拼写单词","url":"https://leetcode.cn/problems/find-words-that-can-be-formed-by-characters","desc":"返回词汇表 words 中你掌握的所有单词的 长度之和。","solutions":[{"date":"2022-03-29","time":40,"memory":14.9,"script":"cpp","desc":"哈希存储。","code":"class Solution {\n   public:\n    int countCharacters(vector<string> &words, string chars) {\n        int list[26] = {0}, ans = 0, tmp[26] = {0};\n        for (auto &ch : chars) list[ch - 'a']++;\n        for (auto &word : words) {\n            memset(tmp, 0, sizeof(int) * 26);\n            int f = 1;\n            for (auto &ch : word) tmp[ch - 'a']++;\n            for (int i = 0; i < 26; i++) {\n                if (list[i] < tmp[i]) {\n                    f = 0;\n                    break;\n                }\n            }\n            if (f) ans += word.size();\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","字符串"],"level":"Easy"}},{"problemName":"1161.最大层内元素和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1161.最大层内元素和.json","problemData":{"id":"1116","name":"1161.最大层内元素和","url":"https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree","desc":"请返回层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。","solutions":[{"date":"2022-08-01","time":156,"memory":104.7,"script":"cpp","desc":"层序遍历。","code":"class Solution {\n   public:\n    int maxLevelSum(TreeNode *root) {\n        queue<TreeNode *> q;\n        q.push(root);\n        int max_level = 1, max_sum = root->val, cur = 0, size = 1, level = 1;\n        while (q.size()) {\n            TreeNode *node = q.front();\n            q.pop();\n            if (node->left) {\n                cur += node->left->val;\n                q.push(node->left);\n            }\n            if (node->right) {\n                cur += node->right->val;\n                q.push(node->right);\n            }\n            if (--size == 0) {\n                size = q.size();\n                level++;\n                if (size > 0 && cur > max_sum) {\n                    max_sum = cur;\n                    max_level = level;\n                }\n                cur = 0;\n            }\n        }\n        return max_level;\n    }\n};"},{"date":"2022-08-01","time":24,"memory":3.2,"script":"rust","desc":"层序遍历。","code":"use std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn max_level_sum(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        use std::collections::VecDeque;\n        let root = root.unwrap();\n        let mut q: VecDeque<Rc<RefCell<TreeNode>>> = VecDeque::new();\n        q.push_back(root.clone());\n        let (mut max_level, mut max_sum, mut cur, mut size, mut level) =\n            (1, root.borrow().val, 0, 1, 1);\n        while let Some(node) = q.pop_front() {\n            if node.as_ref().borrow().left.is_some() {\n                cur += node.as_ref().borrow().left.as_ref().unwrap().borrow().val;\n                q.push_back(node.as_ref().borrow().left.as_ref().unwrap().clone());\n            }\n            if node.as_ref().borrow().right.is_some() {\n                cur += node.as_ref().borrow().right.as_ref().unwrap().borrow().val;\n                q.push_back(node.as_ref().borrow().right.as_ref().unwrap().clone());\n            }\n            size -= 1;\n            if size == 0 {\n                size = q.len();\n                level += 1;\n                if size > 0 && cur > max_sum {\n                    max_sum = cur;\n                    max_level = level;\n                }\n                cur = 0;\n            }\n        }\n        max_level\n    }\n}"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"1163.按字典序排在最后的子串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1163.按字典序排在最后的子串.json","problemData":{"id":"1133","name":"1163.按字典序排在最后的子串","url":"https://leetcode.cn/problems/last-substring-in-lexicographical-order","desc":"给你一个字符串 s ，找出它的所有子串并按字典序排列，返回排在最后的那个子串。","solutions":[{"script":"python","time":6360,"memory":18,"desc":"对所有末尾字符串做比较。","code":"class Solution:\n  def lastSubstring(self, s: str) -> str:\n      return max(s[i:] for i in range(len(s)))","date":"2023-04-24"},{"script":"typescript","time":2020,"memory":51,"desc":"同上。","code":"function lastSubstring(s: string): string {\n    let max = s;\n    for (let i = 1; i < s.length; i++) {\n        const subs = s.substring(i);\n        if (max < subs) max = subs;\n    }\n    return max;\n};","date":"2023-04-24"},{"script":"cpp","time":44,"memory":25.8,"desc":"先找到最末尾的字符，再对该字符为起点到结尾的字符串进行比较。","code":"class Solution {\npublic:\n    string lastSubstring(string s) {\n        int n = s.size(), imax = 0;\n        vector<int> idxs;\n        for (int i = 0; i < n; i++) {\n            if (s[imax] < s[i]) imax = i, idxs.clear();\n            if (s[imax] == s[i]) idxs.push_back(i);\n        }\n        imax = 0;\n        for (int i = 1; i < idxs.size(); i++) {\n            int i1 = idxs[imax] + 1, i2 = idxs[i] + 1;\n            while (i2 < n && s[i1] == s[i2]) i1++, i2++;\n            if (i2 == n) break;\n            if (s[i1] < s[i2]) imax = i;\n        }\n        return s.substr(idxs[imax], n - idxs[imax]);\n    }\n};","date":"2023-04-24"},{"script":"rust","time":16,"memory":5.9,"desc":"同上。","code":"fn str_to_vec(s: &String) -> Vec<char> {\n    s.chars().collect()\n}\nimpl Solution {\n    pub fn last_substring(s: String) -> String {\n        let s = str_to_vec(&s);\n        let n = s.len();\n        let mut imax = 0;\n        let mut idxs = vec![];\n        for i in 0..n {\n            if (s[imax] as u8) < (s[i] as u8) {\n                imax = i;\n                idxs.clear();\n            }\n            if (s[imax] as u8) == (s[i] as u8) {\n                idxs.push(i);\n            }\n        }\n        imax = 0;\n        for i in 1..idxs.len() {\n            let (mut i1, mut i2) = (idxs[imax] + 1, idxs[i] + 1);\n            while i2 < n && s[i1] == s[i2] {\n                i1 += 1;\n                i2 += 1;\n            }\n            if i2 == n {\n                break;\n            }\n            if s[i1] < s[i2] {\n                imax = i;\n            }\n        }\n        String::from_utf8(s[idxs[imax]..].iter().map(|v| *v as u8).collect()).unwrap()\n    }\n}","date":"2023-04-24"}],"tagList":["双指针","字符串"],"level":"Hard"}},{"problemName":"1170.比较字符串最小字母出现频次.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1170.比较字符串最小字母出现频次.json","problemData":{"id":"1273","name":"1170.比较字符串最小字母出现频次","url":"https://leetcode.cn/problems/compare-strings-by-frequency-of-the-smallest-character","desc":"定义一个函数 f(s)，统计 s  中（按字典序比较）最小字母的出现频次 ，其中 s 是一个非空字符串。请你返回一个整数数组 answer 作为答案，其中每个 answer[i] 是第 i 次查询的结果。","solutions":[{"script":"cpp","time":8,"memory":11.4,"desc":"排序后二分查找。","code":"class Solution {\npublic:\n    vector<int> numSmallerByFrequency(vector<string>& queries, vector<string>& words) {\n        vector<int> ws;\n        for (auto &w : words) ws.push_back(f(w));\n        sort(ws.begin(), ws.end());\n        vector<int> res;\n        for (auto &q : queries) {\n            int target = f(q), l = 0, r = words.size();\n            while (l < r) {\n                int m = (l + r) / 2;\n                if (target < ws[m]) r = m;\n                else l = m + 1;\n            }\n            res.push_back(words.size() - l);\n        }\n        return res;\n    }\n    int f(string &w) {\n        int cnt = 0;\n        char ch = 'z';\n        for (auto &c : w) {\n            if (c < ch) ch = c, cnt = 1;\n            else if (c == ch) cnt++;\n        }\n        return cnt;\n    }\n};","date":"2023-06-10"},{"script":"python","time":56,"memory":16.7,"desc":"同上。","code":"class Solution:\n    def numSmallerByFrequency(self, queries: List[str], words: List[str]) -> List[int]:\n        def f(w: str):\n            cnt = 0\n            ch = ord('z')\n            for c in w:\n                if ord(c) < ch:\n                    ch = ord(c)\n                    cnt = 1\n                elif ord(c) == ch:\n                    cnt += 1\n            return cnt\n        ws = [f(w) for w in words]\n        ws.sort()\n\n        def query(q: str):\n            target = f(q)\n            l = 0\n            r = len(words)\n            while l < r:\n                m = (l + r)//2\n                if target < ws[m]:\n                    r = m\n                else:\n                    l = m + 1\n            return len(words) - l\n\n        return [query(q) for q in queries]","date":"2023-06-10"}],"tagList":["数组","哈希表","字符串","二分查找","排序"],"level":"Medium"}},{"problemName":"1171.从链表中删去总和值为零的连续节点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1171.从链表中删去总和值为零的连续节点.json","problemData":{"id":"1267","name":"1171.从链表中删去总和值为零的连续节点","url":"https://leetcode.cn/problems/remove-zero-sum-consecutive-nodes-from-linked-list","desc":"给你一个链表的头节点 head，请你编写代码，反复删去链表中由 总和 值为 0 的连续节点组成的序列，直到不存在这样的序列为止。删除完毕后，请你返回最终结果链表的头节点。","solutions":[{"script":"cpp","time":40,"memory":12.1,"desc":"前缀和存储，每次找最前面可以组合为0的节点，递归删除节点。","code":"class Solution {\npublic:\n    ListNode *h = new ListNode();\n    ListNode* removeZeroSumSublists(ListNode* head) {\n        h->next = head;\n        vector<int> sums(1, 0);\n        auto p = h;\n        int start = -1, end = -1;\n        bool find = false;\n        while (p->next && !find) {\n            int sum = p->next->val + sums.back();\n            sums.push_back(sum);\n            for (int i = 0; i < sums.size() - 1; i++) {\n                if (sum - sums[i] == 0) {\n                    start = i;\n                    end = sums.size() - 1;\n                    find = true;\n                    break;\n                }\n            }\n            p = p->next;\n        }\n        if (start == -1) return h->next;\n        p = h;\n        for (int i = 0; i < start; i++) p = p->next;\n        while (end - start > 0) p->next = p->next->next, end--;\n        return removeZeroSumSublists(h->next);\n    }\n};","date":"2023-06-11"},{"script":"python","time":280,"memory":16.8,"desc":"同上。","code":"class Solution:\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        h = ListNode()\n        h.next = head\n        sums = [1]\n        p = h\n        start = end = -1\n        find = False\n        while p.next and not find:\n            sum = p.next.val + sums[-1]\n            sums.append(sum)\n            for i in range(len(sums) - 1):\n                if sum - sums[i] == 0:\n                    start = i\n                    end = len(sums) - 1\n                    find = True\n                    break\n            p = p.next\n        if start == -1:\n            return h.next\n        p = h\n        for i in range(start):\n            p = p.next\n        while end-start > 0:\n            p.next = p.next.next\n            end -= 1\n        return self.removeZeroSumSublists(h.next)","date":"2023-06-11"},{"script":"rust","time":8,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn remove_zero_sum_sublists(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        let mut h = Box::new(ListNode::new(0));\n        h.next = head;\n        let mut sums = vec![1];\n        let mut p = &mut h;\n        let (mut start, mut end) = (usize::MAX, usize::MAX);\n        let mut find = false;\n        while p.next.is_some() && !find {\n            let next = p.next.as_mut().unwrap();\n            let sum = next.val + sums.last().unwrap();\n            sums.push(sum);\n            for i in 0..sums.len() - 1 {\n                if sum - sums[i] == 0 {\n                    start = i;\n                    end = sums.len() - 1;\n                    find = true;\n                    break;\n                }\n            }\n            p = next;\n        }\n        if start == usize::MAX {\n            h.next\n        } else {\n            p = &mut h;\n            for i in 0..start {\n                p = p.next.as_mut().unwrap();\n            }\n            while end - start > 0 {\n                let child = p.next.as_mut().unwrap().next.take();\n                p.next = child;\n                end -= 1;\n            }\n            Solution::remove_zero_sum_sublists(h.next)\n        }\n    }\n}","date":"2023-06-11"}],"tagList":["哈希表","链表"],"level":"Medium"}},{"problemName":"1172.餐盘栈.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1172.餐盘栈.json","problemData":{"id":"1270","name":"1172.餐盘栈","url":"https://leetcode.cn/problems/dinner-plate-stacks","desc":"我们把无限数量 ∞ 的栈排成一行，按从左到右的次序从 0 开始编号。每个栈的的最大容量 capacity 都相同。实现一个叫「餐盘」的类 DinnerPlates。","solutions":[{"script":"cpp","time":448,"memory":205.7,"desc":"模拟栈，用优先队列和哈希表存储从左往右空着的元素，末尾为空时删除末尾的栈。","code":"class DinnerPlates {\npublic:\n    int capacity;\n    vector<vector<int>> ss;\n    unordered_set<int> used;\n    priority_queue<int, vector<int>, greater<int>> q;\n\n    DinnerPlates(int capacity): capacity(capacity) {}\n\n    int load_stack() {\n        ss.push_back(vector<int>());\n        return ss.size() - 1;\n    }\n\n    void clear_last() {\n        while (ss.size() && ss.back().size() == 0) ss.pop_back();\n    }\n    \n    void push(int val) {\n        while (q.size() && q.top() >= ss.size()) q.pop();\n        if (q.empty()) {\n            int idx = ss.size() - 1;\n            if (ss.empty() || ss[idx].size() == capacity) idx = load_stack();\n            ss[idx].push_back(val);\n        } else {\n            int idx = q.top();\n            ss[idx].push_back(val);\n            if (ss[idx].size() == capacity) q.pop(), used.erase(idx);\n        }\n    }\n    \n    int pop() {\n        clear_last();\n        if (ss.empty()) return -1;\n        int back = ss.back().back();\n        ss.back().pop_back();\n        return back;\n    }\n    \n    int popAtStack(int index) {\n        if (index >= ss.size() || ss[index].size() == 0) return -1;\n        int back = ss[index].back();\n        ss[index].pop_back();\n        clear_last();\n        if (index < ss.size() && !used.count(index)) q.push(index), used.insert(index);\n        return back;\n    }\n};","date":"2023-04-28"},{"script":"cpp","time":384,"memory":205.6,"desc":"模拟栈，用优先队列和哈希表存储从左往右空着的元素，用last记录末尾元素。","code":"class DinnerPlates {\npublic:\n    int capacity, last;\n    vector<vector<int>> ss;\n    unordered_set<int> used;\n    priority_queue<int, vector<int>, greater<int>> q;\n\n    DinnerPlates(int capacity): capacity(capacity), last(0) {\n        ss.push_back(vector<int>());\n    }\n\n    int get_last() {\n        if (ss[last].size() == capacity) last++;\n        if (last == ss.size()) ss.push_back(vector<int>());\n        return last;\n    }\n    \n    void push(int val) {\n        while (q.size() && q.top() > last) q.pop();\n        if (q.empty()) {\n            ss[get_last()].push_back(val);\n        } else {\n            int idx = q.top();\n            ss[idx].push_back(val);\n            if (ss[idx].size() == capacity) q.pop(), used.erase(idx);\n        }\n    }\n    \n    int pop() {\n        while (last > 0 && ss[last].size() == 0) last--;\n        if (last == 0 && ss[last].size() == 0) return -1;\n        int back = ss[last].back();\n        ss[last].pop_back();\n        return back;\n    }\n    \n    int popAtStack(int index) {\n        if (index > last || ss[index].size() == 0) return -1;\n        int back = ss[index].back();\n        ss[index].pop_back();\n        if (!used.count(index)) q.push(index), used.insert(index);\n        return back;\n    }\n};","date":"2023-04-28"},{"script":"python","time":632,"memory":100.7,"desc":"同上。","code":"from heapq import *\nclass DinnerPlates:\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.last = 0\n        self.ss = [[]]\n        self.used = set()\n        self.q = []\n\n    def get_last(self):\n        if len(self.ss[self.last]) == self.capacity:\n            self.last += 1\n        if self.last == len(self.ss):\n            self.ss.append([])\n        return self.last\n\n    def push(self, val: int) -> None:\n        while len(self.q) and self.q[0] > self.last:\n            heappop(self.q)\n        if len(self.q) == 0:\n            self.ss[self.get_last()].append(val)\n        else:\n            idx = self.q[0]\n            self.ss[idx].append(val)\n            if len(self.ss[idx]) == self.capacity:\n                heappop(self.q)\n                self.used.remove(idx)\n\n    def pop(self) -> int:\n        while self.last > 0 and len(self.ss[self.last]) == 0:\n            self.last -= 1\n        if self.last == 0 and len(self.ss[self.last]) == 0:\n            return -1\n        back = self.ss[self.last][-1]\n        self.ss[self.last].pop()\n        return back\n\n    def popAtStack(self, index: int) -> int:\n        if index > self.last or len(self.ss[index]) == 0:\n            return -1\n        back = self.ss[index][-1]\n        self.ss[index].pop()\n        if index not in self.used:\n            heappush(self.q, index)\n            self.used.add(index)\n        return back","date":"2023-04-28"},{"script":"rust","time":116,"memory":76.6,"desc":"同上。","code":"use std::cmp::Ordering;\n\n#[derive(PartialEq)]\nstruct RevUnsize(usize);\nimpl Eq for RevUnsize {}\n\nimpl PartialOrd for RevUnsize {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n}\nimpl Ord for RevUnsize {\n    fn cmp(&self, other: &RevUnsize) -> Ordering {\n        other.0.partial_cmp(&self.0).unwrap()\n    }\n}\n\nstruct DinnerPlates {\n    capacity: usize,\n    last: usize,\n    ss: Vec<Vec<i32>>,\n    used: std::collections::HashSet<usize>,\n    q: std::collections::BinaryHeap<RevUnsize>,\n}\n\nimpl DinnerPlates {\n    fn new(capacity: i32) -> Self {\n        Self {\n            capacity: capacity as usize,\n            last: 0,\n            ss: vec![vec![]],\n            used: Default::default(),\n            q: Default::default(),\n        }\n    }\n\n    fn format_last(&mut self) {\n        if self.ss[self.last].len() == self.capacity {\n            self.last += 1;\n        }\n        if self.last == self.ss.len() {\n            self.ss.push(vec![]);\n        }\n    }\n\n    fn push(&mut self, val: i32) {\n        while !self.q.is_empty() && (*self.q.peek().unwrap()).0 > self.last {\n            self.q.pop();\n        }\n        if self.q.is_empty() {\n            self.format_last();\n            self.ss[self.last].push(val);\n        } else {\n            let idx = (*self.q.peek().unwrap()).0;\n            self.ss[idx].push(val);\n            if self.ss[idx].len() == self.capacity {\n                self.q.pop();\n                self.used.remove(&idx);\n            }\n        }\n    }\n\n    fn pop(&mut self) -> i32 {\n        while self.last > 0 && self.ss[self.last].len() == 0 {\n            self.last -= 1;\n        }\n        if self.last == 0 && self.ss[self.last].len() == 0 {\n            -1\n        } else {\n            self.ss[self.last].pop().unwrap()\n        }\n    }\n\n    fn pop_at_stack(&mut self, index: i32) -> i32 {\n        let index = index as usize;\n        if index > self.last || self.ss[index].len() == 0 {\n            -1\n        } else {\n            let back = self.ss[index].pop().unwrap();\n            if !self.used.contains(&index) {\n                self.q.push(RevUnsize(index));\n                self.used.insert(index);\n            }\n            back\n        }\n    }\n}","date":"2023-04-28"}],"tagList":["栈","设计","哈希表","堆（优先队列）"],"level":"Hard"}},{"problemName":"1175.质数排列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1175.质数排列.json","problemData":{"id":"1279","name":"1175.质数排列","url":"https://leetcode.cn/problems/prime-arrangements","desc":"请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。","solutions":[{"date":"2021-12-04","time":88,"memory":39.5,"script":"typescript","desc":"算出质数位置进行阶乘。","code":"function numPrimeArrangements(n: number): number {\n  const MOD = BigInt(10 ** 9 + 7);\n  const cnt = count(n);\n  return Number((factorial(cnt) * factorial(n - cnt)) % MOD);\n  function count(n: number): number {\n    const arr: boolean[] = new Array(n + 1).fill(true);\n    arr[0] = arr[1] = false;\n    for (let i = 2; i <= n; i++) {\n      if (!arr[i]) continue;\n      for (let j = 2; i * j <= n; j++) arr[i * j] = false;\n    }\n    return arr.filter(Boolean).length;\n  }\n  function factorial(n: number): bigint {\n    let ans = 1n;\n    for (let i = 2n; i <= n; i++) ans = (ans * i) % MOD;\n    return ans;\n  }\n}"}],"tagList":["数学"],"level":"Easy"}},{"problemName":"1177.构建回文串检测.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1177.构建回文串检测.json","problemData":{"id":"1281","name":"1177.构建回文串检测","url":"https://leetcode.cn/problems/can-make-palindrome-from-substring","desc":"给你一个字符串 s，请你对 s 的子串进行检测。每次检测，待检子串都可以表示为 queries[i] = [left, right, k]。我们可以 重新排列 子串 s[left], ..., s[right]，并从中选择 最多 k 项替换成任何小写英文字母。     如果在上述检测过程中，子串可以变成回文形式的字符串，那么检测结果为 true，否则结果为 false。    返回答案数组 answer[]，其中 answer[i] 是第 i 个待检子串 queries[i] 的检测结果。","solutions":[{"script":"cpp","time":284,"memory":92.6,"desc":"因为可以重新排列，所以只需要考虑区间内的奇偶即可。","code":"class Solution {\npublic:\n    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {\n        vector<int> list(1, 0);\n        for (auto &c : s) list.push_back(list.back() ^ (1 << (c - 'a')));\n        vector<bool> res;\n        for (auto &q : queries) {\n            int l = q[0], r = q[1], k = q[2], val = list[r + 1] ^ list[l], cnt = 0;\n            for (int i = 0; i < 26; i++) \n                if (val & (1 << i)) cnt++;\n            if ((r - l + 1) % 2 == 0) res.push_back(2 * k >= cnt);\n            else res.push_back(2 * k >= cnt - 1);\n        }\n        return res;\n    }\n};","date":"2023-06-15"},{"script":"python","time":588,"memory":56.4,"desc":"同上。","code":"class Solution:\n    def canMakePaliQueries(self, s: str, queries: List[List[int]]) -> List[bool]:\n        list = [1]\n        for c in s:\n            list.append(list[-1] ^ (1 << (ord(c) - ord('a'))))\n\n        def check(q: List[int]):\n            l, r, k = q[0], q[1], q[2]\n            val = list[r+1] ^ list[l]\n            cnt = 0\n            for i in range(26):\n                if val & (1 << i):\n                    cnt += 1\n            if (r-l+1) % 2:\n                return 2 * k >= cnt - 1\n            else:\n                return 2 * k >= cnt\n\n        return [check(q) for q in queries]","date":"2023-06-15"},{"script":"rust","time":28,"memory":9.5,"desc":"同上。","code":"impl Solution {\n    pub fn can_make_pali_queries(s: String, queries: Vec<Vec<i32>>) -> Vec<bool> {\n        let mut list = vec![0];\n        for c in s.as_bytes() {\n            list.push(list.last().unwrap() ^ (1 << (*c - b'a')));\n        }\n        let check = |q: Vec<i32>| -> bool {\n            let l = q[0] as usize;\n            let r = q[1] as usize;\n            let k = q[2];\n            let val = list[r + 1] ^ list[l];\n            let mut cnt = 0;\n            for i in 0..26 {\n                if (val & (1 << i)) != 0 {\n                    cnt += 1;\n                }\n            }\n            if (r - l + 1) % 2 == 0 {\n                2 * k >= cnt\n            } else {\n                2 * k >= cnt - 1\n            }\n        };\n        queries.into_iter().map(|q| check(q)).collect()\n    }\n}","date":"2023-06-15"}],"tagList":["位运算","数组","哈希表","字符串","前缀和"],"level":"Medium"}},{"problemName":"1184.公交站间的距离.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1184.公交站间的距离.json","problemData":{"id":"1287","name":"1184.公交站间的距离","url":"https://leetcode.cn/problems/distance-between-bus-stops","desc":"返回乘客从出发点 start 到目的地 destination 之间的最短距离。","solutions":[{"date":"2022-03-29","time":0,"memory":8.6,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    int comp(vector<int>& distance, int start, int destination, int f) {\n        int sum = 0;\n        while (start != destination) {\n            if (f == 1) sum += distance[start];\n            start += f;\n            if (start == distance.size())\n                start = 0;\n            else if (start == -1)\n                start = distance.size() - 1;\n            if (f == -1) sum += distance[start];\n        }\n        return sum;\n    }\n    int distanceBetweenBusStops(vector<int>& distance, int start,\n                                int destination) {\n        return min(comp(distance, start, destination, 1),\n                   comp(distance, start, destination, -1));\n    }\n};"},{"date":"2022-07-24","time":0,"memory":2.1,"script":"rust","desc":"遍历。","code":"impl Solution {\n    pub fn distance_between_bus_stops(distance: Vec<i32>, start: i32, destination: i32) -> i32 {\n        let n = distance.len() as i32;\n        let (mut sum1, mut sum2) = (0, 0);\n        let (mut cur1, mut cur2) = (start, destination);\n        let mut i = start;\n        while i != destination {\n            sum1 += distance[i as usize];\n            i = (i + 1) % n;\n        }\n        i = destination;\n        while i != start {\n            sum2 += distance[i as usize];\n            i = (i + 1) % n;\n        }\n        sum1.min(sum2)\n    }\n}"}],"tagList":["数组"],"level":"Easy"}},{"problemName":"1185.一周中的第几天.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1185.一周中的第几天.json","problemData":{"id":"1289","name":"1185.一周中的第几天","url":"https://leetcode.cn/problems/day-of-the-week","desc":"给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。","solutions":[{"date":"2022-01-04","time":0,"memory":5.9,"script":"cpp","desc":"遍历求出距离第一天的天数并取模。","code":"string names[] = {\"Friday\",  \"Saturday\",  \"Sunday\",  \"Monday\",\n                  \"Tuesday\", \"Wednesday\", \"Thursday\"};\nint isLeapYear(int year) {\n    return year % 400 == 0 || year % 100 != 0 && year % 4 == 0;\n}\nclass Solution {\n   public:\n    string dayOfTheWeek(int day, int month, int year) {\n        int months[] = {\n            0,  31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31,\n            30, 31};\n        while (month) day += months[--month];\n        while (year > 1971) day += isLeapYear(--year) ? 366 : 365;\n        return names[(day - 1) % 7];\n    }\n};"},{"script":"python","time":36,"memory":17.09,"desc":"计算天数后取模。","code":"def isLeapYear(year: int) -> bool:\n        return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0\n    weeks = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"]\n    \n    class Solution:\n        def dayOfTheWeek(self, day: int, month: int, year: int) -> str:\n            months = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30]\n            if isLeapYear(year): months[1] = 29\n            day += sum(365 + isLeapYear(y) for y in range(1971, year)) + sum(months[:month - 1])\n            return weeks[(day + 3) % 7]","date":"2023-12-30"}],"tagList":["数学"],"level":"Easy"}},{"problemName":"1186.删除一次得到子数组最大和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1186.删除一次得到子数组最大和.json","problemData":{"name":"1186.删除一次得到子数组最大和","url":"https://leetcode.cn/problems/maximum-subarray-sum-with-one-deletion/submissions/","desc":"给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。","solutions":[{"script":"cpp","time":32,"memory":22.6,"desc":"dp[i]表示以arr[i]为结尾的删0个和1个时的最大值。","code":"#define MIN -0x3f3f3f3f\nclass Solution {\npublic:\n    int maximumSum(vector<int>& arr) {\n        int n = arr.size(), dp0 = MIN, dp1 = MIN, res = MIN;\n        for (int i = 0; i < n; i++) {\n            dp1 = max(dp0, dp1 + arr[i]);\n            dp0 = max(dp0, 0) + arr[i];\n            res = max(res, max(dp0, dp1));\n        }\n        return res;\n    }\n};","date":"2023-06-27"},{"script":"python","time":104,"memory":24.2,"desc":"同上。","code":"class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        dp0 = dp1 = res = -inf\n        for num in arr:\n            dp1 = max(dp0, dp1 + num)\n            dp0 = max(dp0, 0) + num\n            res = max(res, max(dp0, dp1))\n        return res","date":"2023-06-27"},{"script":"rust","time":8,"memory":3,"desc":"同上。","code":"impl Solution {\n    pub fn maximum_sum(arr: Vec<i32>) -> i32 {\n        use std::cmp::max;\n        let (mut dp0, mut dp1, mut res) = (-0x3f3f3f3f, -0x3f3f3f3f, -0x3f3f3f3f);\n        for num in arr {\n            dp1 = max(dp0, dp1 + num);\n            dp0 = max(dp0, 0) + num;\n            res = max(res, max(dp0, dp1));\n        }\n        res\n    }\n}","date":"2023-06-27"},{"script":"python","time":110,"memory":40.88,"desc":"dp[i][j]表示以i为结尾的数组，当前已经删除了j个元素时的最大和。","code":"class Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        n = len(arr)\n        dp = [[0] * 2 for _ in range(n)]\n        dp[0][0] = arr[0]\n        dp[0][1] = 0\n        for i in range(1, n):\n            dp[i][0] = max(dp[i - 1][0], 0) + arr[i]\n            dp[i][1] = max(dp[i - 1][1] + arr[i], dp[i - 1][0])\n        return max([v for item in dp[1:] for v in item], default = arr[0])","date":"2024-07-21"}],"tagList":[],"level":"Easy"}},{"problemName":"1187.使数组严格递增.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1187.使数组严格递增.json","problemData":{"id":"1290","name":"1187.使数组严格递增","url":"https://leetcode.cn/problems/make-array-strictly-increasing","desc":"给你两个整数数组 arr1 和 arr2，返回使 arr1 严格递增所需要的最小「操作」数（可能为 0）。每一步「操作」中，你可以分别从 arr1 和 arr2 中各选出一个索引，分别为 i 和 j，0 <= i < arr1.length 和 0 <= j < arr2.length，然后进行赋值运算 arr1[i] = arr2[j]。如果无法让 arr1 严格递增，请返回 -1。","solutions":[{"script":"cpp","time":604,"memory":71.1,"desc":"dfs，每次记录当前下标和上一个值，如果当前值替换，应该换成最大可换的值。","code":"class Solution {\n    public:\n        int makeArrayIncreasing(vector<int>& arr1, vector<int>& arr2) {\n            set<int> s;\n            for (auto &num : arr2) s.insert(num);\n            unordered_map<int, unordered_map<int, int>> m;\n            function<int(int, int)> dfs = [&](int idx, int pre) -> int {\n                if (m[idx].count(pre)) return m[idx][pre];\n                if (idx == - 1) return m[idx][pre] = 0;\n                int res = INT_MAX;\n                if (arr1[idx] < pre) res = dfs(idx - 1, arr1[idx]);\n                auto find = s.lower_bound(pre);\n                if (find != s.begin()) {\n                    int next = dfs(idx - 1, *(--find));\n                    if (next != INT_MAX)\n                    res = min(res, 1 + next);\n                }\n                return m[idx][pre] = res;\n            };\n            int res = dfs(arr1.size() - 1, INT_MAX);\n            return res == INT_MAX ? -1 : res;\n        }\n    };","date":"2023-04-20"},{"script":"python","time":724,"memory":131.3,"desc":"同上。","code":"class Solution:\n    def makeArrayIncreasing(self, arr1: List[int], arr2: List[int]) -> int:\n        arr2.sort()\n\n        @cache\n        def dfs(idx: int, pre: int) -> int:\n            if idx == -1:\n                return 0\n            res = inf\n            if arr1[idx] < pre:\n                res = dfs(idx-1, arr1[idx])\n            find = bisect_left(arr2, pre)\n            if find > 0:\n                res = min(res, dfs(idx-1, arr2[find - 1]) + 1)\n            return res\n        res = dfs(len(arr1) - 1, inf)\n        return res if res != inf else -1","date":"2023-04-20"}],"tagList":["数组","二分查找","动态规划","排序"],"level":"Hard"}},{"problemName":"1189.“气球”的最大数量.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1189.“气球”的最大数量.json","problemData":{"id":"1297","name":"1189.“气球”的最大数量","url":"https://leetcode.cn/problems/maximum-number-of-balloons","desc":"字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 \"balloon\"。","solutions":[{"date":"2022-02-13","time":0,"memory":6.5,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    int maxNumberOfBalloons(string text) {\n        int m[26] = {0};\n        for (auto &ch : text) m[ch - 'a']++;\n        return min(min(min(m[1], m[0]), m['n' - 'a']),\n                   min(m['l' - 'a'], m['o' - 'a']) / 2);\n    }\n};"}],"tagList":["哈希表","字符串","计数"],"level":"Easy"}},{"problemName":"1190.反转每对括号间的子串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1190.反转每对括号间的子串.json","problemData":{"id":"1298","name":"1190.反转每对括号间的子串","url":"https://leetcode.cn/problems/reverse-substrings-between-each-pair-of-parentheses","desc":"给出一个字符串 s（仅含有小写英文字母和括号）。请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。","solutions":[{"date":"2021-05-26","time":72,"memory":39.4,"script":"typescript","desc":"栈储存。","code":"function reverseParentheses(s: string): string {\n  const stack: string[] = [];\n  for (const c of s) {\n    if (c === ')') {\n      let str = '';\n      while (stack[stack.length - 1] !== '(') str = stack.pop()! + str;\n      stack.pop();\n      stack.push(str.split('').reverse().join(''));\n    } else stack.push(c);\n  }\n  return stack.join('');\n}"}],"tagList":["栈","字符串"],"level":"Medium"}},{"problemName":"1200.最小绝对差.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1101-1200/1200.最小绝对差.json","problemData":{"id":"1306","name":"1200.最小绝对差","url":"https://leetcode.cn/problems/minimum-absolute-difference","desc":"请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。","solutions":[{"date":"2022-03-29","time":52,"memory":32.3,"script":"cpp","desc":"排序。","code":"class Solution {\n   public:\n    vector<vector<int>> minimumAbsDifference(vector<int>& arr) {\n        vector<vector<int>> ans;\n        sort(arr.begin(), arr.end());\n        int prev = arr[0], nmax = INT_MAX;\n        for (int i = 1; i < arr.size(); i++) {\n            int num = arr[i];\n            if (num - prev <= nmax) {\n                if (num - prev < nmax) ans.clear();\n                vector<int> item;\n                item.push_back(prev);\n                item.push_back(num);\n                ans.push_back(item);\n                nmax = num - prev;\n            }\n            prev = num;\n        }\n        return ans;\n    }\n};"},{"date":"2022-07-04","time":60,"memory":31.8,"script":"cpp","desc":"遍历，对于每个点找到他的最小值。","code":"class Solution {\n  public:\n    vector<vector<int>> minimumAbsDifference(vector<int>& arr) {\n        vector<vector<int>> ans;\n        sort(arr.begin(), arr.end());\n        int nmin = INT_MAX;\n        for (int l = 0, r = 1; r < arr.size(); r++) {\n            while (l < r && abs(arr[l] - arr[r]) > nmin) l++;\n            if (l == r) continue;\n            int nextmin = abs(arr[l] - arr[r]);\n            if (nextmin < nmin) ans.clear();\n            nmin = nextmin;\n            vector<int> item(2);\n            item[0] = arr[l];\n            item[1] = arr[r];\n            ans.push_back(item);\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","排序"],"level":"Easy"}}]},{"dirName":"1201-1300","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\1201-1300","problems":[{"problemName":"1201.丑数III.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1201.丑数III.json","problemData":{"id":"1307","name":"1201.丑数III","url":"https://leetcode.cn/problems/ugly-number-iii","desc":"给你四个整数：n 、a 、b 、c ，请你设计一个算法来找出第 n 个丑数。","solutions":[{"date":"2022-01-07","time":0,"memory":5.8,"script":"cpp","desc":"二分答案，求出在数值 x 之前有几个丑数。","code":"class Solution {\n   public:\n    long long gcd(long long a, long long b) {\n        if (b) return gcd(b, a % b);\n        return a;\n    }\n    long long lcm(long long a, long long b) {\n        return (long long)(a * b / gcd(a, b));\n    }\n    long long a, b, c, ab, ac, bc, abc;\n    long long get(long long cnt) {\n        //printf(\"a = %d, b = %d, c = %d, ab = %d, ac = %d, bc = %d, abc = %d\n\",\n        //       a, b, c, ab, ac, bc, abc);\n        return cnt / a + cnt / b + cnt / c - cnt / ab - cnt / bc - cnt / ac +\n               cnt / abc;\n    }\n    int nthUglyNumber(int n, int a, int b, int c) {\n        this->a = a;\n        this->b = b;\n        this->c = c;\n        ab = lcm(a, b);\n        ac = lcm(a, c);\n        bc = lcm(b, c);\n        abc = lcm(a, lcm(b, c));\n        long long l = 1, r = 2000000000, m;\n        while (l < r) {\n            m = (l + r) / 2;\n            if (get(m) >= n)\n                r = m;\n            else\n                l = m + 1;\n        }\n        return l;\n    }\n};"}],"tagList":["数学","二分查找","组合数学","数论"],"level":"Medium"}},{"problemName":"1202.交换字符串中的元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1202.交换字符串中的元素.json","problemData":{"id":"1308","name":"1202.交换字符串中的元素","url":"https://leetcode.cn/problems/smallest-string-with-swaps","desc":"给你一个字符串 s,返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。","solutions":[{"date":"2021-05-01","time":236,"memory":67.1,"script":"typescript","desc":"并查集。","code":"class UnionFind {\n  elements: number[];\n  constructor(public size: number) {\n    this.elements = new Array(size).fill(0).map((_, i) => i);\n  }\n  same(v1: number, v2: number): boolean {\n    return this.find(v1) === this.find(v2);\n  }\n  find(v: number): number {\n    return v === this.elements[v] ? v : (this.elements[v] = this.find(this.elements[v]));\n  }\n  union(v1: number, v2: number): void {\n    const e1 = this.find(v1);\n    const e2 = this.find(v2);\n    if (e1 !== e2) {\n      this.elements[e1] = e2;\n      this.size--;\n    }\n  }\n}\nfunction smallestStringWithSwaps(s: string, pairs: number[][]): string {\n  const len = s.length;\n  const uf = new UnionFind(len);\n  pairs.forEach(([i1, i2]) => uf.union(i1, i2));\n  const map: Record<number, number[]> = {};\n  for (let i = 0; i < len; i++) {\n    const index = uf.find(i);\n    let list = map[index];\n    if (!list) list = map[index] = [];\n    list.push(i);\n  }\n  const lists = Object.values(map);\n  const cache = s.split('');\n  let ans = s.split('');\n  for (const list of lists) {\n    const sorted = list.slice().sort((i1, i2) => s[i1].codePointAt(0)! - s[i2].codePointAt(0)!);\n    for (let i = 0, l = list.length; i < l; i++) {\n      ans[list[i]] = cache[sorted[i]];\n    }\n  }\n  return ans.join('');\n}"}],"tagList":["深度优先搜索","广度优先搜索","并查集","数组","哈希表","字符串","排序"],"level":"Medium"}},{"problemName":"1206.设计跳表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1206.设计跳表.json","problemData":{"id":"1337","name":"1206.设计跳表","url":"https://leetcode.cn/problems/design-skiplist","desc":"不使用任何库函数，设计一个跳表 。","solutions":[{"date":"2022-07-26","time":516,"memory":28.1,"script":"cpp","desc":"构造跳表。","code":"class Node {\n   public:\n    int key, cnt;\n    Node *next, *skip_next;\n    Node(int _key) {\n        key = _key;\n        cnt = 1;\n        next = skip_next = nullptr;\n    }\n};\n\nclass Skiplist {\n   public:\n    Node *head;\n    Skiplist() { head = new Node(0); }\n    bool search(int target) {\n        Node *node = head->next;\n        while (node && node->key < target) {\n            if (node->skip_next && node->skip_next->key < target)\n                node = node->skip_next;\n            else\n                node = node->next;\n        }\n        return node && node->key == target;\n    }\n    void add(int num) {\n        Node *node = head->next, *prev = head;\n        while (node && node->key < num) {\n            prev = node;\n            if (node->skip_next && node->skip_next->key < num)\n                node = node->skip_next;\n            else\n                node = node->next;\n        }\n        if (node && node->key == num)\n            node->cnt++;\n        else {\n            Node *next = new Node(num);\n            next->next = node;\n            prev->next = next;\n            maintain_skip();\n        }\n    }\n    bool erase(int num) {\n        Node *node = head->next, *prev = head;\n        while (node && node->key < num) {\n            prev = node;\n            if (node->skip_next && node->skip_next->key < num)\n                node = node->skip_next;\n            else\n                node = node->next;\n        }\n        if (!node || node->key != num) return false;\n        if (node->cnt > 1)\n            node->cnt--;\n        else {\n            prev->next = node->next;\n            maintain_skip();\n            delete node;\n        }\n        return true;\n    }\n    void maintain_skip() {\n        bool check = true;\n        Node *node = head->next;\n        while (node) {\n            if (check && node->next && node->next->next) {\n                node->skip_next = node->next->next;\n            } else {\n                node->skip_next = nullptr;\n            }\n            node = node->next;\n        }\n    }\n};"}],"tagList":["设计","链表"],"level":"Hard"}},{"problemName":"1207.独一无二的出现次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1207.独一无二的出现次数.json","problemData":{"id":"1319","name":"1207.独一无二的出现次数","url":"https://leetcode.cn/problems/unique-number-of-occurrences","desc":"给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。","solutions":[{"date":"2020-10-28","time":72,"memory":40.2,"script":"typescript","desc":"用 map 储存数据，用 set 去重比较。","code":"function uniqueOccurrences(arr: number[]): boolean {\n  const map = new Map<number, number>();\n  const setMap = (num: number) => map.set(num, map.has(num) ? map.get(num)! + 1 : 1);\n  arr.forEach(v => setMap(v));\n  // console.log(map);\n  return new Set(map.values()).size === map.size;\n}"}],"tagList":["数组","哈希表"],"level":"Easy"}},{"problemName":"1208.尽可能使字符串相等.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1208.尽可能使字符串相等.json","problemData":{"id":"1321","name":"1208.尽可能使字符串相等","url":"https://leetcode.cn/problems/get-equal-substrings-within-budget","desc":"给你两个长度相同的字符串，s 和 t。将 s  中的第  i  个字符变到  t  中的第 i 个字符需要  |s[i] - t[i]|  的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。用于变更字符串的最大预算是  maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。","solutions":[{"date":"2021-02-05","time":116,"memory":49,"script":"typescript","desc":"双指针。","code":"function equalSubstring(s: string, t: string, maxCost: number): number {\n  const len = s.length;\n  const arr = new Array(len)\n    .fill(0)\n    .map((_, i) => Math.abs(s[i].charCodeAt(0) - t[i].charCodeAt(0)));\n  let l = 0,\n    r = 0,\n    cost = arr[l];\n  while (r < len) cost = cost + arr[++r] - (cost > maxCost ? arr[l++] : 0);\n  return r - l;\n}"}],"tagList":["字符串","二分查找","前缀和","滑动窗口"],"level":"Medium"}},{"problemName":"1210.穿过迷宫的最少移动次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1210.穿过迷宫的最少移动次数.json","problemData":{"id":"1322","name":"1210.穿过迷宫的最少移动次数","url":"https://leetcode.cn/problems/minimum-moves-to-reach-target-with-rotations","desc":"返回蛇抵达目的地所需的最少移动次数。","solutions":[{"script":"cpp","time":24,"memory":12.9,"desc":"bfs。","code":"struct Node {\n    int x, y, dir;\n    Node(int x, int y, int dir): x(x), y(y), dir(dir) {}\n};\nclass Solution {\npublic:\n    int minimumMoves(vector<vector<int>>& grid) {\n        int n = grid.size();\n        bool cache[n][n][2];\n        memset(cache, false, sizeof(bool) * n * n * 2);\n        cache[0][0][0] = true;\n        queue<Node> q;\n        q.push(Node(0, 0, 0));\n        int step = 0, size = 1;\n        while (q.size()) {\n            Node node = q.front();\n            q.pop();\n            int x = node.x, y = node.y, dir = node.dir;\n            if (x == n - 1 && y == n - 2 && dir == 0) return step;\n            if (dir == 0 && y + 2 < n && grid[x][y + 2] == 0 && !cache[x][y + 1][0]) {\n                q.push(Node(x, y + 1, 0));\n                cache[x][y + 1][0] = true;\n            }\n            if (dir == 0 && x + 1 < n && grid[x + 1][y + 1] == 0 && grid[x + 1][y] == 0 && !cache[x][y][1]) {\n                q.push(Node(x, y, 1));\n                cache[x][y][1] = true;\n            }\n            if (dir == 0 && x + 1 < n && grid[x + 1][y] == 0 && grid[x + 1][y + 1] == 0 && !cache[x + 1][y][0]) {\n                q.push(Node(x + 1, y, 0));\n                cache[x + 1][y][0] = true;\n            }\n\n            if (dir == 1 && x + 2 < n && grid[x + 2][y] == 0 && !cache[x + 1][y][1]) {\n                q.push(Node(x + 1, y, 1));\n                cache[x + 1][y][1] = true;\n            }\n            if (dir == 1 && y + 1 < n && grid[x + 1][y + 1] == 0 && grid[x][y + 1] == 0 && !cache[x][y][0]) {\n                q.push(Node(x, y, 0));\n                cache[x][y][0] = true;\n            }\n            if (dir == 1 && y + 1 < n && grid[x + 1][y + 1] == 0 && grid[x][y + 1] == 0 && !cache[x][y + 1][1]) {\n                q.push(Node(x, y + 1, 1));\n                cache[x][y + 1][1] = true;\n            }\n            if (--size == 0) step += 1, size = q.size();\n        }\n        return -1;\n    }\n};","date":"2023-02-05"},{"script":"python","time":364,"memory":16.4,"desc":"同上。","code":"from queue import Queue\nclass Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        cache = [[[False for _ in range(2)] for _ in range(n)] for _ in range(n)]\n        cache[0][0][0] = True\n        q = Queue()\n        q.put((0, 0, 0))\n        step, size = 0, 1\n        while q.qsize():\n            (x, y, d) = q.get()\n            if x == n - 1 and y == n - 2 and d == 0:\n                return step\n            if d == 0 and y + 2 < n and grid[x][y + 2] == 0 and not cache[x][y + 1][0]:\n                q.put((x, y + 1, 0))\n                cache[x][y + 1][0] = True\n            if d == 0 and x + 1 < n and grid[x + 1][y + 1] == 0 and grid[x + 1][y] == 0 and not cache[x][y][1]:\n                q.put((x, y, 1))\n                cache[x][y][1] = True\n            if d == 0 and x + 1 < n and grid[x + 1][y] == 0 and grid[x + 1][y + 1] == 0 and not cache[x + 1][y][0]:\n                q.put((x + 1, y, 0))\n                cache[x + 1][y][0] = True\n            if d == 1 and x + 2 < n and grid[x + 2][y] == 0 and not cache[x + 1][y][1]:\n                q.put((x + 1, y, 1))\n                cache[x + 1][y][1] = True\n            if d == 1 and y + 1 < n and grid[x + 1][y + 1] == 0 and grid[x][y + 1] == 0 and not cache[x][y][0]:\n                q.put((x, y, 0))\n                cache[x][y][0] = True\n            if d == 1 and y + 1 < n and grid[x + 1][y + 1] == 0 and grid[x][y + 1] == 0 and not cache[x][y + 1][1]:\n                q.put((x, y + 1, 1))\n                cache[x][y + 1][1] = True\n            size -= 1\n            if size == 0:\n                 step += 1\n                 size = q.qsize()\n        return -1","date":"2023-02-05"},{"script":"rust","time":4,"memory":2.7,"desc":"同上。","code":"impl Solution {\n    pub fn minimum_moves(grid: Vec<Vec<i32>>) -> i32 {\n        use std::collections::VecDeque;\n        let n = grid.len();\n        let mut cache = vec![vec![vec![false; 2]; n]; n];\n        cache[0][0][0] = true;\n        let mut q = VecDeque::<(usize, usize, usize)>::new();\n        q.push_back((0, 0, 0));\n        let (mut step, mut size) = (0, 1);\n        while !q.is_empty() {\n            let (x, y, dir) = q.pop_front().unwrap();\n            if x == n - 1 && y == n - 2 && dir == 0 {\n                return step;\n            }\n            if dir == 0 && y + 2 < n && grid[x][y + 2] == 0 && !cache[x][y + 1][0] {\n                q.push_back((x, y + 1, 0));\n                cache[x][y + 1][0] = true;\n            }\n            if dir == 0\n                && x + 1 < n\n                && grid[x + 1][y + 1] == 0\n                && grid[x + 1][y] == 0\n                && !cache[x][y][1]\n            {\n                q.push_back((x, y, 1));\n                cache[x][y][1] = true;\n            }\n            if dir == 0\n                && x + 1 < n\n                && grid[x + 1][y] == 0\n                && grid[x + 1][y + 1] == 0\n                && !cache[x + 1][y][0]\n            {\n                q.push_back((x + 1, y, 0));\n                cache[x + 1][y][0] = true;\n            }\n            if dir == 1 && x + 2 < n && grid[x + 2][y] == 0 && !cache[x + 1][y][1] {\n                q.push_back((x + 1, y, 1));\n                cache[x + 1][y][1] = true;\n            }\n            if dir == 1\n                && y + 1 < n\n                && grid[x + 1][y + 1] == 0\n                && grid[x][y + 1] == 0\n                && !cache[x][y][0]\n            {\n                q.push_back((x, y, 0));\n                cache[x][y][0] = true;\n            }\n            if dir == 1\n                && y + 1 < n\n                && grid[x + 1][y + 1] == 0\n                && grid[x][y + 1] == 0\n                && !cache[x][y + 1][1]\n            {\n                q.push_back((x, y + 1, 1));\n                cache[x][y + 1][1] = true;\n            }\n            size -= 1;\n            if size == 0 {\n                step += 1;\n                size = q.len();\n            }\n        }\n        -1\n    }\n}","date":"2023-02-05"}],"tagList":["广度优先搜索","数组","矩阵"],"level":"Hard"}},{"problemName":"1217.玩筹码.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1217.玩筹码.json","problemData":{"id":"1329","name":"1217.玩筹码","url":"https://leetcode.cn/problems/minimum-cost-to-move-chips-to-the-same-position","desc":"返回将所有筹码移动到同一位置上所需要的 最小代价 。","solutions":[{"date":"2022-07-08","time":0,"memory":7,"script":"cpp","desc":"因为跳一格 1 消费，跳两格 0 消费，相当于只有在相邻格才会消费。","code":"class Solution {\n   public:\n    int minCostToMoveChips(vector<int>& position) {\n        int ans1 = 0, ans2 = 0;\n        for (auto& num : position) {\n            if (num & 1)\n                ans1++;\n            else\n                ans2++;\n        }\n        return min(ans1, ans2);\n    }\n};"}],"tagList":["贪心","数组","数学"],"level":"Easy"}},{"problemName":"1218.最长定差子序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1218.最长定差子序列.json","problemData":{"id":"1330","name":"1218.最长定差子序列","url":"https://leetcode.cn/problems/longest-arithmetic-subsequence-of-given-difference","desc":"给你一个整数数组  arr  和一个整数  difference，请你找出并返回 arr  中最长等差子序列的长度，该子序列中相邻元素之间的差等于 difference 。","solutions":[{"date":"2021-11-05","time":96,"memory":48.5,"script":"typescript","desc":"哈希存储。","code":"function longestSubsequence(arr: number[], difference: number): number {\n  let max = 1;\n  const map = new Map<number, number>();\n  for (const num of arr) {\n    const cnt = (map.get(num) ?? 0) + 1;\n    map.set(num + difference, cnt);\n    max = Math.max(max, cnt);\n  }\n  return max;\n}"}],"tagList":["数组","哈希表","动态规划"],"level":"Medium"}},{"problemName":"1219.黄金矿工.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1219.黄金矿工.json","problemData":{"id":"1331","name":"1219.黄金矿工","url":"https://leetcode.cn/problems/path-with-maximum-gold","desc":"要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为  m \\* n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。","solutions":[{"date":"2022-02-05","time":580,"memory":169.2,"script":"cpp","desc":"dfs。","code":"int dirs[4][2] = {\n    {0, 1},\n    {0, -1},\n    {1, 0},\n    {-1, 0},\n};\n\nclass Solution {\n   public:\n    int m, n, ans = 0;\n    int getMaximumGold(vector<vector<int>>& grid) {\n        m = grid.size();\n        n = grid[0].size();\n        vector<vector<int>> check(m, vector(n, 0));\n        for (int row = 0; row < m; row++) {\n            for (int col = 0; col < n; col++) {\n                if (grid[row][col] == 0) continue;\n                int cnt = 0;\n                for (int i = 0; i < 4; i++) {\n                    int nrow = row + dirs[i][0], ncol = col + dirs[i][1];\n                    if (nrow >= 0 && nrow < m && ncol >= 0 && ncol < n &&\n                        grid[nrow][ncol] != 0)\n                        cnt++;\n                }\n                if (cnt < 3) dfs(grid, check, row, col, 0);\n            }\n        }\n        return ans;\n    }\n    void dfs(vector<vector<int>>& grid, vector<vector<int>> check, int row,\n             int col, int cur) {\n        check[row][col] = 1;\n        cur += grid[row][col];\n        ans = max(ans, cur);\n        for (int i = 0; i < 4; i++) {\n            int nrow = row + dirs[i][0], ncol = col + dirs[i][1];\n            if (nrow < 0 || nrow >= m || ncol < 0 || ncol >= n ||\n                grid[nrow][ncol] == 0 || check[nrow][ncol] == 1)\n                continue;\n            dfs(grid, check, nrow, ncol, cur);\n        }\n        check[row][col] = 0;\n    }\n};"}],"tagList":["数组","回溯","矩阵"],"level":"Medium"}},{"problemName":"1220.统计元音字母序列的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1220.统计元音字母序列的数目.json","problemData":{"id":"1332","name":"1220.统计元音字母序列的数目","url":"https://leetcode.cn/problems/count-vowels-permutation","desc":"给你一个整数 n，请你帮忙统计一下我们可以按下述规则形成多少个长度为 n 的字符串。","solutions":[{"date":"2022-01-17","time":0,"memory":5.8,"script":"cpp","desc":"动态规划，dp[i][j]表示第 i 轮时，j 元音为结尾的数量。","code":"class Solution {\n   public:\n    int mod = 1e9 + 7;\n    int countVowelPermutation(int n) {\n        // 0 : a, 1 : e, 2 : i, 3 : o, 4 : u\n        // a -> e\n        // e -> a i\n        // i -> a e o u\n        // o -> i u\n        // u -> a\n        long long dp[2][5];\n        for (int i = 0; i < 5; i++) {\n            dp[0][i] = 0;\n            dp[1][i] = 1;\n        }\n        for (int i = 2; i <= n; i++) {\n            int pidx = (i + 1) % 2;\n            int idx = i % 2;\n            dp[idx][0] = (dp[pidx][1] + dp[pidx][2] + dp[pidx][4]) % mod;\n            dp[idx][1] = (dp[pidx][0] + dp[pidx][2]) % mod;\n            dp[idx][2] = (dp[pidx][1] + dp[pidx][3]) % mod;\n            dp[idx][3] = dp[pidx][2] % mod;\n            dp[idx][4] = (dp[pidx][2] + dp[pidx][3]) % mod;\n        }\n        long long ans = 0;\n        for (int i = 0; i < 5; i++) ans = (ans + dp[n % 2][i]) % mod;\n        return ans;\n    }\n};"}],"tagList":["动态规划"],"level":"Hard"}},{"problemName":"1222.可以攻击国王的皇后.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1222.可以攻击国王的皇后.json","problemData":{"id":"1342","name":"1222.可以攻击国王的皇后","url":"https://leetcode.cn/problems/queens-that-can-attack-the-king","desc":"在一个 8x8 的棋盘上，放置着若干「黑皇后」和一个「白国王」。给定一个由整数坐标组成的数组 queens ，表示黑皇后的位置；以及一对坐标 king ，表示白国王的位置，返回所有可以攻击国王的皇后的坐标(任意顺序)。","solutions":[{"script":"cpp","time":8,"memory":10.97,"desc":"方向数组遍历。","code":"vector<vector<int>> dirs2 = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};\n\nclass Solution {\npublic:\n    vector<vector<int>> queensAttacktheKing(vector<vector<int>>& queens, vector<int>& king) {\n        vector<vector<bool>> board(8, vector<bool>(8, false));\n        for (auto &q : queens) board[q[0]][q[1]] = true;\n        vector<vector<int>> res;\n        auto check = [&](vector<int> pos, vector<int> &dir) {\n            for (int i = 1; i < 8; i++) {\n                pos[0] += dir[0];\n                pos[1] += dir[1];\n                if (0 <= pos[0] && pos[0] < 8 && 0 <= pos[1] && pos[1] < 8) {\n                    if (board[pos[0]][pos[1]]) {\n                        res.push_back(pos);\n                        return;\n                    }\n                } else return;\n            }\n        };\n        for (auto &d : dirs2) check(king, d);\n        return res;\n    }\n};","date":"2023-09-14"},{"script":"python","time":40,"memory":16,"desc":"同上。","code":"class Solution:\n    def queensAttacktheKing(self, queens: List[List[int]], king: List[int]) -> List[List[int]]:\n        dirs2 = [(0, 1), (0, -1), (1, 0), (-1, 0),\n                    (1, 1), (1, -1), (-1, 1), (-1, -1)]\n        board = [[False for j in range(8)] for i in range(8)]\n        for [x, y] in queens:\n            board[x][y] = True\n        res = []\n        for i in range(1, 8):\n            if not dirs2: break\n            for j in range(len(dirs2) - 1, -1, -1):\n                x = king[0] + dirs2[j][0] * i\n                y = king[1] + dirs2[j][1] * i\n                if 0 <= x < 8 and 0 <= y < 8:\n                    if board[x][y]:\n                        res.append([x, y])\n                        dirs2.remove(dirs2[j])\n                else:\n                    dirs2.remove(dirs2[j])\n        return res","date":"2023-09-14"},{"script":"python","time":48,"memory":15.65,"desc":"同上。","code":"dirs = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n\n    class Solution:\n        def queensAttacktheKing(self, queens: List[List[int]], king: List[int]) -> List[List[int]]:\n            board = [[False for j in range(8)] for i in range(8)]\n            for [x, y] in queens:\n                board[x][y] = True\n            res = []\n            def check(pos: List[int], dir: List[int]) -> bool:\n                for _ in range(1, 8):\n                    pos[0] += dir[0]\n                    pos[1] += dir[1]\n    \n                    if 0 <= pos[0] < 8 and 0 <= pos[1] < 8:\n                        if board[pos[0]][pos[1]]:\n                            res.append([pos[0], pos[1]])\n                            return \n                    else:\n                        return\n            for d in dirs:\n                check(list(king), d)\n            return res","date":"2023-09-14"},{"script":"rust","time":0,"memory":2.1,"desc":"同上。","code":"pub const DIRS2: [[i32; 2]; 8] = [\n    [0, 1],\n    [0, -1],\n    [1, 0],\n    [-1, 0],\n    [1, 1],\n    [1, -1],\n    [-1, 1],\n    [-1, -1],\n];\n\nimpl Solution {\n    pub fn queens_attackthe_king(queens: Vec<Vec<i32>>, king: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut board = vec![vec![false; 8]; 8];\n        for queen in queens {\n            board[queen[0] as usize][queen[1] as usize] = true;\n        }\n        let mut res = vec![];\n        let mut check = |mut pos: Vec<usize>, dir: &[i32]| {\n            for i in 1..8 {\n                let x = pos[0] as i32 + dir[0] * i;\n                let y = pos[1] as i32 + dir[1] * i;\n                if 0 <= x && x < 8 && 0 <= y && y < 8 {\n                    if board[x as usize][y as usize] {\n                        res.push(vec![x, y]);\n                        return;\n                    }\n                } else {\n                    return;\n                }\n            }\n        };\n        for d in &DIRS2 {\n            check(king.iter().map(|v| *v as usize).collect(), d);\n        }\n        res\n    }\n}","date":"2023-09-14"}],"tagList":["数组","矩阵","模拟"],"level":"Medium"}},{"problemName":"1223.掷骰子模拟.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1223.掷骰子模拟.json","problemData":{"id":"1343","name":"1223.掷骰子模拟","url":"https://leetcode.cn/problems/dice-roll-simulation","desc":"你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。","solutions":[{"script":"cpp","time":196,"memory":29.7,"desc":"dp[i][j][k]表示第i次投掷时投了j点，且连续投了k次j点的次数。","code":"class Solution {\npublic:\n    int dieSimulator(int n, vector<int>& rollMax) {\n        int mod = 1e9 + 7;\n        vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(6, vector<int>(16, 0)));\n        for (int j = 0; j < 6; j++) dp[1][j][1] = 1;\n        // 第i次投骰子\n        for (int i = 1; i <= n; i++) {\n            // 骰子点数是j\n            for (int j = 0; j < 6; j++) {\n                // 对于每个点数已经消耗了k次连续投掷次数\n                for (int k = 1; k <= rollMax[j]; k++) {\n                    // 当前次投了p点\n                    for (int p = 0; p < 6; p++) {\n                        if (p != j) dp[i][p][1] = (dp[i][p][1] + dp[i - 1][j][k]) % mod;\n                        else if (k + 1 <= rollMax[j]) dp[i][p][k + 1] = (dp[i][p][k + 1] + dp[i - 1][j][k]) % mod;\n                    }\n                }\n            }\n        }\n        int res = 0;\n        for (int i = 0; i < 6; i++) {\n            for (int j = 1; j <= rollMax[i]; j++) {\n                res = (res + dp[n][i][j]) % mod;\n            }\n        }\n        return res;\n    }\n};","date":"2023-02-10"},{"script":"python","time":1764,"memory":30.7,"desc":"同上。","code":"class Solution:\n  def dieSimulator(self, n: int, rollMax: List[int]) -> int:\n      mod = 10 ** 9 + 7\n      dp = [[([0] * 16) for _ in range(6)] for _ in range(n + 1)]\n      for j in range(6):\n          dp[1][j][1] = 1\n      for i in range(1, n + 1):\n          for j in range(6):\n              for k in range(1, rollMax[j] + 1):\n                  for p in range(6):\n                      if p != j:\n                          dp[i][p][1] = (dp[i][p][1] + dp[i - 1][j][k]) % mod\n                      elif k + 1 <= rollMax[j]:\n                          dp[i][p][k + 1] = (dp[i][p]\n                                             [k + 1] + dp[i-1][j][k]) % mod\n      res = 0\n      for i in range(6):\n          for j in range(1, rollMax[i] + 1):\n              res = (res + dp[n][i][j]) % mod\n      return res","date":"2023-02-10"},{"script":"rust","time":20,"memory":5,"desc":"同上。","code":"impl Solution {\n    pub fn die_simulator(n: i32, roll_max: Vec<i32>) -> i32 {\n        let n = n as usize;\n        let MOD = 10i32.pow(9) + 7;\n        let mut dp = vec![vec![vec![0; 16]; 6]; n + 1];\n        for j in 0..6 {\n            dp[1][j][1] = 1;\n        }\n        for i in 1..=n {\n            for j in 0..6 {\n                for k in 1..=roll_max[j] as usize {\n                    for p in 0..6 {\n                        if p != j {\n                            dp[i][p][1] = (dp[i][p][1] + dp[i - 1][j][k]) % MOD;\n                        } else if k + 1 <= roll_max[j] as usize {\n                            dp[i][p][k + 1] = (dp[i][p][k + 1] + dp[i - 1][j][k]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n        let mut res = 0;\n        for i in 0..6 {\n            for j in 1..=roll_max[i] as usize {\n                res = (res + dp[n][i][j]) % MOD;\n            }\n        }\n        res\n    }\n}","date":"2023-02-10"}],"tagList":["数组","动态规划"],"level":"Hard"}},{"problemName":"1224.最大相等频率.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1224.最大相等频率.json","problemData":{"id":"1344","name":"1224.最大相等频率","url":"https://leetcode.cn/problems/maximum-equal-frequency","desc":"给你一个正整数数组 nums，请你帮忙从该数组中找出能满足下面要求的 最长 前缀，并返回该前缀的长度。","solutions":[{"date":"2022-08-18","time":52,"memory":3.4,"script":"rust","desc":"只有三种情况可以成立，1.最大频率只有一，2.所有数只有最大频率和第二大频率且最大频率只有一种数，3.所有数除了一个都是最大频率，剩下的一个数频率是 1。","code":"impl Solution {\n    pub fn max_equal_freq(nums: Vec<i32>) -> i32 {\n        use std::collections::HashMap;\n        let (mut freq_map, mut cnt_map) =\n            (HashMap::<usize, usize>::new(), HashMap::<i32, usize>::new());\n        let mut ans = 0;\n        let mut max_freq = 0;\n        for i in 0..nums.len() {\n            let num = nums[i];\n            let cnt = cnt_map.get(&num).unwrap_or(&0);\n            let prev_freq = freq_map.get_mut(cnt);\n            if prev_freq.is_some() {\n                *prev_freq.unwrap() -= 1;\n            }\n            let cnt = *cnt + 1;\n            cnt_map.insert(num, cnt);\n            freq_map.insert(cnt, freq_map.get(&cnt).unwrap_or(&0) + 1);\n            max_freq = max_freq.max(cnt);\n            if max_freq == 1\n                || freq_map.get(&max_freq).unwrap_or(&0) * max_freq\n                    + freq_map.get(&(max_freq - 1)).unwrap_or(&0) * (max_freq - 1)\n                    == i + 1\n                    && *freq_map.get(&max_freq).unwrap_or(&0) == 1\n                || freq_map.get(&max_freq).unwrap_or(&0) * max_freq == i\n                    && *freq_map.get(&1).unwrap_or(&0) == 1\n            {\n                ans = i + 1;\n            }\n        }\n        ans as i32\n    }\n}"}],"tagList":["数组","哈希表"],"level":"Hard"}},{"problemName":"1232.缀点成线.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1232.缀点成线.json","problemData":{"id":"1349","name":"1232.缀点成线","url":"https://leetcode.cn/problems/check-if-it-is-a-straight-line","desc":"在一个  XY 坐标系中有一些点，我们用数组  coordinates  来分别记录它们的坐标，其中  coordinates[i] = [x, y]  表示横坐标为 x、纵坐标为 y  的点。请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。","solutions":[{"date":"2021-01-17","time":92,"memory":40.4,"script":"typescript","desc":"计算直线方程式。","code":"function checkStraightLine(coordinates: number[][]): boolean {\n  const len = coordinates.length;\n  if (len <= 2) return true;\n  const [[x1, y1], [x2, y2]] = coordinates;\n  if (x1 === x2) return coordinates.every(([x]) => x === x1);\n  const k = (y1 - y2) / (x1 - x2);\n  const b = y1 - k * x1;\n  return coordinates.every(([x, y]) => y === k * x + b);\n}"}],"tagList":["几何","数组","数学"],"level":"Easy"}},{"problemName":"1233.删除子文件夹.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1233.删除子文件夹.json","problemData":{"id":"1350","name":"1233.删除子文件夹","url":"https://leetcode.cn/problems/remove-sub-folders-from-the-filesystem","desc":"你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。","solutions":[{"script":"cpp","time":208,"memory":51.4,"desc":"trie。","code":"struct Node {\n    bool end;\n    unordered_map<string, Node*> children;\n    Node(): end(false) {}\n};\nclass Solution {\npublic:\n    vector<string> removeSubfolders(vector<string>& folder) {\n        sort(folder.begin(), folder.end());\n        Node *root = new Node();\n        vector<string> ans;\n        for (auto &path : folder) {\n            Node *next = root;\n            istringstream iss(path);\n            string tmp;\n            getline(iss, tmp, '/');\n            while (getline(iss, tmp, '/')) {\n                if (!next->children.count(tmp)) next = next->children[tmp] = new Node();\n                else next = next->children[tmp];\n                if (next->end) break;\n            }\n            if (!next->end) ans.push_back(path);\n            next->end = true;\n        }\n        return ans;\n    }\n};","date":"2023-02-08"},{"script":"python","time":140,"memory":25.4,"desc":"同上。","code":"class Node:\n    def __init__(self) -> None:\n        self.end = False\n        self.children = defaultdict(Node)\n\nclass Solution:\n    def removeSubfolders(self, folder: List[str]) -> List[str]:\n        folder.sort()\n        root = Node()\n        ans = []\n        for path in folder:\n            nextNode = root\n            l = path.split('/')\n            for i in range(1, len(l)):\n                nextNode = nextNode.children[l[i]]\n                if nextNode.end:\n                    break\n            if not nextNode.end:\n                ans.append(path)\n            nextNode.end = True\n        return ans","date":"2023-02-08"},{"script":"rust","time":56,"memory":6.8,"desc":"同上。","code":"use std::collections::HashMap;\n#[derive(Clone)]\nstruct Node {\n    end: bool,\n    children: HashMap<String, Node>,\n}\nimpl Node {\n    fn new() -> Self {\n        Self {\n            end: false,\n            children: HashMap::new(),\n        }\n    }\n}\n\nimpl Solution {\n    pub fn remove_subfolders(folder: Vec<String>) -> Vec<String> {\n        let mut folder = folder;\n        folder.sort();\n        let mut root = Node::new();\n        let mut ans = vec![];\n        for path in folder {\n            let mut next = &mut root;\n            let l: Vec<&str> = path.split(\"/\").collect();\n            for i in 1..l.len() {\n                if !next.children.contains_key(l[i]) {\n                    next.children.insert(l[i].to_string(), Node::new());\n                }\n                next = next.children.get_mut(l[i]).unwrap();\n                if next.end {\n                    break;\n                }\n            }\n            if !next.end {\n                ans.push(path);\n            }\n            next.end = true;\n        }\n        ans\n    }\n}","date":"2023-02-08"}],"tagList":["深度优先搜索","字典树","数组","字符串"],"level":"Medium"}},{"problemName":"1234.替换子串得到平衡字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1234.替换子串得到平衡字符串.json","problemData":{"id":"1351","name":"1234.替换子串得到平衡字符串","url":"https://leetcode.cn/problems/replace-the-substring-for-balanced-string","desc":"请返回待替换子串的最小可能长度。","solutions":[{"script":"cpp","time":16,"memory":7.5,"desc":"双指针，找出所有可以匹配的段落。","code":"class Solution {\npublic:\n    int id(char c) {\n        switch (c) {\n            case 'Q': return 0;\n            case 'W': return 1;\n            case 'E': return 2;\n            case 'R': return 3;\n        }\n        return -1;\n    }\n    bool isBalance(int *cnt, int target) {\n        return cnt[0] <= target && cnt[1] <= target && cnt[2] <= target && cnt[3] <= target;\n    }\n    int balancedString(string s) {\n        int n = s.size(), m = n / 4, cnt[4] = {0};\n        for (auto &c : s) cnt[id(c)] += 1;\n        if (isBalance(cnt, m)) return 0;\n        int ans = 0x3f3f3f3f;\n        for (int l = 0, r = 0; r < n; r++) {\n            cnt[id(s[r])]--;\n            while (l < r && isBalance(cnt, m)) {\n                cnt[id(s[l])]++;\n                if (isBalance(cnt, m)) l++;\n                else { cnt[id(s[l])]--; break; }\n            }\n            if (isBalance(cnt, m)) ans = min(ans, r - l + 1);\n        }\n        return ans;\n    }\n};","date":"2023-02-13"},{"script":"python","time":348,"memory":15.4,"desc":"同上。","code":"class Solution:\n    def balancedString(self, s: str) -> int:\n        n = len(s)\n        m = int(n/4)\n        cnt = [0] * 4\n\n        def getId(c: str) -> int:\n            match c:\n                case 'Q': return 0\n                case 'W': return 1\n                case 'E': return 2\n                case 'R': return 3\n            return -1\n\n        def isBalance() -> bool:\n            nonlocal m, cnt\n            return cnt[0] <= m and cnt[1] <= m and cnt[2] <= m and cnt[3] <= m\n\n        for c in s:\n            cnt[getId(c)] += 1\n        if isBalance():\n            return 0\n        ans = 0x3f3f3f3f\n        l = 0\n        for r in range(0, n):\n            cnt[getId(s[r])] -= 1\n            while l < r and isBalance():\n                cnt[getId(s[l])] += 1\n                if isBalance():\n                    l += 1\n                else:\n                    cnt[getId(s[l])] -= 1\n                    break\n            if isBalance():\n                ans = min(ans, r - l+1)\n        return ans","date":"2023-02-13"},{"script":"rust","time":8,"memory":2.5,"desc":"同上。","code":"impl Solution {\n    pub fn balanced_string(s: String) -> i32 {\n        let s = s.chars().collect::<Vec<char>>();\n        let n = s.len();\n        let m = (n / 4) as i32;\n        let mut cnt = [0; 4];\n        let id = |c| match c {\n            'Q' => 0,\n            'W' => 1,\n            'E' => 2,\n            'R' => 3,\n            _ => 0,\n        };\n        let is_balance = |cnt: &[i32; 4]| cnt[0] <= m && cnt[1] <= m && cnt[2] <= m && cnt[3] <= m;\n        for c in s.iter() {\n            cnt[id(*c)] += 1;\n        }\n        if is_balance(&cnt) {\n            0\n        } else {\n            let mut ans = 0x3f3f3f3f;\n            let mut l = 0;\n            for r in 0..n {\n                cnt[id(s[r])] -= 1;\n                while l < r && is_balance(&cnt) {\n                    cnt[id(s[l])] += 1;\n                    if is_balance(&cnt) {\n                        l += 1;\n                    } else {\n                        cnt[id(s[l])] -= 1;\n                        break;\n                    }\n                }\n                if is_balance(&cnt) {\n                    ans = ans.min(r - l + 1);\n                }\n            }\n            ans as i32\n        }\n    }\n}","date":"2023-02-13"}],"tagList":["字符串","滑动窗口"],"level":"Medium"}},{"problemName":"1235.规划兼职工作.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1235.规划兼职工作.json","problemData":{"id":"1352","name":"1235.规划兼职工作","url":"https://leetcode.cn/problems/maximum-profit-in-job-scheduling","desc":"给你一份兼职工作表，包含开始时间 startTime，结束时间 endTime 和预计报酬 profit 三个数组，请你计算并返回可以获得的最大报酬。","solutions":[{"date":"2022-10-22","time":252,"memory":64.1,"script":"cpp","desc":"dp 存储当前点选中和不选中两种情况，利用 map 快速查找当前节点启动前结束的最大值。","code":"struct Node { int l, r, profit; };\nclass Solution {\npublic:\n    map<int, int> m;\n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        int n = startTime.size();\n        vector<Node> list(n);\n        for (int i = 0; i < n; i++) {\n            list[i].l = startTime[i];\n            list[i].r = endTime[i];\n            list[i].profit = profit[i];\n        }\n        sort(list.begin(), list.end(), [](Node &a, Node &b){ return a.r < b.r; });\n        vector<vector<int>> dp(n, vector<int>(2, 0));\n        dp[0][1] = list[0].profit;\n        m[list[0].r] = list[0].profit;\n        for (int i = 1; i < n; i++) {\n            dp[i][1] += list[i].profit;\n            dp[i][0] = max(dp[i][0], dp[i - 1][0]);\n            dp[i][0] = max(dp[i][0], dp[i - 1][1]);\n            auto upper = m.upper_bound(list[i].l);\n            upper--;\n            if (upper->first <= list[i].l) dp[i][1] = upper->second + list[i].profit;\n            m[list[i].r] = max(m[list[i].r], max(dp[i][0], dp[i][1]));\n        }\n        return max(dp[n - 1][0], dp[n - 1][1]);\n    }\n};"},{"script":"python","time":195,"memory":34.35,"desc":"记录当前开始时间以前结束的收益最高的任务。","code":"class Solution:\n    def jobScheduling(self, startTime: List[int], endTime: List[int], profit: List[int]) -> int:\n        n = len(startTime)\n        arr = sorted([i for i in range(n)], key = lambda i: startTime[i])\n        q = []\n        wait_q = []\n        dp = [profit[arr[i]] for i in range(n)]\n        for i in range(0, n):\n            idx = arr[i]\n            while wait_q and wait_q[0][0] <= startTime[idx]:\n                wait_idx = heappop(wait_q)[1]\n                heappush(q, (-dp[wait_idx], wait_idx))\n            if q: dp[i] += -q[0][0]\n            heappush(wait_q, (endTime[idx], i))\n        return max(dp)","date":"2024-05-04"}],"tagList":["数组","二分查找","动态规划","排序"],"level":"Hard"}},{"problemName":"1237.找出给定方程的正整数解.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1237.找出给定方程的正整数解.json","problemData":{"id":"1358","name":"1237.找出给定方程的正整数解","url":"https://leetcode.cn/problems/find-positive-integer-solution-for-a-given-equation","desc":"给你一个函数  f(x, y) 和一个目标结果 z，函数公式未知，请你计算方程 f(x,y) == z 所有可能的正整数 数对 x 和 y。","solutions":[{"script":"cpp","time":0,"memory":6.3,"desc":"二分。","code":"class Solution {\npublic:\n    vector<vector<int>> findSolution(CustomFunction& customfunction, int z) {\n        vector<vector<int>> res;\n        for (int x = 1; x <= 1000; x++) {\n            int l = 1, r = 1000, m;\n            while (l <= r) {\n                m = (l + r) / 2;\n                int val = customfunction.f(x, m);\n                if (val == z) {\n                    vector<int> item{ x, m };\n                    res.push_back(item);\n                    break;\n                }\n                if (val > z) r = m - 1;\n                else l = m + 1;\n            }\n        }\n        return res;\n    }\n  };","date":"2023-02-18"},{"script":"python","time":148,"memory":14.9,"desc":"同上。","code":"class Solution:\n    def findSolution(self, customfunction: 'CustomFunction', z: int) -> List[List[int]]:\n        res = []\n        for x in range(1, 1001):\n            l, r = 1, 1000\n            while l <= r:\n                m = (l + r)//2\n                val = customfunction.f(x, m)\n                if val == z:\n                    res.append([x, m])\n                    break\n                if val > z:\n                    r = m - 1\n                else:\n                    l = m + 1\n        return res","date":"2023-02-18"},{"script":"rust","time":4,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn find_solution(customfunction: &CustomFunction, z: i32) -> Vec<Vec<i32>> {\n        let mut res = vec![];\n        for x in 1..=1000 {\n            let (mut l, mut r) = (1, 1000);\n            while l <= r {\n                let m = (l + r) / 2;\n                let val = customfunction.f(x, m);\n                if val == z {\n                    res.push(vec![x, m]);\n                    break;\n                }\n                if val > z {\n                    r = m - 1;\n                } else {\n                    l = m + 1;\n                }\n            }\n        }\n        res\n    }\n}","date":"2023-02-18"}],"tagList":["数学","双指针","二分查找","交互"],"level":"Medium"}},{"problemName":"1238.循环码排列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1238.循环码排列.json","problemData":{"id":"1359","name":"1238.循环码排列","url":"https://leetcode.cn/problems/circular-permutation-in-binary-representation","desc":"给你两个整数 n 和 start。你的任务是返回任意 (0,1,2,,...,2^n-1) 的排列 p，并且满足：, p[0] = start, p[i] 和 p[i+1] 的二进制表示形式只有一位不同, p[0] 和 p[2^n -1] 的二进制表示形式也只有一位不同。","solutions":[{"script":"cpp","time":120,"memory":57,"desc":"dfs。","code":"class Solution {\npublic:\n    vector<int> circularPermutation(int n, int start) {\n        vector<int> ans(pow(2, n));\n        ans[0] = start;\n        unordered_set<int> used;\n        used.insert(start);\n        dfs(ans, used, n, start, 1);\n        return ans;\n    }\n    bool dfs(vector<int> &ans, unordered_set<int> &used, int n, int prev, int idx) {\n        if (idx == pow(2, n)) {\n            return compare(n, ans[0], ans[idx - 1]);\n        }\n        for (int i = 0; i < n; i++) {\n            int v = prev & (1 << i), next = prev;\n            if (v) next &= ~(1 << i);\n            else next |= (1 << i); \n            if (used.count(next)) continue;\n            used.insert(next);\n            ans[idx] = next;\n            if (dfs(ans, used, n, next, idx + 1)) return true;\n            used.erase(next);\n        }\n        return false;\n    }\n    bool compare(int n, int num1, int num2) {\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            int v1 = num1 & (1 << i), v2 = num2 & (1 << i);\n            if (v1 != v2) cnt++;\n        }\n        return cnt == 1;\n    }\n};","date":"2023-02-23"},{"script":"python","time":372,"memory":106.3,"desc":"同上。","code":"class Solution:\n        def circularPermutation(self, n: int, start: int) -> List[int]:\n            ans = [0] * pow(2, n)\n            ans[0] = start\n            used = set()\n            used.add(start)\n    \n            def compare(num1: int, num2: int) -> bool:\n                cnt = 0\n                for i in range(n):\n                    v1 = num1 & (1 << i)\n                    v2 = num2 & (1 << i)\n                    if v1 != v2:\n                        cnt += 1\n                return cnt == 1\n    \n            def dfs(prev: int, idx: int) -> bool:\n                if idx == pow(2, n):\n                    return compare(ans[0], ans[-1])\n                for i in range(n):\n                    v = prev & (1 << i)\n                    nextv = prev\n                    if v:\n                        nextv &= ~(1 << i)\n                    else:\n                        nextv |= (1 << i)\n                    if nextv in used:\n                        continue\n                    used.add(nextv)\n                    ans[idx] = nextv\n                    if dfs(nextv, idx+1):\n                        return True\n                    used.remove(nextv)\n                return False\n            dfs(start, 1)\n            return ans","date":"2023-02-23"},{"script":"rust","time":44,"memory":12.4,"desc":"同上。","code":"use std::collections::HashSet;\nimpl Solution {\n    pub fn circular_permutation(n: i32, start: i32) -> Vec<i32> {\n        let n = n as u32;\n        let mut ans = vec![0; 2usize.pow(n)];\n        ans[0] = start;\n        let mut used = HashSet::<i32>::new();\n        used.insert(start);\n        Solution::dfs(&mut ans, &mut used, n, start, 1);\n        ans\n    }\n    fn dfs(ans: &mut Vec<i32>, used: &mut HashSet<i32>, n: u32, prev: i32, idx: usize) -> bool {\n        if idx == 2usize.pow(n) {\n            Solution::compare(n, *ans.first().unwrap(), *ans.last().unwrap())\n        } else {\n            for i in 0..n {\n                let v = prev & (1 << i);\n                let mut next = prev;\n                if v != 0 {\n                    next &= !(1 << i);\n                } else {\n                    next |= 1 << i;\n                }\n                if used.contains(&next) {\n                    continue;\n                }\n                used.insert(next);\n                ans[idx] = next;\n                if Solution::dfs(ans, used, n, next, idx + 1) {\n                    return true;\n                }\n                used.remove(&next);\n            }\n            false\n        }\n    }\n    fn compare(n: u32, num1: i32, num2: i32) -> bool {\n        let mut cnt = 0;\n        for i in 0..n {\n            let v1 = num1 & (1 << i);\n            let v2 = num2 & (1 << i);\n            if v1 != v2 {\n                cnt += 1;\n            }\n        }\n        cnt == 1\n    }\n}","date":"2023-02-23"}],"tagList":["位运算","数学","回溯"],"level":"Medium"}},{"problemName":"1239.串联字符串的最大长度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1239.串联字符串的最大长度.json","problemData":{"id":"1360","name":"1239.串联字符串的最大长度","url":"https://leetcode.cn/problems/maximum-length-of-a-concatenated-string-with-unique-characters","desc":"给定一个字符串数组 arr，字符串 s 是将 arr 某一子序列字符串连接所得的字符串，如果 s 中的每一个字符都只出现过一次，那么它就是一个可行解。请返回所有可行解 s 中最长长度。","solutions":[{"date":"2021-06-19","time":188,"memory":43.8,"script":"typescript","desc":"利用二进制储存，进行比较。","code":"function maxLength(arr: string[]): number {\n  const masks = arr\n    .map(s => {\n      if (s === '') return -1;\n      let mask = 0;\n      for (const c of s) {\n        const num = c.codePointAt(0)!;\n        if ((mask >> num) & 1) return -1;\n        mask |= 1 << num;\n      }\n      return mask;\n    })\n    .filter(num => num !== -1);\n  let ans = 0;\n  const masksLen = masks.length;\n  const dfs = (index = 0, num = 0) => {\n    if (index === masksLen) {\n      ans = Math.max(ans, num.toString(2).split('0').join('').length);\n      return;\n    }\n    if ((num & masks[index]) === 0) dfs(index + 1, num | masks[index]);\n    dfs(index + 1, num);\n  };\n  dfs();\n  return ans;\n}"}],"tagList":["位运算","数组","字符串","回溯"],"level":"Medium"}},{"problemName":"1240.铺瓷砖.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1240.铺瓷砖.json","problemData":{"id":"1361","name":"1240.铺瓷砖","url":"https://leetcode.cn/problems/tiling-a-rectangle-with-the-fewest-squares","desc":"房子的客厅大小为 n x m，为保持极简的风格，需要使用尽可能少的 正方形 瓷砖来铺盖地面。假设正方形瓷砖的规格不限，边长都是整数。请你帮设计师计算一下，最少需要用到多少块方形瓷砖？。","solutions":[{"script":"cpp","time":8,"memory":6,"desc":"dfs，储存已经遍历过的点。","code":"class Solution {\npublic:\n    int tilingRectangle(int n, int m) {\n        int res = INT_MAX, list[20] = {0};\n        function<void(int, int, int)> dfs = [&](int i, int j, int cnt) {\n            if (i == n) {\n                res = min(res, cnt);\n            } else if (j == m) {\n                dfs(i + 1, 0, cnt);\n            } else if (list[i] & (1 << j)) {\n                dfs(i, j + 1, cnt);\n            } else if (cnt < res) {\n                int ncnt = 0, mcnt = 0;\n                for (int p = i; p < n && !(list[p] & (1 << j)); p++) ncnt++;\n                for (int p = j; p < m && !(list[i] & (1 << p)); p++) mcnt++;\n                int nmcnt = min(ncnt, mcnt);\n                for (int ccnt = nmcnt; ccnt >= 1; ccnt--) {\n                    for (int p = i; p < i + ccnt; p++) list[p] |= (((1 << ccnt) - 1) << j);\n                    dfs(i, j + ccnt, cnt + 1);\n                    for (int p = i; p < i + ccnt; p++) list[p] &= ~(((1 << ccnt) - 1) << j);\n                }\n            }\n        };\n        dfs(0, 0, 0);\n        return res;\n    }\n};","date":"2023-06-08"}],"tagList":["回溯"],"level":"Hard"}},{"problemName":"1247.交换字符使得字符串相同.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1247.交换字符使得字符串相同.json","problemData":{"id":"1369","name":"1247.交换字符使得字符串相同","url":"https://leetcode.cn/problems/minimum-swaps-to-make-strings-equal","desc":"最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。","solutions":[{"script":"cpp","time":4,"memory":6.1,"desc":"贪心。","code":"class Solution {\npublic:\n    int minimumSwap(string s1, string s2) {\n        int xcnt = 0, ycnt = 0, n = s1.size(), ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (s1[i] == s2[i]) continue;\n            if (s1[i] == 'x') xcnt++;\n            else ycnt++;\n        }\n        ans += xcnt / 2;\n        xcnt %= 2;\n        ans += ycnt / 2;\n        ycnt %= 2;\n        if (xcnt && ycnt) ans += 2, xcnt = 0, ycnt = 0;\n        return xcnt || ycnt ? -1 : ans;\n    }\n};","date":"2023-02-25"},{"script":"python","time":36,"memory":15,"desc":"同上。","code":"class Solution:\n    def minimumSwap(self, s1: str, s2: str) -> int:\n        xcnt, ycnt = 0, 0\n        ans = 0\n        for a, b in zip(s1, s2):\n            if a != b:\n                if a == 'x':\n                    xcnt += 1\n                else:\n                    ycnt += 1\n        ans += xcnt // 2\n        xcnt %= 2\n        ans += ycnt // 2\n        ycnt %= 2\n        if xcnt and ycnt:\n            ans += 2\n            xcnt = 0\n            ycnt = 0\n        return -1 if xcnt or ycnt else ans","date":"2023-02-25"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn minimum_swap(s1: String, s2: String) -> i32 {\n        let s1 = s1.chars().collect::<Vec<char>>();\n        let s2 = s2.chars().collect::<Vec<char>>();\n        let n = s1.len();\n        let mut ans = 0;\n        let (mut x, mut y) = (0, 0);\n        for i in 0..n {\n            if s1[i] != s2[i] {\n                if s1[i] == 'x' {\n                    x += 1;\n                } else {\n                    y += 1;\n                }\n            }\n        }\n        ans += x / 2 + y / 2;\n        x %= 2;\n        y %= 2;\n        if x != 0 && y != 0 {\n            ans += 2;\n            x = 0;\n            y = 0;\n        }\n        if x != 0 || y != 0 {\n            -1\n        } else {\n            ans\n        }\n    }\n}","date":"2023-02-25"}],"tagList":["贪心","数学","字符串"],"level":"Medium"}},{"problemName":"1249.移除无效的括号.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1249.移除无效的括号.json","problemData":{"id":"1371","name":"1249.移除无效的括号","url":"https://leetcode.cn/problems/minimum-remove-to-make-valid-parentheses","desc":"给你一个由 '('、')' 和小写字母组成的字符串 s。你需要从字符串中删除最少数目的 '(' 或者 ')' （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。请返回任意一个合法字符串。","solutions":[{"date":"2021-03-19","time":112,"memory":45.3,"script":"typescript","desc":"从左到右去除右括号，从右到左去除左括号。","code":"function minRemoveToMakeValid(s: string): string {\n  let fCount = 0;\n  let ans = '';\n  for (const c of s) {\n    if (c === '(') {\n      fCount++;\n      ans += c;\n    } else if (c === ')') {\n      if (fCount !== 0) {\n        ans += c;\n        fCount--;\n      }\n    } else {\n      ans += c;\n    }\n  }\n  const temp = ans;\n  fCount = 0;\n  ans = '';\n  for (let i = temp.length - 1; i >= 0; i--) {\n    const c = temp[i];\n    if (c === ')') {\n      fCount++;\n      ans = c + ans;\n    } else if (c === '(') {\n      if (fCount !== 0) {\n        ans = c + ans;\n        fCount--;\n      }\n    } else {\n      ans = c + ans;\n    }\n  }\n  return ans;\n}"}],"tagList":["栈","字符串"],"level":"Medium"}},{"problemName":"1250.检查「好数组」.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1250.检查「好数组」.json","problemData":{"id":"1372","name":"1250.检查「好数组」","url":"https://leetcode.cn/problems/check-if-it-is-a-good-array","desc":"给你一个正整数数组 nums，你需要从中任选一些子集，然后将子集中每一个数乘以一个 任意整数，并求出他们的和。假如该和结果为 1，那么原数组就是一个「好数组」，则返回 True；否则请返回 False。","solutions":[{"script":"cpp","time":44,"memory":28.5,"desc":"裴蜀定理。","code":"class Solution {\npublic:\n    int gcd(int a, int b) {\n        if (!b) return a;\n        if (a < b) return gcd(b, a);\n        return gcd(b, a % b);\n    }\n    bool isGoodArray(vector<int>& nums) {\n        int res = nums[0];\n        for (auto &num : nums) {\n            res = gcd(res, num);\n            if (res == 1) break;\n        }\n        return res == 1;\n    }\n};","date":"2023-02-15"},{"script":"python","time":92,"memory":22.7,"desc":"同上。","code":"class Solution:\n    def isGoodArray(self, nums: List[int]) -> bool:\n        def gcd(a, b):\n            if not b:\n                return a\n            if a < b:\n                return gcd(b, a)\n            return gcd(b, a % b)\n        res = nums[0]\n        for num in nums:\n            res = gcd(res, num)\n            if res == 1:\n                break\n        return res == 1","date":"2023-02-15"},{"script":"rust","time":4,"memory":3.4,"desc":"同上。","code":"fn gcd(a: i32, b: i32) -> i32 {\n    if b == 0 {\n        a\n    } else if a < b {\n        gcd(b, a)\n    } else {\n        gcd(b, a % b)\n    }\n}\n\nimpl Solution {\n    pub fn is_good_array(nums: Vec<i32>) -> bool {\n        let mut res = nums[0];\n        for num in nums {\n            res = gcd(res, num);\n            if res == 1 {\n                break;\n            }\n        }\n        res == 1\n    }\n}","date":"2023-02-15"}],"tagList":["数组","数学","数论"],"level":"Hard"}},{"problemName":"1252.奇数值单元格的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1252.奇数值单元格的数目.json","problemData":{"id":"1378","name":"1252.奇数值单元格的数目","url":"https://leetcode.cn/problems/cells-with-odd-values-in-a-matrix","desc":"给你 m、n 和 indices 。请你在执行完所有 indices 指定的增量操作后，返回矩阵中 奇数值单元格 的数目。","solutions":[{"date":"2022-07-12","time":4,"memory":7.9,"script":"cpp","desc":"模拟遍历。","code":"class Solution {\n   public:\n    int oddCells(int m, int n, vector<vector<int>>& indices) {\n        vector<vector<int>> list(m, vector<int>(n, 0));\n        for (auto& item : indices) {\n            for (int i = 0; i < n; i++) list[item[0]][i]++;\n            for (int i = 0; i < m; i++) list[i][item[1]]++;\n        }\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (list[i][j] & 1) ans++;\n            }\n        }\n        return ans;\n    }\n};"},{"date":"2022-07-12","time":4,"memory":7.5,"script":"cpp","desc":"统计奇数行和奇数列再减去重复部分。","code":"class Solution {\n   public:\n    int oddCells(int m, int n, vector<vector<int>> &indices) {\n        vector<int> rows(m), cols(n);\n        for (auto &item : indices) {\n            rows[item[0]]++;\n            cols[item[1]]++;\n        }\n        int rowCnt = 0, colCnt = 0;\n        for (auto &row : rows)\n            if (row & 1) rowCnt++;\n        for (auto &col : cols)\n            if (col & 1) colCnt++;\n        return rowCnt * n + colCnt * m - 2 * rowCnt * colCnt;\n    }\n};"}],"tagList":["数组","数学","模拟"],"level":"Easy"}},{"problemName":"1253.重构2行二进制矩阵.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1253.重构2行二进制矩阵.json","problemData":{"id":"1379","name":"1253.重构2行二进制矩阵","url":"https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix","desc":"给你一个 2 行 n 列的二进制数组。你需要利用 upper，lower 和 colsum 来重构这个矩阵，并以二维整数数组的形式返回它。","solutions":[{"script":"cpp","time":56,"memory":60.9,"desc":"贪心，先填充2的列，再依次填充1的列。","code":"class Solution {\npublic:\n    vector<vector<int>> reconstructMatrix(int upper, int lower, vector<int>& colsum) {\n        int n = colsum.size();\n        vector<int> list1(n, 0), list2(n, 0);\n        for (int i = 0; i < n; i++) {\n            if (colsum[i] == 2) {\n                list1[i] = list2[i] = 1;\n                if (upper <= 0 || lower <= 0) return {};\n                upper -= 1;\n                lower -= 1;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (colsum[i] == 1) {\n                if (upper > 0) {\n                    list1[i] = 1;\n                    upper--;\n                } else if (lower > 0) {\n                    list2[i] = 1;\n                    lower--;\n                } else {\n                    return {};\n                }\n            }\n        }\n        if (upper > 0 || lower > 0) return {};\n        return { list1, list2 };\n    }\n};","date":"2023-06-29"},{"script":"python","time":132,"memory":22.5,"desc":"同上。","code":"class Solution:\n    def reconstructMatrix(self, upper: int, lower: int, colsum: List[int]) -> List[List[int]]:\n        n = len(colsum)\n        list1 = [0 for _ in range(n)]\n        list2 = [0 for _ in range(n)]\n        for i in range(n):\n            if colsum[i] == 2:\n                list1[i] = list2[i] = 1\n                if upper <= 0 or lower <= 0:\n                    return []\n                upper -= 1\n                lower -= 1\n        for i in range(n):\n            if colsum[i] == 1:\n                if upper > 0:\n                    list1[i] = 1\n                    upper -= 1\n                elif lower > 0:\n                    list2[i] = 1\n                    lower -= 1\n                else:\n                    return []\n        return [list1, list2] if upper == 0 and lower == 0 else []","date":"2023-06-29"},{"script":"rust","time":28,"memory":3.6,"desc":"同上。","code":"impl Solution {\n    pub fn reconstruct_matrix(mut upper: i32, mut lower: i32, colsum: Vec<i32>) -> Vec<Vec<i32>> {\n        let n = colsum.len();\n        let mut list1 = vec![0; n];\n        let mut list2 = vec![0; n];\n        for i in 0..n {\n            if colsum[i] == 2 {\n                list1[i] = 1;\n                list2[i] = 1;\n                if upper <= 0 || lower <= 0 {\n                    return vec![];\n                }\n                upper -= 1;\n                lower -= 1;\n            }\n        }\n        for i in 0..n {\n            if colsum[i] == 1 {\n                if upper > 0 {\n                    list1[i] = 1;\n                    upper -= 1;\n                } else if lower > 0 {\n                    list2[i] = 1;\n                    lower -= 1;\n                } else {\n                    return vec![];\n                }\n            }\n        }\n        if upper > 0 || lower > 0 {\n            vec![]\n        } else {\n            vec![list1, list2]\n        }\n    }\n}","date":"2023-06-29"}],"tagList":["贪心","数组","矩阵"],"level":"Medium"}},{"problemName":"1254.统计封闭岛屿的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1254.统计封闭岛屿的数目.json","problemData":{"id":"1380","name":"1254.统计封闭岛屿的数目","url":"https://leetcode.cn/problems/number-of-closed-islands","desc":"二维矩阵 grid 由 0 （土地）和 1 （水）组成。岛是由最大的4个方向连通的 0 组成的群，封闭岛是一个 完全 由1包围（左、上、右、下）的岛。请返回 封闭岛屿 的数目。","solutions":[{"script":"cpp","time":20,"memory":13,"desc":"bfs。","code":"#define X first\n#define Y second\n#define pii pair<int, int>\nvector<vector<int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\nclass Solution {\npublic:\n    int closedIsland(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size(), res = 0;\n        bool used[100][100] = {0};\n        auto check = [&](int i, int j) {\n            bool res = true;\n            queue<pii> q;\n            q.push(make_pair(i, j));\n            used[i][j] = true;\n            while (q.size()) {\n                auto cur = q.front();\n                q.pop();\n                for (auto &dir : dirs) {\n                    int ni = cur.X + dir[0], nj = cur.Y + dir[1];\n                    if (ni < 0 || ni >= n || nj < 0 || nj >= m || grid[ni][nj] == 1 || used[ni][nj]) continue;\n                    if (ni == 0 || ni == n - 1 || nj == 0 || nj == m - 1) res = false;\n                    q.push(make_pair(ni, nj));\n                    used[ni][nj] = true;\n                }\n            }\n            return res;\n        };\n        for (int i = 1; i < n - 1; i++) {\n            for (int j = 1; j < m - 1; j++) {\n                if (grid[i][j] == 0 && !used[i][j] && check(i, j)) res += 1;\n            }\n        }\n        return res;\n    }\n};","date":"2023-06-18"}],"tagList":["深度优先搜索","广度优先搜索","并查集","数组","矩阵"],"level":"Medium"}},{"problemName":"1255.得分最高的单词集合.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1255.得分最高的单词集合.json","problemData":{"id":"1381","name":"1255.得分最高的单词集合","url":"https://leetcode.cn/problems/maximum-score-words-formed-by-letters","desc":"请你帮忙计算玩家在单词拼写游戏中所能获得的「最高得分」：能够由 letters 里的字母拼写出的 任意 属于 words 单词子集中，分数最高的单词集合的得分。","solutions":[{"script":"cpp","time":8,"memory":9.3,"desc":"状态压缩后遍历所有可能。","code":"class Solution {\npublic:\n    int maxScoreWords(vector<string>& words, vector<char>& letters, vector<int>& score) {\n        int ans = 0, n = words.size();\n        vector<int> clist(26, 0), wscore(n, 0), cclist;\n        for (auto &c : letters) clist[c - 'a']++;\n        for (int i = 0; i < n; i++) {\n            for (auto &c : words[i]) wscore[i] += score[c - 'a'];\n        }\n        for (int i = 0; i < (1 << n); i++) {\n            cclist = clist;\n            bool f = true;\n            int s = 0;\n            for (int j = 0; j < n && f; j++) {\n                if (i & (1 << j)) {\n                    s += wscore[j];\n                    for (auto &c : words[j]) {\n                        if (cclist[c - 'a'] == 0) {\n                            f = false;\n                            break;\n                        }\n                        cclist[c - 'a']--;\n                    }\n                }\n            }\n            if (f) ans = max(ans, s);\n        }\n        return ans;\n    }\n};","date":"2023-02-26"},{"script":"python","time":468,"memory":14.9,"desc":"同上。","code":"class Solution:\n    def maxScoreWords(self, words: List[str], letters: List[str], score: List[int]) -> int:\n        def toScore(word: str) -> int:\n            res = 0\n            for c in word:\n                res += score[ord(c) - ord('a')]\n            return res\n  \n        ans = 0\n        n = len(words)\n        clist = [0] * 26\n        for c in letters:\n            clist[ord(c) - ord('a')] += 1\n        wscore = [toScore(w) for w in words]\n        for i in range(1 << n):\n            cclist = [clist[i] for i in range(26)]\n            f = True\n            s = 0\n            for j in range(n):\n                if i & (1 << j):\n                    s += wscore[j]\n                    for c in words[j]:\n                        if cclist[ord(c) - ord('a')] == 0:\n                            f = False\n                            break\n                        cclist[ord(c) - ord('a')] -= 1\n                if f:\n                    ans = max(ans, s)\n        return ans","date":"2023-02-26"},{"script":"rust","time":4,"memory":2.1,"desc":"同上。","code":"impl Solution {\n        pub fn max_score_words(words: Vec<String>, letters: Vec<char>, score: Vec<i32>) -> i32 {\n            let words = words\n                .into_iter()\n                .map(|s| s.chars().collect::<Vec<char>>())\n                .collect::<Vec<Vec<char>>>();\n            let mut ans = 0;\n            let n = words.len();\n            let list = letters.into_iter().fold([0; 26], |list, c| {\n                let mut list = list;\n                list[c as usize - 'a' as usize] += 1;\n                list\n            });\n            let wscore = words\n                .iter()\n                .map(|w| {\n                    let mut s = 0;\n                    for c in w.iter() {\n                        s += score[*c as usize - 'a' as usize];\n                    }\n                    s\n                })\n                .collect::<Vec<i32>>();\n            for i in 0..(1 << n) {\n                let mut clist = list.clone();\n                let mut f = true;\n                let mut s = 0;\n                for j in 0..n {\n                    if (i & (1 << j)) != 0 {\n                        s += wscore[j];\n                        for c in words[j].iter() {\n                            if clist[*c as usize - 'a' as usize] == 0 {\n                                f = false;\n                                break;\n                            }\n                            clist[*c as usize - 'a' as usize] -= 1;\n                        }\n                    }\n                }\n                if f {\n                    ans = ans.max(s);\n                }\n            }\n            ans\n        }\n    }","date":"2023-02-26"}],"tagList":["位运算","数组","字符串","动态规划","回溯","状态压缩"],"level":"Hard"}},{"problemName":"1260.二维网格迁移.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1260.二维网格迁移.json","problemData":{"id":"1386","name":"1260.二维网格迁移","url":"https://leetcode.cn/problems/shift-2d-grid","desc":"请你返回 k 次迁移操作后最终得到的 二维网格。","solutions":[{"date":"2022-07-20","time":20,"memory":2.3,"script":"rust","desc":"对于每个下标找到对应的下一个值。","code":"impl Solution {\n    pub fn shift_grid(grid: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\n        let n = grid.len();\n        let m = grid[0].len();\n        let mut newGrid = grid.clone();\n        let mut i: usize = 0;\n        while i < n {\n            let mut j: usize = 0;\n            while j < m {\n                let (ni, nj) = Solution::get_next(n, m, i, j, k);\n                newGrid[i][j] = grid[ni][nj];\n                j += 1;\n            }\n            i += 1;\n        }\n        newGrid\n    }\n    fn get_next(n: usize, m: usize, i: usize, j: usize, cnt: i32) -> (usize, usize) {\n        if cnt == 0 {\n            (i, j)\n        } else if j != 0 {\n            return Solution::get_next(n, m, i, j - 1, cnt - 1);\n        } else if i != 0 {\n            return Solution::get_next(n, m, i - 1, m - 1, cnt - 1);\n        } else {\n            return Solution::get_next(n, m, n - 1, m - 1, cnt - 1);\n        }\n    }\n}"},{"date":"2022-07-20","time":8,"memory":2.3,"script":"rust","desc":"对于每个下标找到对应的下一个值。","code":"impl Solution {\n    pub fn shift_grid(grid: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\n        let (n, m) = (grid.len(), grid[0].len());\n        let num = m * n;\n        let k = (k as usize) % num;\n        let mut ans = vec![vec![0; m]; n];\n        for idx in 0..num {\n            let next = (idx + num - k) % num;\n            ans[idx / m][idx % m] = grid[next / m][next % m];\n        }\n        ans\n    }\n}"}],"tagList":["数组","矩阵","模拟"],"level":"Easy"}},{"problemName":"1261.在受污染的二叉树中查找元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1261.在受污染的二叉树中查找元素.json","problemData":{"id":"1387","name":"1261.在受污染的二叉树中查找元素","url":"https://leetcode.cn/problems/find-elements-in-a-contaminated-binary-tree","desc":"请你先还原二叉树，然后实现 FindElements 类。","solutions":[{"script":"python","time":66,"memory":20.3,"desc":"dfs。","code":"class FindElements:\n    def __init__(self, root: Optional[TreeNode]):\n        self.set = set()\n        def dfs(node: Optional[TreeNode], cur: int):\n            if not node: return\n            self.set.add(cur)\n            dfs(node.left, cur * 2 + 1)\n            dfs(node.right, cur * 2 + 2)\n        dfs(root, 0)\n    def find(self, target: int) -> bool:\n        return target in self.set","date":"2024-03-12"}],"tagList":["树","深度优先搜索","广度优先搜索","设计","哈希表","二叉树"],"level":"Medium"}},{"problemName":"1262.可被三整除的最大和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1262.可被三整除的最大和.json","problemData":{"id":"1388","name":"1262.可被三整除的最大和","url":"https://leetcode.cn/problems/greatest-sum-divisible-by-three","desc":"给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。","solutions":[{"script":"cpp","time":24,"memory":26,"desc":"求出总和，模3判断多了的数字。","code":"class Solution {\npublic:\n    int maxSumDivThree(vector<int>& nums) {\n        int sum = 0;\n        vector<int> v1, v2;\n        for (auto &num : nums) {\n            sum += num;\n            switch (num % 3) {\n                case 1: v1.push_back(num); break;\n                case 2: v2.push_back(num); break;\n            }\n        }\n        if (sum % 3 == 0) return sum;\n        sort(v1.begin(), v1.end());\n        sort(v2.begin(), v2.end());\n        if (sum % 3 == 2) swap(v1, v2);\n        int res = v1.size() ? sum - v1[0] : 0;\n        if (v2.size() > 1) res = max(res, sum - v2[0] - v2[1]);\n        return res;\n    }\n};","date":"2023-06-19"},{"script":"cpp","time":72,"memory":36,"desc":"dp表示余i个数的时候的最大和。","code":"class Solution {\npublic:\n    int maxSumDivThree(vector<int>& nums) {\n        vector<int> dp = {0, INT_MIN, INT_MIN};\n        for (auto &num : nums) {\n            auto nextDp = dp;\n            for (int i = 0; i < 3; i++) {\n                int idx = (i + num) % 3;\n                nextDp[idx] = max(nextDp[idx], dp[i] + num);\n            }\n            dp = nextDp;\n        }\n        return dp[0];\n    }\n};","date":"2023-06-19"}],"tagList":["贪心","数组","动态规划","排序"],"level":"Medium"}},{"problemName":"1263.推箱子.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1263.推箱子.json","problemData":{"id":"1389","name":"1263.推箱子","url":"https://leetcode.cn/problems/minimum-moves-to-move-a-box-to-their-target-location","desc":"返回将箱子推到目标位置的最小 推动 次数，如果无法做到，请返回 -1。","solutions":[{"script":"cpp","time":72,"memory":15.4,"desc":"dfs每次统计左右子树的差值。","code":"#define X first\n#define Y second\n#define pii pair<int, int>\n\nclass UnionFind {\n    public:\n    int n;\n    vector<int> data, cnt;\n    UnionFind(int n) : n(n), data(vector<int>(n, 0)), cnt(vector<int>(n, 1)) {\n        iota(data.begin(), data.end(), 0);\n    }\n    int size(int v) { return cnt[find(v)]; }\n    int find(int v) {\n        if (data[v] == v) return v;\n        return data[v] = find(data[v]);\n    }\n    void uni(int v1, int v2) {\n        int p1 = find(v1), p2 = find(v2);\n        if (p1 != p2) cnt[p1] += cnt[p2], data[p2] = p1;\n    }\n    bool same(int v1, int v2) { return find(v1) == find(v2); }\n};\nint pos2Idx(int x, int y, int size) { return x * size + y; }\nvoid idx2Pos(int idx, int size, int &x, int &y) {\n    x = idx / size;\n    y = idx % size;\n}\nvector<vector<int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n// 记录箱子和人的位置\nstruct Node {\n    pii p, b;\n    Node(pii p, pii b): p(p), b(b) {}\n};\nclass Solution {\npublic:\n    int minPushBox(vector<vector<char>>& grid) {\n        pii t, p, b;\n        int n = grid.size(), m = grid[0].size();\n        // 统计箱子和人的位置放置重复计算\n        unordered_map<int, unordered_map<int, bool>> used;\n        // 判断两个坐标是否相等\n        auto is_same = [&](pii a, pii b) -> bool {\n            return a.X == b.X && a.Y == b.Y;\n        };\n        // 针对当前Node值，计算并查集，计算时要排除箱子位置，用于后面判断人是不是能到这个点\n        auto get_uf = [&](Node cur) -> UnionFind {\n            UnionFind uf(n * m);\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    if (grid[i][j] == '.' && !is_same(cur.b, make_pair(i, j))) {\n                        for (int k = 0; k < 4; k++) {\n                            int ni = i + dirs[k][0], nj = j + dirs[k][1];\n                            if (0 <= ni && ni < n && 0 <= nj && nj < m && grid[ni][nj] == '.' && !is_same(cur.b, make_pair(ni, nj))) {\n                                uf.uni(pos2Idx(i, j, m), pos2Idx(ni, nj, m));\n                            }\n                        }\n                    }\n                }\n            }\n            return uf;\n        };\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 'T') t = make_pair(i, j), grid[i][j] = '.';\n                else if (grid[i][j] == 'B') b = make_pair(i, j), grid[i][j] = '.';\n                else if (grid[i][j] == 'S') p = make_pair(i, j), grid[i][j] = '.';\n            }\n        }\n        queue<Node> q;\n        q.push(Node(p, b));\n        int size = 1, step = 0;\n        while (q.size()) {\n            auto cur = q.front();\n            q.pop();\n            if (is_same(cur.b, t)) return step;\n            auto uf = get_uf(cur);\n            for (int k = 0; k < 4; k++) {\n                int ni = cur.b.X + dirs[k][0], nj = cur.b.Y + dirs[k][1],\n                    bi = cur.b.X - dirs[k][0], bj = cur.b.Y - dirs[k][1];\n                // 如果箱子要推到(ni, nj), 那么人要在(bi, bj)位置上推，所以这两个位置都要空，且这个位置没有被统计过\n                if (0 <= ni && ni < n && 0 <= nj && nj < m && grid[ni][nj] == '.' &&\n                    0 <= bi && bi < n && 0 <= bj && bj < m && grid[bi][bj] == '.' &&\n                    uf.same(pos2Idx(cur.p.X, cur.p.Y, m), pos2Idx(bi, bj, m)) &&\n                    !used[pos2Idx(cur.b.X, cur.b.Y, m)][pos2Idx(ni, nj, m)]) {\n                    q.push(Node(make_pair(cur.b.X, cur.b.Y), make_pair(ni, nj)));\n                    used[pos2Idx(cur.b.X, cur.b.Y, m)][pos2Idx(ni, nj, m)] = true;\n                }\n            }\n            if (--size == 0) {\n                size = q.size();\n                step++;\n            }\n        }\n\n        return -1;\n    }\n};","date":"2023-05-08"},{"script":"python","time":2080,"memory":16.5,"desc":"同上。","code":"dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\nclass UnionFind:\n    def __init__(self, n) -> None:\n        self.n = n\n        self.data = [i for i in range(0, n)]\n        self.cnt = [1] * n\n\n    def size(self, v: int) -> int:\n        return self.cnt[self.find(v)]\n\n    def find(self, v: int) -> int:\n        if self.data[v] != v:\n            self.data[v] = self.find(self.data[v])\n        return self.data[v]\n\n    def uni(self, v1: int, v2: int):\n        p1 = self.find(v1)\n        p2 = self.find(v2)\n        if p1 != p2:\n            self.cnt[p1] += self.cnt[p2]\n            self.data[p2] = p1\n\n    def same(self, v1: int, v2: int):\n        return self.find(v1) == self.find(v2)\n\n\ndef pos2Idx(x: int, y: int, size: int):\n    return x * size + y\n\n\ndef idx2pox(idx: int, size: int) -> Tuple[int,  int]:\n    return (idx // size, idx % size)\n\nclass Node:\n    def __init__(self, p: Tuple[int, int], b: Tuple[int, int]) -> None:\n        self.p = p\n        self.b = b\n\nclass Solution:\n    def minPushBox(self, grid: List[List[str]]) -> int:\n        t, p, b = (0, 0), (0, 0), (0, 0)\n        n = len(grid)\n        m = len(grid[0])\n        used = defaultdict(dict)\n\n        def is_valid(v: Tuple[int, int]) -> bool:\n            return 0 <= v[0] < n and 0 <= v[1] < m\n\n        def is_same(a: Tuple[int, int], b: Tuple[int, int]):\n            return a[0] == b[0] and a[1] == b[1]\n\n        def get_uf(cur: Node) -> UnionFind:\n            uf = UnionFind(n * m)\n            for i in range(n):\n                for j in range(m):\n                    if grid[i][j] == '.' and not is_same(cur.b, (i, j)):\n                        for k in range(4):\n                            ni = i + dirs[k][0]\n                            nj = j + dirs[k][1]\n                            if is_valid((ni, nj)) and grid[ni][nj] == '.' and not is_same(cur.b, (ni, nj)):\n                                uf.uni(pos2Idx(i, j, m), pos2Idx(ni, nj, m))\n            return uf\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 'T':\n                    t = (i, j)\n                    grid[i][j] = '.'\n                elif grid[i][j] == 'B':\n                    b = (i, j)\n                    grid[i][j] = '.'\n                elif grid[i][j] == 'S':\n                    p = (i, j)\n                    grid[i][j] = '.'\n        q = deque()\n        q.append(Node(p, b))\n        size = 1\n        step = 0\n        while len(q):\n            cur: Node = q.popleft()\n            if is_same(cur.b, t):\n                return step\n            uf = get_uf(cur)\n            for k in range(4):\n                ni = cur.b[0] + dirs[k][0]\n                nj = cur.b[1] + dirs[k][1]\n                bi = cur.b[0] - dirs[k][0]\n                bj = cur.b[1] - dirs[k][1]\n                pidx = pos2Idx(cur.p[0], cur.p[1], m)\n                bidx = pos2Idx(cur.b[0], cur.b[1], m)\n                if is_valid((ni, nj)) and grid[ni][nj] == '.' and is_valid((bi, bj)) and grid[bi][bj] == '.' and uf.same(pidx, pos2Idx(bi, bj, m)) and pos2Idx(ni, nj, m) not in used[bidx]:\n                    q.append(Node(cur.b, (ni, nj)))\n                    used[bidx][pos2Idx(ni, nj, m)] = True\n            size -= 1\n            if size == 0:\n                size = len(q)\n                step += 1\n        return -1","date":"2023-05-09"},{"script":"rust","time":16,"memory":2.2,"desc":"同上。","code":"pub use std::collections::HashMap;\npub use std::collections::VecDeque;\npub const dirs: [[i32; 2]; 4] = [[0, 1], [0, -1], [1, 0], [-1, 0]];\npub struct UnionFind {\n    n: usize,\n    data: Vec<usize>,\n    cnt: Vec<usize>,\n}\nimpl UnionFind {\n    pub fn new(n: usize) -> Self {\n        let mut data = vec![0; n];\n        for i in 0..data.len() {\n            data[i] = i;\n        }\n        Self {\n            n,\n            data,\n            cnt: vec![0; n],\n        }\n    }\n    pub fn size(&mut self, v: usize) -> usize {\n        let idx = self.find(v);\n        self.cnt[idx]\n    }\n    pub fn find(&mut self, v: usize) -> usize {\n        if self.data[v] != v {\n            self.data[v] = self.find(self.data[v]);\n        }\n        self.data[v]\n    }\n    pub fn uni(&mut self, v1: usize, v2: usize) {\n        let p1 = self.find(v1);\n        let p2 = self.find(v2);\n        if p1 != p2 {\n            self.cnt[p1] += self.cnt[p2];\n            self.data[p2] = p1;\n        }\n    }\n    pub fn same(&mut self, v1: usize, v2: usize) -> bool {\n        self.find(v1) == self.find(v2)\n    }\n}\npub fn pos2Idx(x: usize, y: usize, size: usize) -> usize {\n    x * size + y\n}\npub fn idx2Pos(idx: usize, size: usize) -> (usize, usize) {\n    (idx / size, idx % size)\n}\n\ntype Position = (usize, usize);\n\n#[derive(Clone, Copy, Debug)]\nstruct Node {\n    p: Position,\n    b: Position,\n}\nimpl Node {\n    fn new(p: Position, b: Position) -> Self {\n        Self { p, b }\n    }\n}\n\nimpl Solution {\n    pub fn min_push_box(mut grid: Vec<Vec<char>>) -> i32 {\n        let mut p: Position = (0, 0);\n        let mut b: Position = (0, 0);\n        let mut t: Position = (0, 0);\n        let n = grid.len();\n        let m = grid[0].len();\n        let mut used = HashMap::<usize, HashMap<usize, bool>>::new();\n        let is_same = |a: Position, b: Position| a.0 == b.0 && a.1 == b.1;\n        let is_valid = |v: (i32, i32)| 0 <= v.0 && v.0 < n as i32 && 0 <= v.1 && v.1 < m as i32;\n        let get_uf = |grid: &Vec<Vec<char>>, cur: Node| {\n            let mut uf = UnionFind::new(n * m);\n            for i in 0..n {\n                for j in 0..m {\n                    if grid[i][j] == '.' && !is_same(cur.b, (i, j)) {\n                        for k in 0..4 {\n                            let ni = i as i32 + dirs[k][0];\n                            let nj = j as i32 + dirs[k][1];\n                            if is_valid((ni, nj))\n                                && grid[ni as usize][nj as usize] == '.'\n                                && !is_same(cur.b, (ni as usize, nj as usize))\n                            {\n                                uf.uni(pos2Idx(i, j, m), pos2Idx(ni as usize, nj as usize, m));\n                            }\n                        }\n                    }\n                }\n            }\n            uf\n        };\n        for i in 0..n {\n            for j in 0..m {\n                let t1 = grid[i][j] == 'T';\n                let t2 = grid[i][j] == 'B';\n                let t3 = grid[i][j] == 'S';\n                if t1 {\n                    t = (i, j);\n                    grid[i][j] = '.';\n                } else if t2 {\n                    b = (i, j);\n                    grid[i][j] = '.';\n                } else if t3 {\n                    p = (i, j);\n                    grid[i][j] = '.';\n                }\n            }\n        }\n        let mut q = VecDeque::<Node>::new();\n        q.push_back(Node::new(p, b));\n        let mut size = 1;\n        let mut step = 0;\n        while let Some(cur) = q.pop_front() {\n            if is_same(cur.b, t) {\n                return step;\n            }\n            let mut uf = get_uf(&grid, cur);\n            for k in 0..4 {\n                let ni = cur.b.0 as i32 + dirs[k][0];\n                let nj = cur.b.1 as i32 + dirs[k][1];\n                let bi = cur.b.0 as i32 - dirs[k][0];\n                let bj = cur.b.1 as i32 - dirs[k][1];\n                let pidx = pos2Idx(cur.p.0, cur.p.1, m);\n                let bidx = pos2Idx(cur.b.0, cur.b.1, m);\n                if is_valid((ni, nj))\n                    && grid[ni as usize][nj as usize] == '.'\n                    && is_valid((bi, bj))\n                    && grid[bi as usize][bj as usize] == '.'\n                    && uf.same(pidx, pos2Idx(bi as usize, bj as usize, m))\n                {\n                    if used.contains_key(&bidx)\n                        && used.get(&bidx).unwrap().contains_key(&pos2Idx(\n                            ni as usize,\n                            nj as usize,\n                            m,\n                        ))\n                    {\n                        continue;\n                    }\n                    let ni = ni as usize;\n                    let nj = nj as usize;\n                    q.push_back(Node::new(cur.b, (ni, nj)));\n                    let item = used.entry(bidx).or_insert(HashMap::new());\n                    *item.entry(pos2Idx(ni, nj, m)).or_insert(false) = true;\n                }\n            }\n            size -= 1;\n            if size == 0 {\n                size = q.len();\n                step += 1;\n            }\n        }\n        -1\n    }\n}","date":"2023-05-09"}],"tagList":["广度优先搜索","数组","矩阵","堆（优先队列）"],"level":"Hard"}},{"problemName":"1267.统计参与通信的服务器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1267.统计参与通信的服务器.json","problemData":{"id":"1396","name":"1267.统计参与通信的服务器","url":"https://leetcode.cn/problems/count-servers-that-communicate","desc":"请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。","solutions":[{"script":"cpp","time":40,"memory":21.36,"desc":"两次遍历。","code":"class Solution {\npublic:\n    int countServers(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size(), mmap[250][250] = {0};\n        pair<int, int> prev = make_pair(-1, -1);\n        for (int i = 0; i < n; i++) {\n            prev = make_pair(-1, -1);\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) {\n                    if (prev.first == -1) prev = make_pair(i, j);\n                    else {\n                        mmap[prev.first][prev.second] = true;\n                        mmap[i][j] = true;\n                    }\n                }\n            }\n        }\n        for (int j = 0; j < m; j++) {\n            prev = make_pair(-1, -1);\n            for (int i = 0; i < n; i++) {\n                if (grid[i][j] == 1) {\n                    if (prev.first == -1) prev = make_pair(i, j);\n                    else {\n                        mmap[prev.first][prev.second] = true;\n                        mmap[i][j] = true;\n                    }\n                }\n            }\n        }\n        int res = 0;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                if (mmap[i][j]) res += 1;\n        return res;\n    }\n};","date":"2023-08-24"},{"script":"python","time":100,"memory":17.79,"desc":"同上。","code":"class Solution:\n    def countServers(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n        mmap = [[0 for _ in range(m)] for _ in range(n)]\n        prev = (-1, -1)\n        for i in range(n):\n            prev = (-1, -1)\n            for j in range(m):\n                if grid[i][j] == 1:\n                    if prev[0] == -1:\n                        prev = (i, j)\n                    else:\n                        mmap[prev[0]][prev[1]] = True\n                        mmap[i][j] = True\n        for j in range(m):\n            prev = (-1, -1)\n            for i in range(n):\n                if grid[i][j] == 1:\n                    if prev[0] == -1:\n                        prev = (i, j)\n                    else:\n                        mmap[prev[0]][prev[1]] = True\n                        mmap[i][j] = True\n        res = 0\n        for i in range(n):\n            for j in range(m):\n                if mmap[i][j]:\n                    res += 1\n        return res","date":"2023-08-24"},{"script":"rust","time":8,"memory":2.26,"desc":"同上。","code":"impl Solution {\n    pub fn count_servers(grid: Vec<Vec<i32>>) -> i32 {\n        let n = grid.len();\n        let m = grid[0].len();\n        let mut mmap = vec![vec![false; m]; n];\n        let mut prev = (usize::MAX, usize::MAX);\n        for i in 0..n {\n            prev = (usize::MAX, usize::MAX);\n            for j in 0..m {\n                if grid[i][j] == 1 {\n                    if prev.0 == usize::MAX {\n                        prev = (i, j);\n                    } else {\n                        mmap[prev.0][prev.1] = true;\n                        mmap[i][j] = true;\n                    }\n                }\n            }\n        }\n        for j in 0..m {\n            prev = (usize::MAX, usize::MAX);\n            for i in 0..n {\n                if grid[i][j] == 1 {\n                    if prev.0 == usize::MAX {\n                        prev = (i, j);\n                    } else {\n                        mmap[prev.0][prev.1] = true;\n                        mmap[i][j] = true;\n                    }\n                }\n            }\n        }\n        let mut res = 0;\n        for i in 0..n {\n            for j in 0..m {\n                if mmap[i][j] {\n                    res += 1;\n                }\n            }\n        }\n        res\n    }\n}","date":"2023-08-24"}],"tagList":["深度优先搜索","广度优先搜索","并查集","数组","计数","矩阵"],"level":"Medium"}},{"problemName":"1268.搜索推荐系统.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1268.搜索推荐系统.json","problemData":{"id":"1397","name":"1268.搜索推荐系统","url":"https://leetcode.cn/problems/search-suggestions-system","desc":"请你以二维列表的形式，返回在输入 searchWord 每个字母后相应的推荐产品的列表。","solutions":[{"date":"2021-10-25","time":820,"memory":66.6,"script":"typescript","desc":"trie 中序遍历。","code":"const MAX_COUNT = 26;\nconst getIdx = (ch: string) => ch.codePointAt(0)! - 'a'.codePointAt(0)!;\nclass TrieNode {\n  end = false;\n  children: TrieNode[] = new Array(MAX_COUNT);\n  constructor(public val: string) {}\n}\nclass Trie {\n  root = new TrieNode('');\n  insert(word: string): void {\n    let node = this.root;\n    for (const ch of word) {\n      const idx = getIdx(ch);\n      if (!node.children[idx]) node.children[idx] = new TrieNode(ch);\n      node = node.children[idx];\n    }\n    node.end = true;\n  }\n  findNode(word: string): TrieNode | null {\n    let node = this.root;\n    for (const ch of word) {\n      const idx = getIdx(ch);\n      if (!node.children[idx]) return null;\n      node = node.children[idx];\n    }\n    return node;\n  }\n  search(word: string): boolean {\n    return !!this.findNode(word)?.end;\n  }\n  startsWith(prefix: string): boolean {\n    return !!this.findNode(prefix);\n  }\n}\nfunction suggestedProducts(products: string[], searchWord: string): string[][] {\n  const trie = new Trie();\n  products.forEach(ch => trie.insert(ch));\n  let str = '';\n  const ans: string[][] = [];\n  for (const ch of searchWord) {\n    const node = trie.findNode(str + ch);\n    const list = dfs(node)\n      .slice(0, 3)\n      .map(v => str + v);\n    ans.push(list);\n    str += ch;\n  }\n  return ans;\n  function dfs(node: TrieNode | null): string[] {\n    const ans: string[] = [];\n    _dfs(node);\n    return ans;\n    function _dfs(node: TrieNode | null, str = ''): void {\n      if (!node) return;\n      str += node.val;\n      if (node.end) ans.push(str);\n      for (let i = 0; i < 26; i++) _dfs(node.children[i], str);\n    }\n  }\n}"}],"tagList":["字典树","数组","字符串","二分查找","排序","堆（优先队列）"],"level":"Medium"}},{"problemName":"1269.停在原地的方案数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1269.停在原地的方案数.json","problemData":{"id":"1398","name":"1269.停在原地的方案数","url":"https://leetcode.cn/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps","desc":"给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。","solutions":[{"date":"2020-04-26","time":404,"memory":37.3,"script":"javascript","desc":"循环数组进行添加，把数组两两添加，添加时判断数值小以及是否为 null。","code":"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode[]} lists\n * @return {ListNode}\n */\nvar mergeKLists = function (lists) {\n  if (lists.length === 0) return null;\n  if (lists.length === 1) return lists[0];\n  let resNode;\n  for (const node of lists) {\n    if (node === null) continue;\n    if (resNode === undefined) resNode = node;\n    else resNode = add(resNode, node);\n  }\n  return resNode === undefined ? null : resNode;\n};\nfunction add(node1, node2) {\n  let tempNode1 = node1;\n  let tempNode2 = node2;\n  let resNode;\n  let tempNode3;\n  while (tempNode1 !== null || tempNode2 !== null) {\n    let minNode;\n    if (tempNode1 === null) {\n      minNode = tempNode2;\n      tempNode2 = tempNode2.next;\n    } else if (tempNode2 === null) {\n      minNode = tempNode1;\n      tempNode1 = tempNode1.next;\n    } else if (tempNode1.val < tempNode2.val) {\n      minNode = tempNode1;\n      tempNode1 = tempNode1.next;\n    } else {\n      minNode = tempNode2;\n      tempNode2 = tempNode2.next;\n    }\n    if (resNode === undefined) {\n      tempNode3 = resNode = minNode;\n    } else {\n      tempNode3.next = minNode;\n      tempNode3 = tempNode3.next;\n    }\n  }\n  return resNode;\n}"},{"date":"2021-05-13","time":220,"memory":48.3,"script":"typescript","desc":"归并思想排序。","code":"function mergeKLists(lists: Array<ListNode | null>): ListNode | null {\n  lists = lists.filter(list => list !== null);\n  const len = lists.length;\n  if (len === 0) return null;\n  const merge = (start: number, end: number): ListNode | null => {\n    console.log(start, end);\n    if (start > end) return null;\n    if (start === end) return lists[start];\n    const mid = (start + end) >> 1;\n    const list1 = merge(start, mid);\n    const list2 = merge(mid + 1, end);\n    if (list1 === null) return list2;\n    if (list2 === null) return list1;\n    const first = new ListNode(0);\n    let temp = first;\n    let p1: ListNode | null = list1;\n    let p2: ListNode | null = list2;\n    while (p1 && p2) {\n      if (p1.val <= p2.val) {\n        temp.next = p1;\n        temp = temp.next;\n        p1 = p1.next;\n      } else {\n        temp.next = p2;\n        temp = temp.next;\n        p2 = p2.next;\n      }\n    }\n    if (p1) temp.next = p1;\n    if (p2) temp.next = p2;\n    return first.next;\n  };\n  return merge(0, len - 1);\n}"}],"tagList":["动态规划"],"level":"Hard"}},{"problemName":"1276.不浪费原料的汉堡制作方案.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1276.不浪费原料的汉堡制作方案.json","problemData":{"id":"1401","name":"1276.不浪费原料的汉堡制作方案","url":"https://leetcode.cn/problems/number-of-burgers-with-no-waste-of-ingredients","desc":"请你以 [total_jumbo, total_small]（[巨无霸汉堡总数，小皇堡总数]）的格式返回恰当的制作方案，使得剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量都是 0。","solutions":[{"script":"python","time":40,"memory":16.8,"desc":"二元一次方程。","code":"class Solution:\n    def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> List[int]:\n        # 4x + 2y = num1\n        # x  + y  = num2\n        # x = (num1 - 2num2) / 2\n        # y = num2 - x\n        x = (tomatoSlices - 2 * cheeseSlices) // 2\n        y = cheeseSlices - x\n        return [x, y] if x >= 0 and y >= 0 and 4 * x + 2 * y == tomatoSlices and x + y == cheeseSlices else []","date":"2023-12-25"}],"tagList":["数学"],"level":"Medium"}},{"problemName":"1281.整数的各位积和之差.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1281.整数的各位积和之差.json","problemData":{"id":"1406","name":"1281.整数的各位积和之差","url":"https://leetcode.cn/problems/subtract-the-product-and-sum-of-digits-of-an-integer","desc":"给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。","solutions":[{"script":"cpp","time":0,"memory":5.7,"desc":"遍历。","code":"class Solution {\npublic:\n    int subtractProductAndSum(int n) {\n        int num1 = 1, num2 = 0;\n        while (n) {\n            num1 *= n % 10;\n            num2 += n % 10;\n            n /= 10;\n        }\n        return num1 - num2;\n    }\n};","date":"2023-08-09"},{"script":"python","time":44,"memory":16.1,"desc":"同上。","code":"class Solution:\n    def subtractProductAndSum(self, n: int) -> int:\n        num1 = 1\n        num2 = 0\n        while n:\n            num1 *= n % 10\n            num2 += n % 10\n            n //= 10\n        return num1 - num2","date":"2023-08-09"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn subtract_product_and_sum(mut n: i32) -> i32 {\n        let mut num1 = 1;\n        let mut num2 = 0;\n        while n != 0 {\n            num1 *= n % 10;\n            num2 += n % 10;\n            n /= 10;\n        }\n        num1 - num2\n    }\n}","date":"2023-08-09"}],"tagList":["数学"],"level":"Easy"}},{"problemName":"1282.用户分组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1282.用户分组.json","problemData":{"id":"1407","name":"1282.用户分组","url":"https://leetcode.cn/problems/group-the-people-given-the-group-size-they-belong-to","desc":"返回一个组列表，使每个人 i 都在一个大小为 groupSizes[i] 的组中。","solutions":[{"date":"2022-08-12","time":4,"memory":2.3,"script":"rust","desc":"map 重组。","code":"use std::collections::*;\nimpl Solution {\n    pub fn group_the_people(group_sizes: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut ans = Vec::new();\n        let mut map = HashMap::<i32, Vec<Vec<i32>>>::new();\n        for i in 0..group_sizes.len() {\n            let k = group_sizes[i];\n            let list = map.entry(k).or_insert(vec![vec![]]);\n            let item = list.last_mut().unwrap();\n            item.push(i as i32);\n            if item.len() == k as usize {\n                ans.push(item.clone());\n                list.push(Vec::new());\n            }\n        }\n        ans\n    }\n}"}],"tagList":["数组","哈希表"],"level":"Medium"}},{"problemName":"1289.下降路径最小和II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1289.下降路径最小和II.json","problemData":{"id":"1224","name":"1289.下降路径最小和II","url":"https://leetcode.cn/problems/minimum-falling-path-sum-ii","desc":"给你一个 n x n 整数矩阵 grid ，请你返回 非零偏移下降路径 数字和的最小值。","solutions":[{"script":"cpp","time":40,"memory":13.82,"desc":"遍历，只记录最小值和第二小值。","code":"class Solution {\npublic:\n    int minFallingPathSum(vector<vector<int>>& grid) {\n        int n = grid.size(), min1, min2, res;\n        auto refresh = [&](int row) {\n            res = INT_MAX;\n            min1 = INT_MAX;\n            min2 = INT_MAX;\n            for (int j = 0; j < n; j++) {\n                res = min(res, grid[row][j]);\n                if (min1 == INT_MAX || grid[row][j] < grid[row][min1]) min2 = min1, min1 = j;\n                else if (min2 == INT_MAX || grid[row][j] < grid[row][min2]) min2 = j;\n            }\n        };\n        for (int row = 1; row < n; row++) {\n            refresh(row - 1);\n            for (int j = 0; j < n; j++) {\n                grid[row][j] += j == min1 ? grid[row - 1][min2] : grid[row - 1][min1];\n            }\n        }\n        refresh(n - 1);\n        return res;\n    }\n};","date":"2023-08-10"},{"script":"python","time":128,"memory":18.97,"desc":"同上。","code":"class Solution:\n    def minFallingPathSum(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        min1 = min2 = res = 0\n\n        def refresh(row: int):\n            nonlocal res\n            nonlocal min1\n            nonlocal min2\n            res = min1 = min2 = inf\n            for j in range(n):\n                res = min(res, grid[row][j])\n                if min1 == inf or grid[row][j] < grid[row][min1]:\n                    min2 = min1\n                    min1 = j\n                elif min2 == inf or grid[row][j] < grid[row][min2]:\n                    min2 = j\n        for row in range(1, n):\n            refresh(row-1)\n            for j in range(n):\n                grid[row][j] += grid[row -\n                                        1][min2] if j == min1 else grid[row - 1][min1]\n        refresh(n-1)\n        return res","date":"2023-08-10"},{"script":"rust","time":0,"memory":2.53,"desc":"同上。","code":"impl Solution {\n    pub fn min_falling_path_sum(mut grid: Vec<Vec<i32>>) -> i32 {\n        let n = grid.len();\n        let mut min1 = 0;\n        let mut min2 = 0;\n        for row in 1..n {\n            min1 = usize::MAX;\n            min2 = usize::MAX;\n            for j in 0..n {\n                if min1 == usize::MAX || grid[row - 1][j] < grid[row - 1][min1] {\n                    min2 = min1;\n                    min1 = j;\n                } else if min2 == usize::MAX || grid[row - 1][j] < grid[row - 1][min2] {\n                    min2 = j;\n                }\n            }\n            for j in 0..n {\n                grid[row][j] += if j == min1 {\n                    grid[row - 1][min2]\n                } else {\n                    grid[row - 1][min1]\n                };\n            }\n        }\n        *grid[n - 1].iter().min().unwrap()\n    }\n}","date":"2023-08-10"}],"tagList":["数组","动态规划","矩阵"],"level":"Hard"}},{"problemName":"1300.转变数组后最接近目标值的数组和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1201-1300/1300.转变数组后最接近目标值的数组和.json","problemData":{"id":"1232","name":"1300.转变数组后最接近目标值的数组和","url":"https://leetcode.cn/problems/sum-of-mutated-array-closest-to-target","desc":"排序后进行判断，四舍五入","solutions":[{"date":"2020-06-17","time":96,"memory":36,"script":"typescript","desc":"description。","code":"function findBestValue(arr: number[], target: number): number {\n  const len = arr.length;\n  if (len === 1) return target > arr[0] ? target : arr[0];\n  arr.sort((a, b) => a - b);\n  let sum = 0;\n  let min = Infinity;\n  let cha = Infinity;\n  for (let i = 0; i < len; i++) {\n    const num = arr[i];\n    const sLen = len - i - 1;\n    sum += num;\n    const need = Math.round((target - sum) / sLen);\n    if (need < num || (i !== len - 1 && need > arr[i + 1])) continue;\n    const newCha = Math.abs(need * sLen + sum - target);\n    compCha(newCha, need);\n    const newCha2 = Math.abs((need - 1) * sLen + sum - target);\n    compCha(newCha2, need - 1);\n  }\n  if (min === Infinity) {\n    const num = Math.round(target / len);\n    if (num < arr[0]) {\n      const newCha = Math.abs(num * len - target);\n      compCha(newCha, num);\n    }\n  }\n  compCha(Math.abs(target - sum), arr[len - 1]);\n  return min;\n  function compCha(newCha: number, need: number): void {\n    if (newCha < cha || (newCha === cha && need < min)) {\n      cha = newCha;\n      min = need;\n    }\n  }\n}"}],"tagList":["数组","二分查找","排序"],"level":"Medium"}}]},{"dirName":"1301-1400","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\1301-1400","problems":[{"problemName":"1302.层数最深叶子节点的和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1302.层数最深叶子节点的和.json","problemData":{"id":"1254","name":"1302.层数最深叶子节点的和","url":"https://leetcode.cn/problems/deepest-leaves-sum","desc":"给你一棵二叉树的根节点 root ，请你返回 层数最深的叶子节点的和 。","solutions":[{"date":"2021-05-13","time":124,"memory":48.3,"script":"typescript","desc":"层序遍历。","code":"function deepestLeavesSum(root: TreeNode | null): number {\n  if (root === null) return 0;\n  const queue: TreeNode[] = [root];\n  let size = 1;\n  let ans = root.val;\n  while (queue.length !== 0) {\n    const node = queue.shift()!;\n    node.left && queue.push(node.left);\n    node.right && queue.push(node.right);\n    if (--size === 0) {\n      if (queue.length !== 0) ans = queue.reduce((total, node) => total + node.val, 0);\n      size = queue.length;\n    }\n  }\n  return ans;\n}"},{"date":"2021-05-13","time":116,"memory":48.3,"script":"typescript","desc":"中序遍历。","code":"function deepestLeavesSum(root: TreeNode | null): number {\n  if (root === null) return 0;\n  let maxDep = 1;\n  let ans = root.val;\n  const inorder = (node: TreeNode, dep = 1): void => {\n    if (dep > maxDep) {\n      ans = 0;\n      maxDep = dep;\n    }\n    node.left && inorder(node.left, dep + 1);\n    node.right && inorder(node.right, dep + 1);\n    if (!node.left && !node.right && dep === maxDep) ans += node.val;\n  };\n  inorder(root);\n  return ans;\n}"},{"date":"2022-08-17","time":12,"memory":3,"script":"rust","desc":"层序遍历。","code":"use std::cell::RefCell;\nuse std::collections::VecDeque;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn deepest_leaves_sum(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        let root = root.unwrap();\n        let mut q = VecDeque::<Rc<RefCell<TreeNode>>>::new();\n        q.push_back(root.clone());\n        let mut ans = root.as_ref().borrow().val;\n        let mut cur = 0;\n        let mut size = 1;\n        while !q.is_empty() {\n            let node = q.pop_front().unwrap();\n            let node = node.as_ref().borrow();\n            if node.left.is_some() {\n                cur += node.left.as_ref().unwrap().as_ref().borrow().val;\n                q.push_back(node.left.as_ref().unwrap().clone());\n            }\n            if node.right.is_some() {\n                cur += node.right.as_ref().unwrap().as_ref().borrow().val;\n                q.push_back(node.right.as_ref().unwrap().clone());\n            }\n            size -= 1;\n            if size == 0 {\n                size = q.len();\n                if size != 0 {\n                    ans = cur;\n                }\n                cur = 0;\n            }\n        }\n        ans\n    }\n}"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"1305.两棵二叉搜索树中的所有元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1305.两棵二叉搜索树中的所有元素.json","problemData":{"id":"1427","name":"1305.两棵二叉搜索树中的所有元素","url":"https://leetcode.cn/problems/all-elements-in-two-binary-search-trees","desc":"请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。","solutions":[{"date":"2021-05-13","time":204,"memory":51.6,"script":"typescript","desc":"归并。","code":"function getAllElements(root1: TreeNode | null, root2: TreeNode | null): number[] {\n  const inorder = (node: TreeNode | null, queue: number[]): void => {\n    if (node === null) return;\n    inorder(node.left, queue);\n    queue.push(node.val);\n    inorder(node.right, queue);\n  };\n  const queue1: number[] = [];\n  inorder(root1, queue1);\n  const queue2: number[] = [];\n  inorder(root2, queue2);\n  let p1 = 0;\n  const len1 = queue1.length;\n  let p2 = 0;\n  const len2 = queue2.length;\n  const ans: number[] = [];\n  while (p1 < len1 || p2 < len2) {\n    ans.push(p2 >= len2 || queue1[p1] <= queue2[p2] ? queue1[p1++] : queue2[p2++]);\n  }\n  return ans;\n}"},{"date":"2022-05-01","time":84,"memory":8.4,"script":"go","desc":"dfs。","code":"func getAllElements(root1 *TreeNode, root2 *TreeNode) []int {\n  arr1 := getArr(root1)\n  n1 := len(arr1)\n  arr2 := getArr(root2)\n  n2 := len(arr2)\n  ans := make([]int, n1+n2)\n  var i1, i2 = 0, 0\n  for i := 0; i1 < n1 || i2 < n2; i++ {\n    if i1 != n1 && (i2 == n2 || arr1[i1] < arr2[i2]) {\n      ans[i] = arr1[i1]\n      i1++\n    } else {\n      ans[i] = arr2[i2]\n      i2++\n    }\n  }\n  return ans\n}\nfunc getArr(node *TreeNode) (arr []int) {\n  var dfs func(*TreeNode)\n  dfs = func(node *TreeNode) {\n    if node == nil {\n      return\n    }\n    dfs(node.Left)\n    arr = append(arr, node.Val)\n    dfs(node.Right)\n  }\n  dfs(node)\n  return arr\n}"},{"date":"2022-05-01","time":196,"memory":56.4,"script":"c","desc":"dfs。","code":"int *getAllElements(struct TreeNode *root1, struct TreeNode *root2,\n  int *returnSize) {\n    int n1 = 0, n2 = 0;\n    int *arr1 = (int *)malloc(sizeof(int) * 5005);\n    int *arr2 = (int *)malloc(sizeof(int) * 5005);\n    createArr(arr1, &n1, root1);\n    createArr(arr2, &n2, root2);\n    *returnSize = 0;\n    int *ans = (int *)malloc(sizeof(int) * (n1 + n2));\n    for (int i1 = 0, i2 = 0; i1 < n1 || i2 < n2;) {\n        if (i1 != n1 && (i2 == n2 || arr1[i1] < arr2[i2]))\n            ans[(*returnSize)++] = arr1[i1++];\n        else\n            ans[(*returnSize)++] = arr2[i2++];\n    }\n    free(arr1);\n    free(arr2);\n    return ans;\n}\nvoid createArr(int *arr, int *size, struct TreeNode *node) {\n    if (node == NULL) return;\n    createArr(arr, size, node->left);\n    arr[(*size)++] = node->val;\n    createArr(arr, size, node->right);\n}"}],"tagList":["树","深度优先搜索","二叉搜索树","二叉树","排序"],"level":"Medium"}},{"problemName":"1310.子数组异或查询.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1310.子数组异或查询.json","problemData":{"id":"1435","name":"1310.子数组异或查询","url":"https://leetcode.cn/problems/xor-queries-of-a-subarray","desc":"有一个正整数数组 arr，现给你一个对应的查询数组 queries，其中 queries[i] = [Li, Ri]，返回一个包含给定查询 queries 所有结果的数组。","solutions":[{"date":"2021-05-12","time":1492,"memory":52.9,"script":"typescript","desc":"直接循环异或。","code":"function xorQueries(arr: number[], queries: number[][]): number[] {\n  return queries.map(([start, end]) => {\n    let ans!: number;\n    for (let i = start; i <= end; i++) {\n      if (ans) ans ^= arr[i];\n      else ans = arr[i];\n    }\n    return ans;\n  });\n}"},{"date":"2021-05-12","time":132,"memory":53.2,"script":"typescript","desc":"前缀和。","code":"function xorQueries(arr: number[], queries: number[][]): number[] {\n  let num = arr[0];\n  const prefixSumList: number[] = arr.map((v, i) => (i === 0 ? num : (num ^= v)));\n  return queries.map(([start, end]) => prefixSumList[start - 1] ^ prefixSumList[end]);\n}"},{"date":"2021-11-14","time":124,"memory":52.7,"script":"typescript","desc":"树状数组。","code":"class FenwickTree {\n  private arr: number[];\n  constructor(private n: number) {\n    this.arr = new Array(n + 1).fill(0);\n  }\n  add(idx: number, num: number): void {\n    while (idx <= this.n) {\n      this.arr[idx] += num;\n      idx += this.lowbit(idx);\n    }\n  }\n  at(idx: number): number {\n    return this.query(idx) - this.query(idx - 1);\n  }\n  query(idx: number): number {\n    let sum = 0;\n    while (idx) {\n      sum += this.arr[idx];\n      idx -= this.lowbit(idx);\n    }\n    return sum;\n  }\n  private lowbit(num: number) {\n    return num & -num;\n  }\n}\nclass StreamRank {\n  tree = new FenwickTree(50001);\n  track(x: number): void {\n    this.tree.add(x + 1, 1);\n  }\n  getRankOfNumber(x: number): number {\n    return this.tree.query(x + 1);\n  }\n}"}],"tagList":["位运算","数组","前缀和"],"level":"Medium"}},{"problemName":"1319.连通网络的操作次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1319.连通网络的操作次数.json","problemData":{"id":"1442","name":"1319.连通网络的操作次数","url":"https://leetcode.cn/problems/number-of-operations-to-make-network-connected","desc":"用以太网线缆将  n  台计算机连接成一个网络，计算机的编号从  0  到  n-1。线缆用  connections  表示，其中  connections[i] = [a, b]  连接了计算机  a  和  b。网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。给你这个计算机网络的初始布线  connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回  -1 。","solutions":[{"date":"2021-01-23","time":212,"memory":54.6,"script":"typescript","desc":"并查集。","code":"class UnionFind {\n  elements: number[];\n  constructor(public size: number) {\n    this.elements = new Array(size).fill(0).map((_, i) => i);\n  }\n  same(v1: number, v2: number): boolean {\n    return this.find(v1) === this.find(v2);\n  }\n  find(v: number): number {\n    return v === this.elements[v] ? v : (this.elements[v] = this.find(this.elements[v]));\n  }\n  union(v1: number, v2: number): void {\n    const e1 = this.find(v1);\n    const e2 = this.find(v2);\n    if (e1 !== e2) {\n      this.elements[e1] = e2;\n      this.size--;\n    }\n  }\n}\nfunction makeConnected(n: number, connections: number[][]): number {\n  const uf = new UnionFind(n);\n  let count = 0;\n  for (const [c1, c2] of connections) {\n    if (uf.same(c1, c2)) {\n      count++;\n    } else {\n      uf.union(c1, c2);\n    }\n  }\n  return uf.size - 1 <= count ? uf.size - 1 : -1;\n}"},{"date":"2021-04-30","time":192,"memory":53.8,"script":"typescript","desc":"并查集。","code":"class UnionFind {\n  elements: number[];\n  constructor(public size: number) {\n    this.elements = new Array(size).fill(0).map((_, i) => i);\n  }\n  same(v1: number, v2: number): boolean {\n    return this.find(v1) === this.find(v2);\n  }\n  find(v: number): number {\n    return v === this.elements[v] ? v : (this.elements[v] = this.find(this.elements[v]));\n  }\n  union(v1: number, v2: number): void {\n    const e1 = this.find(v1);\n    const e2 = this.find(v2);\n    if (e1 !== e2) {\n      this.elements[e1] = e2;\n      this.size--;\n    }\n  }\n}\nfunction makeConnected(n: number, connections: number[][]): number {\n  let c = 0;\n  const uf = new UnionFind(n);\n  for (const [comp1, comp2] of connections) {\n    if (uf.same(comp1, comp2)) cpp;\n    else uf.union(comp1, comp2);\n  }\n  return c >= uf.size - 1 ? uf.size - 1 : -1;\n}"}],"tagList":["深度优先搜索","广度优先搜索","并查集","图"],"level":"Medium"}},{"problemName":"1326.灌溉花园的最少水龙头数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1326.灌溉花园的最少水龙头数目.json","problemData":{"id":"1451","name":"1326.灌溉花园的最少水龙头数目","url":"https://leetcode.cn/problems/minimum-number-of-taps-to-open-to-water-a-garden","desc":"请你返回可以灌溉整个花园的 最少水龙头数目 。","solutions":[{"script":"cpp","time":16,"memory":14.3,"desc":"贪心，对每个起点找尽可能远的终点。","code":"class Solution {\npublic:\n    int minTaps(int n, vector<int>& ranges) {\n        vector<int> list(n + 1, -1);\n        for (int i = 0; i < n + 1; i++) {\n            int start = max(i - ranges[i], 0), end = min(i + ranges[i], n);\n            list[start] = max(list[start], end);\n        }\n        int cnt = 0, prev = 0, last = 0;\n        for (int i = 0; i < n; i++) {\n            last = max(last, list[i]);\n            if (last == i) return -1;\n            if (i == prev) cnt++, prev = last;\n        }\n        return cnt;\n    }\n};","date":"2023-02-21"},{"script":"python","time":84,"memory":15.3,"desc":"同上。","code":"class Solution:\n    def minTaps(self, n: int, ranges: List[int]) -> int:\n        l = [-1] * (n + 1)\n        for i in range(len(ranges)):\n            start = max(i - ranges[i], 0)\n            end = min(i + ranges[i], n)\n            l[start] = max(l[start], end)\n        cnt = prev = last = 0\n        for i in range(n):\n            last = max(last, l[i])\n            if last == i:\n                return -1\n            if i == prev:\n                prev = last\n                cnt += 1\n        return cnt","date":"2023-02-21"},{"script":"rust","time":4,"memory":2.4,"desc":"同上。","code":"impl Solution {\n    pub fn min_taps(n: i32, ranges: Vec<i32>) -> i32 {\n        let n = n as usize;\n        let mut l = vec![0; n + 1];\n        for i in 0..ranges.len() {\n            let start = 0.max(i as i32 - ranges[i]) as usize;\n            let end = (n as i32).min(i as i32 + ranges[i]) as usize;\n            l[start] = l[start].max(end);\n        }\n        let (mut res, mut pre, mut last) = (0, 0, 0);\n        for i in 0..n {\n            last = last.max(l[i]);\n            if last == i {\n                return -1;\n            }\n            if i == pre {\n                res += 1;\n                pre = last\n            }\n        }\n        res\n    }\n}","date":"2023-02-21"}],"tagList":["贪心","数组","动态规划"],"level":"Hard"}},{"problemName":"1329.将矩阵按对角线排序.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1329.将矩阵按对角线排序.json","problemData":{"id":"1253","name":"1329.将矩阵按对角线排序","url":"https://leetcode.cn/problems/sort-the-matrix-diagonally","desc":"给你一个 m * n 的整数矩阵 mat ，请你将同一条 矩阵对角线 上的元素按升序排序后，返回排好序的矩阵。","solutions":[{"script":"python","time":50,"memory":16.85,"desc":"遍历。","code":"class Solution:\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\n        n, m = len(mat), len(mat[0])\n        def next(x: int, y: int) -> Tuple[int, int]:\n            return (x + 1, y + 1) if x + 1 < n and y + 1 < m else (-1, -1)\n        def sort(x: int, y : int):\n            arr = []\n            i, j = x, y\n            while i != -1:\n                arr.append(mat[i][j])\n                i, j = next(i, j)\n            arr.sort()\n            i, j = x, y\n            while i != -1:\n                mat[i][j] = arr[i - x]\n                i, j = next(i, j)\n        for j in range(m): sort(0, j)\n        for i in range(1, n): sort(i, 0)\n        return mat","date":"2024-04-29"}],"tagList":["数组","矩阵","排序"],"level":"Medium"}},{"problemName":"1330.翻转子数组得到最大的数组值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1330.翻转子数组得到最大的数组值.json","problemData":{"id":"1255","name":"1330.翻转子数组得到最大的数组值","url":"https://leetcode.cn/problems/reverse-subarray-to-maximize-array-value","desc":"给你一个整数数组 nums 。「数组值」定义为所有满足 0 <= i < nums.length-1 的 |nums[i]-nums[i+1]| 的和。","solutions":[{"script":"cpp","time":84,"memory":39.3,"desc":"https://leetcode.cn/problems/reverse-subarray-to-maximize-array-value/solution/bu-hui-hua-jian-qing-kan-zhe-pythonjavac-c2s6/。","code":"class Solution {\npublic:\n    int maxValueAfterReverse(vector<int>& nums) {\n        int n = nums.size(), sums = 0, nmax = INT_MIN, nmin = INT_MAX, val = 0;\n        for (int i = 1; i < n; i++) {\n            int num = abs(nums[i] - nums[i - 1]);\n            sums += num;\n            nmax = max(nmax, min(nums[i], nums[i - 1]));\n            nmin = min(nmin, max(nums[i], nums[i - 1]));\n            val = max(val, max(abs(nums[i] - nums[0]), abs(nums[i - 1] - nums[n - 1])) - num);\n        }\n        return sums + max(val, 2 * (nmax - nmin));\n    }\n};","date":"2023-05-12"},{"script":"python","time":328,"memory":19.6,"desc":"同上。","code":"class Solution:\ndef maxValueAfterReverse(self, nums: List[int]) -> int:\n    n = len(nums)\n    sums = 0\n    nmax = -inf\n    nmin = inf\n    val = 0\n    for i in range(1, n):\n        num = abs(nums[i] - nums[i - 1])\n        sums += num\n        nmax = max(nmax, min(nums[i], nums[i - 1]))\n        nmin = min(nmin, max(nums[i], nums[i - 1]))\n        val = max(val, max(abs(nums[i] - nums[0]), abs(nums[i - 1] - nums[n - 1])) - num)\n    return sums + max(val, 2 * (nmax - nmin))","date":"2023-05-12"},{"script":"rust","time":8,"memory":2.3,"desc":"同上。","code":"impl Solution {\n    pub fn max_value_after_reverse(nums: Vec<i32>) -> i32 {\n        use std::cmp::{max, min};\n        let n = nums.len();\n        let mut sums = 0;\n        let mut nmax = i32::MIN;\n        let mut nmin = i32::MAX;\n        let mut val = 0;\n        for i in 1..n {\n            let num = (nums[i] - nums[i - 1]).abs();\n            sums += num;\n            nmax = max(nmax, min(nums[i], nums[i - 1]));\n            nmin = min(nmin, max(nums[i], nums[i - 1]));\n            val = max(\n                val,\n                max((nums[i] - nums[0]).abs(), (nums[i - 1] - nums[n - 1]).abs()) - num,\n            );\n        }\n        sums + max(val, 2 * (nmax - nmin))\n    }\n}","date":"2023-05-12"}],"tagList":["贪心","数组","数学"],"level":"Hard"}},{"problemName":"1331.数组序号转换.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1331.数组序号转换.json","problemData":{"id":"1256","name":"1331.数组序号转换","url":"https://leetcode.cn/problems/rank-transform-of-an-array","desc":"给你一个整数数组 arr ，请你将数组中的每个元素替换为它们排序后的序号。","solutions":[{"date":"2022-07-28","time":32,"memory":5.5,"script":"rust","desc":"存到 map。","code":"use std::collections::HashMap;\nimpl Solution {\n    pub fn array_rank_transform(arr: Vec<i32>) -> Vec<i32> {\n        let n = arr.len();\n        let mut ilist = Vec::with_capacity(n);\n        for i in 0..n {\n            ilist.push(i)\n        }\n        ilist.sort_by(|a, b| arr[*a].cmp(&arr[*b]));\n        let mut map = HashMap::<i32, i32>::new();\n        let mut idx = 1;\n        for i in 0..n {\n            if i == 0 {\n                map.insert(arr[ilist[i]], idx);\n            } else if arr[ilist[i - 1]] == arr[ilist[i]] {\n                continue;\n            } else {\n                idx += 1;\n                map.insert(arr[ilist[i]], idx);\n            }\n        }\n        arr\n            .iter()\n            .map(|num|*map.get(&num).unwrap())\n            .collect()\n    }\n}"}],"tagList":["数组","哈希表","排序"],"level":"Easy"}},{"problemName":"1332.删除回文子序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1332.删除回文子序列.json","problemData":{"id":"1454","name":"1332.删除回文子序列","url":"https://leetcode.cn/problems/remove-palindromic-subsequences","desc":"返回删除给定字符串中所有字符（字符串为空）的最小删除次数。","solutions":[{"date":"2022-01-22","time":0,"memory":6.1,"script":"cpp","desc":"考虑是回文子序列，并非连续，且只有两种字母。","code":"class Solution {\n   public:\n    int removePalindromeSub(string s) {\n        for (int start = 0, end = s.size() - 1; start <= end; start++, end--) {\n            if (s[start] != s[end]) return 2;\n        }\n        return 1;\n    }\n};"}],"tagList":["双指针","字符串"],"level":"Easy"}},{"problemName":"1334.阈值距离内邻居最少的城市.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1334.阈值距离内邻居最少的城市.json","problemData":{"id":"1456","name":"1334.阈值距离内邻居最少的城市","url":"https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance","desc":"有 n 个城市，按从 0 到 n-1 编号。给你一个边数组 edges，其中 edges[i] = [fromi, toi, weighti] 代表 fromi 和 toi 两个城市之间的双向加权边，距离阈值是一个整数 distanceThreshold。返回能通过某些路径到达其他城市数目最少、且路径距离 最大 为 distanceThreshold 的城市。如果有多个这样的城市，则返回编号最大的城市。","solutions":[{"script":"python","time":560,"memory":16.87,"desc":"佛洛依德短路算法。","code":"class Solution:\n    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:\n        d = [[inf] * n for _ in range(n)]\n        for i in range(n): d[i][i] = 0\n        for edge in edges:\n            d[edge[0]][edge[1]] = edge[2]\n            d[edge[1]][edge[0]] = edge[2]\n        for k in range(n):\n            for i in range(n):\n                for j in range(n):\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j])\n\n        ans = 0\n        cnt = inf\n        for i in range(n):\n            cur = len(list(filter(lambda o: o <= distanceThreshold, d[i]))) - 1\n            if cur <= cnt:\n                ans = i\n                cnt = cur\n        return ans","date":"2023-11-14"},{"script":"python","time":268,"memory":17,"desc":"迪杰特斯拉短路算法。","code":"class Solution:\n    def findTheCity(self, n: int, edges: List[List[int]], distanceThreshold: int) -> int:\n        nodes = [[] for _ in range(n)]\n        for edge in edges:\n            nodes[edge[0]].append((edge[1], edge[2]))\n            nodes[edge[1]].append((edge[0], edge[2]))\n        ans = 0\n        cnt = inf\n        for i in range(n):\n            q = [(0, i)]\n            used = [False] * n\n            cur = -1\n            while q:\n                d, node = heappop(q)\n                if used[node]: continue\n                used[node] = True\n                cur += 1\n                for next_node, next_d in nodes[node]:\n                    if not used[next_node] and d + next_d <= distanceThreshold:\n                        heappush(q, (d + next_d, next_node))\n            if cur <= cnt:\n                cnt = cur\n                ans = i\n        return ans","date":"2023-11-14"}],"tagList":["图","动态规划","最短路"],"level":"Medium"}},{"problemName":"1335.工作计划的最低难度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1335.工作计划的最低难度.json","problemData":{"id":"1457","name":"1335.工作计划的最低难度","url":"https://leetcode.cn/problems/minimum-difficulty-of-a-job-schedule","desc":"返回整个工作计划的 最小难度 。如果无法制定工作计划，则返回 -1 。","solutions":[{"script":"cpp","time":52,"memory":7.4,"desc":"dp[i][j]表示只有i天时，只有j个job时的最小难度。","code":"class Solution {\npublic:\n    int minDifficulty(vector<int>& jobDifficulty, int d) {\n        int n = jobDifficulty.size(), num = 0;\n        if (n < d) return -1;\n        vector<vector<int>> dp(d, vector<int>(n, INT_MAX));\n        for (int i = 0; i < n; i++) dp[0][i] = num = max(num, jobDifficulty[i]);\n        for (int dd = 1; dd < d; dd++) {\n            for (int i = dd; i < n; i++) {\n                num = 0;\n                for (int j = i; j >= dd; j--) {\n                    num = max(num, jobDifficulty[j]);\n                    dp[dd][i] = min(dp[dd][i], dp[dd - 1][j - 1] + num);\n                }\n            }\n        }\n        return dp[d - 1][n - 1];\n    }\n};","date":"2023-05-16"},{"script":"python","time":892,"memory":16.2,"desc":"同上。","code":"class Solution:\n    def minDifficulty(self, jobDifficulty: List[int], d: int) -> int:\n        n = len(jobDifficulty)\n        if n < d:\n            return -1\n        num = 0\n        dp = [[inf for _ in range(n)] for _ in range(d)]\n        for i in range(n):\n            dp[0][i] = num = max(num, jobDifficulty[i])\n        for dd in range(1, d):\n            for i in range(dd, n):\n                num = 0\n                for j in range(i, dd - 1, -1):\n                    num = max(num, jobDifficulty[j])\n                    dp[dd][i] = min(dp[dd][i], dp[dd - 1][j - 1] + num)\n        return dp[d - 1][n - 1]","date":"2023-05-16"},{"script":"rust","time":4,"memory":2.1,"desc":"同上。","code":"impl Solution {\n    pub fn min_difficulty(job_difficulty: Vec<i32>, d: i32) -> i32 {\n        let d = d as usize;\n        let n = job_difficulty.len();\n        if n < d {\n            -1\n        } else {\n            let mut num = 0;\n            let mut dp = vec![vec![i32::MAX; n]; d];\n            for i in 0..n {\n                num = num.max(job_difficulty[i]);\n                dp[0][i] = num;\n            }\n            for dd in 1..d {\n                for i in dd..n {\n                    num = 0;\n                    for j in (dd..=i).rev() {\n                        num = num.max(job_difficulty[j]);\n                        dp[dd][i] = dp[dd][i].min(dp[dd - 1][j - 1] + num);\n                    }\n                }\n            }\n            dp[d - 1][n - 1]\n        }\n    }\n}\n","date":"2023-05-16"}],"tagList":["数组","动态规划"],"level":"Hard"}},{"problemName":"1337.矩阵中战斗力最弱的K行.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1337.矩阵中战斗力最弱的K行.json","problemData":{"id":"1463","name":"1337.矩阵中战斗力最弱的K行","url":"https://leetcode.cn/problems/the-k-weakest-rows-in-a-matrix","desc":"给你一个大小为  m \\* n  的矩阵  mat，矩阵由若干军人和平民组成，分别用 1 和 0 表示。请你返回矩阵中战斗力最弱的  k  行的索引，按从最弱到最强排序。","solutions":[{"date":"2021-08-01","time":76,"memory":39.9,"script":"typescript","desc":"哈希储存。","code":"function kWeakestRows(mat: number[][], k: number): number[] {\n  return mat\n    .map((list, i) => {\n      const ans: [number, number] = [i, 0];\n      for (const n of list) {\n        if (n === 1) ans[1]++;\n        else break;\n      }\n      return ans;\n    })\n    .sort(([i1, v1], [i2, v2]) => (v1 === v2 ? i1 - i2 : v1 - v2))\n    .map(([i]) => i)\n    .slice(0, k);\n}"},{"date":"2021-08-01","time":108,"memory":42.1,"script":"typescript","desc":"哈希储存+二分查找。","code":"function kWeakestRows(mat: number[][], k: number): number[] {\n  return mat\n    .map((list, i) => [i, find(list)])\n    .map(v => {\n      console.log(v);\n      return v;\n    })\n    .sort(([i1, v1], [i2, v2]) => (v1 === v2 ? i1 - i2 : v1 - v2))\n    .map(([i]) => i)\n    .slice(0, k);\n  function find(list: number[]): number {\n    let l = 0;\n    let r = list.length - 1;\n    while (l < r) {\n      const mid = (l + r) >> 1;\n      if (list[mid] === 0) r = mid;\n      else l = mid + 1;\n    }\n    if (list[l] === 1) return list.length;\n    return l;\n  }\n}"}],"tagList":["数组","二分查找","矩阵","排序","堆（优先队列）"],"level":"Easy"}},{"problemName":"1339.分裂二叉树的最大乘积.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1339.分裂二叉树的最大乘积.json","problemData":{"id":"1465","name":"1339.分裂二叉树的最大乘积","url":"https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree","desc":"给你一棵二叉树，它的根为 root 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。 。","solutions":[{"date":"2021-08-14","time":184,"memory":63.9,"script":"typescript","desc":"寻找最接近 sum/2 的值。","code":"function maxProduct(root: TreeNode): number {\n  const map = new Map<TreeNode, number>();\n  const sum = dfsSum(root);\n  let ans = 0;\n  dfsNode(root);\n  return ((sum - ans) * ans) % (10 ** 9 + 7);\n  function dfsSum(node: TreeNode | null): number {\n    if (node === null) return 0;\n    const sum = dfsSum(node.left) + dfsSum(node.right) + node.val;\n    map.set(node, sum);\n    return sum;\n  }\n  function dfsNode(node: TreeNode | null): void {\n    if (node === null) return;\n    if (Math.abs(sum / 2 - ans) > Math.abs(sum / 2 - map.get(node!)!)) {\n      ans = map.get(node!)!;\n    }\n    dfsNode(node.left);\n    dfsNode(node.right);\n  }\n}"}],"tagList":["树","深度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"1342.将数字变成0的操作次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1342.将数字变成0的操作次数.json","problemData":{"id":"1444","name":"1342.将数字变成0的操作次数","url":"https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-to-zero","desc":"给你一个非负整数 num ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。","solutions":[{"date":"2022-01-31","time":0,"memory":5.9,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    int numberOfSteps(int num) {\n        int ans = 0;\n        while (num) {\n            num = num & 1 ? num - 1 : num / 2;\n            ++ans;\n        }\n        return ans;\n    }\n};"}],"tagList":["位运算","数学"],"level":"Easy"}},{"problemName":"1345.跳跃游戏IV.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1345.跳跃游戏IV.json","problemData":{"id":"1447","name":"1345.跳跃游戏IV","url":"https://leetcode.cn/problems/jump-game-iv","desc":"请你返回到达数组最后一个元素的下标处所需的 最少操作次数 。","solutions":[{"date":"2022-01-21","time":248,"memory":95.7,"script":"cpp","desc":"bfs。","code":"class Solution {\n   public:\n    struct node {\n        int idx, step;\n    };\n    int minJumps(vector<int>& arr) {\n        unordered_map<int, vector<int>> m;\n        unordered_set<int> s;\n        s.insert(0);\n        queue<node> q;\n        q.push((node){0, 0});\n        int n = arr.size();\n        for (int i = 0; i < n; i++) m[arr[i]].push_back(i);\n        while (q.size()) {\n            node v = q.front();\n            if (v.idx == n - 1) return v.step;\n            q.pop();\n            if (v.idx > 0 && !s.count(v.idx - 1)) {\n                q.push((node){v.idx - 1, v.step + 1});\n                s.insert(v.idx - 1);\n            }\n            if (v.idx < n - 1 && !s.count(v.idx + 1)) {\n                q.push((node){v.idx + 1, v.step + 1});\n                s.insert(v.idx + 1);\n            }\n            if (!m.count(arr[v.idx])) continue;\n            for (auto& next_idx : m[arr[v.idx]]) {\n                if (next_idx == v.idx || s.count(next_idx)) continue;\n                q.push((node){next_idx, v.step + 1});\n                s.insert(next_idx);\n            }\n            m.erase(arr[v.idx]);\n        }\n        return 0;\n    }\n};"}],"tagList":["广度优先搜索","数组","哈希表"],"level":"Hard"}},{"problemName":"1349.参加考试的最大学生数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1349.参加考试的最大学生数.json","problemData":{"id":"1471","name":"1349.参加考试的最大学生数","url":"https://leetcode.cn/problems/maximum-students-taking-exam","desc":"请你计算并返回该考场可以容纳的同时参加考试且无法作弊的 最大 学生人数。","solutions":[{"script":"rust","time":4,"memory":2.05,"desc":"状态压缩，动态规划每一层的所有状态。","code":"use std::collections::HashMap;\nfn is1(num: usize, offset: usize) -> bool {\n    return (num & (1 << offset)) != 0;\n}\nfn check1(seats: &Vec<Vec<char>>, row: usize, used: usize) -> bool {\n    let mut prev = false;\n    for col in 0..seats[0].len() {\n        if is1(used, col) {\n            if prev || seats[row][col] == '#' {\n                return false;\n            }\n            prev = true;\n        } else {\n            prev = false;\n        }\n    }\n    true\n}\nfn check2(seats: &Vec<Vec<char>>, used: usize, pre_used: usize) -> bool {\n    for col in 0..seats[0].len() {\n        if is1(used, col)\n            && (col - 1 >= 0 && is1(pre_used, col - 1)\n                || col + 1 < seats[0].len() && is1(pre_used, col + 1))\n        {\n            return false;\n        }\n    }\n    true\n}\nfn dfs(\n    seats: &Vec<Vec<char>>,\n    cache: &mut HashMap<usize, HashMap<usize, i32>>,\n    pre_used: usize,\n    row: usize,\n) -> i32 {\n    if row < seats.len() {\n        if let Some(Some(res)) = cache.get(&row).map(|item| item.get(&pre_used)) {\n            *res\n        } else {\n            let res = (0..(1 << seats[0].len()))\n                .map(|used| {\n                    if check1(seats, row, used) && check2(seats, used, pre_used) {\n                        used.count_ones() as i32 + dfs(seats, cache, used, row + 1)\n                    } else {\n                        0\n                    }\n                })\n                .max()\n                .unwrap();\n            cache.entry(row).or_default().entry(pre_used).or_insert(res);\n            res\n        }\n    } else {\n        0\n    }\n}\nimpl Solution {\n    pub fn max_students(seats: Vec<Vec<char>>) -> i32 {\n        let mut cache = HashMap::new();\n        (0..(1 << seats[0].len()))\n            .map(|used| {\n                if check1(&seats, 0, used) {\n                    used.count_ones() as i32 + dfs(&seats, &mut cache, used, 1)\n                } else {\n                    0\n                }\n            })\n            .max()\n            .unwrap()\n    }\n}","date":"2023-12-26"}],"tagList":["位运算","数组","动态规划","状态压缩","矩阵"],"level":"Hard"}},{"problemName":"1356.根据数字二进制下1的数目排序.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1356.根据数字二进制下1的数目排序.json","problemData":{"id":"1458","name":"1356.根据数字二进制下1的数目排序","url":"https://leetcode.cn/problems/sort-integers-by-the-number-of-1-bits","desc":"给你一个整数数组 arr 。请你将数组中的元素按照其二进制表示中数字 1 的数目升序排序。","solutions":[{"date":"2020-11-06","time":244,"memory":44.3,"script":"typescript","desc":"利用 toString 转换成二进制进行计算。","code":"function sortByBits(arr: number[]): number[] {\n  const count = (num: number): number =>\n    num\n      .toString(2)\n      .split('')\n      .reduce((total, cur) => total + Number(cur), 0);\n  return arr.sort((a, b) => {\n    const c1 = count(a);\n    const c2 = count(b);\n    return c1 === c2 ? a - b : c1 - c2;\n  });\n}"},{"date":"2020-11-06","time":104,"memory":40.7,"script":"typescript","desc":"利用位运算计算二进制 1 个数。","code":"function sortByBits(arr: number[]): number[] {\n  const count = (num: number): number => {\n    let ans = 0;\n    while (num) {\n      num &= num - 1;\n      ans++;\n    }\n    return ans;\n  };\n  return arr.sort((a, b) => {\n    const c1 = count(a);\n    const c2 = count(b);\n    return c1 === c2 ? a - b : c1 - c2;\n  });\n}"}],"tagList":["位运算","数组","计数","排序"],"level":"Easy"}},{"problemName":"1359.有效的快递序列数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1359.有效的快递序列数目.json","problemData":{"id":"1461","name":"1359.有效的快递序列数目","url":"https://leetcode.cn/problems/count-all-valid-pickup-and-delivery-options","desc":"请你统计所有有效的 收件/配送 序列的数目，确保第 i 个物品的配送服务 delivery(i) 总是在其收件服务 pickup(i) 之后。","solutions":[{"date":"2021-12-11","time":76,"memory":39.4,"script":"typescript","desc":"动态规划，每次多一个快递，就计算新快递可能放置的数量。","code":"const mod = 1e9 + 7;\nfunction sum(n: number) {\n  return ((1 + n) * n) / 2;\n}\nfunction countOrders(n: number): number {\n  const dp = new Array(n).fill(0);\n  dp[0] = 1;\n  for (let i = 1; i < n; i++) {\n    const num = 1 + 2 * i;\n    dp[i] = (dp[i - 1] * sum(num)) % mod;\n  }\n  return dp[n - 1];\n}"},{"date":"2021-12-11","time":76,"memory":39.7,"script":"typescript","desc":"优化上一题解。","code":"const mod = 1e9 + 7;\nfunction sum(n: number) {\n  return ((1 + n) * n) / 2;\n}\nfunction countOrders(n: number): number {\n  let ans = 1;\n  for (let i = 2; i <= n; i++) ans = (ans * sum(1 + 2 * (i - 1))) % mod;\n  return ans;\n}"}],"tagList":["数学","动态规划","组合数学"],"level":"Hard"}},{"problemName":"1365.有多少小于当前数字的数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1365.有多少小于当前数字的数字.json","problemData":{"id":"1482","name":"1365.有多少小于当前数字的数字","url":"https://leetcode.cn/problems/how-many-numbers-are-smaller-than-the-current-number","desc":"给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。","solutions":[{"date":"2020-10-26","time":120,"memory":40.6,"script":"typescript","desc":"对于每一个数进行重复统计。","code":"function smallerNumbersThanCurrent(nums: number[]): number[] {\n  const ans: number[] = [];\n  for (let i = 0, l = nums.length; i < l; i++) {\n    ans[i] = count(i);\n  }\n  return ans;\n  function count(i: number) {\n    const num = nums[i];\n    let c = 0;\n    nums.forEach(v => {\n      if (v < num) cpp;\n    });\n    return c;\n  }\n}"},{"date":"2020-10-26","time":100,"memory":41,"script":"typescript","desc":"对于每个出现的数进行计数后累加。","code":"function smallerNumbersThanCurrent(nums: number[]): number[] {\n  const arr = new Array(101).fill(0);\n  const len = nums.length;\n  for (let i = 0; i < len; i++) arr[nums[i]] += 1;\n  for (let i = 1; i < 100; i++) arr[i] += arr[i - 1];\n  const ans: number[] = [];\n  for (let i = 0; i < len; i++) ans.push(nums[i] ? arr[nums[i] - 1] : 0);\n  return ans;\n}"}],"tagList":["数组","哈希表","计数","排序"],"level":"Easy"}},{"problemName":"1367.二叉树中的链表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1367.二叉树中的链表.json","problemData":{"id":"1484","name":"1367.二叉树中的链表","url":"https://leetcode.cn/problems/linked-list-in-binary-tree","desc":"给你一棵以  root  为根的二叉树和一个  head  为第一个节点的链表。如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以  head  为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。","solutions":[{"date":"2021-07-29","time":84,"memory":45,"script":"typescript","desc":"dfs 递归遍历。","code":"function isSubPath(head: ListNode | null, root: TreeNode | null): boolean {\n  if (head === null) return true;\n  if (root === null) return false;\n  if (head.val === root.val && find(head, root)) return true;\n  return isSubPath(head, root.left) || isSubPath(head, root.right);\n  function find(head: ListNode | null, root: TreeNode | null): boolean {\n    if (head === null) return true;\n    if (root === null) return false;\n    if (head.val !== root.val) return false;\n    return find(head.next, root.left) || find(head.next, root.right);\n  }\n}"}],"tagList":["树","深度优先搜索","广度优先搜索","链表","二叉树"],"level":"Medium"}},{"problemName":"1370.上升下降字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1370.上升下降字符串.json","problemData":{"id":"1472","name":"1370.上升下降字符串","url":"https://leetcode.cn/problems/increasing-decreasing-string","desc":"给你一个字符串 s ，请你根据下面的算法重新构造字符串，请你返回将 s 中字符重新排序后的 结果字符串 。","solutions":[{"date":"2020-11-25","time":124,"memory":45.1,"script":"typescript","desc":"利用 while 进行永动。","code":"function sortString(s: string): string {\n  let len = s.length;\n  const cache: Record<string, number> = {};\n  const setCache = (c: string) => {\n    cache[c] = 1 + (cache[c] ? cache[c] : 0);\n  };\n  for (const c of s) setCache(c);\n  const arr = Object.entries(cache).sort(([c1], [c2]) => c1.codePointAt(0)! - c2.codePointAt(0)!);\n  let i = -1;\n  let ans = '';\n  const compute = () => {\n    ans += arr[i][0];\n    arr[i][1]--;\n    len--;\n  };\n  while (len !== 0) {\n    while (len !== 0) {\n      i++;\n      if (i === arr.length) break;\n      if (arr[i][1] === 0) continue;\n      compute();\n    }\n    while (len !== 0) {\n      i--;\n      if (i === -1) break;\n      if (arr[i][1] === 0) continue;\n      compute();\n    }\n  }\n  return ans;\n}"}],"tagList":["哈希表","字符串","计数"],"level":"Easy"}},{"problemName":"1371.每个元音包含偶数次的最长子字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1371.每个元音包含偶数次的最长子字符串.json","problemData":{"id":"1473","name":"1371.每个元音包含偶数次的最长子字符串","url":"https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts","desc":"给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。","solutions":[{"date":"2020-05-20","time":120,"memory":40,"script":"javascript","desc":"利用奇数-奇数=偶数，偶数-偶数=奇数进行前缀和的判断局部字符串，再利用位运算压缩字符串数量。","code":"/**\n * @param {string} s\n * @return {number}\n */\nvar findTheLongestSubstring = function (s) {\n  const len = s.length;\n  const pos = new Array(1 << 5).fill(-1);\n  const statusCache = {\n    a: 1 << 0,\n    e: 1 << 1,\n    i: 1 << 2,\n    o: 1 << 3,\n    u: 1 << 4,\n  };\n  let ans = 0,\n    status = 0;\n  pos[0] = 0;\n  for (let i = 0; i < len; ++i) {\n    const c = s[i];\n    status = statusCache[c] ? statusCache[c] ^ status : status;\n    if (~pos[status]) ans = Math.max(ans, i + 1 - pos[status]);\n    else pos[status] = i + 1;\n  }\n  return ans;\n};"}],"tagList":["位运算","哈希表","字符串","前缀和"],"level":"Medium"}},{"problemName":"1373.二叉搜索子树的最大键值和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1373.二叉搜索子树的最大键值和.json","problemData":{"id":"1475","name":"1373.二叉搜索子树的最大键值和","url":"https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree","desc":"给你一棵以 root 为根的 二叉树 ，请你返回 任意 二叉搜索子树的最大键值和。","solutions":[{"script":"cpp","time":128,"memory":110.6,"desc":"遍历左右子树的同时记录最大值，最小值和总和。","code":"struct Node {\n    int l, r, sum;\n    Node(int l, int r, int sum): l(l), r(r), sum(sum) {}\n};\n\nclass Solution {\npublic:\n    int maxSumBST(TreeNode* root) {\n        int res = 0;\n        Node no(INT_MIN, -1, -1);\n        function<Node(TreeNode*)> dfs = [&](TreeNode *node) -> Node {\n            if (!node) return no;\n            int val = node->val;\n            auto lv = dfs(node->left), rv = dfs(node->right);\n            if (node->left == nullptr && node->right == nullptr) {\n                res = max(res, val);\n                return Node(val, val, val);\n            } else if (node->left == nullptr) {\n                if (rv.l == no.l) return no;\n                if (val >= rv.l) return no;\n                rv.l = val;\n                rv.sum += val;\n                res = max(res, rv.sum);\n                return rv;\n            } else if (node->right == nullptr) {\n                if (lv.l == no.l) return no;\n                if (lv.r >= val) return no;\n                lv.r = val;\n                lv.sum += val;\n                res = max(res, lv.sum);\n                return lv;\n            } else {\n                if (lv.l == no.l || rv.l == no.l) return no;\n                if (lv.r >= val) return no;\n                if (val >= rv.l) return no;\n                Node next(lv.l, rv.r, lv.sum + rv.sum + val);\n                res = max(res, next.sum);\n                return next;\n            }\n        };\n        dfs(root);\n        return res;\n    }\n};","date":"2023-05-20"},{"script":"python","time":304,"memory":65.5,"desc":"同上。","code":"class Node:\n    def __init__(self, l: int, r: int, sum: int):\n        self.l = l\n        self.r = r\n        self.sum = sum\n\n\nclass Solution:\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\n        res = 0\n        no = Node(-inf, -1, -1)\n\n        def dfs(node: Optional[TreeNode]) -> Node:\n            nonlocal res\n            if not node:\n                return no\n            val = node.val\n            lv, rv = dfs(node.left), dfs(node.right)\n            if node.left == None and node.right == None:\n                res = max(res, val)\n                return Node(val, val, val)\n            elif node.left == None:\n                if rv.l == no.l:\n                    return no\n                if val >= rv.l:\n                    return no\n                rv.l = val\n                rv.sum += val\n                res = max(res, rv.sum)\n                return rv\n            elif node.right == None:\n                if lv.l == no.l:\n                    return no\n                if lv.r >= val:\n                    return no\n                lv.r = val\n                lv.sum += val\n                res = max(res, lv.sum)\n                return lv\n            else:\n                if lv.l == no.l or rv.l == no.l:\n                    return no\n                if lv.r >= val:\n                    return no\n                if val >= rv.l:\n                    return no\n                next = Node(lv.l, rv.r, lv.sum + rv.sum + val)\n                res = max(res, next.sum)\n                return next\n        dfs(root)\n        return res","date":"2023-05-20"},{"script":"rust","time":24,"memory":9.8,"desc":"同上。","code":"static NoVal: i32 = i32::MIN;\n#[derive(Debug, Clone)]\nstruct Node {\n    l: i32,\n    r: i32,\n    sum: i32,\n}\nimpl Node {\n    fn new(l: i32, r: i32, sum: i32) -> Node {\n        Node { l, r, sum }\n    }\n    fn no() -> Node {\n        Node {\n            l: NoVal,\n            r: 0,\n            sum: 0,\n        }\n    }\n}\nuse std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn max_sum_bst(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        let mut res = 0;\n        dfs(&mut res, &root);\n        res\n    }\n}\nfn dfs(res: &mut i32, node: &Option<Rc<RefCell<TreeNode>>>) -> Node {\n    match node {\n        Some(node) => {\n            let nodeRef = node.as_ref().borrow();\n            let val = nodeRef.val;\n            let (mut lv, mut rv) = (dfs(res, &nodeRef.left), dfs(res, &nodeRef.right));\n            if nodeRef.left.is_none() && nodeRef.right.is_none() {\n                *res = (*res).max(val);\n                Node::new(val, val, val)\n            } else if nodeRef.left.is_none() {\n                if rv.l == NoVal {\n                    Node::no()\n                } else if val >= rv.l {\n                    Node::no()\n                } else {\n                    rv.l = val;\n                    rv.sum += val;\n                    *res = (*res).max(rv.sum);\n                    rv\n                }\n            } else if nodeRef.right.is_none() {\n                if lv.l == NoVal {\n                    Node::no()\n                } else if lv.r >= val {\n                    Node::no()\n                } else {\n                    lv.r = val;\n                    lv.sum += val;\n                    *res = (*res).max(lv.sum);\n                    lv\n                }\n            } else {\n                if lv.l == NoVal || rv.l == NoVal {\n                    Node::no()\n                } else if lv.r >= val {\n                    Node::no()\n                } else if val >= rv.l {\n                    Node::no()\n                } else {\n                    let next = Node::new(lv.l, rv.r, lv.sum + rv.sum + val);\n                    *res = (*res).max(next.sum);\n                    next\n                }\n            }\n        }\n        None => Node::no(),\n    }\n}","date":"2023-05-20"}],"tagList":["树","深度优先搜索","二叉搜索树","动态规划","二叉树"],"level":"Hard"}},{"problemName":"1374.生成每种字符都是奇数个的字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1374.生成每种字符都是奇数个的字符串.json","problemData":{"id":"1490","name":"1374.生成每种字符都是奇数个的字符串","url":"https://leetcode.cn/problems/generate-a-string-with-characters-that-have-odd-counts","desc":"给你一个整数 n，请你返回一个含 n 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次 。","solutions":[{"date":"2022-08-01","time":0,"memory":6,"script":"cpp","desc":"直接判断奇偶。","code":"class Solution {\n        public:\n         string generateTheString(int n) {\n             string ans = \"\";\n             if ((n & 1) == 0) {\n                 ans += 'b';\n                 n--;\n             }\n             for (int i = 0; i < n; i++) ans += 'a';\n             return ans;\n         }\n     };"},{"date":"2022-08-01","time":0,"memory":2,"script":"rust","desc":"直接判断奇偶。","code":"impl Solution {\n    pub fn generate_the_string(n: i32) -> String {\n        let mut n = n;\n        let mut ans = String::new();\n        if n & 1 == 0 {\n            ans.push('b');\n            n -= 1;\n        }\n        ans.push_str(&\"a\".repeat(n as usize));\n        ans\n    }\n}"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"1375.二进制字符串前缀一致的次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1375.二进制字符串前缀一致的次数.json","problemData":{"id":"1491","name":"1375.二进制字符串前缀一致的次数","url":"https://leetcode.cn/problems/number-of-times-binary-string-is-prefix-aligned","desc":"返回二进制字符串在翻转过程中 前缀一致 的次数。","solutions":[{"script":"cpp","time":40,"memory":37.6,"desc":"遍历，记录当前反转的最大值。","code":"class Solution {\npublic:\n    int numTimesAllBlue(vector<int>& flips) {\n        int nmax = 0, res = 0;\n        for (int i = 0; i < flips.size(); i++) {\n            nmax = max(nmax, flips[i]);\n            if (nmax == i + 1) res++;\n        }\n        return res;\n    }\n};","date":"2023-06-14"},{"script":"python","time":80,"memory":21.4,"desc":"同上。","code":"class Solution:\n    def numTimesAllBlue(self, flips: List[int]) -> int:\n        nmax = res = 0\n        for i in range(len(flips)):\n            nmax = max(nmax, flips[i])\n            if nmax == i + 1: res += 1\n        return res","date":"2023-06-14"},{"script":"rust","time":4,"memory":2.3,"desc":"同上。","code":"impl Solution {\n    pub fn num_times_all_blue(flips: Vec<i32>) -> i32 {\n        let (mut nmax, mut res) = (0, 0);\n        for i in 0..flips.len() {\n            nmax = nmax.max(flips[i]);\n            if nmax as usize == i + 1 {\n                res += 1\n            }\n        }\n        res\n    }\n}","date":"2023-06-14"}],"tagList":["数组"],"level":"Medium"}},{"problemName":"1376.通知所有员工所需的时间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1376.通知所有员工所需的时间.json","problemData":{"id":"1492","name":"1376.通知所有员工所需的时间","url":"https://leetcode.cn/problems/time-needed-to-inform-all-employees","desc":"返回通知所有员工这一紧急消息所需要的 分钟数 。","solutions":[{"script":"cpp","time":248,"memory":119.4,"desc":"dfs。","code":"class Solution {\npublic:\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\n        vector<vector<int>> list(n);\n        for (int i = 0; i < n; i++)\n            if (manager[i] != -1) list[manager[i]].push_back(i);\n        function<int(int)> dfs = [&](int cur) -> int {\n            int sum = 0;\n            for (auto &next : list[cur]) sum = max(sum, dfs(next));\n            return informTime[cur] + sum;\n        };\n        return dfs(headID);\n    }\n};","date":"2023-05-01"},{"script":"python","time":392,"memory":43.5,"desc":"同上。","code":"class Solution:\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\n        list = [[] for _ in range(n)]\n        for i in range(n):\n            if manager[i] != -1:\n                list[manager[i]].append(i)\n\n        def dfs(cur: int) -> int:\n            sum = 0\n            for next in list[cur]:\n                sum = max(sum, dfs(next))\n            return informTime[cur] + sum\n        return dfs(headID)","date":"2023-05-01"},{"script":"rust","time":48,"memory":8.2,"desc":"同上。","code":"impl Solution {\npub fn num_of_minutes(n: i32, head_id: i32, manager: Vec<i32>, inform_time: Vec<i32>) -> i32 {\n    let n = n as usize;\n    let mut list = vec![vec![]; n];\n    for i in 0..n {\n        if manager[i] != -1 {\n            list[manager[i] as usize].push(i);\n        }\n    }\n    fn dfs(list: &Vec<Vec<usize>>, inform_time: &Vec<i32>, cur: usize) -> i32 {\n        inform_time[cur]\n            + list[cur]\n                .iter()\n                .map(|v| dfs(list, inform_time, *v))\n                .max()\n                .unwrap_or_default()\n    }\n    dfs(&list, &inform_time, head_id as usize)\n}\n}","date":"2023-05-01"}],"tagList":["树","深度优先搜索","广度优先搜索"],"level":"Medium"}},{"problemName":"1377.T秒后青蛙的位置.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1377.T秒后青蛙的位置.json","problemData":{"id":"1493","name":"1377.T秒后青蛙的位置","url":"https://leetcode.cn/problems/frog-position-after-t-seconds","desc":"返回青蛙在 t 秒后位于目标顶点 target 上的概率。","solutions":[{"script":"cpp","time":24,"memory":14.5,"desc":"dfs遍历，因为每个点之间都连通，判断当青蛙到目标点后是否还能继续向外跳。","code":"class Solution {\npublic:\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\n        vector<vector<int>> nodes(n + 1);\n        for (auto &e : edges) {\n            nodes[e[0]].push_back(e[1]);\n            nodes[e[1]].push_back(e[0]);\n        }\n        vector<bool> used(n + 1, false);\n        used[1] = true;\n        function<double(int, int)> dfs = [&](int cur, int t) {\n            int sum = 0;\n            for (auto &next : nodes[cur]) {\n                if (!used[next]) sum += 1;\n            }\n            if (cur == target || t == 0) {\n                return cur == target && (t == 0 || sum == 0) ? 1.0 : 0.0;\n            }\n            for (auto &next : nodes[cur]) {\n                if (!used[next]) {\n                    used[next] = true;\n                    auto res = dfs(next, t - 1);\n                    used[next] = false;\n                    if (res != 0.0) return res / sum;\n                }\n            }\n            return 0.0;\n        };\n        return dfs(1, t);\n    }\n};","date":"2023-05-24"},{"script":"python","time":52,"memory":16.4,"desc":"同上。","code":"class Solution:\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\n        nodes = [[] for _ in range(n + 1)]\n        for e in edges:\n            nodes[e[0]].append(e[1])\n            nodes[e[1]].append(e[0])\n        used = [False for _ in range(n + 1)]\n        used[1] = True\n\n        def dfs(cur: int, t: int) -> float:\n            sum = 0\n            for next in nodes[cur]:\n                if not used[next]:\n                    sum += 1\n            if cur == target or t == 0:\n                return 1 if cur == target and (t == 0 or sum == 0) else 0\n            for next in nodes[cur]:\n                if not used[next]:\n                    used[next] = True\n                    res = dfs(next, t - 1)\n                    used[next] = False\n                    if res != 0:\n                        return res / sum\n            return 0\n        return dfs(1, t)","date":"2023-05-24"},{"script":"rust","time":4,"memory":1.9,"desc":"同上。","code":"fn dfs(nodes: &Vec<Vec<usize>>, used: &mut Vec<bool>, target: usize, cur: usize, t: i32) -> f64 {\nlet mut sum: f64 = 0.0;\nfor next in &nodes[cur] {\n    if !used[*next] {\n        sum += 1.0;\n    }\n}\nif cur == target || t == 0 {\n    if cur == target && (t == 0 || sum == 0.0) {\n        1.0\n    } else {\n        0.0\n    }\n} else {\n    for next in &nodes[cur] {\n        if !used[*next] {\n            used[*next] = true;\n            let res = dfs(nodes, used, target, *next, t - 1);\n            used[*next] = false;\n            if res != 0.0 {\n                return res / sum;\n            }\n        }\n    }\n    0.0\n}\n}\n\nimpl Solution {\n    pub fn frog_position(n: i32, edges: Vec<Vec<i32>>, t: i32, target: i32) -> f64 {\n        let n = n as usize;\n        let mut nodes: Vec<Vec<usize>> = vec![vec![]; n + 1];\n        for e in edges {\n            let (e0, e1) = (e[0] as usize, e[1] as usize);\n            nodes[e0].push(e1);\n            nodes[e1].push(e0);\n        }\n        let mut used = vec![false; n + 1];\n        used[1] = true;\n        dfs(&nodes, &mut used, target as usize, 1, t)\n    }\n}","date":"2023-05-24"}],"tagList":["树","深度优先搜索","广度优先搜索","图"],"level":"Hard"}},{"problemName":"1379.找出克隆二叉树中的相同节点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1379.找出克隆二叉树中的相同节点.json","problemData":{"id":"1498","name":"1379.找出克隆二叉树中的相同节点","url":"https://leetcode.cn/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree","desc":"请找出在树 cloned 中，与 target 相同 的节点，并返回对该节点的引用（在 C/C++ 等有指针的语言中返回 节点指针，其他语言返回节点本身）。","solutions":[{"script":"python","time":311,"memory":24.11,"desc":"dfs。","code":"class Solution:\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\n        if not original: return None\n        if original == target: return cloned\n        res = self.getTargetCopy(original.left, cloned.left, target)\n        return res if res else self.getTargetCopy(original.right, cloned.right, target)","date":"2024-04-03"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉树"],"level":"Easy"}},{"problemName":"1380.矩阵中的幸运数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1380.矩阵中的幸运数.json","problemData":{"id":"1496","name":"1380.矩阵中的幸运数","url":"https://leetcode.cn/problems/lucky-numbers-in-a-matrix","desc":"给你一个 m \\* n 的矩阵，矩阵中的数字 各不相同 。请你按 任意 顺序返回矩阵中的所有幸运数。","solutions":[{"date":"2022-02-15","time":20,"memory":10.9,"script":"cpp","desc":"遍历后记录每行最小值和每列最大值，如果第 i 行最小为 j 且第 j 列最大位 i，即可成立。","code":"class Solution {\n   public:\n    int rows[50] = {0}, cols[50] = {0};\n    vector<int> luckyNumbers(vector<vector<int>>& matrix) {\n        int n = matrix.size(), m = matrix[0].size();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (matrix[i][j] < matrix[i][rows[i]]) rows[i] = j;\n                if (matrix[i][j] > matrix[cols[j]][j]) cols[j] = i;\n            }\n        }\n        vector<int> ans;\n        for (int i = 0; i < n; i++) {\n            if (i == cols[rows[i]]) ans.push_back(matrix[i][rows[i]]);\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","矩阵"],"level":"Easy"}},{"problemName":"1382.将二叉搜索树变平衡.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1382.将二叉搜索树变平衡.json","problemData":{"id":"1285","name":"1382.将二叉搜索树变平衡","url":"https://leetcode.cn/problems/balance-a-binary-search-tree","desc":"给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。","solutions":[{"date":"2021-08-07","time":148,"memory":53.2,"script":"typescript","desc":"中序遍历排序后依次插入。","code":"function balanceBST(root: TreeNode | null): TreeNode | null {\n  const q: TreeNode[] = [];\n  inorder(root);\n  return build(q);\n  function inorder(node: TreeNode | null) {\n    if (node === null) return;\n    const { left, right } = node;\n    inorder(left);\n    q.push(node);\n    inorder(right);\n  }\n  function build(list: TreeNode[]): TreeNode | null {\n    if (list.length === 0) return null;\n    const mid = (0 + list.length - 1) >> 1;\n    const node = list[mid];\n    node.left = build(list.slice(0, mid));\n    node.right = build(list.slice(mid + 1));\n    return node;\n  }\n}"}],"tagList":["贪心","树","深度优先搜索","二叉搜索树","分治","二叉树"],"level":"Medium"}},{"problemName":"1388.3n块披萨.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1388.3n块披萨.json","problemData":{"id":"1489","name":"1388.3n块披萨","url":"https://leetcode.cn/problems/pizza-with-3n-slices","desc":"请你返回你可以获得的披萨大小总和的最大值。","solutions":[{"script":"cpp","time":28,"memory":14.1,"desc":"题目转化为3n个块中，选n个不相邻的块的最大和,dp[i][j]表示存在前i个块时，选取j个块的最大值。","code":"class Solution {\npublic:\n    int maxSizeSlices(vector<int>& slices) {\n        int m = slices.size() / 3;\n        auto check = [&](vector<int> nums) {\n            int n = nums.size();\n            vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));\n            for (int i = 1; i <= n; i++) {\n                for (int j = 1; j <= m; j++) {\n                    dp[i][j] = max(dp[i - 1][j], nums[i - 1]);\n                    if (i >= 2) dp[i][j] = max(dp[i][j], dp[i - 2][j - 1] + nums[i - 1]);\n                }\n            }\n            return dp[n][m];\n        };\n        return max(\n            check(vector<int>(slices.begin() + 1, slices.end())),\n            check(vector<int>(slices.begin(), slices.end() - 1))\n        );\n    }\n};","date":"2023-08-18"},{"script":"python","time":444,"memory":16.19,"desc":"同上。","code":"class Solution:\n    def maxSizeSlices(self, slices: List[int]) -> int:\n        m = len(slices) // 3\n\n        def check(nums: List[int]) -> int:\n            n = len(nums)\n            dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n            for i in range(1, n+1):\n                for j in range(1, m+1):\n                    dp[i][j] = max(dp[i-1][j], nums[i-1])\n                    if i >= 2:\n                        dp[i][j] = max(dp[i][j], dp[i-2][j-1]+nums[i-1])\n            return dp[n][m]\n\n        return max(check(slices[1:]), check(slices[0:-1]))","date":"2023-08-18"},{"script":"rust","time":4,"memory":2.16,"desc":"同上。","code":"impl Solution {\n    pub fn max_size_slices(slices: Vec<i32>) -> i32 {\n        use std::cmp::max;\n        let m = slices.len() / 3;\n        let check = |nums: &[i32]| -> i32 {\n            let n = nums.len();\n            let mut dp = vec![vec![0; m + 1]; n + 1];\n            for i in 1..=n {\n                for j in 1..=m {\n                    dp[i][j] = max(dp[i - 1][j], nums[i - 1]);\n                    if i >= 2 {\n                        dp[i][j] = max(dp[i][j], dp[i - 2][j - 1] + nums[i - 1])\n                    }\n                }\n            }\n            dp[n][m]\n        };\n        max(check(&slices[1..]), check(&slices[0..slices.len() - 1]))\n    }\n}","date":"2023-08-18"}],"tagList":["贪心","数组","动态规划","堆（优先队列）"],"level":"Hard"}},{"problemName":"1392.最长快乐前缀.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1301-1400/1392.最长快乐前缀.json","problemData":{"id":"1508","name":"1392.最长快乐前缀","url":"https://leetcode.cn/problems/longest-happy-prefix","desc":"给你一个字符串 s，请你返回它的 最长快乐前缀。","solutions":[{"date":"2021-10-13","time":96,"memory":50.1,"script":"typescript","desc":"kmp。","code":"function getNext(str: string) {\n  const next = [-1];\n  for (let i = 1, j = -1; str[i]; i++) {\n    while (j !== -1 && str[i] !== str[j + 1]) j = next[j];\n    if (str[i] === str[j + 1]) j++;\n    next[i] = j;\n  }\n  return next;\n}\nfunction longestPrefix(s: string): string {\n  const next = getNext(s);\n  const last = next[s.length - 1];\n  return last === -1 ? '' : s.substring(0, last + 1);\n}"},{"date":"2021-10-14","time":96,"memory":49.9,"script":"typescript","desc":"kmp。","code":"function longestPrefix(s: string): string {\n  const next = [-1];\n  for (let i = 1, j = -1; s[i]; i++) {\n    while (j !== -1 && s[i] !== s[j + 1]) j = next[j];\n    if (s[i] === s[j + 1]) j++;\n    next[i] = j;\n  }\n  return s.substring(0, next[s.length - 1] + 1);\n}"}],"tagList":["字符串","字符串匹配","哈希函数","滚动哈希"],"level":"Hard"}}]},{"dirName":"1401-1500","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\1401-1500","problems":[{"problemName":"1401.圆和矩形是否有重叠.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1401.圆和矩形是否有重叠.json","problemData":{"id":"1501","name":"1401.圆和矩形是否有重叠","url":"https://leetcode.cn/problems/circle-and-rectangle-overlapping","desc":"给你一个以 (radius, xCenter, yCenter) 表示的圆和一个与坐标轴平行的矩形 (x1, y1, x2, y2) ，其中 (x1, y1) 是矩形左下角的坐标，而 (x2, y2) 是右上角的坐标。如果圆和矩形有重叠的部分，请你返回 true ，否则返回 false 。换句话说，请你检测是否 存在 点 (xi, yi) ，它既在圆上也在矩形上（两者都包括点落在边界上的情况）。","solutions":[{"script":"cpp","time":0,"memory":5.7,"desc":"对于圆在矩形的四边和在四个远郊区都进行检测。","code":"class Solution {\npublic:\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\n        double xCenter2 = 1.0 * (x2 + x1) / 2, yCenter2 = 1.0 * (y2 + y1) / 2, d2 = yCenter2 - y1, d1 = xCenter2 - x1;\n        auto check = [&](double x1, double y1, double x2, double y2, double d) { return fabs(x1 - x2) * fabs(x1 - x2) + fabs(y1 - y2) * fabs(y1 - y2) <= d * d; };\n        return xCenter2 - d1 <= xCenter && xCenter <= xCenter2 + d1 && yCenter2 - d2 <= yCenter && yCenter <= yCenter2 + d2 ||\n               xCenter2 - d1 <= xCenter && xCenter <= xCenter2 + d1 && yCenter2 <= yCenter && yCenter <= yCenter2 + d2 + radius ||\n               xCenter2 - d1 <= xCenter && xCenter <= xCenter2 + d1 && yCenter2 - d2 - radius <= yCenter && yCenter <= yCenter2 ||\n               yCenter2 - d2 <= yCenter && yCenter <= yCenter2 + d2 && xCenter2 <= xCenter && xCenter <= xCenter2 + d1 + radius ||\n               yCenter2 - d2 <= yCenter && yCenter <= yCenter2 + d2 && xCenter2 - d1 - radius <= xCenter && xCenter <= xCenter2 ||\n               check(xCenter, yCenter, x1, y1, radius) ||\n               check(xCenter, yCenter, x1, y2, radius) ||\n               check(xCenter, yCenter, x2, y1, radius) ||\n               check(xCenter, yCenter, x2, y2, radius)\n               ;\n               \n    }\n};","date":"2023-06-25"},{"script":"cpp","time":4,"memory":5.6,"desc":"计算两个形状的最近距离。","code":"class Solution {\npublic:\n    bool checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\n        int x = clamp(xCenter, x1, x2) - xCenter, y = clamp(yCenter, y1, y2) - yCenter;\n        return pow(x, 2) + pow(y, 2) <= pow(radius, 2);\n    }\n};","date":"2023-06-25"},{"script":"python","time":40,"memory":16,"desc":"同上。","code":"class Solution:\n    def checkOverlap(self, radius: int, xCenter: int, yCenter: int, x1: int, y1: int, x2: int, y2: int) -> bool:\n        x = max(min(xCenter, x2), x1) - xCenter\n        y = max(min(yCenter, y2), y1) - yCenter\n        return pow(x, 2) + pow(y, 2) <= pow(radius, 2)\n","date":"2023-06-25"},{"script":"rust","time":0,"memory":1.9,"desc":"同上。","code":"impl Solution {\n    pub fn check_overlap(\n        radius: i32,\n        x_center: i32,\n        y_center: i32,\n        x1: i32,\n        y1: i32,\n        x2: i32,\n        y2: i32,\n    ) -> bool {\n        let x = x_center.clamp(x1, x2) - x_center;\n        let y = y_center.clamp(y1, y2) - y_center;\n        x.pow(2) + y.pow(2) <= radius.pow(2)\n    }\n}","date":"2023-06-25"}],"tagList":["几何","数学"],"level":"Medium"}},{"problemName":"1402.做菜顺序.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1402.做菜顺序.json","problemData":{"id":"1503","name":"1402.做菜顺序","url":"https://leetcode.cn/problems/reducing-dishes","desc":"返回厨师在准备了一定数量的菜肴后可以获得的最大 like-time 系数 总和。","solutions":[{"script":"cpp","time":4,"memory":7.93,"desc":"排序后贪心判断。","code":"class Solution {\npublic:\n    int maxSatisfaction(vector<int>& satisfaction) {\n        sort(satisfaction.begin(), satisfaction.end());\n        int n = satisfaction.size(), nsum = 0, vsum = 0, res = 0;\n        for (int i = 0; i < n; i++) {\n            nsum += (i + 1) * satisfaction[i];\n            vsum += satisfaction[i];\n        }\n        res = max(res, nsum);\n        for (int i = 1; i < n; i++) {\n            if (satisfaction[i] >= 0) break;\n            nsum -= vsum;\n            vsum -= satisfaction[i - 1];\n            res = max(res, nsum);\n        }\n        return res;\n    }\n};","date":"2023-10-22"},{"script":"python","time":24,"memory":15.69,"desc":"同上。","code":"class Solution:\n    def maxSatisfaction(self, satisfaction: List[int]) -> int:\n        satisfaction.sort()\n        n = len(satisfaction)\n        res = nsum = sum((i + 1) * satisfaction[i] for i in range(n))\n        sumv = sum(satisfaction)\n        for i in range(1, n):\n            if satisfaction[i] >= 0: break\n            nsum -= sumv\n            sumv -= satisfaction[i - 1]\n            res = max(res, nsum)\n\n        return max(0, res)","date":"2023-10-22"},{"script":"rust","time":0,"memory":1.98,"desc":"同上。","code":"impl Solution {\n    pub fn max_satisfaction(mut satisfaction: Vec<i32>) -> i32 {\n        satisfaction.sort();\n        let n = satisfaction.len();\n        let mut res = 0;\n        let mut nsum = 0;\n        let mut vsum = 0;\n        for i in 0..n {\n            nsum += (i as i32 + 1) * satisfaction[i];\n            vsum += satisfaction[i]\n        }\n        res = res.max(nsum);\n        for i in 1..n {\n            if satisfaction[i] >= 0 {\n                break;\n            }\n            nsum -= vsum;\n            vsum -= satisfaction[i - 1];\n            res = res.max(nsum);\n        }\n        res\n    }\n}\n","date":"2023-10-22"}],"tagList":["贪心","数组","动态规划","排序"],"level":"Hard"}},{"problemName":"1403.非递增顺序的最小子序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1403.非递增顺序的最小子序列.json","problemData":{"id":"1519","name":"1403.非递增顺序的最小子序列","url":"https://leetcode.cn/problems/minimum-subsequence-in-non-increasing-order","desc":"和 严格 大于未包含在该子序列中的各元素之和。","solutions":[{"date":"2022-08-04","time":0,"memory":2.1,"script":"rust","desc":"排序后，从后往前取值。","code":"impl Solution {\n    pub fn min_subsequence(nums: Vec<i32>) -> Vec<i32> {\n        let mut nums = nums;\n        nums.sort();\n        let sum: i32 = nums.iter().sum();\n        let mut cur = 0;\n        let mut i = nums.len() - 1;\n        let mut ans = Vec::new();\n        while cur * 2 <= sum {\n            cur += nums[i];\n            ans.push(nums[i]);\n            i -= 1;\n        }\n        ans\n    }\n}"}],"tagList":["贪心","数组","排序"],"level":"Easy"}},{"problemName":"1405.最长快乐字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1405.最长快乐字符串.json","problemData":{"id":"1304","name":"1405.最长快乐字符串","url":"https://leetcode.cn/problems/longest-happy-string","desc":"给你三个整数 a，b ，c，请你返回 任意一个 满足下列全部条件的字符串 s。","solutions":[{"date":"2022-02-07","time":0,"memory":5.9,"script":"cpp","desc":"贪心,堆,每次取最大的元素进行塞入。","code":"class Solution {\n   public:\n    typedef pair<char, int> node;\n    string longestDiverseString(int a, int b, int c) {\n        auto cmp = [&](node x, node y) -> bool { return x.second < y.second; };\n        priority_queue<node, vector<node>, decltype(cmp)> q(cmp);\n        q.push(make_pair('a', a));\n        q.push(make_pair('b', b));\n        q.push(make_pair('c', c));\n        string ans = \"\";\n        while (1) {\n            node v = q.top();\n            int prev_cnt = 0;  // 看看前面有几个一样的\n            for (int i = ans.size() - 1; i >= 0 && ans[i] == v.first; i--)\n                prev_cnt++;\n            if (v.second == 0 || prev_cnt >= 2)\n                break;  // 如果所有的都没了或者前面有两个一样的，就不要了\n            q.pop();\n            int cnt = prev_cnt == 1 ? 1 : v.second >= 2 ? 2 : 1;\n            v.second -= cnt;\n            while (cnt--) ans += v.first;  // 塞进去\n            node nv = q.top();  // 尝试从下一个字符拿一个做间隔\n            q.pop();\n            if (nv.second >= 1) {\n                ans += nv.first;\n                nv.second -= 1;\n            }\n            q.push(nv);\n            q.push(v);\n        }\n        return ans;\n    }\n};"}],"tagList":["贪心","字符串","堆（优先队列）"],"level":"Medium"}},{"problemName":"1408.数组中的字符串匹配.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1408.数组中的字符串匹配.json","problemData":{"id":"1524","name":"1408.数组中的字符串匹配","url":"https://leetcode.cn/problems/string-matching-in-an-array","desc":"给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。","solutions":[{"date":"2022-08-06","time":88,"memory":43.6,"script":"typescript","desc":"判断是否是子串。","code":"function stringMatching(words: string[]): string[] {\n  words.sort((a, b) => a.length - b.length);\n  const set = new Set<string>();\n  for (let i = 0; i < words.length; i++) {\n    for (let j = 0; j < i; j++) {\n      if (words[i].includes(words[j])) set.add(words[j]);\n    }\n  }\n  return [...set];\n}"}],"tagList":["数组","字符串","字符串匹配"],"level":"Easy"}},{"problemName":"1409.查询带键的排列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1409.查询带键的排列.json","problemData":{"id":"1525","name":"1409.查询带键的排列","url":"https://leetcode.cn/problems/queries-on-a-permutation-with-key","desc":"给你一个待查数组 queries ，数组中的元素为 1 到 m 之间的正整数。 请你以数组形式返回待查数组 queries 的查询结果。","solutions":[{"date":"2021-11-14","time":92,"memory":40.3,"script":"typescript","desc":"链表。","code":"class Data {\n  next: Data | null;\n  idx: number;\n  val: number = -1;\n}\nfunction processQueries(queries: number[], m: number): number[] {\n  const root = new Data();\n  let p = root;\n  for (let i = 1; i <= m; i++) {\n    const item = new Data();\n    item.idx = i - 1;\n    item.val = i;\n    p.next = item;\n    p = item;\n  }\n  const ans: number[] = [];\n  for (const query of queries) {\n    p = root;\n    while (p.next!.val !== query) {\n      p = p.next!;\n      p.idx++;\n    }\n    const node = p.next!;\n    p.next = node.next;\n    node.next = root.next;\n    root.next = node;\n    ans.push(node.idx);\n    node.idx = 0;\n  }\n  return ans;\n}"},{"date":"2021-11-14","time":96,"memory":40.3,"script":"typescript","desc":"树状数组。","code":"class FenwickTree {\n  arr: number[];\n  constructor(private n: number) {\n    this.arr = new Array(n + 1).fill(0);\n  }\n  add(idx: number, num: number): void {\n    while (idx <= this.n) {\n      this.arr[idx] += num;\n      idx += this.lowbit(idx);\n    }\n  }\n  at(idx: number): number {\n    return this.query(idx) - this.query(idx - 1);\n  }\n  query(idx: number): number {\n    let sum = 0;\n    while (idx) {\n      sum += this.arr[idx];\n      idx -= this.lowbit(idx);\n    }\n    return sum;\n  }\n  private lowbit(num: number) {\n    return num & -num;\n  }\n}\nfunction processQueries(queries: number[], m: number): number[] {\n  const n = queries.length;\n  const tree = new FenwickTree(n + m);\n  const idxList = new Array(m + 1).fill(0).map((_, i) => n + i);\n  const ans: number[] = [];\n  for (let i = 1; i <= m; i++) tree.add(i + n, 1);\n  for (let i = 0; i < n; i++) {\n    const query = queries[i];\n    const idx = idxList[query];\n    const cnt = tree.query(idx);\n    ans.push(cnt - 1);\n    tree.add(idx, -1);\n    tree.add(n - i, 1);\n    idxList[query] = n - i;\n  }\n  return ans;\n}"}],"tagList":["树状数组","数组","模拟"],"level":"Medium"}},{"problemName":"1410.HTML实体解析器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1410.HTML实体解析器.json","problemData":{"id":"1526","name":"1410.HTML实体解析器","url":"https://leetcode.cn/problems/html-entity-parser","desc":"给你输入字符串 text ，请你实现一个 HTML 实体解析器，返回解析器解析后的结果。","solutions":[{"script":"python","time":68,"memory":16.32,"desc":"字符串替换。","code":"class Solution:\n            def entityParser(self, text: str) -> str:\n    return text.replace('&quot;', '\\\"').replace('&apos;', '\\'').replace('&gt;', '>').replace('&lt;', '<').replace('&frasl;', '/').replace('&amp;', '&')","date":"2023-11-23"}],"tagList":["哈希表","字符串"],"level":"Medium"}},{"problemName":"1413.逐步求和得到正数的最小值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1413.逐步求和得到正数的最小值.json","problemData":{"id":"1514","name":"1413.逐步求和得到正数的最小值","url":"https://leetcode.cn/problems/minimum-value-to-get-positive-step-by-step-sum","desc":"请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 正数 作为 startValue 。","solutions":[{"date":"2022-08-09","time":0,"memory":2.2,"script":"rust","desc":"前缀和判断每一次数组中值相加的绝对值小于 ans。","code":"impl Solution {\n    pub fn min_start_value(nums: Vec<i32>) -> i32 {\n        let mut ans = 1;\n        let mut sum  = 0;\n        for num in nums {\n            sum += num;\n            if sum < 0 && ans <= sum.abs() {\n                ans = sum.abs() + 1;\n            }\n        }\n        ans\n    }\n}"},{"date":"2022-08-09","time":0,"memory":2,"script":"rust","desc":"前缀和判断每一次数组中值相加的绝对值小于 ans。","code":"impl Solution {\n    pub fn min_start_value(nums: Vec<i32>) -> i32 {\n        let (mut ans, mut sum) = (0, 0);\n        for num in nums {\n            sum += num;\n            ans = ans.min(sum);\n        }\n        ans.abs() + 1\n    }\n}"},{"date":"2022-08-09","time":0,"memory":2,"script":"rust","desc":"二分。","code":"fn check(nums: &Vec<i32>, v: i32) -> bool {\n    let mut v = v;\n    for num in nums {\n        v += num;\n        if v <= 0 {\n            return false;\n        }\n    }\n    true\n}\n\nimpl Solution {\n    pub fn min_start_value(nums: Vec<i32>) -> i32 {\n        let (mut l, mut r) = (1, i32::MAX);\n        while l < r {\n            let m = l + (r - l) / 2;\n            if check(&nums, m) {\n                r = m;\n            } else {\n                l = m + 1;\n            }\n        }\n        l\n    }\n}"}],"tagList":["数组","前缀和"],"level":"Easy"}},{"problemName":"1414.和为K的最少斐波那契数字数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1414.和为K的最少斐波那契数字数目.json","problemData":{"id":"1515","name":"1414.和为K的最少斐波那契数字数目","url":"https://leetcode.cn/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k","desc":"给你数字 k ，请你返回和为 k 的斐波那契数字的最少数目，其中，每个斐波那契数字都可以被使用多次。","solutions":[{"date":"2022-02-03","time":0,"memory":5.9,"script":"cpp","desc":"贪心策略。","code":"int fib[] = {1,         1,        2,        3,         5,         8,\n             13,        21,       34,       55,        89,        144,\n             233,       377,      610,      987,       1597,      2584,\n             4181,      6765,     10946,    17711,     28657,     46368,\n             75025,     121393,   196418,   317811,    514229,    832040,\n             1346269,   2178309,  3524578,  5702887,   9227465,   14930352,\n             24157817,  39088169, 63245986, 102334155, 165580141, 267914296,\n             433494437, 701408733};\n\nclass Solution {\n   public:\n    int findMinFibonacciNumbers(int k) {\n        int cnt = 0;\n        for (int idx = 43; k; idx--) {\n            while (fib[idx] > k) idx--;\n            cnt += k / fib[idx];\n            k %= fib[idx];\n        }\n        return cnt;\n    }\n};"}],"tagList":["贪心","数学"],"level":"Medium"}},{"problemName":"1417.重新格式化字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1417.重新格式化字符串.json","problemData":{"id":"1532","name":"1417.重新格式化字符串","url":"https://leetcode.cn/problems/reformat-the-string","desc":"请你返回 重新格式化后 的字符串；如果无法按要求重新格式化，则返回一个 空字符串 。","solutions":[{"date":"2022-08-11","time":4,"memory":2.1,"script":"rust","desc":"重新排列。","code":"impl Solution {\n    pub fn reformat(s: String) -> String {\n        let (mut list_num, mut list_char) = (Vec::new(), Vec::new());\n        for c in s.chars().collect::<Vec<char>>() {\n            if c.is_numeric() {\n                list_num.push(c);\n            } else {\n                list_char.push(c);\n            }\n        }\n        let mut ans = String::new();\n        if (list_num.len() as i32 - list_char.len() as i32).abs() > 1 {\n            return ans;\n        }\n        let (mut list1, mut list2) = if list_num.len() > list_char.len() {\n            (list_num.into_iter(), list_char.into_iter())\n        } else {\n            (list_char.into_iter(), list_num.into_iter())\n        };\n        loop {\n            let mut c;\n            c = list1.next();\n            if c.is_none() {\n                break;\n            };\n            ans.push(c.unwrap());\n            c = list2.next();\n            if c.is_none() {\n                break;\n            };\n            ans.push(c.unwrap());\n        }\n        ans\n    }\n}"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"1418.点菜展示表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1418.点菜展示表.json","problemData":{"id":"1533","name":"1418.点菜展示表","url":"https://leetcode.cn/problems/display-table-of-food-orders-in-a-restaurant","desc":"请你返回该餐厅的 点菜展示表 。在这张表中，表中第一行为标题，其第一列为餐桌桌号 “Table” ，后面每一列都是按字母顺序排列的餐品名称。接下来每一行中的项则表示每张餐桌订购的相应餐品数量，第一列应当填对应的桌号，后面依次填写下单的餐品数量。","solutions":[{"date":"2021-07-06","time":228,"memory":57.3,"script":"typescript","desc":"遍历每张桌子进行排序。","code":"function displayTable(orders: string[][]): string[][] {\n  const foodSet = new Set<string>();\n  const tables: Map<number, Map<string, number>> = new Map();\n  for (const [, table, foodName] of orders) {\n    const tableNumber = +table;\n    let map = tables.get(tableNumber);\n    if (!map) tables.set(tableNumber, (map = new Map()));\n    map.set(foodName, (map.get(foodName) ?? 0) + 1);\n    foodSet.add(foodName);\n  }\n  const title = [\n    'Table',\n    ...[...foodSet].sort((s1, s2) => {\n      const len1 = s1.length;\n      const len2 = s2.length;\n      let i = 0;\n      while (i < Math.min(len1, len2)) {\n        const code1 = s1.codePointAt(i)!;\n        const code2 = s2.codePointAt(i)!;\n        if (code1 !== code2) return code1 - code2;\n        else i++;\n      }\n      if (i === len1) return -1;\n      else if (i === len2) return 1;\n      else return 0;\n    }),\n  ];\n  const data: number[][] = [];\n  for (const [table, map] of tables.entries()) {\n    const item: number[] = [table];\n    for (let i = 1, l = title.length; i < l; i++) item[i] = map.get(title[i]) ?? 0;\n    data.push(item);\n  }\n  return [title, ...data.sort(([t1], [t2]) => t1 - t2).map(v => v.map(v => v + ''))];\n}"}],"tagList":["数组","哈希表","字符串","有序集合","排序"],"level":"Medium"}},{"problemName":"1419.数青蛙.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1419.数青蛙.json","problemData":{"id":"1534","name":"1419.数青蛙","url":"https://leetcode.cn/problems/minimum-number-of-frogs-croaking","desc":"请你返回模拟字符串中所有蛙鸣所需不同青蛙的最少数目。","solutions":[{"script":"cpp","time":24,"memory":9,"desc":"遍历。","code":"class Solution {\npublic:\n    int minNumberOfFrogs(string croakOfFrogs) {\n        int n = croakOfFrogs.size(), wait[5] = {0}, res = 0;\n        unordered_map<char, int> m;\n        m['c'] = 0; m['r'] = 1; m['o'] = 2; m['a'] = 3; m['k'] = 4;\n        for (int i = 0; i < n; i++) {\n            int idx = m[croakOfFrogs[i]];\n            if (idx == 0) {\n                if (wait[4] == 0) res++;\n                else wait[4] -= 1;\n                wait[idx]++;\n            } else {\n                if (wait[idx - 1] == 0) return -1;\n                wait[idx - 1]--;\n                wait[idx]++;\n            }\n        }\n        return wait[4] == res ? res : -1;\n    }\n};","date":"2023-05-06"},{"script":"python","time":172,"memory":16.6,"desc":"同上。","code":"class Solution:\n    def minNumberOfFrogs(self, croakOfFrogs: str) -> int:\n        n = len(croakOfFrogs)\n        wait = [0] * 5\n        res = 0\n        m = {}\n        m['c'] = 0\n        m['r'] = 1\n        m['o'] = 2\n        m['a'] = 3\n        m['k'] = 4\n        for i in range(n):\n            idx = m[croakOfFrogs[i]]\n            if idx == 0:\n                if wait[4] == 0:\n                    res += 1\n                else:\n                    wait[4] -= 1\n                wait[idx] += 1\n            else:\n                if wait[idx - 1] == 0:\n                    return -1\n                wait[idx-1] -= 1\n                wait[idx] += 1\n        return res if wait[4] == res else -1","date":"2023-05-06"},{"script":"rust","time":4,"memory":2.6,"desc":"同上。","code":"fn get_idx(c: char) -> usize {\n    match c {\n        'c' => 0,\n        'r' => 1,\n        'o' => 2,\n        'a' => 3,\n        'k' => 4,\n        _ => 0,\n    }\n}\nfn str_to_vec(s: &String) -> Vec<char> {\n    s.chars().collect()\n}\nimpl Solution {\n    pub fn min_number_of_frogs(croak_of_frogs: String) -> i32 {\n        let croak_of_frogs = str_to_vec(&croak_of_frogs);\n        let n = croak_of_frogs.len();\n        let mut wait = vec![0; 5];\n        let mut res = 0;\n        for i in 0..croak_of_frogs.len() {\n            let idx = get_idx(croak_of_frogs[i]);\n            if idx == 0 {\n                if wait[4] == 0 {\n                    res += 1\n                } else {\n                    wait[4] -= 1;\n                }\n                wait[idx] += 1;\n            } else {\n                if wait[idx - 1] == 0 {\n                    return -1;\n                };\n                wait[idx - 1] -= 1;\n                wait[idx] += 1\n            }\n        }\n        return if wait[4] == res { res } else { -1 };\n    }\n}\n","date":"2023-05-06"}],"tagList":["字符串","计数"],"level":"Medium"}},{"problemName":"1422.分割字符串的最大得分.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1422.分割字符串的最大得分.json","problemData":{"id":"1537","name":"1422.分割字符串的最大得分","url":"https://leetcode.cn/problems/maximum-score-after-splitting-a-string","desc":"给你一个由若干 0 和 1 组成的字符串 s ，请你计算并返回将该字符串分割成两个 非空 子字符串（即 左 子字符串和 右 子字符串）所能获得的最大得分。","solutions":[{"date":"2022-08-15","time":0,"memory":6.2,"script":"cpp","desc":"遍历并计算左 0 和右 1 的数量。","code":"class Solution {\npublic:\n    int maxScore(string s) {\n        int ans = 0, cnt0 = 0, cnt1 = 0;\n        for (auto &c : s) {\n            if (c == '1') cnt1++;\n        }\n        for (int i = 0; i < s.size() - 1; i++) {\n            char c = s[i];\n            if (c == '0') cnt0++;\n            else cnt1--;\n            ans = max(ans, cnt0 + cnt1);\n        }\n        return ans;\n    }\n};"}],"tagList":["字符串","前缀和"],"level":"Easy"}},{"problemName":"1423.可获得的最大点数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1423.可获得的最大点数.json","problemData":{"id":"1538","name":"1423.可获得的最大点数","url":"https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards","desc":"给你一个整数数组 cardPoints 和整数 k，请你返回可以获得的最大点数。","solutions":[{"date":"2021-02-06","time":80,"memory":46.5,"script":"typescript","desc":"利用滑动窗口减少次数判断。","code":"function maxScore(cardPoints: number[], k: number): number {\n  const len = cardPoints.length;\n  let rightNum = 0;\n  let num = cardPoints.slice(0, k).reduce((total, cur) => total + cur, 0);\n  let max = num;\n  while (rightNum < k) {\n    max = Math.max(\n      max,\n      (num = num - cardPoints[k - rightNum - 1] + cardPoints[len - rightNum - 1])\n    );\n    rightNum++;\n  }\n  return max;\n}"},{"script":"python","time":92,"memory":26.23,"desc":"滑动窗口记录左右两侧。","code":"class Solution:\n    def maxScore(self, cardPoints: List[int], k: int) -> int:\n        n = len(cardPoints)\n        l = sum(cardPoints[0:k])\n        r = 0\n        ans = l\n        for i in range(k):\n            r += cardPoints[n - 1 - i]\n            l -= cardPoints[k - 1 - i]\n            ans = max(ans, l + r)\n        return ans","date":"2023-12-03"},{"script":"rust","time":8,"memory":3.19,"desc":"同上。","code":"impl Solution {\n    pub fn max_score(card_points: Vec<i32>, k: i32) -> i32 {\n        let k = k as usize;\n        let n = card_points.len();\n        let mut l = card_points[0..k].iter().sum::<i32>();\n        let mut r = 0;\n        let mut ans = l;\n        for i in 0..k {\n            r += card_points[n - 1 - i];\n            l -= card_points[k - 1 - i];\n            ans = ans.max(l + r);\n        }\n        ans\n    }\n}","date":"2023-12-03"}],"tagList":["数组","前缀和","滑动窗口"],"level":"Medium"}},{"problemName":"1431.拥有最多糖果的孩子.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1431.拥有最多糖果的孩子.json","problemData":{"id":"1528","name":"1431.拥有最多糖果的孩子","url":"https://leetcode.cn/problems/kids-with-the-greatest-number-of-candies","desc":"给你一个数组  candies  和一个整数  extraCandies ，其中  candies[i]  代表第 i 个孩子拥有的糖果数目。对每一个孩子，检查是否存在一种方案，将额外的  extraCandies  个糖果分配给孩子们之后，此孩子有 最多   的糖果。注意，允许有多个孩子同时拥有 最多   的糖果数目。","solutions":[{"date":"2020-06-01","time":92,"memory":36.3,"script":"typescript","desc":"遍历两遍，第一遍获取最大值，第二遍判断是否值最大。","code":"var kidsWithCandies = function (candies: number[], extraCandies: number): boolean[] {\n  let max = -1;\n  for (const num of candies) max = max < num ? num : max;\n  const res: boolean[] = [];\n  for (const num of candies) res.push(num + extraCandies >= max);\n  return res;\n};"}],"tagList":["数组"],"level":"Easy"}},{"problemName":"1436.旅行终点站.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1436.旅行终点站.json","problemData":{"id":"1547","name":"1436.旅行终点站","url":"https://leetcode.cn/problems/destination-city","desc":"给你一份旅游线路图，该线路图中的旅行线路用数组 paths 表示，其中 paths[i] = [cityAi, cityBi] 表示该线路将会从 cityAi 直接前往 cityBi 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市。","solutions":[{"date":"2021-10-01","time":84,"memory":40.9,"script":"typescript","desc":"哈希。","code":"function destCity(paths: string[][]): string {\n  const map = new Map<string, string>();\n  const set = new Set<string>();\n  for (const [c1, c2] of paths) {\n    map.set(c1, c2);\n    set.add(c1);\n    set.add(c2);\n  }\n  for (const c of map.keys()) set.delete(c);\n  return [...set][0];\n}"}],"tagList":["数组","哈希表","字符串"],"level":"Easy"}},{"problemName":"1438.绝对差不超过限制的最长连续子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1438.绝对差不超过限制的最长连续子数组.json","problemData":{"id":"1549","name":"1438.绝对差不超过限制的最长连续子数组","url":"https://leetcode.cn/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit","desc":"给你一个整数数组 nums ，和一个表示限制的整数 limit，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 limit 。","solutions":[{"date":"2021-02-21","time":208,"memory":61.8,"script":"typescript","desc":"滑动窗口,记录最值进行比较。","code":"function longestSubarray(nums: number[], limit: number): number {\n  const zero = nums[0];\n  let l = 0;\n  let r = 0;\n  let max = zero;\n  let min = zero;\n  let win: Record<number, number> = { [zero]: 1 };\n  let ans = 1;\n  let sortArr = [zero];\n  const len = nums.length;\n  while (++r < len) {\n    const num = nums[r];\n    const value = win[num];\n    win[num] = 1 + (value ?? 0);\n    if (!value) {\n      if (num > max) sortArr.push((max = num));\n      else if (num < min) sortArr.unshift((min = num));\n      else {\n        for (let i = 0, l = sortArr.length; i < l; i++) {\n          if (sortArr[i] > num) {\n            sortArr.splice(i, 0, num);\n            break;\n          }\n        }\n      }\n      while (l < r && max - min > limit) {\n        const prevNum = nums[l++];\n        const count = win[prevNum];\n        win[prevNum] = count - 1;\n        if (count === 1) {\n          if (prevNum === max) max = sortArr[sortArr.length - 2];\n          else if (prevNum === min) min = sortArr[1];\n          for (let i = 0, l = sortArr.length; i < l; i++) {\n            if (sortArr[i] === prevNum) {\n              sortArr.splice(i, 1);\n              break;\n            }\n          }\n        }\n      }\n    }\n    ans = Math.max(ans, r - l + 1);\n  }\n  return ans;\n}"},{"date":"2021-07-21","time":2712,"memory":65.9,"script":"typescript","desc":"遍历每个长度，利用单调栈维护滑动窗口中的最值。","code":"function longestSubarray(nums: number[], limit: number): number {\n  const n = nums.length;\n  return search();\n  function search(l = 0, r = nums.length): number {\n    if (l === r) return l;\n    const mid = (l + r + 1) >> 1;\n    if (check(mid)) l = mid;\n    else r = mid - 1;\n    return search(l, r);\n  }\n  function check(len: number): boolean {\n    const qMax: number[] = [];\n    const qMin: number[] = [];\n    for (let i = 0; i < n; i++) {\n      const num = nums[i];\n      while (qMax.length && nums[qMax[qMax.length - 1]] < num) qMax.pop();\n      while (qMin.length && nums[qMin[qMin.length - 1]] > num) qMin.pop();\n      qMax.push(i);\n      qMin.push(i);\n      if (i + 1 < len) continue;\n      if (i - qMax[0] === len) qMax.shift();\n      if (i - qMin[0] === len) qMin.shift();\n      if (nums[qMax[0]] - nums[qMin[0]] <= limit) return true;\n    }\n    return false;\n  }\n}"}],"tagList":["队列","数组","有序集合","滑动窗口","单调队列","堆（优先队列）"],"level":"Medium"}},{"problemName":"1439.有序矩阵中的第k个最小数组和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1439.有序矩阵中的第k个最小数组和.json","problemData":{"id":"1550","name":"1439.有序矩阵中的第k个最小数组和","url":"https://leetcode.cn/problems/find-the-kth-smallest-sum-of-a-matrix-with-sorted-rows","desc":"给你一个 m * n 的矩阵 mat，以及一个整数 k ，矩阵中的每一行都以非递减的顺序排列。","solutions":[{"script":"cpp","time":156,"memory":32.9,"desc":"每次求和只取前k个数字，后面数字不需要。","code":"class Solution {\npublic:\n    int kthSmallest(vector<vector<int>>& mat, int k) {\n        vector<int> list(1, 0);\n        for (auto &m : mat) {\n            vector<int> next;\n            for (auto &num1 : list) {\n                for (auto &num2 : m) {\n                    next.push_back(num1 + num2);\n                }\n            }\n            sort(next.begin(), next.end());\n            if (next.size() > k) next.resize(k);\n            list = next;\n        }\n        return list.back();\n    }\n};","date":"2023-05-28"},{"script":"cpp","time":16,"memory":8.3,"desc":"求出最大最小值，二分答案。","code":"class Solution {\npublic:\n    int kthSmallest(vector<vector<int>>& mat, int k) {\n        int n = mat.size(), m = mat[0].size(), l = 0, r = 0, base = 0;\n        for (int i = 0; i < n; i++) l += mat[i][0], r += mat[i][m - 1], base += mat[i][0];\n        function<bool(int, int, int&)> dfs = [&](int idx, int sum, int &cnt) {\n            if (idx == -1) return --cnt == 0;\n            for (int i = 0; i < mat[idx].size() && sum - (mat[idx][i] - mat[idx][0]) >= 0; i++)\n                if (dfs(idx - 1, sum - (mat[idx][i] - mat[idx][0]), cnt)) return true;\n            return false;\n        };\n        while (l < r) {\n            int m = (l + r) / 2, cnt = k;\n            if (dfs(n - 1, m - base, cnt)) r = m;\n            else l = m + 1;\n        }\n        return l;\n    }\n};","date":"2023-05-28"}],"tagList":["数组","二分查找","矩阵","堆（优先队列）"],"level":"Hard"}},{"problemName":"1441.用栈操作构建数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1441.用栈操作构建数组.json","problemData":{"id":"1552","name":"1441.用栈操作构建数组","url":"https://leetcode.cn/problems/build-an-array-with-stack-operations","desc":"给你一个数组 target 和一个整数 n。每次迭代，需要从 list = { 1 , 2 , 3 ..., n } 中依次读取一个数字。","solutions":[{"date":"2022-10-15","time":8,"memory":7.6,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    vector<string> buildArray(vector<int>& target, int n) {\n        vector<string> list;\n        int cur = 1;\n        for (auto &item : target) {\n            while (cur < item) {\n                list.push_back(\"Push\");\n                list.push_back(\"Pop\");\n                cur++;\n            }\n            list.push_back(\"Push\");\n            cur++;\n        }\n        return list;\n    }\n};"}],"tagList":["栈","数组","模拟"],"level":"Medium"}},{"problemName":"1442.形成两个异或相等数组的三元组数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1442.形成两个异或相等数组的三元组数目.json","problemData":{"id":"1553","name":"1442.形成两个异或相等数组的三元组数目","url":"https://leetcode.cn/problems/count-triplets-that-can-form-two-arrays-of-equal-xor","desc":"请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。","solutions":[{"date":"2021-05-18","time":148,"memory":39.8,"script":"typescript","desc":"前缀和。","code":"function countTriplets(arr: number[]): number {\n  const len = arr.length;\n  if (len === 1) return 0;\n  let ans = 0;\n  const prefixSumList: number[] = [ans, ...arr.map(v => (ans ^= v))];\n  ans = 0;\n  for (let k = 1; k < len; k++) {\n    for (let j = 1; j <= k; j++) {\n      for (let i = 0; i < j; i++) {\n        const a = prefixSumList[j] ^ prefixSumList[i];\n        const b = prefixSumList[k + 1] ^ prefixSumList[j];\n        if (a === b) ans++;\n      }\n    }\n  }\n  return ans;\n}"},{"date":"2021-05-18","time":100,"memory":40.3,"script":"typescript","desc":"在前后相等的情况下，可取任意 j。","code":"function countTriplets(arr: number[]): number {\n  const len = arr.length;\n  if (len === 1) return 0;\n  let ans = 0;\n  const prefixSumList: number[] = [ans, ...arr.map(v => (ans ^= v))];\n  ans = 0;\n  for (let k = 1; k < len; k++) {\n    for (let i = 0; i < k; i++) {\n      if (prefixSumList[k + 1] === prefixSumList[i]) ans += k - i;\n    }\n  }\n  return ans;\n}"}],"tagList":["位运算","数组","哈希表","数学","前缀和"],"level":"Medium"}},{"problemName":"1444.切披萨的方案数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1444.切披萨的方案数.json","problemData":{"id":"1555","name":"1444.切披萨的方案数","url":"https://leetcode.cn/problems/number-of-ways-of-cutting-a-pizza","desc":"给你一个 rows x cols 大小的矩形披萨和一个整数 k ，矩形包含两种字符： 'A' （表示苹果）和 '.' （表示空白格子）。你需要切披萨 k-1 次，得到 k 块披萨并送给别人。请你返回确保每一块披萨包含 至少 一个苹果的切披萨方案数。","solutions":[{"script":"python","time":220,"memory":19.05,"desc":"记忆化dfs。","code":"class Solution:\n    def ways(self, pizza: List[str], k: int) -> int:\n        MOD = 1000000000 + 7\n        n = len(pizza)\n        m = len(pizza[0])\n\n        @cache\n        def has_apple(i1: int, j1: int, i2: int, j2: int) -> int:\n            for i in range(i1, i2 + 1):\n                for j in range(j1, j2 + 1):\n                    if pizza[i][j] == 'A':\n                        return True\n            return False\n\n        @cache\n        def dfs(i1: int, j1: int, i2: int, j2: int, k: int) -> int:\n            if k == 0:\n                return 1 if has_apple(i1, j1, i2, j2) else 0\n            res = 0\n            if j1 != j2:\n                f = False\n                for j in range(j1, j2):\n                    if not f:\n                        f = f or has_apple(i1, j1, i2, j)\n                    if f:\n                        res = (res + dfs(i1, j + 1, i2, j2, k - 1)) % MOD\n            if i1 != i2:\n                f = False\n                for i in range(i1, i2):\n                    if not f:\n                        f = f or has_apple(i1, j1, i, j2)\n                    if f:\n                        res = (res + dfs(i + 1, j1, i2, j2, k - 1)) % MOD\n            return res\n\n        return dfs(0, 0, n - 1, m - 1, k - 1)","date":"2023-08-17"}],"tagList":["记忆化搜索","数组","动态规划","矩阵"],"level":"Hard"}},{"problemName":"1446.连续字符.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1446.连续字符.json","problemData":{"id":"1542","name":"1446.连续字符","url":"https://leetcode.cn/problems/consecutive-characters","desc":"给你一个字符串 s ，字符串的「能量」定义为：只包含一种字符的最长非空子字符串的长度。","solutions":[{"date":"2021-12-01","time":88,"memory":39.9,"script":"typescript","desc":"遍历。","code":"function maxPower(s: string): number {\n  let ans = 0;\n  for (let i = 0, n = s.length; i < n; i++) {\n    let cnt = 1;\n    const ch = s[i];\n    while (i + 1 < n && s[i + 1] === ch) {\n      i++;\n      cnt++;\n    }\n    ans = Math.max(ans, cnt);\n  }\n  return ans;\n}"},{"date":"2021-12-01","time":4,"memory":5.9,"script":"typescript","desc":"遍历。","code":"int maxPower(char * s){\n    int ans = 0;\n    for (int i = 0; i < strlen(s); i++) {\n        int cnt = 1;\n        char ch = s[i];\n        while (i + 1 < strlen(s) && s[i + 1] == ch) {\n            i++;\n            cnt++;\n        }\n        if (cnt > ans) ans = cnt;\n    }\n    return ans;\n}"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"1447.最简分数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1447.最简分数.json","problemData":{"id":"1543","name":"1447.最简分数","url":"https://leetcode.cn/problems/simplified-fractions","desc":"给你一个整数 n ，请你返回所有 0 到 1 之间（不包括 0 和 1）满足分母小于等于 n 的 最简 分数 。分数可以以 任意 顺序返回。","solutions":[{"date":"2021-12-11","time":104,"memory":44.8,"script":"typescript","desc":"最大公约数为 1。","code":"function gcd(a: number, b: number) {\n  return b ? gcd(b, a % b) : a;\n}\nfunction simplifiedFractions(n: number): string[] {\n  const ans: string[] = [];\n  for (let i = 2; i <= n; i++) {\n    for (let j = 1; j < i; j++) {\n      if (gcd(i, j) === 1) ans.push(`${j}/${i}`);\n    }\n  }\n  return ans;\n}"},{"date":"2022-02-10","time":116,"memory":32.5,"script":"cpp","desc":"判断最大公约数。","code":"class Solution {\n   public:\n    vector<string> simplifiedFractions(int n) {\n        unordered_set<string> s;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j < i; j++) {\n                int num = gcd(i, j);\n                s.insert(to_string(j / num) + \"/\" + to_string(i / num));\n            }\n        }\n        vector<string> ans;\n        for (auto& str : s) ans.push_back(str);\n        return ans;\n    }\n};"},{"date":"2022-02-10","time":48,"memory":21.3,"script":"cpp","desc":"判断最大公约数。","code":"class Solution {\n   public:\n    vector<string> simplifiedFractions(int n) {\n        vector<string> ans;\n        for (int i = 2; i <= n; i++) {\n            for (int j = 1; j < i; j++) {\n                if (j == 1 || gcd(i, j) == 1)\n                    ans.push_back(to_string(j) + \"/\" + to_string(i));\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["数学","字符串","数论"],"level":"Medium"}},{"problemName":"1448.统计二叉树中好节点的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1448.统计二叉树中好节点的数目.json","problemData":{"id":"1544","name":"1448.统计二叉树中好节点的数目","url":"https://leetcode.cn/problems/count-good-nodes-in-binary-tree","desc":"给你一棵根为 root 的二叉树，请你返回二叉树中好节点的数目。","solutions":[{"script":"cpp","time":112,"memory":84.3,"desc":"dfs。","code":"class Solution {\npublic:\n    int countServers(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size(), mmap[250][250] = {0};\n        pair<int, int> prev = make_pair(-1, -1);\n        for (int i = 0; i < n; i++) {\n            prev = make_pair(-1, -1);\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) {\n                    if (prev.first == -1) prev = make_pair(i, j);\n                    else {\n                        mmap[prev.first][prev.second] = true;\n                        mmap[i][j] = true;\n                    }\n                }\n            }\n        }\n        for (int j = 0; j < m; j++) {\n            prev = make_pair(-1, -1);\n            for (int i = 0; i < n; i++) {\n                if (grid[i][j] == 1) {\n                    if (prev.first == -1) prev = make_pair(i, j);\n                    else {\n                        mmap[prev.first][prev.second] = true;\n                        mmap[i][j] = true;\n                    }\n                }\n            }\n        }\n        int res = 0;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                if (mmap[i][j]) res += 1;\n        return res;\n    }\n};","date":"2023-08-25"},{"script":"python","time":204,"memory":34.5,"desc":"同上。","code":"class Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        res = 0\n        def dfs(node: TreeNode, max: int):\n            nonlocal res\n            if not node: return\n            if node.val >= max:\n                max = node.val\n                res += 1\n            dfs(node.left, max)\n            dfs(node.right, max)\n        dfs(root, -inf)\n        return res","date":"2023-08-25"},{"script":"rust","time":20,"memory":6.7,"desc":"同上。","code":"use std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn good_nodes(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        let mut res = 0;\n        fn dfs(res: &mut i32, node: &Option<Rc<RefCell<TreeNode>>>, mut max: i32) {\n            if let Some(ref node) = node {\n                let node_ref = node.as_ref().borrow();\n                if node_ref.val >= max {\n                    max = node_ref.val;\n                    *res += 1;\n                }\n                dfs(res, &node_ref.left, max);\n                dfs(res, &node_ref.right, max);\n            }\n        }\n        dfs(&mut res, &root, i32::MIN);\n        res\n    }\n}","date":"2023-08-25"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"1450.在既定时间做作业的学生人数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1450.在既定时间做作业的学生人数.json","problemData":{"id":"1560","name":"1450.在既定时间做作业的学生人数","url":"https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time","desc":"请返回在查询时间 queryTime 时正在做作业的学生人数。","solutions":[{"date":"2022-08-19","time":0,"memory":2.1,"script":"rust","desc":"遍历。","code":"impl Solution {\n    pub fn busy_student(start_time: Vec<i32>, end_time: Vec<i32>, query_time: i32) -> i32 {\n        let mut ans = 0;\n        for i in 0..start_time.len() {\n            if start_time[i] <= query_time && end_time[i] >= query_time {\n                ans += 1;\n            }\n        }\n        ans\n    }\n}"}],"tagList":["数组"],"level":"Easy"}},{"problemName":"1455.检查单词是否为句中其他单词的前缀.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1455.检查单词是否为句中其他单词的前缀.json","problemData":{"id":"1566","name":"1455.检查单词是否为句中其他单词的前缀","url":"https://leetcode.cn/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence","desc":"请你检查检索词 searchWord 是否为句子 sentence 中任意单词的前缀。","solutions":[{"date":"2022-08-21","time":4,"memory":6.1,"script":"cpp","desc":"分割字符串。","code":"class Solution {\npublic:\n    int isPrefixOfWord(string sentence, string searchWord) {\n        istringstream iss(sentence);\n        string tmp;\n        int cnt = 1;\n        while (getline(iss, tmp, ' ')) {\n            int i = 0, j = 0;\n            bool f = true;\n            for (; i < tmp.size() && j < searchWord.size(); i++, j++) {\n                if (tmp[i] != searchWord[j]) {\n                    f = false;\n                    break;\n                }\n            }\n            if (f && j == searchWord.size()) return cnt;\n            cnt++;\n        }\n        return -1;\n    }\n};"},{"date":"2022-08-21","time":56,"memory":42.2,"script":"typescript","desc":"分割字符串。","code":"function isPrefixOfWord(sentence: string, searchWord: string): number {\n  const list = sentence.split(' ');\n  for (let i = 0; i < list.length; i++) {\n    if (list[i].startsWith(searchWord)) return i + 1;\n  }\n  return -1;\n}"}],"tagList":["双指针","字符串","字符串匹配"],"level":"Easy"}},{"problemName":"1457.二叉树中的伪回文路径.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1457.二叉树中的伪回文路径.json","problemData":{"id":"1568","name":"1457.二叉树中的伪回文路径","url":"https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree","desc":"给你一棵二叉树，每个节点的值为 1 到 9 。我们称二叉树中的一条路径是 「伪回文」的，当它满足：路径经过的所有节点值的排列中，存在一个回文序列。请你返回从根到叶子节点的所有路径中 伪回文 路径的数目。","solutions":[{"script":"python","time":656,"memory":90.31,"desc":"dfs。","code":"class Solution:\n    def pseudoPalindromicPaths (self, root: Optional[TreeNode]) -> int:\n        def dfs(node: Optional[TreeNode], val: int) -> int:\n            if not node: return 0\n            val ^= (1 << node.val)\n            if not node.left and not node.right: return int(val == 0 or (val & (-val)) == val)\n            return dfs(node.left, val) + dfs(node.right, val)\n        return dfs(root, 0)","date":"2023-11-25"}],"tagList":["位运算","树","深度优先搜索","广度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"1460.通过翻转子数组使两个数组相等.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1460.通过翻转子数组使两个数组相等.json","problemData":{"id":"1556","name":"1460.通过翻转子数组使两个数组相等","url":"https://leetcode.cn/problems/make-two-arrays-equal-by-reversing-subarrays","desc":"给你两个长度相同的整数数组 target 和 arr 。每一步中，你可以选择 arr 的任意 非空子数组 并将它翻转。你可以执行此过程任意次。","solutions":[{"date":"2022-08-24","time":12,"memory":13.9,"script":"cpp","desc":"只要数的数量相同就可以匹配。","code":"class Solution {\npublic:\n    bool canBeEqual(vector<int>& target, vector<int>& arr) {\n       int map[1005] = {0};\n       for (auto &num : arr) map[num]++;\n       for (auto &num : target) {\n           if (map[num]-- == 0) return false;\n       }\n       return true;\n    }\n};"},{"date":"2022-08-24","time":0,"memory":2,"script":"rust","desc":"只要数的数量相同就可以匹配。","code":"impl Solution {\n    pub fn can_be_equal(target: Vec<i32>, arr: Vec<i32>) -> bool {\n        let mut map = [0; 1005];\n        for num in arr {\n            map[num as usize] += 1;\n        }\n        for num in target {\n            if map[num as usize] == 0 {\n                return false;\n            }\n            map[num as usize] -= 1;\n        }\n        true\n    }\n}"}],"tagList":["数组","哈希表","排序"],"level":"Easy"}},{"problemName":"1462.课程表IV.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1462.课程表IV.json","problemData":{"id":"1558","name":"1462.课程表IV","url":"https://leetcode.cn/problems/course-schedule-iv","desc":"你也得到一个数组 queries ，其中 queries[j] = [uj, vj]。对于第 j 个查询，您应该回答课程 uj 是否是课程 vj 的先决条件。返回一个布尔数组 answer ，其中 answer[j] 是第 j 个查询的答案。","solutions":[{"script":"cpp","time":816,"memory":164.73,"desc":"提前预处理。","code":"class Solution {\npublic:\n    vector<bool> checkIfPrerequisite(int numCourses, vector<vector<int>>& prerequisites, vector<vector<int>>& queries) {\n        vector<unordered_set<int>> parr(numCourses);\n        for (auto &item : prerequisites) {\n            parr[item[1]].insert(item[0]);\n        }\n        unordered_map<int, unordered_set<int>> m;\n        function<unordered_set<int>(int)> find_parent = [&](int idx) {\n            if (m.count(idx)) return m[idx];\n            unordered_set<int> res(parr[idx].begin(), parr[idx].end());\n            if (parr[idx].size()) {\n                for (auto &p : parr[idx]) {\n                    for (auto &item : find_parent(p)) {\n                        res.insert(item);\n                    }\n                }\n            }\n            return m[idx] = res;\n        };\n        for (int idx = 0; idx < numCourses; idx++) {\n            parr[idx] = find_parent(idx);\n        }\n        vector<bool> res;\n        for (auto &query : queries) {\n            res.push_back(parr[query[1]].count(query[0]));\n        }\n        return res;\n    }\n};","date":"2023-09-12"},{"script":"python","time":80,"memory":19.1,"desc":"同上。","code":"class Solution:\n    def checkIfPrerequisite(self, numCourses: int, prerequisites: List[List[int]], queries: List[List[int]]) -> List[bool]:\n        parr = [set() for _ in range(numCourses)]\n        for [item1, item2] in prerequisites:\n            parr[item2].add(item1)\n        @cache\n        def find_parent(idx: int) -> set:\n            res = set(parr[idx])\n            if len(parr[idx]):\n                for p in parr[idx]:\n                    res |= find_parent(p)\n            return res\n        for idx in range(numCourses):\n            parr[idx] = find_parent(idx)\n        return [query[0] in parr[query[1]] for query in queries]","date":"2023-09-12"},{"script":"rust","time":60,"memory":3.11,"desc":"同上。","code":"impl Solution {\n    pub fn check_if_prerequisite(\n        num_courses: i32,\n        prerequisites: Vec<Vec<i32>>,\n        queries: Vec<Vec<i32>>,\n    ) -> Vec<bool> {\n        use std::collections::{HashMap, HashSet};\n        let num_courses = num_courses as usize;\n        let mut parr = vec![HashSet::<usize>::new(); num_courses];\n        for item in prerequisites {\n            let (item1, item2) = (item[0] as usize, item[1] as usize);\n            parr[item2].insert(item1);\n        }\n        let mut m = HashMap::new();\n        fn dfs(m: &mut HashMap<usize, HashSet<usize>>, parr: &Vec<HashSet<usize>>, idx: usize) {\n            if m.contains_key(&idx) {\n                return;\n            }\n            let mut item = HashSet::new();\n            for p in &parr[idx] {\n                item.insert(*p);\n                dfs(m, parr, *p);\n                for p in m.get(p).unwrap() {\n                    item.insert(*p);\n                }\n            }\n            m.insert(idx, item);\n        }\n        for idx in 0..num_courses {\n            dfs(&mut m, &parr, idx);\n        }\n        queries\n            .into_iter()\n            .map(|query| {\n                m.get(&(query[1] as usize))\n                    .unwrap()\n                    .contains(&(query[0] as usize))\n            })\n            .collect()\n    }\n}","date":"2023-09-12"}],"tagList":["深度优先搜索","广度优先搜索","图","拓扑排序"],"level":"Medium"}},{"problemName":"1463.摘樱桃II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1463.摘樱桃II.json","problemData":{"id":"1559","name":"1463.摘樱桃II","url":"https://leetcode.cn/problems/cherry-pickup-ii","desc":"你有两个机器人帮你收集樱桃，机器人 1 从左上角格子 (0,0) 出发，机器人 2 从右上角格子 (0, cols-1) 出发。请你按照如下规则，返回两个机器人能收集的最多樱桃数目。","solutions":[{"script":"python","time":871,"memory":57.7,"desc":"dfs记录当前x坐标下，第一个人在y1，第二个人在y2时的最大樱桃数。","code":"class Solution:\n    def cherryPickup(self, grid: List[List[int]]) -> int:\n        n, m = len(grid), len(grid[0])\n        dirs = [1, 0, -1]\n        @cache\n        def dfs(x: int, y1: int, y2: int) -> int:\n            if x == n: return 0\n            res = 0\n            for dir in dirs:\n                ny1 = y1 + dir\n                if 0 <= ny1 < m:\n                    for dir in dirs:\n                        ny2 = y2 + dir\n                        if 0 <= ny2 < m:\n                            res = max(res, dfs(x + 1, ny1, ny2))\n            res += grid[x][y1]\n            if y1 != y2: res += grid[x][y2]\n            return res\n        return dfs(0, 0, m - 1)","date":"2024-05-07"}],"tagList":["数组","动态规划","矩阵"],"level":"Hard"}},{"problemName":"1464.数组中两元素的最大乘积.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1464.数组中两元素的最大乘积.json","problemData":{"id":"1574","name":"1464.数组中两元素的最大乘积","url":"https://leetcode.cn/problems/maximum-product-of-two-elements-in-an-array","desc":"给你一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)\\*(nums[j]-1) 取得最大值。","solutions":[{"date":"2022-08-27","time":0,"memory":2.5,"script":"rust","desc":"层序遍历。","code":"use std::cell::RefCell;\nuse std::collections::VecDeque;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn width_of_binary_tree(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        let root = root.unwrap();\n        let mut q = VecDeque::<(i32, Rc<RefCell<TreeNode>>)>::new();\n        q.push_back((0, root.clone()));\n        let mut ans = 1_i32;\n        let mut size = 1;\n        while !q.is_empty() {\n            let (idx, node) = q.pop_front().unwrap();\n            if node.as_ref().borrow().left.is_some() {\n                q.push_back((\n                    idx * 2 + 1,\n                    node.as_ref().borrow().left.as_ref().unwrap().clone(),\n                ));\n            }\n            if node.as_ref().borrow().right.is_some() {\n                q.push_back((\n                    idx * 2 + 2,\n                    node.as_ref().borrow().right.as_ref().unwrap().clone(),\n                ));\n            }\n            size -= 1;\n            if size == 0 {\n                size = q.len();\n                if !q.is_empty() {\n                    ans = ans.max(q.back().unwrap().0 - q.front().unwrap().0 + 1);\n                }\n            }\n        }\n        ans\n    }\n}"}],"tagList":["数组","排序","堆（优先队列）"],"level":"Easy"}},{"problemName":"1465.切割后面积最大的蛋糕.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1465.切割后面积最大的蛋糕.json","problemData":{"id":"1575","name":"1465.切割后面积最大的蛋糕","url":"https://leetcode.cn/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts","desc":"请你按数组 horizontalCuts 和 verticalCuts 中提供的水平和竖直位置切割后，请你找出 面积最大 的那份蛋糕，并返回其 面积 。","solutions":[{"script":"cpp","time":64,"memory":31.09,"desc":"排序后计算间隔。","code":"class Solution {\npublic:\n    int maxArea(int h, int w, vector<int>& horizontalCuts, vector<int>& verticalCuts) {\n        long long resH = 0, resW = 0;\n        sort(horizontalCuts.begin(), horizontalCuts.end());\n        horizontalCuts.insert(horizontalCuts.begin(), 0);\n        horizontalCuts.push_back(h);\n        for (int i = 1; i < horizontalCuts.size(); i++) resH = max(resH, (long long)horizontalCuts[i] - horizontalCuts[i - 1]);\n        sort(verticalCuts.begin(), verticalCuts.end());\n        verticalCuts.insert(verticalCuts.begin(), 0);\n        verticalCuts.push_back(w);\n        for (int i = 1; i < verticalCuts.size(); i++) resW = max(resW, (long long)verticalCuts[i] - verticalCuts[i - 1]);\n        return resH * resW % ((long long)1e9 + 7);\n    }\n};","date":"2023-10-27"},{"script":"python","time":108,"memory":27.1,"desc":"同上。","code":"class Solution:\n    def maxArea(self, h: int, w: int, horizontalCuts: List[int], verticalCuts: List[int]) -> int:\n        res = [0, 0]\n        horizontalCuts.sort()\n        horizontalCuts = [0] + horizontalCuts + [h]\n        for i in range(1, len(horizontalCuts)):\n            res[0] = max(res[0], horizontalCuts[i] - horizontalCuts[i - 1])\n        \n        verticalCuts.sort()\n        verticalCuts = [0] + verticalCuts + [w]\n        for i in range(1, len(verticalCuts)):\n            res[1] = max(res[1], verticalCuts[i] - verticalCuts[i - 1])\n        return res[0] * res[1] % (10 ** 9 + 7)","date":"2023-10-27"},{"script":"rust","time":16,"memory":4.29,"desc":"同上。","code":"impl Solution {\n    pub fn max_area(h: i32, w: i32, horizontal_cuts: Vec<i32>, vertical_cuts: Vec<i32>) -> i32 {\n        let mut horizontal_cuts = horizontal_cuts\n            .into_iter()\n            .map(|v| v as i64)\n            .collect::<Vec<_>>();\n        horizontal_cuts.sort();\n        horizontal_cuts.insert(0, 0);\n        horizontal_cuts.push(h as i64);\n        let mut h = 0;\n        for i in 1..horizontal_cuts.len() {\n            h = h.max(horizontal_cuts[i] - horizontal_cuts[i - 1]);\n        }\n        let mut vertical_cuts = vertical_cuts\n            .into_iter()\n            .map(|v| v as i64)\n            .collect::<Vec<_>>();\n        vertical_cuts.sort();\n        vertical_cuts.insert(0, 0);\n        vertical_cuts.push(w as i64);\n        let mut w = 0;\n        for i in 1..vertical_cuts.len() {\n            w = w.max(vertical_cuts[i] - vertical_cuts[i - 1]);\n        }\n        (h * w % (10i64.pow(9) + 7)) as i32\n    }\n}","date":"2023-10-27"}],"tagList":["贪心","数组","排序"],"level":"Medium"}},{"problemName":"1466.重新规划路线.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1466.重新规划路线.json","problemData":{"id":"1576","name":"1466.重新规划路线","url":"https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero","desc":"请你帮助重新规划路线方向，使每个城市都可以访问城市 0 。返回需要变更方向的最小路线数。","solutions":[{"date":"2023-12-07","script":"python","time":272,"memory":36.8,"desc":"从0点开始向外bfs。","code":"class Solution:\n    def minReorder(self, n: int, connections: List[List[int]]) -> int:\n        froms = [[] for _ in range(n)]\n        tos = [[] for _ in range(n)]\n        for a, b in connections:\n            froms[a].append(b)\n            tos[b].append(a)\n        q = deque()\n        q.append((0, 0, -1))\n        ans = 0\n        while q:\n            cur, f, p = q.popleft()\n            ans += len(froms[cur]) - f\n            for next in froms[cur]:\n                if next != p: q.append((next, 0, cur))\n            for next in tos[cur]:\n                if next != p: q.append((next, 1, cur))\n        return ans"}],"tagList":["深度优先搜索","广度优先搜索","图"],"level":"Medium"}},{"problemName":"1470.重新排列数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1470.重新排列数组.json","problemData":{"id":"1580","name":"1470.重新排列数组","url":"https://leetcode.cn/problems/shuffle-the-array","desc":"请你将数组按 [x1,y1,x2,y2,...,xn,yn] 格式重新排列，返回重排后的数组。","solutions":[{"date":"2022-08-29","time":12,"memory":6.9,"script":"cpp","desc":"层序遍历。","code":"int* shuffle(int* nums, int numsSize, int n, int* returnSize){\n     int *ans = (int *)malloc(sizeof(int) * n * 2);\n    for (int i = 0, j = n, idx = 0; idx < n * 2; i++, j++) {\n        ans[idx++] = nums[i];\n        ans[idx++] = nums[j];\n    }\n    *returnSize = 2 * n;\n    return ans;\n}"}],"tagList":["数组"],"level":"Easy"}},{"problemName":"1475.商品折扣后的最终价格.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1475.商品折扣后的最终价格.json","problemData":{"id":"1570","name":"1475.商品折扣后的最终价格","url":"https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop","desc":"请你返回一个数组，数组中第 i 个元素是折扣后你购买商品 i 最终需要支付的价格。","solutions":[{"date":"2022-09-01","time":4,"memory":9.8,"script":"cpp","desc":"单调栈。","code":"class Solution {\npublic:\n    vector<int> finalPrices(vector<int>& prices) {\n        stack<int> s;\n        vector<int> ans(prices.begin(), prices.end());\n        for (int i = 0; i < prices.size(); i++) {\n            while (s.size() && prices[s.top()] >= prices[i]) {\n                int prev = s.top();\n                s.pop();\n                ans[prev] -= prices[i];\n            }\n            s.push(i);\n        }\n        return ans;\n    }\n};"},{"date":"2022-09-01","time":0,"memory":2.1,"script":"cpp","desc":"单调栈。","code":"impl Solution {\n    pub fn final_prices(prices: Vec<i32>) -> Vec<i32> {\n        let mut s = Vec::<usize>::new();\n        let mut prices = prices;\n        for i in 0..prices.len() {\n            while !s.is_empty() && prices[*s.last().unwrap()] >= prices[i] {\n                let prev = s.pop().unwrap();\n                prices[prev] -= prices[i];\n            }\n            s.push(i);\n        }\n        prices\n    }\n}"}],"tagList":["栈","数组","单调栈"],"level":"Easy"}},{"problemName":"1480.一维数组的动态和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1480.一维数组的动态和.json","problemData":{"id":"1603","name":"1480.一维数组的动态和","url":"https://leetcode.cn/problems/running-sum-of-1d-array","desc":"请返回 nums 的动态和。","solutions":[{"date":"2021-08-28","time":84,"memory":39.4,"script":"typescript","desc":"前缀和。","code":"function runningSum(nums: number[]): number[] {\n  const ans: number[] = [0];\n  nums.forEach(num => ans.push(num + ans[ans.length - 1]));\n  return ans.slice(1);\n}"},{"date":"2021-08-28","time":84,"memory":39.4,"script":"typescript","desc":"前缀和。","code":"function runningSum(nums: number[]): number[] {\n  for (let i = 1, n = nums.length; i < n; i++) nums[i] += nums[i - 1];\n  return nums;\n}"}],"tagList":["数组","前缀和"],"level":"Easy"}},{"problemName":"1482.制作m束花所需的最少天数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1482.制作m束花所需的最少天数.json","problemData":{"id":"1605","name":"1482.制作m束花所需的最少天数","url":"https://leetcode.cn/problems/minimum-number-of-days-to-make-m-bouquets","desc":"请你返回从花园中摘 m 束花需要等待的最少的天数。如果不能摘到 m 束花则返回 -1 。","solutions":[{"date":"2021-05-09","time":136,"memory":50.3,"script":"typescript","desc":"二分法，通过最大日和最小日进行快速筛选。","code":"function minDays(bloomDay: number[], m: number, k: number): number {\n  const n = bloomDay.length;\n  const minCount = m * k;\n  if (n < minCount) return -1;\n  if (k === 1) return bloomDay.sort((a, b) => a - b)[m - 1];\n  const check = (day: number): boolean => {\n    let count = 0;\n    let flower = 0;\n    for (let i = 0; i < n && count < m; i++) {\n      if (bloomDay[i] <= day) {\n        if (++flower === k) {\n          flower = 0;\n          count++;\n        }\n      } else {\n        flower = 0;\n      }\n    }\n    return count >= m;\n  };\n  let low = 0;\n  let high = Math.max(...bloomDay);\n  while (low < high) {\n    const midDay = (low + high) >> 1;\n    if (check(midDay)) high = midDay;\n    else low = midDay + 1;\n  }\n  return low;\n}"}],"tagList":["数组","二分查找"],"level":"Medium"}},{"problemName":"1483.树节点的第K个祖先.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1483.树节点的第K个祖先.json","problemData":{"id":"1296","name":"1483.树节点的第K个祖先","url":"https://leetcode.cn/problems/kth-ancestor-of-a-tree-node","desc":"给你一棵树，树上有 n 个节点，按从 0 到 n-1 编号。树以父节点数组的形式给出，其中 parent[i] 是节点 i 的父节点。树的根节点是编号为 0 的节点。树节点的第 k 个祖先节点是从该节点到根节点路径上的第 k 个节点。","solutions":[{"script":"cpp","time":520,"memory":132.2,"desc":"倍增法。","code":"class TreeAncestor {\npublic:\n    vector<vector<int>> list;\n\n    TreeAncestor(int n, vector<int>& parent): list(vector<vector<int>>(n)) {\n        for (int i = 1; i < parent.size(); i++) {\n            list[i].push_back(parent[i]);\n            for (int j = 1, res = 1; res != -1; j++) {\n                res = getKthAncestor(i, pow(2, j));\n                if (res != -1) list[i].push_back(res);\n            }\n        }\n    }\n\n    int getKthAncestor(int node, int k) {\n        if (k == 0) return node;\n        int l = -1, r = list[node].size() - 1;\n        while (l < r) {\n            int m = (l + r + 1) / 2;\n            if (k >= pow(2, m)) l = m;\n            else r = m - 1;\n        }\n        if (l == -1) return l;\n        return getKthAncestor(list[node][l], k - pow(2, l));\n    }\n};","date":"2023-06-12"},{"script":"python","time":7080,"memory":48.2,"desc":"同上。","code":"class TreeAncestor:\n\n    def __init__(self, n: int, parent: List[int]):\n        self.list = [[] for _ in range(n)]\n        for i in range(1, len(parent)):\n            self.list[i].append(parent[i])\n            j = res = 1\n            while res != -1:\n                res = self.getKthAncestor(i, pow(2, j))\n                if res != -1:\n                    self.list[i].append(res)\n                j += 1\n\n    def getKthAncestor(self, node: int, k: int) -> int:\n        if k == 0:\n            return node\n        l = -1\n        r = len(self.list[node]) - 1\n        while l < r:\n            m = (l+r+1)//2\n            if k >= pow(2, m):\n                l = m\n            else:\n                r = m-1\n        if l == -1:\n            return l\n        return self.getKthAncestor(self.list[node][l], k-pow(2, l))\n","date":"2023-06-12"},{"script":"rust","time":204,"memory":34.9,"desc":"同上。","code":"struct TreeAncestor {\n    list: Vec<Vec<usize>>,\n}\nimpl TreeAncestor {\n    fn new(n: i32, parent: Vec<i32>) -> Self {\n        let mut list = vec![vec![]; n as usize];\n        for i in 1..parent.len() {\n            list[i].push(parent[i] as usize);\n            let mut res = 1;\n            for j in 1.. {\n                res = TreeAncestor::_get_kth_ancestor(&list, i as i32, 2i32.pow(j as u32));\n                if res != -1 {\n                    list[i].push(res as usize);\n                } else {\n                    break;\n                }\n            }\n        }\n        Self { list }\n    }\n    fn _get_kth_ancestor(list: &Vec<Vec<usize>>, node: i32, k: i32) -> i32 {\n        if k == 0 {\n            node\n        } else {\n            let mut l = -1 as i32;\n            let mut r = (list[node as usize].len() - 1) as i32;\n            while l < r {\n                let m = (l + r + 1) / 2;\n                if k >= 2i32.pow(m as u32) {\n                    l = m;\n                } else {\n                    r = m - 1;\n                }\n            }\n            if l == -1 {\n                l\n            } else {\n                TreeAncestor::_get_kth_ancestor(list, list[node as usize][l as usize] as i32, k - (2i32.pow(l as u32)))\n            }\n        }\n    }\n    fn get_kth_ancestor(&self, node: i32, k: i32) -> i32 {\n        TreeAncestor::_get_kth_ancestor(&self.list, node, k)\n    }\n}","date":"2023-06-12"},{"script":"cpp","time":392,"memory":132.1,"desc":"当前节点的第n项等于第n-1个父节点的第n-1项。","code":"class TreeAncestor {\npublic:\n    vector<vector<int>> list;\n\n    TreeAncestor(int n, vector<int>& parent): list(vector<vector<int>>(n)) {\n        for (int i = 1; i < parent.size(); i++) {\n            list[i].push_back(parent[i]);\n            for (int j = 1; ; j++) {\n                if (list[list[i].back()].size() > j - 1) list[i].push_back(list[list[i].back()][j - 1]);\n                else break;\n            }\n        }\n    }\n\n    int getKthAncestor(int node, int k) {\n        if (k == 0) return node;\n        int l = -1, r = list[node].size() - 1;\n        while (l < r) {\n            int m = (l + r + 1) / 2;\n            if (k >= pow(2, m)) l = m;\n            else r = m - 1;\n        }\n        if (l == -1) return l;\n        return getKthAncestor(list[node][l], k - pow(2, l));\n    }\n};","date":"2023-06-12"},{"script":"python","time":901,"memory":55.49,"desc":"倍增法。","code":"class TreeAncestor:\n    def __init__(self, n: int, parents: List[int]):\n        self.parents = [[] for _ in range(n + 1)]\n        children = [[] for _ in range(n + 1)]\n        for i in range(n):\n            self.parents[i].append(parents[i])\n            children[parents[i]].append(i)\n        q = deque([0])\n        while q:\n            node = q.popleft()\n            for child in children[node]:\n                q.append(child)\n            arr = self.parents[node]\n            i = 1\n            while node and len(self.parents[arr[i - 1]]) > i - 1:\n                arr.append(self.parents[arr[i - 1]][i - 1])\n                i += 1\n\n    def getKthAncestor(self, node: int, k: int) -> int:\n        idx = 0\n        while pow(2, idx + 1) <= k: idx += 1\n        if len(self.parents[node]) <= idx: return -1\n        if pow(2, idx) == k: return self.parents[node][idx]\n        return self.getKthAncestor(self.parents[node][idx], k - pow(2, idx))","date":"2024-04-06"}],"tagList":["树","深度优先搜索","广度优先搜索","设计","二分查找","动态规划"],"level":"Hard"}},{"problemName":"1486.数组异或操作.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1486.数组异或操作.json","problemData":{"id":"1610","name":"1486.数组异或操作","url":"https://leetcode.cn/problems/xor-operation-in-an-array","desc":"请返回 nums 中所有元素按位异或（XOR）后得到的结果。","solutions":[{"date":"2021-05-07","time":76,"memory":39.3,"script":"typescript","desc":"利用异或读取下一个值。","code":"function xorOperation(n: number, start: number): number {\n  return new Array(n)\n    .fill(0)\n    .map((_, i) => start + 2 * i)\n    .reduce((total, cur, i) => (i === 0 ? cur : total ^ cur));\n}"}],"tagList":["位运算","数学"],"level":"Easy"}},{"problemName":"1487.保证文件名唯一.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1487.保证文件名唯一.json","problemData":{"id":"1611","name":"1487.保证文件名唯一","url":"https://leetcode.cn/problems/making-file-names-unique","desc":"返回长度为 n 的字符串数组，其中 ans[i] 是创建第 i 个文件夹时系统分配给该文件夹的实际名称。","solutions":[{"script":"cpp","time":168,"memory":57.2,"desc":"哈希存储。","code":"class Solution {\npublic:\n    vector<string> getFolderNames(vector<string>& names) {\n        unordered_map<string, int> m;\n        for (int i = 0; i < names.size(); i++) {\n            string name = names[i];\n            if (m.count(name)) {\n                for (int j = m[name]; ; j++) {\n                    string next = name + \"(\" + to_string(j) + \")\";\n                    if (!m.count(next)) {\n                        names[i] = next;\n                        m[next] = 1;\n                        m[name] = j + 1;\n                        break;\n                    }\n                }\n            } else {\n                m[name] = 1;\n            }\n        }\n        return names;\n    }\n};","date":"2023-03-03"},{"script":"python","time":140,"memory":28.3,"desc":"同上。","code":"class Solution:\n    def getFolderNames(self, names: List[str]) -> List[str]:\n        m = {}\n        for i in range(len(names)):\n            name = names[i]\n            if name in m:\n                j = m[name]\n                while name + \"(\" + str(j) + \")\" in m:\n                    j += 1\n                next_name = name + \"(\" + str(j) + \")\"\n                names[i] = next_name\n                m[next_name] = 1\n                m[name] = j + 1\n            else:\n                m[name] = 1\n        return names","date":"2023-03-03"},{"script":"rust","time":48,"memory":9.3,"desc":"同上。","code":"impl Solution {\n    pub fn get_folder_names(names: Vec<String>) -> Vec<String> {\n        let mut names = names;\n        let mut m = std::collections::HashMap::<String, usize>::new();\n        for i in 0..names.len() {\n            let name = names[i].clone();\n            if m.contains_key(&name) {\n                let mut j = *m.get(&name).unwrap();\n                let next;\n                loop {\n                    let mut item = name.clone();\n                    item.push('(');\n                    item.push_str(&j.to_string());\n                    item.push(')');\n                    if !m.contains_key(&item) {\n                        next = item;\n                        break;\n                    }\n                    j += 1;\n                }\n                m.insert(next.clone(), 1);\n                names[i] = next.clone();\n                *m.get_mut(&name).unwrap() = j + 1;\n            } else {\n                m.insert(name.clone(), 1);\n            }\n        }\n        names\n    }\n}","date":"2023-03-03"}],"tagList":["数组","哈希表","字符串"],"level":"Medium"}},{"problemName":"1488.避免洪水泛滥.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1488.避免洪水泛滥.json","problemData":{"id":"1612","name":"1488.避免洪水泛滥","url":"https://leetcode.cn/problems/avoid-flood-in-the-city","desc":"如果有多种可行解，请返回它们中的 任意一个 。如果没办法阻止洪水，请返回一个 空的数组 。请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生。","solutions":[{"script":"python","time":3896,"memory":31.44,"desc":"记录前一次蓄满水后，最近的放空时间。","code":"class Solution:\n    def avoidFlood(self, rains: List[int]) -> List[int]:\n        full = dict()\n        empty = []\n        res = [-1] * len(rains)\n        for i, rain in enumerate(rains):\n            if rain == 0:\n                empty.append(i)\n            elif rain not in full:\n                full[rain] = i\n            else:\n                l = bisect_left(empty, full[rain])\n                if l == len(empty):\n                    return []\n                res[empty[l]] = rain\n                full[rain] = i\n                empty.pop(l)\n        for o in empty:\n            res[o] = 1\n        return res","date":"2023-10-13"}],"tagList":["贪心","数组","哈希表","二分查找","堆（优先队列）"],"level":"Medium"}},{"problemName":"1491.去掉最低工资和最高工资后的工资平均值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1491.去掉最低工资和最高工资后的工资平均值.json","problemData":{"id":"1584","name":"1491.去掉最低工资和最高工资后的工资平均值","url":"https://leetcode.cn/problems/average-salary-excluding-the-minimum-and-maximum-salary","desc":"请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。","solutions":[{"script":"python","time":41,"memory":60.37,"desc":"遍历。","code":"class Solution:\n    def average(self, salary: List[int]) -> float:\n        nmin, nmax = min(salary), max(salary)\n        return (sum(salary) - nmin - nmax) / (len(salary) - 2)","date":"2024-05-03"}],"tagList":["数组","排序"],"level":"Easy"}},{"problemName":"1494.并行课程II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1494.并行课程II.json","problemData":{"id":"1587","name":"1494.并行课程II","url":"https://leetcode.cn/problems/parallel-courses-ii","desc":"给你一个整数 n 表示某所大学里课程的数目，编号为 1 到 n ，数组 relations 中， relations[i] = [xi, yi]  表示一个先修课的关系，也就是课程 xi 必须在课程 yi 之前上。同时你还有一个整数 k 。在一个学期中，你 最多 可以同时上 k 门课，前提是这些课的先修课在之前的学期里已经上过了。请你返回上完所有课最少需要多少个学期。","solutions":[{"script":"cpp","time":680,"memory":168.4,"desc":"dfs遍历，判断同一期每个点上课的情况。","code":"#define SIZE 13\nstruct Node {\n    int idx, child_cnt;\n    unordered_set<int> parents, children;\n\n};\nclass Solution {\npublic:\n    int minNumberOfSemesters(int n, vector<vector<int>>& relations, int k) {\n        vector<Node> list(n);\n\n        for (int i = 0; i < n; i++) {\n            list[i].idx = i;\n            list[i].child_cnt = 0;\n        }\n\n        for (auto &item : relations) {\n            list[item[1] - 1].parents.insert(item[0] - 1);\n            list[item[0] - 1].children.insert(item[1] - 1);\n        }\n\n        // for (int i = 0; i < n; i++) {\n        //     cout << \"i = \" << i\n        //          << \", parent = \";\n        //     for (auto &p : list[i].parents) cout << p << \", \";\n        //     cout << \", children = \";\n        //     for (auto &c : list[i].children) cout << c << \", \";\n        //     cout << endl;\n        // }\n\n        int empty = 0, res = INT_MAX;\n        for (int i = 0; i < n; i++) {\n            if (list[i].parents.size() == 0) empty |= 1 << i;\n        }\n\n        unordered_map<int, unordered_map<int, unordered_map<int, unordered_map<int, int>>>> cache;\n        function<int(int, int, int, int)> dfs = [&](int empty, int used, int cur_res, int cur_k){\n            if (cache[empty][used][cur_res][cur_k]) return cache[empty][used][cur_res][cur_k];\n            // cout << \"dfs \"\n            //      << \", empty = \" << bitset<SIZE>(empty).to_string()\n            //      << \", used = \" << bitset<SIZE>(used).to_string()\n            //      << \", cur_res = \" << cur_res\n            //      << \", cur_k = \" << cur_k\n            //      << endl;\n            if (used == (1 << n) - 1) {\n                if (cur_k) cur_res += 1;\n                return cache[empty][used][cur_res][cur_k] = cur_res;\n            }\n\n            if (cur_k == k || empty == 0) {\n                int next_empty = empty;\n                for (int i = 0; i < n; i++) {\n                    if ((used & (1 << i)) == 0 && list[i].parents.size() == 0) next_empty |= 1 << i;\n                }\n                return cache[empty][used][cur_res][cur_k] = dfs(next_empty, used, cur_res + 1, 0);\n            }\n\n            int res = INT_MAX;\n            for (int i = 0; i < n; i++) {\n                if (empty & (1 << i)) {\n                    for (auto &c : list[i].children) list[c].parents.erase(i);\n                    res = min(res, dfs(empty & ~(1 << i), used | (1 << i), cur_res, cur_k + 1));\n                    for (auto &c : list[i].children) list[c].parents.insert(i);\n                }\n            }\n            return cache[empty][used][cur_res][cur_k] = res;\n        };\n\n        return dfs(empty, 0, 0, 0);\n    }\n};","date":"2023-06-16"}],"tagList":["位运算","图","动态规划","状态压缩"],"level":"Hard"}},{"problemName":"1499.满足不等式的最大值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1401-1500/1499.满足不等式的最大值.json","problemData":{"id":"1622","name":"1499.满足不等式的最大值","url":"https://leetcode.cn/problems/max-value-of-equation","desc":"定一个长度为 n 的环形整数数组 nums ，返回 nums 的非空 子数组 的最大可能和 。","solutions":[{"script":"cpp","time":16,"memory":19.6,"desc":"统计左右最大高度。","code":"class Solution {\npublic:\n    int trap(vector<int>& height) {\n        int sum = 0, n = height.size();\n        vector<int> r(n, 0);\n        for (int i = n - 1, cur = 0; i >= 0; i--) {\n            r[i] = cur;\n            cur = max(cur, height[i]);\n        }\n        for (int i = 0, cur = 0; i < n; i++) {\n            cur = max(cur, height[i]);\n            sum += max(0, min(cur, r[i]) - height[i]);\n        }\n        return sum;\n    }\n};","date":"2023-07-23"},{"script":"python","time":68,"memory":17.7,"desc":"同上。","code":"class Solution:\n    def trap(self, height: List[int]) -> int:\n        sum = 0\n        n = len(height)\n        cur = 0\n        r = [0] * n\n        for i in range(n-1, -1, -1):\n            r[i] = cur\n            cur = max(cur, height[i])\n        cur = 0\n        for i in range(n):\n            cur = max(cur, height[i])\n            sum += max(0, min(cur, r[i])-height[i])\n        return sum","date":"2023-07-23"},{"script":"rust","time":0,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn trap(height: Vec<i32>) -> i32 {\n        let mut sum = 0;\n        let n = height.len();\n        let mut cur = 0;\n        let mut r = vec![0; n];\n        for i in (0..n).rev() {\n            r[i] = cur;\n            cur = cur.max(height[i]);\n        }\n        cur = 0;\n        for i in 0..n {\n            cur = cur.max(height[i]);\n            sum += 0.max(cur.min(r[i]) - height[i]);\n        }\n        sum\n    }\n}","date":"2023-07-23"}],"tagList":["队列","数组","滑动窗口","单调队列","堆（优先队列）"],"level":"Hard"}}]},{"dirName":"1501-1600","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\1501-1600","problems":[{"problemName":"1508.子数组和排序后的区间和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1501-1600/1508.子数组和排序后的区间和.json","problemData":{"id":"1615","name":"1508.子数组和排序后的区间和","url":"https://leetcode.cn/problems/range-sum-of-sorted-subarray-sums","desc":"请你返回在新数组中下标为  left  到  right （下标从 1 开始）的所有数字和（包括左右端点）。由于答案可能很大，请你将它对 10^9 + 7 取模后返回。","solutions":[{"date":"2021-05-13","time":436,"memory":75.2,"script":"typescript","desc":"排序。","code":"function rangeSum(nums: number[], n: number, left: number, right: number): number {\n  const prefixSumList: number[] = [];\n  let sum = 0;\n  nums.forEach(v => prefixSumList.push((sum += v)));\n  const list: number[] = nums.slice();\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < i; j++) {\n      list.push(prefixSumList[i] - (prefixSumList[j - 1] ?? 0));\n    }\n  }\n  return (\n    list\n      .sort((a, b) => a - b)\n      .slice(left - 1, right)\n      .reduce((total, cur) => total + cur, 0) %\n    (10 ** 9 + 7)\n  );\n}"}],"tagList":["数组","双指针","二分查找","排序"],"level":"Medium"}},{"problemName":"1512.好数对的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1501-1600/1512.好数对的数目.json","problemData":{"id":"1635","name":"1512.好数对的数目","url":"https://leetcode.cn/problems/number-of-good-pairs","desc":"返回好数对的数目。","solutions":[{"date":"2021-12-11","time":76,"memory":39.5,"script":"typescript","desc":"每次遍历到一个数就查看前面有多少个相同的数。","code":"function numIdenticalPairs(nums: number[]): number {\n  const map: Record<number, number> = {};\n  let ans = 0;\n  for (const num of nums) {\n    if (!map[num]) {\n      map[num] = 1;\n    } else ans += map[num]++;\n  }\n  return ans;\n}"}],"tagList":["数组","哈希表","数学","计数"],"level":"Easy"}},{"problemName":"1518.换水问题.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1501-1600/1518.换水问题.json","problemData":{"id":"1642","name":"1518.换水问题","url":"https://leetcode.cn/problems/water-bottles","desc":"请你计算 最多 能喝到多少瓶酒。","solutions":[{"date":"2021-12-17","time":72,"memory":39.4,"script":"typescript","desc":"每次重新计算当前空瓶子数量。","code":"function numWaterBottles(numBottles: number, numExchange: number): number {\n  let ans = numBottles;\n  while (numBottles >= numExchange) {\n    const bottles = Math.floor(numBottles / numExchange);\n    ans += bottles;\n    numBottles = bottles + (numBottles % numExchange);\n  }\n  return ans;\n}"}],"tagList":["数学","模拟"],"level":"Easy"}},{"problemName":"1535.找出数组游戏的赢家.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1501-1600/1535.找出数组游戏的赢家.json","problemData":{"id":"1657","name":"1535.找出数组游戏的赢家","url":"https://leetcode.cn/problems/find-the-winner-of-an-array-game","desc":"返回赢得比赛的整数。","solutions":[{"script":"python","time":80,"memory":27.17,"desc":"遍历时记录当前最大值和最大次数。","code":"class Solution:\n    def getWinner(self, arr: List[int], k: int) -> int:\n        n = len(arr)\n        nmax = max(arr)\n        if k >= n: return nmax\n        curIndex = 0\n        curCount = 0\n        while curCount < k:\n            # print(f'===> curIndex = {curIndex}, curCount = {curCount}, arr = {arr}')\n            if arr[curIndex] == nmax: return nmax\n            nextIndex = (curIndex + 1) % n\n            if arr[curIndex] > arr[nextIndex]:\n                arr[curIndex], arr[nextIndex] = arr[nextIndex], arr[curIndex]\n            else:\n                curCount = 0\n            curCount += 1\n            curIndex = nextIndex\n            # print(f'curIndex = {curIndex}, curCount = {curCount}, arr = {arr}')\n        return arr[curIndex]","date":"2024-05-19"}],"tagList":["数组","模拟"],"level":"Medium"}},{"problemName":"1542.找出最长的超赞子字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1501-1600/1542.找出最长的超赞子字符串.json","problemData":{"id":"1668","name":"1542.找出最长的超赞子字符串","url":"https://leetcode.cn/problems/find-longest-awesome-substring","desc":"给你一个字符串 s 。请返回 s 中最长的 超赞子字符串 的长度。","solutions":[{"script":"python","time":858,"memory":16.84,"desc":"利用二进制存储便利过的奇偶。","code":"class Solution:\n    def longestAwesome(self, s: str) -> int:\n        n = len(s)\n        res = 0\n        cur = 0\n        map = { 0: -1 }\n        for i in range(n):\n            num = ord(s[i]) - ord('0')\n            cur ^= 1 << num\n            for offset in range(10):\n                v = cur ^ (1 << offset)\n                if v in map:\n                    res = max(res, i - map[v])\n            if cur in map:\n                res = max(res, i - map[cur])\n            else:\n                map[cur] = i\n        return res","date":"2024-05-20"}],"tagList":["位运算","哈希表","字符串"],"level":"Hard"}},{"problemName":"1553.吃掉N个橘子的最少天数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1501-1600/1553.吃掉N个橘子的最少天数.json","problemData":{"id":"1676","name":"1553.吃掉N个橘子的最少天数","url":"https://leetcode.cn/problems/minimum-number-of-days-to-eat-n-oranges","desc":"请你返回吃掉所有 n 个橘子的最少天数。","solutions":[{"script":"python","time":50,"memory":18.6,"desc":"尽可能用除法。","code":"class Solution:\n    @cache\n    def minDays(self, n: int) -> int:\n        if n <= 1: return n\n        return min(self.minDays(n // 2) + n % 2, self.minDays(n // 3) + n % 3) + 1","date":"2024-05-12"}],"tagList":["记忆化搜索","动态规划"],"level":"Hard"}},{"problemName":"1572.矩阵对角线元素的和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1501-1600/1572.矩阵对角线元素的和.json","problemData":{"id":"1677","name":"1572.矩阵对角线元素的和","url":"https://leetcode.cn/problems/matrix-diagonal-sum","desc":"给你一个正方形矩阵 mat，请你返回矩阵对角线元素的和。","solutions":[{"script":"cpp","time":12,"memory":10.8,"desc":"遍历，只记录最小值和第二小值。","code":"class Solution {\npublic:\n    int diagonalSum(vector<vector<int>>& mat) {\n        int n = mat.size(), res = 0;\n        for (int i = 0; i < n; i++) {\n            res += mat[i][i] + mat[i][n - i - 1];\n            if (i == n - i - 1) res -= mat[i][i];\n        }\n        return res;\n    }\n};","date":"2023-08-11"},{"script":"python","time":44,"memory":15.88,"desc":"同上。","code":"class Solution:\n    def diagonalSum(self, mat: List[List[int]]) -> int:\n        n = len(mat)\n        res = 0\n        for i in range(n):\n            res += mat[i][i] + mat[i][n - i - 1]\n            if i == n - i - 1:\n                res -= mat[i][i]\n        return res","date":"2023-08-11"},{"script":"rust","time":4,"memory":2.13,"desc":"同上。","code":"impl Solution {\n    pub fn diagonal_sum(mat: Vec<Vec<i32>>) -> i32 {\n        mat.into_iter().enumerate().fold(0, |mut sum, (i, row)| {\n            sum += row[i] + row[row.len() - 1 - i];\n            if i == row.len() - 1 - i {\n                sum -= row[i];\n            }\n            sum\n        })\n    }\n}","date":"2023-08-11"}],"tagList":["数组","矩阵"],"level":"Easy"}},{"problemName":"1574.删除最短的子数组使剩余数组有序.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1501-1600/1574.删除最短的子数组使剩余数组有序.json","problemData":{"id":"1679","name":"1574.删除最短的子数组使剩余数组有序","url":"https://leetcode.cn/problems/shortest-subarray-to-be-removed-to-make-array-sorted","desc":"给你一个整数数组 arr ，请你删除一个子数组（可以为空），使得 arr 中剩下的元素是 非递减 的。","solutions":[{"script":"cpp","time":100,"memory":65.37,"desc":"贪心的取左右最长递增。","code":"class Solution {\npublic:\n    int findLengthOfShortestSubarray(vector<int>& arr) {\n        int n = arr.size(), right = n - 1;\n        while (right - 1 >= 0 && arr[right - 1] <= arr[right]) right--;\n        if (right == 0) return 0;\n        int res = right;\n        for (int left = 0; left < n; left++) {\n            if (left && arr[left] < arr[left - 1]) break;\n            while (right < n && arr[right] < arr[left]) right++;\n            res = min(res, right - left - 1);\n        }\n        return res;\n    }\n};","date":"2023-03-25"},{"script":"python","time":72,"memory":29.8,"desc":"同上。","code":"class Solution:\n    def findLengthOfShortestSubarray(self, arr: List[int]) -> int:\n        n = len(arr)\n        r = n-1\n        while r - 1 >= 0 and arr[r-1] <= arr[r]:\n            r -= 1\n        if r == 0:\n            return 0\n        res = r\n        for l in range(n):\n            if l and arr[l] < arr[l-1]:\n                break\n            while r < n and arr[r] < arr[l]:\n                r += 1\n            res = min(res, r-l-1)\n        return res","date":"2023-03-25"},{"script":"rust","time":12,"memory":3.5,"desc":"同上。","code":"impl Solution {\n    pub fn find_length_of_shortest_subarray(arr: Vec<i32>) -> i32 {\n        let n = arr.len();\n        let mut right = n - 1;\n        while right != 0 && arr[right - 1] <= arr[right] {\n            right -= 1;\n        }\n        if right == 0 {\n            0\n        } else {\n            let mut res = right;\n            for left in 0..n {\n                if left > 0 && arr[left] < arr[left - 1] {\n                    break;\n                }\n                while right < n && arr[right] < arr[left] {\n                    right += 1\n                }\n                res = res.min(right - left - 1)\n            }\n            res as i32\n        }\n    }\n}","date":"2023-03-25"}],"tagList":["栈","数组","双指针","二分查找","单调栈"],"level":"Medium"}},{"problemName":"1576.替换所有的问号.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1501-1600/1576.替换所有的问号.json","problemData":{"id":"1698","name":"1576.替换所有的问号","url":"https://leetcode.cn/problems/replace-all-s-to-avoid-consecutive-repeating-characters","desc":"给你一个仅包含小写英文字母和 '?' 字符的字符串 s，请你将所有的 '?' 转换为若干小写字母，使最终的字符串不包含任何 连续重复 的字符。","solutions":[{"date":"2022-01-05","time":0,"memory":5.8,"script":"cpp","desc":"遍历到问号进行重新赋值 。","code":"class Solution {\n   public:\n    string modifyString(string s) {\n        for (int i = 0, n = s.size(); i < n; i++) {\n            if (s[i] != '?') continue;\n            char prev = i > 0 ? s[i - 1] : '\\0',\n                 next = i < n - 1 ? s[i + 1] : '\\0';\n            for (char ch = 'a'; ch <= 'z'; ch++) {\n                if (prev != ch && next != ch) {\n                    s[i] = ch;\n                    break;\n                }\n            }\n        }\n        return s;\n    }\n};"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"1579.保证图可完全遍历.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1501-1600/1579.保证图可完全遍历.json","problemData":{"id":"1701","name":"1579.保证图可完全遍历","url":"https://leetcode.cn/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable","desc":"给你一个数组 edges ，其中 edges[i] = [typei, ui, vi]  表示节点 ui 和 vi 之间存在类型为 typei 的双向边。请你在保证图仍能够被 Alice 和 Bob 完全遍历的前提下，找出可以删除的最大边数。如果从任何节点开始，Alice 和 Bob 都可以到达所有其他节点，则认为图是可以完全遍历的。返回可以删除的最大边数，如果 Alice 和 Bob 无法完全遍历图，则返回 -1 。","solutions":[{"date":"2021-01-27","time":312,"memory":70.6,"script":"typescript","desc":"并查集。","code":"class UnionFind {\n  elements: number[];\n  constructor(public size: number) {\n    this.elements = new Array(size).fill(0).map((_, i) => i);\n  }\n  same(v1: number, v2: number): boolean {\n    return this.find(v1) === this.find(v2);\n  }\n  find(v: number): number {\n    return v === this.elements[v] ? v : (this.elements[v] = this.find(this.elements[v]));\n  }\n  union(v1: number, v2: number): void {\n    const e1 = this.find(v1);\n    const e2 = this.find(v2);\n    if (e1 !== e2) {\n      this.elements[e1] = e2;\n      this.size--;\n    }\n  }\n}\nfunction maxNumEdgesToRemove(n: number, edges: number[][]): number {\n  let ans = 0;\n  const uf1 = new UnionFind(n);\n  const uf2 = new UnionFind(n);\n  edges.sort(([type1], [type2]) => (type1 === 3 ? -1 : 0));\n  for (let [type, u, v] of edges) {\n    u--;\n    v--;\n    if (type === 1) {\n      if (uf1.same(u, v)) ans++;\n      else uf1.union(u, v);\n    } else if (type === 2) {\n      if (uf2.same(u, v)) ans++;\n      else uf2.union(u, v);\n    } else {\n      if (uf1.same(u, v) && uf2.same(u, v)) ans++;\n      uf1.union(u, v);\n      uf2.union(u, v);\n    }\n  }\n  if (uf1.size !== 1 || uf2.size !== 1) return -1;\n  return ans;\n}"}],"tagList":["并查集","图"],"level":"Hard"}},{"problemName":"1583.统计不开心的朋友.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1501-1600/1583.统计不开心的朋友.json","problemData":{"id":"1705","name":"1583.统计不开心的朋友","url":"https://leetcode.cn/problems/count-unhappy-friends","desc":"返回 不开心的朋友的数目。","solutions":[{"date":"2021-08-14","time":140,"memory":55,"script":"typescript","desc":"n2 计算不开心的人进行累加。","code":"class Person {\n  map = new Map<number, number>();\n  constructor(public val: number, link: number[]) {\n    let c = 0;\n    for (const p of link) this.map.set(p, cpp);\n  }\n  compare(p1: Person, p2: Person): boolean {\n    return this.map.get(p1.val)! < this.map.get(p2.val)!;\n  }\n}\nfunction unhappyFriends(n: number, preferences: number[][], pairs: number[][]): number {\n  const map = new Map<number, Person>();\n  for (let i = 0; i < n; i++) map.set(i, new Person(i, preferences[i]));\n  const ans = new Array(n).fill(false);\n  for (let i = 0; i < n / 2; i++) {\n    const [v1, v2] = pairs[i];\n    const p1 = map.get(v1)!;\n    const p2 = map.get(v2)!;\n    for (let j = 0; j < i; j++) {\n      const [v3, v4] = pairs[j];\n      const p3 = map.get(v3)!;\n      const p4 = map.get(v4)!;\n      if (p1.compare(p3, p2) && p3.compare(p1, p4)) ans[v1] = ans[v3] = true;\n      if (p1.compare(p4, p2) && p4.compare(p1, p3)) ans[v1] = ans[v4] = true;\n      if (p2.compare(p3, p1) && p3.compare(p2, p4)) ans[v2] = ans[v3] = true;\n      if (p2.compare(p4, p1) && p4.compare(p2, p3)) ans[v2] = ans[v4] = true;\n    }\n  }\n  return ans.filter(Boolean).length;\n}"}],"tagList":["数组","模拟"],"level":"Medium"}},{"problemName":"1588.所有奇数长度子数组的和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1501-1600/1588.所有奇数长度子数组的和.json","problemData":{"id":"1693","name":"1588.所有奇数长度子数组的和","url":"https://leetcode.cn/problems/sum-of-all-odd-length-subarrays","desc":"请你返回 arr 中 所有奇数长度子数组的和 。","solutions":[{"date":"2021-08-29","time":84,"memory":39.7,"script":"typescript","desc":"前缀和。","code":"function sumOddLengthSubarrays(arr: number[]): number {\n  const n = arr.length;\n  const sums = [0];\n  arr.forEach(v => sums.push(v + sums[sums.length - 1]));\n  let ans = 0;\n  for (let l = 0; l <= n; l++) {\n    for (let r = l + 1; r <= n; r += 2) {\n      ans += sums[r] - sums[l];\n    }\n  }\n  return ans;\n}"}],"tagList":["数组","数学","前缀和"],"level":"Easy"}},{"problemName":"1590.使数组和能被P整除.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1501-1600/1590.使数组和能被P整除.json","problemData":{"id":"1694","name":"1590.使数组和能被P整除","url":"https://leetcode.cn/problems/make-sum-divisible-by-p","desc":"给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空），使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 -1 。","solutions":[{"script":"cpp","time":152,"memory":65,"desc":"前缀和，如果sum%p=x, 那么(f[i+1]-f[j])%p=x才可以求得值。","code":"class Solution {\npublic:\n    int minSubarray(vector<int>& nums, int p) {\n        unordered_map<int, int> m;\n        m[0] = -1;\n        int n = nums.size(), cur = 0, res = n, sum = 0;\n        for (auto &num : nums) sum = (sum + num) % p;\n        if (sum == 0) return 0;\n        for (int i = 0; i < n; i++) {\n            cur = (cur + nums[i]) % p;\n            if (m.count((cur - sum + p) % p)) res = min(res, i - m[(cur - sum + p) % p]);\n            m[cur] = i;\n        }\n        return res == n ? -1 : res;\n    }\n};","date":"2023-03-10"},{"script":"python","time":128,"memory":35.5,"desc":"同上。","code":"class Solution:\n    def minSubarray(self, nums: List[int], p: int) -> int:\n        m = dict()\n        m[0] = -1\n        n, cur, res, sums = len(nums), 0, 0x3f3f3f3f, sum(nums) % p\n        if sums == 0:\n            return 0\n        for i in range(n):\n            cur = (cur + nums[i]) % p\n            if (cur - sums + p) % p in m:\n                res = min(res, i - m[(cur - sums + p) % p])\n            m[cur] = i\n        return res if res != n else -1","date":"2023-03-10"},{"script":"rust","time":28,"memory":4.7,"desc":"同上。","code":"impl Solution {\n    pub fn min_subarray(nums: Vec<i32>, p: i32) -> i32 {\n        let mut m = std::collections::HashMap::<i32, i32>::new();\n        m.insert(0, -1);\n        let (n, mut cur, mut sums) = (nums.len(), 0, 0);\n        let mut res = n as i32;\n        for num in nums.iter() {\n            sums = (sums + num) % p;\n        }\n        if sums == 0 {\n            0\n        } else {\n            for i in 0..n {\n                cur = (cur + nums[i]) % p;\n                let target = (cur - sums + p) % p;\n                if m.contains_key(&target) {\n                    res = res.min(i as i32 - m.get(&target).unwrap());\n                }\n                m.insert(cur, i as i32);\n            }\n            if res == n as i32 {\n                -1\n            } else {\n                res\n            }\n        }\n    }\n}","date":"2023-03-10"}],"tagList":["数组","哈希表","前缀和"],"level":"Medium"}},{"problemName":"1592.重新排列单词间的空格.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1501-1600/1592.重新排列单词间的空格.json","problemData":{"id":"1714","name":"1592.重新排列单词间的空格","url":"https://leetcode.cn/problems/rearrange-spaces-between-words","desc":"返回 重新排列空格后的字符串 。","solutions":[{"date":"2022-09-07","time":0,"memory":5.4,"script":"c","desc":"重组。","code":"char * reorderSpaces(char * text){\n    int len = strlen(text), list_len = 0, blank_cnt = 0;\n    char *list[100] = {0}, *ans = (char *)calloc(len + 1, sizeof(char));\n    for (int i = 0; i < len; i++) {\n        if (text[i] == ' ') blank_cnt++;\n        else {\n            list[list_len++] = text + i;\n            while (i + 1< len && text[i + 1] != ' ') i++;\n        }\n    }\n    int blank_common_cnt = list_len > 1 ? blank_cnt / (list_len - 1) : 0,\n        blank_last_cnt   = list_len > 1 ? blank_cnt % (list_len - 1) : blank_cnt,\n        ans_len = 0;\n    for (int i = 0; i < list_len; i++) {\n        for (char *j = list[i]; *j != ' ' && *j != '\\0'; j++) ans[ans_len++] = *j;\n        if (i == list_len - 1) for (int i = 0; i < blank_last_cnt; i++) ans[ans_len++] = ' ';\n        else for (int i = 0; i < blank_common_cnt; i++) ans[ans_len++] = ' ';\n    }\n    return ans;\n}"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"1595.连通两组点的最小成本.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1501-1600/1595.连通两组点的最小成本.json","problemData":{"id":"1717","name":"1595.连通两组点的最小成本","url":"https://leetcode.cn/problems/minimum-cost-to-connect-two-groups-of-points","desc":"给你两组点，其中第一组中有 size1 个点，第二组中有 size2 个点，且 size1 >= size2 。任意两点间的连接成本 cost 由大小为 size1 x size2 矩阵给出，其中 cost[i][j] 是第一组中的点 i 和第二组中的点 j 的连接成本。如果两个组中的每个点都与另一组中的一个或多个点连接，则称这两组点是连通的。换言之，第一组中的每个点必须至少与第二组中的一个点连接，且第二组中的每个点必须至少与第一组中的一个点连接。返回连通两组点所需的最小成本。","solutions":[{"script":"cpp","time":104,"memory":9.8,"desc":"dp[i][j]表示只有i个第一行元素的时候，已经使用了bitcount(j)个第二行元素时的最小开销。","code":"class Solution {\npublic:\n    int connectTwoGroups(vector<vector<int>>& cost) {\n        int n = cost.size(), m = cost[0].size();\n        vector<vector<int>>cache(n + 1, vector<int>(1 << m, 0x3f3f3f3f));\n        cache[0][0] = 0;\n        for (int i = 1; i <= n; i++) {\n            for (int mask = 0; mask < (1 << m); mask++) {\n                for (int j = 0; j < m; j++) {\n                    if (mask & (1 << j)) {\n                        cache[i][mask] = min(cache[i][mask], cache[i][mask & ~(1 << j)] + cost[i - 1][j]);\n                        cache[i][mask] = min(cache[i][mask], cache[i - 1][mask] + cost[i - 1][j]);\n                        cache[i][mask] = min(cache[i][mask], cache[i - 1][mask & ~(1 << j)] + cost[i - 1][j]);\n                    }\n                }\n            }\n        }\n        return cache[n][(1 << m) - 1];\n    }\n};","date":"2023-06-20"},{"script":"python","time":1308,"memory":16.8,"desc":"同上。","code":"class Solution:\n    def connectTwoGroups(self, cost: List[List[int]]) -> int:\n        n = len(cost)\n        m = len(cost[0])\n        cache = [[inf for _ in range(1 << m)] for _ in range(n + 1)]\n        cache[0][0] = 0\n        for i in range(1, n+1):\n            for mask in range(1 << m):\n                for j in range(m):\n                    if mask & (1 << j):\n                        cache[i][mask] = min(\n                            cache[i][mask], cache[i][mask & ~(1 << j)] + cost[i - 1][j])\n                        cache[i][mask] = min(\n                            cache[i][mask], cache[i - 1][mask] + cost[i - 1][j])\n                        cache[i][mask] = min(\n                            cache[i][mask], cache[i - 1][mask & ~(1 << j)] + cost[i - 1][j])\n        return cache[n][(1 << m) - 1]","date":"2023-06-20"},{"script":"rust","time":16,"memory":2.3,"desc":"同上。","code":"impl Solution {\n    pub fn connect_two_groups(cost: Vec<Vec<i32>>) -> i32 {\n        let n = cost.len();\n        let m = cost[0].len();\n        let mut cache = vec![vec![0x3f3f3f3f; 1 << m]; n + 1];\n        cache[0][0] = 0;\n        for i in 1..=n {\n            for mask in 0..(1 << m) {\n                for j in 0..m {\n                    if (mask & (1 << j)) != 0 {\n                        cache[i][mask] = cache[i][mask]\n                            .min(cache[i][mask & !(1 << j)] + cost[i - 1][j])\n                            .min(cache[i - 1][mask] + cost[i - 1][j])\n                            .min(cache[i - 1][mask & !(1 << j)] + cost[i - 1][j]);\n                    }\n                }\n            }\n        }\n        return cache[n][(1 << m) - 1];\n    }\n}","date":"2023-06-20"}],"tagList":["位运算","数组","动态规划","状态压缩","矩阵"],"level":"Hard"}},{"problemName":"1598.文件夹操作日志搜集器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1501-1600/1598.文件夹操作日志搜集器.json","problemData":{"id":"1720","name":"1598.文件夹操作日志搜集器","url":"https://leetcode.cn/problems/crawler-log-folder","desc":"执行完所有变更文件夹操作后，请你找出 返回主文件夹所需的最小步数 。","solutions":[{"date":"2022-09-09","time":0,"memory":2.1,"script":"rust","desc":"[1, k+1, 2, k, 3, k-1..]排列。","code":"impl Solution {\n    pub fn min_operations(logs: Vec<String>) -> i32 {\n        let mut ans = 0_i32;\n        for log in logs {\n            if log.eq(\"../\") {\n                ans = (ans - 1).max(0);\n            } else if log.ne(\"./\") {\n                ans += 1;\n            }\n        }\n        ans\n    }\n}"}],"tagList":["栈","数组","字符串"],"level":"Easy"}},{"problemName":"1599.经营摩天轮的最大利润.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1501-1600/1599.经营摩天轮的最大利润.json","problemData":{"id":"1721","name":"1599.经营摩天轮的最大利润","url":"https://leetcode.cn/problems/maximum-profit-of-operating-a-centennial-wheel","desc":"返回最大化利润所需执行的 最小轮转次数 。","solutions":[{"script":"cpp","time":100,"memory":79.5,"desc":"模拟。","code":"class Solution {\npublic:\n    int minOperationsMaxProfit(vector<int>& customers, int boardingCost, int runningCost) {\n        int resMax = 0, resCnt = -1, wait = 0, cur = 0, i = 0;\n        while (wait != 0 || i < customers.size()) {\n            if (i < customers.size()) wait += customers[i];\n            cur += min(wait, 4) * boardingCost - runningCost;\n            wait = max(wait - 4, 0);\n            if (cur > resMax) resMax = cur, resCnt = i + 1;\n            i += 1;\n        }\n        return resCnt;\n    }\n};","date":"2023-03-05"},{"script":"python","time":1656,"memory":19.1,"desc":"同上。","code":"class Solution:\n        def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n            resMax, resCnt = 0, -1\n            wait, cur, i = 0, 0, 0\n            while wait != 0 or i < len(customers):\n                if i < len(customers):\n                    wait += customers[i]\n                cur += min(wait, 4) * boardingCost - runningCost\n                wait = max(wait - 4, 0)\n                if cur > resMax:\n                    resMax = cur\n                    resCnt = i + 1\n                i += 1\n            return resCnt","date":"2023-03-05"},{"script":"rust","time":24,"memory":2.8,"desc":"同上。","code":"impl Solution {\n    pub fn min_operations_max_profit(\n        customers: Vec<i32>,\n        boarding_cost: i32,\n        running_cost: i32,\n    ) -> i32 {\n        let (mut resMax, mut resCnt, mut wait, mut cur, mut i) = (0, -1, 0, 0, 0);\n        while wait != 0 || i < customers.len() {\n            if i < customers.len() {\n                wait += customers[i];\n            }\n            cur += wait.min(4) * boarding_cost - running_cost;\n            wait = 0.max(wait - 4);\n            if cur > resMax {\n                resMax = cur;\n                resCnt = i as i32 + 1;\n            }\n            i += 1;\n        }\n        resCnt\n    }\n}","date":"2023-03-05"},{"script":"python","time":1200,"memory":20.89,"desc":"模拟。","code":"class Solution:\n    def minOperationsMaxProfit(self, customers: List[int], boardingCost: int, runningCost: int) -> int:\n        costCnt = costSum = resSum =0\n        resCnt = -1\n        mask = 0b0000\n        wait = 0\n        \n        def walk():\n            nonlocal costCnt, costSum, resSum, resCnt, mask, wait\n            cnt = min(wait, 4)\n            costSum += cnt * boardingCost - runningCost\n            wait -= cnt\n            costCnt += 1\n            mask = ((mask << 1) | 0b0001) & 0b1111\n            if costSum > resSum:\n                resCnt, resSum = costCnt, costSum\n\n        for v in customers:\n            wait += v\n            walk()\n\n        while wait: walk()\n        return resCnt","date":"2024-01-01"}],"tagList":["数组","模拟"],"level":"Medium"}},{"problemName":"1600.王位继承顺序.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1501-1600/1600.王位继承顺序.json","problemData":{"id":"1722","name":"1600.王位继承顺序","url":"https://leetcode.cn/problems/throne-inheritance","desc":"一个王国里住着国王、他的孩子们、他的孙子们等等。通过以上的函数，我们总是能得到一个唯一的继承顺序。","solutions":[{"date":"2021-06-20","time":188,"memory":43.8,"script":"typescript","desc":"前序遍历。","code":"class Person {\n  children: Person[] = [];\n  dead = false;\n  constructor(public name: string) {}\n}\nclass ThroneInheritance {\n  king = new Person('');\n  nameMap = new Map<string, Person>();\n  constructor(kingName: string) {\n    this.king.name = kingName;\n    this.nameMap.set(kingName, this.king);\n  }\n  birth(parentName: string, childName: string): void {\n    const parent = this.nameMap.get(parentName)!;\n    const child = new Person(childName);\n    this.nameMap.set(childName, child);\n    parent.children.push(child);\n  }\n  death(name: string): void {\n    this.nameMap.get(name)!.dead = true;\n  }\n  getInheritanceOrder(): string[] {\n    return this._getInheritanceOrder(this.king)\n      .filter(v => !v.dead)\n      .map(v => v.name);\n  }\n  private _getInheritanceOrder(person: Person): Person[] {\n    const ans: Person[] = [person];\n    person.children.forEach(child => {\n      ans.push(...this._getInheritanceOrder(child));\n    });\n    return ans;\n  }\n}"},{"script":"python","time":333,"memory":68.36,"desc":"前序遍历。","code":"class ThroneInheritance:\n    def __init__(self, kingName: str):\n        self.kingName = kingName\n        self.children = defaultdict(list)\n        self.dead = set()\n    def birth(self, parentName: str, childName: str) -> None:\n        self.children[parentName].append(childName)\n    def death(self, name: str) -> None:\n        self.dead.add(name)\n    def successor(self, x: str, curOrder: List[str]) -> List[str]:\n        if x not in self.dead: curOrder.append(x)\n        for child in self.children[x]:\n            self.successor(child, curOrder)\n        return curOrder\n    def getInheritanceOrder(self) -> List[str]:\n        return self.successor(self.kingName, [])","date":"2024-04-07"}],"tagList":["树","深度优先搜索","设计","哈希表"],"level":"Medium"}}]},{"dirName":"1601-1700","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\1601-1700","problems":[{"problemName":"1601.最多可达成的换楼请求数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1601.最多可达成的换楼请求数目.json","problemData":{"id":"1723","name":"1601.最多可达成的换楼请求数目","url":"https://leetcode.cn/problems/maximum-number-of-achievable-transfer-requests","desc":"请你从原请求列表中选出若干个请求，使得它们是一个可行的请求列表，并返回所有可行列表中最大请求数目。","solutions":[{"date":"2022-02-28","time":416,"memory":24.1,"script":"cpp","desc":"统计所有环，依次选择环。","code":"class Solution {\n   public:\n    struct node {\n        int data, cnt;\n        unordered_map<int, int> next;\n    };\n    int maximumRequests(int n, vector<vector<int>> &requests) {\n        vector<node> list(n);\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            list[i].data = i;\n            list[i].cnt = 0;\n        }\n        for (auto &request : requests) {\n            int from = request[0], to = request[1];\n            if (from == to) {\n                ans++;\n                continue;\n            }\n            list[from].next[to]++;\n            list[from].cnt++;\n        }\n        unordered_set<int> s;\n        vector<vector<int>> arr;\n        for (int i = 0; i < n; i++) {\n            vector<vector<int>> res = getlist(list, i, s, i, 1);\n            for (auto &item : res) {\n                reverse(item.begin(), item.end());\n                arr.push_back(item);\n            }\n        }\n        return dfs(list, arr, s) + ans;\n    }\n\n    int dfs(vector<node> &list, vector<vector<int>> &arr,\n            unordered_set<int> &used) {\n        int n = arr.size(), ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (used.count(i) || !check(list, arr[i])) continue;\n            int cur = 0, cnt = 0;\n            while (check(list, arr[i])) {\n                cnt++;\n                cur += arr[i].size() - 1;\n                setlist(list, arr[i], -1);\n            }\n            used.insert(i);\n            cur += dfs(list, arr, used);\n            used.erase(i);\n            while (cnt--) setlist(list, arr[i], 1);\n            ans = max(ans, cur);\n        }\n        return ans;\n    }\n\n    void setlist(vector<node> &list, vector<int> &arr, int add) {\n        for (int i = 0; i < arr.size() - 1; i++) {\n            list[arr[i]].next[arr[i + 1]] += add;\n        }\n    }\n    bool check(vector<node> &list, vector<int> &arr) {\n        for (int i = 0; i < arr.size() - 1; i++) {\n            if (list[arr[i]].next[arr[i + 1]] == 0) return 0;\n        }\n        return 1;\n    }\n    vector<vector<int>> getlist(vector<node> &list, int &find,\n                                unordered_set<int> &s, int cur, int init) {\n        vector<vector<int>> ans;\n        if (init == 0 && cur == find) {\n            vector<int> res(1, cur);\n            ans.push_back(res);\n            return ans;\n        }\n        s.insert(cur);\n        for (auto &item : list[cur].next) {\n            if (!s.count(item.first) || init == 0 && item.first == find) {\n                vector<vector<int>> nextlist =\n                    getlist(list, find, s, item.first, 0);\n                if (nextlist.size() == 0) continue;\n                for (auto &next : nextlist) {\n                    next.push_back(cur);\n                    ans.push_back(next);\n                }\n            }\n        }\n        s.erase(cur);\n        return ans;\n    }\n};"},{"date":"2022-02-28","time":36,"memory":8.6,"script":"cpp","desc":"对于每个请求都选择或不选择。","code":"class Solution {\n   public:\n    int ans = 0, samecnt = 0;\n    vector<vector<int>> list;\n    vector<int> houses = vector<int>(20, 0);\n    int maximumRequests(int n, vector<vector<int>> &requests) {\n        for (auto &request : requests) {\n            if (request[0] == request[1]) {\n                samecnt++;\n                continue;\n            }\n            list.push_back(request);\n        }\n        dfs(0, 0);\n        return ans + samecnt;\n    }\n    void dfs(int idx, int cnt) {\n        if (idx == list.size()) {\n            for (auto &house : houses) {\n                if (house) return;\n            }\n            ans = max(ans, cnt);\n            return;\n        }\n        dfs(idx + 1, cnt);\n        houses[list[idx][0]]++;\n        houses[list[idx][1]]--;\n        dfs(idx + 1, cnt + 1);\n        houses[list[idx][0]]--;\n        houses[list[idx][1]]++;\n    }\n};"}],"tagList":["位运算","数组","回溯","枚举"],"level":"Hard"}},{"problemName":"1603.设计停车系统.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1603.设计停车系统.json","problemData":{"id":"1708","name":"1603.设计停车系统","url":"https://leetcode.cn/problems/design-parking-system","desc":"请你给一个停车场设计一个停车系统。停车场总共有三种不同大小的车位：大，中和小，每种尺寸分别有固定数目的车位。","solutions":[{"date":"2021-03-19","time":164,"memory":45.3,"script":"typescript","desc":"利用数组维护数量。","code":"class ParkingSystem {\n  private parkingLot: number[];\n  constructor(big: number, medium: number, small: number) {\n    this.parkingLot = [big, medium, small];\n  }\n  addCar(carType: number): boolean {\n    if (this.parkingLot[carType - 1] > 0) {\n      this.parkingLot[carType - 1]--;\n      return true;\n    } else return false;\n  }\n}"}],"tagList":["设计","计数","模拟"],"level":"Easy"}},{"problemName":"1604.警告一小时内使用相同员工卡大于等于三次的人.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1604.警告一小时内使用相同员工卡大于等于三次的人.json","problemData":{"id":"1709","name":"1604.警告一小时内使用相同员工卡大于等于三次的人","url":"https://leetcode.cn/problems/alert-using-same-key-card-three-or-more-times-in-a-one-hour-period","desc":"请你返回去重后的收到系统警告的员工名字，将它们按 字典序升序 排序后返回。","solutions":[{"script":"cpp","time":236,"memory":97.4,"desc":"遍历。","code":"class Solution {\npublic:\n    vector<string> alertNames(vector<string>& keyName, vector<string>& keyTime) {\n        unordered_map<string, vector<int>> m;\n        vector<string> ans;\n        for (int i = 0; i < keyName.size(); i++) {\n            string &name = keyName[i];\n            int time = (keyTime[i][0] * 10 + keyTime[i][1]) * 60 + keyTime[i][3] * 10 + keyTime[i][4];\n            m[name].push_back(time);\n        }\n        for (auto &item : m) {\n            sort(item.second.begin(), item.second.end());\n            for (int i = 2; i < item.second.size(); i++) {\n                if (item.second[i] - item.second[i - 2] <= 60) {\n                    ans.push_back(item.first);\n                    break;\n                }\n            }\n        }\n        sort(ans.begin(), ans.end());\n        return ans;\n    }\n};","date":"2023-02-07"},{"script":"python","time":188,"memory":36.8,"desc":"同上。","code":"class Solution:\n    def alertNames(self, keyName: List[str], keyTime: List[str]) -> List[str]:\n        m = defaultdict(list)\n        for i in range(len(keyName)):\n            time = (ord(keyTime[i][0]) * 10 + ord(keyTime[i][1])) *                 60 + ord(keyTime[i][3]) * 10 + ord(keyTime[i][4])\n            m[keyName[i]].append(time)\n        ans = []\n        for k, v in m.items():\n            v.sort()\n            for i in range(2, len(v)):\n                if v[i] - v[i - 2] <= 60:\n                    ans.append(k)\n                    break\n        ans.sort()\n        return ans","date":"2023-02-07"},{"script":"rust","time":76,"memory":18.6,"desc":"同上。","code":"impl Solution {\n  pub fn alert_names(key_name: Vec<String>, key_time: Vec<String>) -> Vec<String> {\n      use std::collections::HashMap;\n      let mut m = HashMap::<String, Vec<i32>>::new();\n      let mut key_name = key_name.into_iter();\n      let mut key_time = key_time.into_iter();\n      loop {\n          let key_name = key_name.next();\n          let key_time = key_time.next().map(|time| {\n              let time = time.chars().map(|v| v as i32).collect::<Vec<i32>>();\n              (time[0] * 10 + time[1]) * 60 + time[3] * 10 + time[4]\n          });\n          if key_name.is_none() {\n              break;\n          }\n          let list = m.entry(key_name.unwrap()).or_insert(Vec::new());\n          list.push(key_time.unwrap());\n      }\n      let mut ans = Vec::new();\n      for (k, mut v) in m {\n          v.sort();\n          for i in 2..v.len() {\n              if v[i] - v[i - 2] <= 60 {\n                  ans.push(k);\n                  break;\n              }\n          }\n      }\n      ans.sort();\n      ans\n  }","date":"2023-02-07"}],"tagList":["数组","哈希表","字符串","排序"],"level":"Medium"}},{"problemName":"1605.给定行和列的和求可行矩阵.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1605.给定行和列的和求可行矩阵.json","problemData":{"id":"1711","name":"1605.给定行和列的和求可行矩阵","url":"https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums","desc":"请找到大小为 rowSum.length x colSum.length 的任意 非负整数 矩阵，且该矩阵满足 rowSum 和 colSum 的要求。","solutions":[{"script":"cpp","time":48,"memory":32.6,"desc":"遍历。","code":"class Solution {\npublic:\n    vector<vector<int>> restoreMatrix(vector<int>& rowSum, vector<int>& colSum) {\n        int n = rowSum.size(), m = colSum.size();\n        vector<vector<int>> res(n, vector<int>(m, 0));\n        for (int i = 0, j = 0; i < n && j < m;) {\n            int v = min(rowSum[i], colSum[j]);\n            res[i][j] = v;\n            rowSum[i] -= v;\n            colSum[j] -= v;\n            if (rowSum[i] == 0) i++;\n            if (colSum[j] == 0) j++;\n        }\n        return res;\n    }\n};","date":"2023-03-14"},{"script":"python","time":64,"memory":19.5,"desc":"遍历。","code":"class Solution:\n    def restoreMatrix(self, rowSum: List[int], colSum: List[int]) -> List[List[int]]:\n        n, m = len(rowSum), len(colSum)\n        res = [[0] * m for _ in range(n)]\n        i, j = 0, 0\n        while i < n and j < m:\n            v = min(rowSum[i], colSum[j])\n            res[i][j] = v\n            rowSum[i] -= v\n            colSum[j] -= v\n            if not rowSum[i]:\n                i += 1\n            if not colSum[j]:\n                j += 1\n        return res","date":"2023-03-14"},{"script":"rust","time":60,"memory":3.5,"desc":"同上。","code":"impl Solution {\n    pub fn restore_matrix(mut row_sum: Vec<i32>, mut col_sum: Vec<i32>) -> Vec<Vec<i32>> {\n        let (n, m) = (row_sum.len(), col_sum.len());\n        let mut res = vec![vec![0; m]; n];\n        let (mut i, mut j) = (0, 0);\n        while i < n && j < m {\n            let v = row_sum[i].min(col_sum[j]);\n            res[i][j] = v;\n            row_sum[i] -= v;\n            col_sum[j] -= v;\n            if row_sum[i] == 0 {\n                i += 1;\n            }\n            if col_sum[j] == 0 {\n                j += 1;\n            }\n        }\n        res\n    }\n}","date":"2023-03-14"}],"tagList":["贪心","数组","矩阵"],"level":"Medium"}},{"problemName":"1608.特殊数组的特征值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1608.特殊数组的特征值.json","problemData":{"id":"1730","name":"1608.特殊数组的特征值","url":"https://leetcode.cn/problems/special-array-with-x-elements-greater-than-or-equal-x","desc":"如果存在一个数 x ，使得 nums 中恰好有 x 个元素 大于或者等于 x ，那么就称 nums 是一个 特殊数组 ，而 x 是该数组的 特征值 。","solutions":[{"date":"2022-09-12","time":0,"memory":8.1,"script":"cpp","desc":"排序后遍历。","code":"class Solution {\npublic:\n    int specialArray(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size(), cnt = n;\n        for (int i = 0; i < n; i++, cnt--) {\n            if (nums[i] >= cnt && (i > 0 && cnt > nums[i - 1] || i == 0)) return cnt;\n        }\n        return -1;\n    }\n};"}],"tagList":["数组","二分查找","排序"],"level":"Easy"}},{"problemName":"1609.奇偶树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1609.奇偶树.json","problemData":{"id":"1731","name":"1609.奇偶树","url":"https://leetcode.cn/problems/even-odd-tree","desc":"给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。","solutions":[{"date":"2021-12-25","time":216,"memory":147.2,"script":"cpp","desc":"层序遍历。","code":"class Solution {\n   public:\n    bool isEvenOddTree(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int size = 1, data = 1, pre = 0;\n        while (q.size()) {\n            TreeNode* node = q.front();\n            if ((node->val & 1) != data) return 0;\n            if (data == 1 && node->val <= pre || data == 0 && node->val >= pre)\n                return 0;\n            q.pop();\n            pre = node->val;\n            if (node->left) q.push(node->left);\n            if (node->right) q.push(node->right);\n            if (--size == 0) {\n                size = q.size();\n                data ^= 1;\n                pre = data ? 0 : 1e6;\n            }\n        }\n        return 1;\n    }\n};"}],"tagList":["树","广度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"1610.可见点的最大数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1610.可见点的最大数目.json","problemData":{"id":"1733","name":"1610.可见点的最大数目","url":"https://leetcode.cn/problems/maximum-number-of-visible-points","desc":"返回你能看到的点的最大数目。","solutions":[{"date":"2021-12-16","time":572,"memory":77.3,"script":"typescript","desc":"遍历每个点获取角度值。","code":"function visiblePoints(points: number[][], angle: number, location: number[]): number {\n  const [x, y] = location;\n  const list: number[] = [];\n  let same = 0;\n  for (const [px, py] of points) {\n    if (px === x && py === y) {\n      same++;\n      continue;\n    }\n    const angle = (Math.atan2(py - y, px - x) * 180) / Math.PI;\n    list.push(angle, angle + 360);\n  }\n  list.sort((a, b) => a - b);\n  const n = list.length;\n  let l = 0;\n  let r = 0;\n  let ans = 0;\n  while (r < n) {\n    while (r < n && list[r] - list[l] <= angle) r++;\n    ans = Math.max(ans, r - l);\n    l++;\n  }\n  return ans + same;\n}"}],"tagList":["几何","数组","数学","排序","滑动窗口"],"level":"Hard"}},{"problemName":"1614.括号的最大嵌套深度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1614.括号的最大嵌套深度.json","problemData":{"id":"1737","name":"1614.括号的最大嵌套深度","url":"https://leetcode.cn/problems/maximum-nesting-depth-of-the-parentheses","desc":"给你一个 有效括号字符串 s，返回该字符串的 s 嵌套深度 。","solutions":[{"date":"2022-01-07","time":0,"memory":6.1,"script":"cpp","desc":"记录括号。","code":"class Solution {\n   public:\n    int maxDepth(string s) {\n        int ans = 0, cur = 0;\n        for (auto& ch : s) {\n            if (ch == '(')\n                ans = max(ans, ++cur);\n            else if (ch == ')')\n                --cur;\n        }\n        return ans;\n    }\n};"}],"tagList":["栈","字符串"],"level":"Easy"}},{"problemName":"1615.最大网络秩.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1615.最大网络秩.json","problemData":{"id":"1738","name":"1615.最大网络秩","url":"https://leetcode.cn/problems/maximal-network-rank","desc":"给你整数 n 和数组 roads，返回整个基础设施网络的 最大网络秩 。","solutions":[{"script":"cpp","time":96,"memory":38.1,"desc":"枚举。","code":"class Solution {\npublic:\n    int maximalNetworkRank(int n, vector<vector<int>>& roads) {\n        vector<unordered_set<int>> list(n);\n        for (auto &road : roads) {\n            list[road[0]].insert(road[1]);\n            list[road[1]].insert(road[0]);\n        }\n        int res = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i != j) {\n                    int add = list[i].count(j) ? -1 : 0;\n                    res = max(res, add + (int)list[i].size() + (int)list[j].size());\n                }\n            }\n        }\n        return res;\n    }\n};","date":"2023-03-15"},{"script":"python","time":120,"memory":16.7,"desc":"同上。","code":"class Solution:\n    def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n        l = [set() for _ in range(n)]\n        for [n1, n2] in roads:\n            l[n1].add(n2)\n            l[n2].add(n1)\n        res = 0\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    res = max(res, len(l[i]) + len(l[j]) + (-1 if j in l[i] else 0))\n        return res","date":"2023-03-15"},{"script":"rust","time":24,"memory":2.4,"desc":"同上。","code":"impl Solution {\n    pub fn maximal_network_rank(n: i32, roads: Vec<Vec<i32>>) -> i32 {\n        let n = n as usize;\n        let mut list = vec![std::collections::HashSet::<usize>::new(); n];\n        for road in roads {\n            let (n1, n2) = (road[0] as usize, road[1] as usize);\n            list[n1].insert(n2);\n            list[n2].insert(n1);\n        }\n        let mut res = 0;\n        for i in 0..n {\n            for j in 0..n {\n                if i != j {\n                    let add = if list[i].contains(&j) { -1 } else { 0 };\n                    res = res.max(list[i].len() as i32 + list[j].len() as i32 + add);\n                }\n            }\n        }\n        res\n    }\n}","date":"2023-03-15"}],"tagList":["图"],"level":"Medium"}},{"problemName":"1616.分割两个字符串得到回文串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1616.分割两个字符串得到回文串.json","problemData":{"id":"1739","name":"1616.分割两个字符串得到回文串","url":"https://leetcode.cn/problems/split-two-strings-to-make-palindrome","desc":"请你判断 aprefix + bsuffix 或者 bprefix + asuffix 能否构成回文串。","solutions":[{"script":"cpp","time":52,"memory":28.5,"desc":"贪心a前缀和b后缀最大匹配个数，a后缀和b前缀最大匹配个数。","code":"class Solution {\npublic:\n    bool checkPalindromeFormation(string a, string b) {\n        int n = a.size(), cnt = 0;\n        while (cnt < n && a[cnt] == b[n - 1 - cnt]) cnt++;\n        if (cnt >= n / 2 || check(a.substr(cnt, n - cnt * 2)) || check(b.substr(cnt, n - cnt * 2))) return true;\n        cnt = 0;\n        while (cnt < n && b[cnt] == a[n - 1 - cnt]) cnt++;\n        if (cnt >= n / 2 || check(a.substr(cnt, n - cnt * 2)) || check(b.substr(cnt, n - cnt * 2))) return true;\n        return false;\n    }\n    bool check(string s) {\n        for (int l = 0, r = s.size() - 1; l < r; l++, r--)\n            if (s[l] != s[r]) return false;\n        return true;\n    }\n};","date":"2023-03-18"},{"script":"python","time":108,"memory":15.6,"desc":"同上。","code":"class Solution:\n    def checkPalindromeFormation(self, a: str, b: str) -> bool:\n        def check(s: str):\n            l, r = 0, len(s)-1\n            while l < r:\n                if s[l] != s[r]:\n                    return False\n                l += 1\n                r -= 1\n            return True\n\n        n, cnt = len(a), 0\n        while cnt < n and a[cnt] == b[n-1-cnt]:\n            cnt += 1\n        if cnt >= n//2 or check(a[cnt:n-cnt]) or check(b[cnt:n-cnt]):\n            return True\n        cnt = 0\n        while cnt < n and b[cnt] == a[n-1-cnt]:\n            cnt += 1\n        if cnt >= n//2 or check(a[cnt:n-cnt]) or check(b[cnt:n-cnt]):\n            return True\n        return False","date":"2023-03-18"},{"script":"rust","time":12,"memory":3.1,"desc":"同上。","code":"impl Solution {\n    pub fn check_palindrome_formation(a: String, b: String) -> bool {\n        let check = |s: &[char]| {\n            let (mut l, mut r) = (0, s.len() - 1);\n            while l < r {\n                if s[l] != s[r] {\n                    return false;\n                }\n                l += 1;\n                r -= 1;\n            }\n            true\n        };\n        let a = a.chars().collect::<Vec<char>>();\n        let b = b.chars().collect::<Vec<char>>();\n        let (n, mut cnt) = (a.len(), 0);\n        while cnt < n && a[cnt] == b[n - 1 - cnt] {\n            cnt += 1;\n        }\n        if cnt >= n / 2 || check(&a[cnt..n - cnt]) || check(&b[cnt..n - cnt]) {\n            return true;\n        }\n        cnt = 0;\n        while cnt < n && b[cnt] == a[n - 1 - cnt] {\n            cnt += 1;\n        }\n        if cnt >= n / 2 || check(&a[cnt..n - cnt]) || check(&b[cnt..n - cnt]) {\n            return true;\n        }\n        false\n    }\n}","date":"2023-03-18"}],"tagList":["双指针","字符串"],"level":"Medium"}},{"problemName":"1617.统计子树中城市之间最大距离.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1617.统计子树中城市之间最大距离.json","problemData":{"id":"1740","name":"1617.统计子树中城市之间最大距离","url":"https://leetcode.cn/problems/count-subtrees-with-max-distance-between-cities","desc":"请你返回一个大小为 n-1 的数组，其中第 d 个元素（下标从 1 开始）是城市间 最大距离 恰好等于 d 的子树数目。","solutions":[{"script":"cpp","time":156,"memory":251.6,"desc":"二进制枚举所有子树，对每个子树求树的直径。","code":"class Solution {\npublic:\n    vector<int> countSubgraphsForEachDiameter(int n, vector<vector<int>>& edges) {\n        vector<vector<int>> nodes(n);\n        for (auto &edge : edges) {\n            nodes[edge[0] - 1].push_back(edge[1] - 1);\n            nodes[edge[1] - 1].push_back(edge[0] - 1);\n        }\n        vector<int> res(n - 1, 0);\n        for (int i = 1; i < (1 << n); i++) {\n            int root = 0, mask = i, last = 0;\n            while (((1 << root) & i) == 0) root++;\n            queue<int> q;\n            q.push(root);\n            mask &= ~(1 << root);\n            while (q.size()) {\n                int cur = q.front();\n                last = cur;\n                q.pop();\n                for (auto &next : nodes[cur]) {\n                    if (mask & (1 << next)) {\n                        mask &= ~(1 << next);\n                        q.push(next);\n                    }\n                }\n            }\n            if (mask == 0) {\n                int d = dfs(nodes, last, i & ~(1 << last));\n                if (d >= 1) res[d - 1]++;\n            }\n        }\n        return res;\n    }\n    int dfs(vector<vector<int>> &nodes, int root, int mask) {\n        if (mask == 0) return 0;\n        int res = 0;\n        for (auto &next : nodes[root]) {\n            if (mask & (1 << next)) {\n                res = max(res, dfs(nodes, next, mask & ~(1 << next)) + 1);\n            }\n        }\n        return res;\n    }\n};","date":"2023-03-12"},{"script":"python","time":4088,"memory":14.9,"desc":"同上。","code":"from queue import Queue\nclass Solution:\n    def countSubgraphsForEachDiameter(self, n: int, edges: List[List[int]]) -> List[int]:\n        nodes = [[] for _ in range(n)]\n        for n1, n2 in edges:\n            nodes[n1-1].append(n2-1)\n            nodes[n2-1].append(n1-1)\n        def dfs(root: int, mask: int):\n            if mask == 0:\n                return 0\n            res = 0\n            for nextNode in nodes[root]:\n                if mask & (1 << nextNode):\n                    resd = dfs(nextNode, mask & ~(1 << nextNode))\n                    if resd != -1:\n                        res = max(res, resd+1)\n            return res\n\n        res = [0] * (n-1)\n        for i in range(1, 1 << n):\n            root, mask, last = 0, i, 0\n            while ((1 << root) & i) == 0:\n                root += 1\n            q = Queue()\n            q.put(root)\n            mask &= ~(1 << root)\n            while q.qsize():\n                cur = q.get()\n                last = cur\n                for nextNode in nodes[cur]:\n                    if mask & (1 << nextNode):\n                        mask &= ~(1 << nextNode)\n                        q.put(nextNode)\n            if mask == 0:\n                d = dfs(last, i & ~(1 << last))\n                if d >= 1:\n                    res[d-1] += 1\n        return res","date":"2023-03-12"},{"script":"rust","time":16,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn count_subgraphs_for_each_diameter(n: i32, edges: Vec<Vec<i32>>) -> Vec<i32> {\n        let n = n as usize;\n        let mut nodes: Vec<Vec<usize>> = vec![vec![]; n];\n        for edge in edges {\n            let (n1, n2) = (edge[0] as usize, edge[1] as usize);\n            nodes[n1 - 1].push(n2 - 1);\n            nodes[n2 - 1].push(n1 - 1);\n        }\n        let mut res = vec![0; n - 1];\n        for i in 1..(1 << n) {\n            let i = i as usize;\n            let (mut root, mut mask, mut last) = (0, i, 0);\n            while ((1 << root) & i) == 0 {\n                root += 1;\n            }\n            let mut q = std::collections::VecDeque::<usize>::new();\n            q.push_back(root);\n            mask &= !(1 << root);\n            while !q.is_empty() {\n                let cur = q.pop_front().unwrap();\n                last = cur;\n                for next in nodes[cur].iter() {\n                    if (mask & (1 << next)) != 0 {\n                        mask &= !(1 << next);\n                        q.push_back(*next);\n                    }\n                }\n            }\n            if mask == 0 {\n                let d = Solution::dfs(&nodes, last, i & !(1 << last));\n                if d >= 1 {\n                    res[d - 1] += 1;\n                }\n            }\n        }\n        res\n    }\n    fn dfs(nodes: &Vec<Vec<usize>>, root: usize, mask: usize) -> usize {\n        if mask == 0 {\n            0\n        } else {\n            let mut res = 0;\n            for next in nodes[root].iter() {\n                if (mask & (1 << next)) != 0 {\n                    res = res.max(Solution::dfs(nodes, *next, mask & !(1 << *next)) + 1)\n                }\n            }\n            res\n        }\n    }\n}","date":"2023-03-12"}],"tagList":["位运算","树","动态规划","状态压缩","枚举"],"level":"Hard"}},{"problemName":"1619.删除某些元素后的数组均值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1619.删除某些元素后的数组均值.json","problemData":{"id":"1210","name":"1619.删除某些元素后的数组均值","url":"https://leetcode.cn/problems/mean-of-array-after-removing-some-elements","desc":"给你一个整数数组 arr ，请你删除最小 5% 的数字和最大 5% 的数字后，剩余数字的平均值。","solutions":[{"date":"2022-09-14","time":8,"memory":9.1,"script":"cpp","desc":"排序后遍历。","code":"class Solution {\npublic:\n    double trimMean(vector<int>& arr) {\n        sort(arr.begin(), arr.end());\n        int n = arr.size(), v = n / 20;\n        double ans = 0;\n        for (int i = v; i < n - v; i++) ans += arr[i];\n        return ans / (n - 2 * v);\n    }\n};"}],"tagList":["数组","排序"],"level":"Easy"}},{"problemName":"1620.网络信号最好的坐标.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1620.网络信号最好的坐标.json","problemData":{"id":"1726","name":"1620.网络信号最好的坐标","url":"https://leetcode.cn/problems/coordinate-with-maximum-network-quality","desc":"请你返回数组 [cx, cy] ，表示 信号强度 最大的 整数 坐标点 (cx, cy) 。如果有多个坐标网络信号一样大，请你返回字典序最小的 非负 坐标。","solutions":[{"date":"2022-11-02","time":44,"memory":8.5,"script":"cpp","desc":"暴力枚举。","code":"class Solution {\npublic:\n    const int MAX = 51;\n    vector<int> bestCoordinate(vector<vector<int>>& towers, int radius) {\n        vector<int> ans(2);\n        int maxQ = 0;\n        for (int x = 0; x < MAX; x++) {\n            for (int y = 0; y < MAX; y++) {\n                int q = comp(towers, radius, x, y);\n                if (q > maxQ || q == maxQ && (x < ans[0] || ans[0] == x && y < ans[1])) {\n                    ans[0] = x;\n                    ans[1] = y;\n                    maxQ = q;\n                }\n            }\n        }\n        return ans;\n    }\n    int comp(vector<vector<int>>& towers, int radius, int x, int y) {\n        int cur = 0;\n        for (auto &tower : towers) {\n            double d = sqrt(pow(tower[0] - x, 2) + pow(tower[1] - y, 2));\n            if (d > radius) continue;\n            cur += floor(1.0 * tower[2] / (1 + d));\n        }\n        return cur;\n    }\n};"}],"tagList":["数组","枚举"],"level":"Medium"}},{"problemName":"1624.两个相同字符之间的最长子字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1624.两个相同字符之间的最长子字符串.json","problemData":{"id":"1746","name":"1624.两个相同字符之间的最长子字符串","url":"https://leetcode.cn/problems/largest-substring-between-two-equal-characters","desc":"给你一个字符串 s，请你返回 两个相同字符之间的最长子字符串的长度 ，计算长度时不含这两个字符。如果不存在这样的子字符串，返回 -1 。","solutions":[{"date":"2022-09-18","time":0,"memory":6,"script":"cpp","desc":"遍历，数组记录。","code":"#define CNT 26\n      class Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int list[CNT], ans = -1;\n        memset(list, -1, sizeof(int) * 26);\n        for (int i = 0; i < s.size(); i++) {\n            if (list[s[i] - 'a'] != -1) ans = max(ans, i - list[s[i] - 'a'] + 1 - 2);\n            else list[s[i] - 'a'] = i;\n        }\n        return ans;\n    }\n};"}],"tagList":["哈希表","字符串"],"level":"Easy"}},{"problemName":"1625.执行操作后字典序最小的字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1625.执行操作后字典序最小的字符串.json","problemData":{"id":"1747","name":"1625.执行操作后字典序最小的字符串","url":"https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations","desc":"请你返回在 s 上执行上述操作任意次后可以得到的 字典序最小 的字符串。","solutions":[{"script":"cpp","time":340,"memory":99,"desc":"bfs。","code":"class Solution {\npublic:\n    string findLexSmallestString(string s, int a, int b) {\n        set<string> sset;\n        sset.insert(s);\n        queue<string> q;\n        q.push(s);\n        auto t1 = [&](string s) {\n            for (int i = 1; i < s.size(); i += 2) s[i] = ((s[i] - '0' + a) % 10) + '0';\n            return s;\n        };\n        auto t2 = [&](string &s) {\n            return s.substr(s.size() - b, b + 1) + s.substr(0, s.size() - b);\n        };\n        while (q.size()) {\n            string cur = q.front();\n            q.pop();\n            string n1 = t1(cur), n2 = t2(cur);\n            if (!sset.count(n1)) sset.insert(n1), q.push(n1);\n            if (!sset.count(n2)) sset.insert(n2), q.push(n2);\n        }\n        return *sset.begin();\n    }\n};","date":"2023-03-19"},{"script":"python","time":1652,"memory":17.6,"desc":"同上。","code":"class Solution:\n    def findLexSmallestString(self, s: str, a: int, b: int) -> str:\n        set = SortedSet()\n        set.add(s)\n        q = Queue()\n        q.put(s)\n\n        def t1(s: str):\n            res = \"\"\n            for i in range(len(s)):\n                if i % 2:\n                    res += str((ord(s[i]) - ord('0') + a) % 10)\n                else:\n                    res += s[i]\n            return res\n\n        def t2(s: str):\n            return s[len(s)-b:] + s[0:len(s)-b]\n        while q.qsize():\n            cur = q.get()\n            n1, n2 = t1(cur), t2(cur)\n            if not n1 in set:\n                set.add(n1)\n                q.put(n1)\n            if not n2 in set:\n                set.add(n2)\n                q.put(n2)\n        return set.pop(0)","date":"2023-03-19"},{"script":"rust","time":104,"memory":3.9,"desc":"同上。","code":"impl Solution {\n    pub fn find_lex_smallest_string(s: String, a: i32, b: i32) -> String {\n        let mut set = std::collections::BTreeSet::<String>::new();\n        set.insert(s.clone());\n        let mut q = std::collections::VecDeque::<String>::new();\n        q.push_back(s.clone());\n        let t1 = |s: String| -> String {\n            let mut s = s.chars().map(|v| v as u8).collect::<Vec<u8>>();\n            let mut i = 1;\n            while i < s.len() {\n                s[i] = (s[i] - '0' as u8 + a as u8) % 10 + '0' as u8;\n                i += 2;\n            }\n            String::from_utf8(s).unwrap()\n        };\n        let t2 = |s: String| -> String {\n            let s = s.chars().collect::<Vec<char>>();\n            let s1 = &s[s.len() - b as usize..];\n            let s2 = &s[0..s.len() - b as usize];\n            let s1 = String::from_utf8(s1.iter().map(|v| *v as u8).collect::<Vec<u8>>()).unwrap();\n            let s2 = String::from_utf8(s2.iter().map(|v| *v as u8).collect::<Vec<u8>>()).unwrap();\n            [s1, s2].concat()\n        };\n        while !q.is_empty() {\n            let cur = q.pop_front().unwrap();\n            let (n1, n2) = (t1(cur.clone()), t2(cur.clone()));\n            if !set.contains(&n1) {\n                set.insert(n1.clone());\n                q.push_front(n1.clone());\n            }\n            if !set.contains(&n2) {\n                set.insert(n2.clone());\n                q.push_front(n2.clone());\n            }\n        }\n        set.into_iter().next().unwrap()\n    }\n}","date":"2023-03-19"}],"tagList":["深度优先搜索","广度优先搜索","字符串","枚举"],"level":"Medium"}},{"problemName":"1626.无矛盾的最佳球队.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1626.无矛盾的最佳球队.json","problemData":{"id":"1748","name":"1626.无矛盾的最佳球队","url":"https://leetcode.cn/problems/best-team-with-no-conflicts","desc":"给你两个列表 scores 和 ages，其中每组 scores[i] 和 ages[i] 表示第 i 名球员的分数和年龄。请你返回 所有可能的无矛盾球队中得分最高那支的分数 。","solutions":[{"script":"cpp","time":452,"memory":18.4,"desc":"dp[i]表示以i为结尾时的最大分数。","code":"class Solution {\npublic:\n    int bestTeamScore(vector<int>& scores, vector<int>& ages) {\n        int n = scores.size(), res = 0;\n        vector<int> idx(n), dp(n, 0);\n        for (int i = 0; i < n; i++) idx[i] = i;\n        sort(idx.begin(), idx.end(), [&](auto &a, auto &b){\n            return ages[a] != ages[b] ? ages[a] < ages[b] : scores[a] < scores[b];\n        });\n        for (int i = 0; i < n; i++) {\n            for (int j = i - 1; j >= 0; j--) {\n                if (ages[idx[i]] == ages[idx[j]] || ages[idx[i]] > ages[idx[j]] && scores[idx[i]] >= scores[idx[j]])\n                    dp[i] = max(dp[i], dp[j]);\n            }\n            dp[i] += scores[idx[i]];\n            res = max(res, dp[i]);\n        }\n        return res;\n    }\n};","date":"2023-03-22"},{"script":"python","time":2676,"memory":15.1,"desc":"同上。","code":"class Solution:\n    def bestTeamScore(self, scores: List[int], ages: List[int]) -> int:\n        n, res = len(scores), 0\n        l = sorted(zip(ages, scores))\n        dp = [0] * n\n        for i in range(n):\n            for j in range(i-1, -1, -1):\n                if l[i][0] == l[j][0] or (l[i][0] > l[j][0] and l[i][1] >= l[j][1]):\n                    dp[i] = max(dp[i], dp[j])\n            dp[i] += l[i][1]\n            res = max(res, dp[i])\n        return res","date":"2023-03-22"},{"script":"rust","time":44,"memory":2.1,"desc":"同上。","code":"impl Solution {\n    pub fn best_team_score(scores: Vec<i32>, ages: Vec<i32>) -> i32 {\n        let (n, mut res) = (scores.len(), 0);\n        let mut idx = (0..n).collect::<Vec<usize>>();\n        idx.sort_by(|a, b| {\n            if ages[*a] != ages[*b] {\n                ages[*a].cmp(&ages[*b])\n            } else {\n                scores[*a].cmp(&scores[*b])\n            }\n        });\n        let mut dp = vec![0; n];\n        for i in 0..n as i32 {\n            for j in ((0i32)..=(i - 1)).rev() {\n                let (i, j) = (i as usize, j as usize);\n                if ages[idx[i]] == ages[idx[j]]\n                    || ages[idx[i]] > ages[idx[j]] && scores[idx[i]] >= scores[idx[j]]\n                {\n                    dp[i] = dp[i].max(dp[j]);\n                }\n            }\n\n            dp[i as usize] += scores[idx[i as usize]];\n            res = res.max(dp[i as usize]);\n        }\n        res\n    }\n}","date":"2023-03-22"}],"tagList":["数组","动态规划","排序"],"level":"Medium"}},{"problemName":"1629.按键持续时间最长的键.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1629.按键持续时间最长的键.json","problemData":{"id":"1751","name":"1629.按键持续时间最长的键","url":"https://leetcode.cn/problems/slowest-key","desc":"请返回按键 持续时间最长 的键，如果有多个这样的键，则返回 按字母顺序排列最大 的那个键。","solutions":[{"date":"2022-01-09","time":4,"memory":10.5,"script":"cpp","desc":"遍历，记录最大值。","code":"class Solution {\n   public:\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\n        int pre = 0, max_v = 0;\n        char max_c;\n        for (int i = 0; i < releaseTimes.size(); i++) {\n            int time = releaseTimes[i] - pre;\n            if (time > max_v || time == max_v && keysPressed[i] > max_c) {\n                max_v = time;\n                max_c = keysPressed[i];\n            }\n            pre = releaseTimes[i];\n        }\n        return max_c;\n    }\n};"}],"tagList":["数组","字符串"],"level":"Easy"}},{"problemName":"1630.等差子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1630.等差子数组.json","problemData":{"id":"1752","name":"1630.等差子数组","url":"https://leetcode.cn/problems/arithmetic-subarrays","desc":"返回 boolean 元素构成的答案列表 answer 。如果子数组 nums[l[i]], nums[l[i]+1], ... , nums[r[i]] 可以 重新排列 形成 等差数列 ，answer[i] 的值就是 true；否则answer[i] 的值就是 false 。","solutions":[{"script":"cpp","time":20,"memory":20.2,"desc":"多次遍历，对每个区间枚举所有值。","code":"class Solution {\npublic:\n    vector<bool> checkArithmeticSubarrays(vector<int>& nums, vector<int>& l, vector<int>& r) {\n        vector<bool> res(l.size(), 0);\n        for (int i = 0; i < l.size(); i++) {\n            int left = l[i], right = r[i], size = right - left,\n                nmax = *max_element(nums.begin() + left, nums.begin() + right + 1), \n                nmin = *min_element(nums.begin() + left, nums.begin() + right + 1);\n            if ((nmax - nmin) % size != 0) res[i] = false;\n            else if (nmin == nmax) res[i] = true;\n            else {\n                bool f = true;\n                int step = (nmax - nmin) / size, list[size + 1];\n                memset(list, 0, sizeof(int) * (size + 1));\n                for (int i = left; i <= right && f; i++) {\n                    int val = (nums[i] - nmin) / step;\n                    if ((nums[i] - nmin) % step != 0 || list[val] != 0) f = false;\n                    else list[val] = 1;\n                }\n                res[i] = f;\n            }\n        }\n        return res;\n    }\n};","date":"2023-03-23"},{"script":"python","time":96,"memory":15,"desc":"同上。","code":"class Solution:\n    def checkArithmeticSubarrays(self, nums: List[int], l: List[int], r: List[int]) -> List[bool]:\n        def check(i: int):\n            left, right = l[i], r[i]\n            size = right-left\n            nmax, nmin = max(nums[left:right + 1]), min(nums[left:right+1])\n            if (nmax - nmin) % size != 0:\n                return False\n            elif nmin == nmax:\n                return True\n            else:\n                step = (nmax - nmin) // size\n                arr = [False] * (size + 1)\n                for i in range(left, right+1):\n                    val = (nums[i] - nmin) // step\n                    if (nums[i] - nmin) % step != 0 or arr[val]:\n                        return False\n                    else:\n                        arr[val] = True\n                return True\n        return [check(i) for i in range(len(l))]","date":"2023-03-23"},{"script":"rust","time":8,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn check_arithmetic_subarrays(nums: Vec<i32>, l: Vec<i32>, r: Vec<i32>) -> Vec<bool> {\n        let check = |i| -> bool {\n            let (left, right) = (l[i] as usize, r[i] as usize);\n            let size = right - left;\n            let (nmax, nmin) = (*nums[left..=right].iter().max().unwrap(), *nums[left..=right].iter().min().unwrap());\n            if (nmax - nmin) % (size as i32) != 0 {\n                false\n            } else if nmax == nmin {\n                true\n            } else {\n                let step = (nmax - nmin) / (size as i32);\n                let mut arr = vec![false; (size + 1) as usize];\n                for i in left..=right {\n                    let val = ((nums[i] - nmin) / step) as usize;\n                    if (nums[i] - nmin) % step != 0 || arr[val] {\n                        return false;\n                    }\n                    arr[val] = true;\n                }\n                true\n            }\n        };\n        (0..l.len()).map(|i| check(i)).collect::<Vec<bool>>()\n    }\n}","date":"2023-03-23"}],"tagList":["数组","哈希表","排序"],"level":"Medium"}},{"problemName":"1631.最小体力消耗路径.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1631.最小体力消耗路径.json","problemData":{"id":"1753","name":"1631.最小体力消耗路径","url":"https://leetcode.cn/problems/path-with-minimum-effort","desc":"一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。请你返回从左上角走到右下角的最小 体力消耗值 。","solutions":[{"script":"python","time":260,"memory":29.27,"desc":"两个单调栈。","code":"class Solution:\n    def secondGreaterElement(self, nums: List[int]) -> List[int]:\n        s1, s2, s3 = [], [], []\n        res = [-1] * len(nums)\n        for i in range(len(nums)):\n            while s2 and nums[s2[-1]] < nums[i]: res[s2.pop()] = nums[i]\n            while s1 and nums[s1[-1]] < nums[i]: s3.append(s1.pop())\n            while s3: s2.append(s3.pop())\n            s1.append(i)\n        return res","date":"2023-12-12"},{"script":"cpp","time":120,"memory":89.23,"desc":"同上。","code":"class Solution {\npublic:\n    vector<int> secondGreaterElement(vector<int>& nums) {\n        vector<int> s1, s2, s3, res(nums.size(), -1);\n        for (int i = 0; i < nums.size(); i++) {\n            while (s2.size() && nums[s2.back()] < nums[i]) res[s2.back()] = nums[i], s2.pop_back();\n            while (s1.size() && nums[s1.back()] < nums[i]) s3.push_back(s1.back()), s1.pop_back();\n            while (s3.size()) s2.push_back(s3.back()), s3.pop_back();\n            s1.push_back(i);\n        }\n        return res;\n    }\n};","date":"2023-12-12"},{"script":"rust","time":44,"memory":4.16,"desc":"同上。","code":"impl Solution {\n    pub fn second_greater_element(nums: Vec<i32>) -> Vec<i32> {\n        let mut s1 = vec![];\n        let mut s2 = vec![];\n        let mut s3 = vec![];\n        let mut res = vec![-1; nums.len()];\n        for i in 0..nums.len() {\n            while !s2.is_empty() && nums[*s2.last().unwrap()] < nums[i] {\n                res[s2.pop().unwrap()] = nums[i];\n            }\n            while !s1.is_empty() && nums[*s1.last().unwrap()] < nums[i] {\n                s3.push(s1.pop().unwrap());\n            }\n            while !s3.is_empty() {\n                s2.push(s3.pop().unwrap());\n            }\n            s1.push(i);\n        }\n        res\n    }\n}","date":"2023-12-12"}],"tagList":["深度优先搜索","广度优先搜索","并查集","数组","二分查找","矩阵","堆（优先队列）"],"level":"Medium"}},{"problemName":"1632.矩阵转换后的秩.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1632.矩阵转换后的秩.json","problemData":{"id":"1257","name":"1632.矩阵转换后的秩","url":"https://leetcode.cn/problems/rank-transform-of-a-matrix","desc":"给你一个 m x n 的矩阵 matrix ，请你返回一个新的矩阵 answer ，其中 answer[row][col] 是 matrix[row][col] 的秩。","solutions":[{"script":"cpp","time":580,"memory":85.8,"desc":"对于所有数字进行排序，快速查找当前行列中的最大秩，并对当前行列所有相同的值的秩都进行赋值，利用并查集+缓存快速查找。","code":"# define X first\n# define Y second\n# define pii pair<int,int>\nclass UnionFind {\npublic:\n    int n;\n    vector<int> data, cnt;\n    UnionFind(int n): n(n), data(vector<int>(n, 0)), cnt(vector<int>(n, 1)) {\n        iota(data.begin(), data.end(), 0);\n    } \n    int size(int v) { return cnt[find(v)]; }\n    int find(int v) {\n        if (data[v] == v) return v;\n        return data[v] = find(data[v]);\n    }\n    void uni(int v1, int v2) {\n        int p1 = find(v1), p2 = find(v2);\n        if (p1 != p2) cnt[p1] += cnt[p2], data[p2] = p1;\n    }\n    bool same(int v1, int v2) { return find(v1) == find(v2); }\n};\nint pos2Idx(int x, int y, int size) { \n    return x * size + y; \n}\nvoid idx2Pos(int idx, int size, int &x, int &y) {\n    x = idx / size;\n    y = idx % size;\n}\nvector<vector<int>> dirs = { {0, 1}, {0, -1}, {1, 0}, {-1, 0} };\n// START\n\nclass Solution {\npublic:\n    vector<vector<int>> matrixRankTransform(vector<vector<int>>& matrix) {\n        int n = matrix.size(), m = matrix[0].size();\n        vector<vector<int>> ans(n, vector<int>(m, 0));\n        vector<vector<bool>> cache(n, vector<bool>(m, false));\n        UnionFind uf(n * m);\n        for (int i = 0; i < n; i++) {\n            unordered_map<int, pii> mmap;\n            for (int j = 0; j < m; j++) {\n                int val = matrix[i][j];\n                if (mmap.count(val)) uf.uni(pos2Idx(mmap[val].X, mmap[val].Y, m), pos2Idx(i, j, m));\n                else mmap[val] = make_pair(i, j);\n            }\n        }\n        for (int j = 0; j < m; j++) {\n            unordered_map<int, pii> mmap;\n            for (int i = 0; i < n; i++) {\n                int val = matrix[i][j];\n                if (mmap.count(val)) uf.uni(pos2Idx(mmap[val].X, mmap[val].Y, m), pos2Idx(i, j, m));\n                else mmap[val] = make_pair(i, j);\n            }\n        }\n        unordered_map<int, vector<pii>> mmap;\n        for (int i = 0; i < n * m; i++) {\n            int p = uf.find(i), row, col;\n            idx2Pos(i, m, row, col);\n            mmap[p].push_back(make_pair(row, col));\n        }\n\n        vector<pii> list, rows(n, make_pair(-1, -1)), cols(m, make_pair(-1, -1));\n        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) list.push_back(make_pair(i, j));\n        sort(list.begin(), list.end(), [&](auto &a, auto &b){ return matrix[a.X][a.Y] < matrix[b.X][b.Y]; });\n\n        auto get_rank = [&](pii &item) -> int {\n            int rank_row = 1, rank_col = 1, rank = ans[item.X][item.Y], val = matrix[item.X][item.Y];\n            auto &row = rows[item.X], &col = cols[item.Y];\n            if (row.X != -1) rank_row = ans[row.X][row.Y] + (matrix[row.X][row.Y] != val);\n            if (col.Y != -1) rank_col = ans[col.X][col.Y] + (matrix[col.X][col.Y] != val);\n            rank = max(rank, max(rank_row, rank_col));\n            return rank;\n        };\n\n        for (auto &item : list) {\n            if (!cache[item.X][item.Y]) {\n                int idx = uf.find(pos2Idx(item.X, item.Y, m)), rank = get_rank(item);\n                for (auto &next : mmap[idx]) {\n                    rank = max(rank, get_rank(next));\n                }\n                for (auto &next : mmap[idx]) {\n                    cache[next.X][next.Y] = true;\n                    ans[next.X][next.Y] = rank;\n                }\n            }\n            rows[item.X] = cols[item.Y] = item;\n        }\n\n        return ans;\n    }\n};\n// END","date":"2023-01-25"}],"tagList":["并查集","图","拓扑排序","数组","矩阵","排序"],"level":"Hard"}},{"problemName":"1636.按照频率将数组升序排序.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1636.按照频率将数组升序排序.json","problemData":{"id":"1741","name":"1636.按照频率将数组升序排序","url":"https://leetcode.cn/problems/sort-array-by-increasing-frequency","desc":"给你一个整数数组 nums ，请你将数组按照每个值的频率 升序 排序。如果有多个值的频率相同，请你按照数值本身将它们 降序 排序。 。","solutions":[{"date":"2022-09-19","time":4,"memory":10.9,"script":"cpp","desc":"用哈希表存储后排序。","code":"class Solution {\npublic:\n    typedef pair<int, int> node;\n    vector<int> frequencySort(vector<int>& nums) {\n        unordered_map<int, int> m;\n        for (auto &num : nums) m[num]++;\n        vector<node> list;\n        for (auto &item : m) list.push_back(item);\n        sort(list.begin(), list.end(), [&](const node a, const node b) -> bool {\n            return a.second == b.second ? b.first < a.first : a.second < b.second;\n        });\n        vector<int> ans;\n        ans.reserve(nums.size());\n        for (auto &item : list) for (int i = 0; i < item.second; i++) ans.push_back(item.first);\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","排序"],"level":"Easy"}},{"problemName":"1637.两点之间不包含任何点的最宽垂直区域.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1637.两点之间不包含任何点的最宽垂直区域.json","problemData":{"id":"1742","name":"1637.两点之间不包含任何点的最宽垂直区域","url":"https://leetcode.cn/problems/widest-vertical-area-between-two-points-containing-no-points","desc":"给你 n 个二维平面上的点 points ，其中 points[i] = [xi, yi] ，请你返回两点之间内部不包含任何点的 最宽垂直区域 的宽度。","solutions":[{"script":"cpp","time":272,"memory":79.3,"desc":"Tree排序。","code":"class Solution {\npublic:\n    int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n        set<int> s;\n        for (auto &p : points) s.insert(p[0]);\n        auto it = s.begin();\n        int res = 0, prev = *it;\n        while (it != s.end()) res = max(res, *it - prev), prev = *it, it++;\n        return res;\n    }\n};","date":"2023-03-30"},{"script":"cpp","time":280,"memory":64.7,"desc":"排序。","code":"class Solution {\npublic:\n    int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n        sort(points.begin(), points.end(), [&](auto &a, auto &b){\n            return a[0] < b[0];\n        });\n        int res = 0;\n        for (int i = 1; i < points.size(); i++) {\n            if (points[i][0] != points[i - 1][0]) {\n                res = max(res, points[i][0] - points[i - 1][0]);\n            }\n        }\n        return res;\n    }\n};","date":"2023-03-30"},{"script":"python","time":240,"memory":45.1,"desc":"同上。","code":"class Solution:\n    def maxWidthOfVerticalArea(self, points: List[List[int]]) -> int:\n        points.sort(key=lambda p: p[0])\n        res = 0\n        for i in range(1, len(points)):\n            if points[i][0] != points[i - 1][0]:\n                res = max(res, points[i][0] - points[i - 1][0])\n        return res","date":"2023-03-30"},{"script":"rust","time":36,"memory":9.3,"desc":"同上。","code":"impl Solution {\n    pub fn max_width_of_vertical_area(mut points: Vec<Vec<i32>>) -> i32 {\n        points.sort_by_key(|p| p[0]);\n        let mut res = 0;\n        for i in 1..points.len() {\n            if (points[i][0] != points[i - 1][0]) {\n                res = res.max(points[i][0] - points[i - 1][0]);\n            }\n        }\n        res\n    }\n}","date":"2023-03-30"}],"tagList":["数组","排序"],"level":"Easy"}},{"problemName":"1638.统计只差一个字符的子串数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1638.统计只差一个字符的子串数目.json","problemData":{"id":"1743","name":"1638.统计只差一个字符的子串数目","url":"https://leetcode.cn/problems/count-substrings-that-differ-by-one-character","desc":"给你两个字符串 s 和 t ，请你找出 s 中的非空子串的数目，这些子串满足替换 一个不同字符 以后，是 t 串的子串。换言之，请你找到 s 和 t 串中 恰好 只有一个字符不同的子字符串对的数目。","solutions":[{"script":"cpp","time":4,"memory":6.1,"desc":"枚举。","code":"class Solution {\npublic:\n    int countSubstrings(string s, string t) {\n        int n = s.size(), m = t.size(), res = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                int cnt = 0;\n                for (int k = 0; i + k < n && j + k < m; k++) {\n                    if (s[i + k] != t[j + k]) cnt++;\n                    if (cnt == 1) res++;\n                    else if (cnt > 1) break;\n                }\n            }\n        }\n        return res;\n    }\n};","date":"2023-03-27"},{"script":"python","time":72,"memory":14.7,"desc":"同上。","code":"class Solution:\n    def countSubstrings(self, s: str, t: str) -> int:\n        n, m, res = len(s), len(t), 0\n        for i in range(n):\n            for j in range(m):\n                cnt, k = 0, 0\n                while i+k < n and j+k < m:\n                    if s[i+k] != t[j+k]:\n                        cnt += 1\n                    if cnt == 1:\n                        res += 1\n                    elif cnt > 1:\n                        break\n                    k += 1\n        return res","date":"2023-03-27"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn count_substrings(s: String, t: String) -> i32 {\n        let (s, t) = (\n            s.chars().collect::<Vec<char>>(),\n            t.chars().collect::<Vec<char>>(),\n        );\n        let (n, m, mut res) = (s.len(), t.len(), 0);\n        for i in 0..n {\n            for j in 0..m {\n                let (mut cnt, mut k) = (0, 0);\n                while i + k < n && j + k < m {\n                    if s[i + k] != t[j + k] {\n                        cnt += 1\n                    }\n                    if cnt == 1 {\n                        res += 1\n                    } else if cnt > 1 {\n                        break;\n                    }\n                    k += 1\n                }\n            }\n        }\n        res\n    }\n}","date":"2023-03-27"}],"tagList":["哈希表","字符串","动态规划","枚举"],"level":"Medium"}},{"problemName":"1640.能否连接形成数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1640.能否连接形成数组.json","problemData":{"id":"1760","name":"1640.能否连接形成数组","url":"https://leetcode.cn/problems/check-array-formation-through-concatenation","desc":"如果可以连接 pieces 中的数组形成 arr ，返回 true ；否则，返回 false 。","solutions":[{"date":"2022-09-22","time":4,"memory":9,"script":"cpp","desc":"哈希存储。","code":"class Solution {\npublic:\n    bool canFormArray(vector<int>& arr, vector<vector<int>>& pieces) {\n        unordered_map<int, int> m;\n        for (int i = 0; i < pieces.size(); i++) m[pieces[i][0]] = i;\n        for (int i = 0; i < arr.size();) {\n            if (!m.count(arr[i])) return false;\n            int idx = m[arr[i]];\n            for (int j = 0; j < pieces[idx].size(); j++, i++) if (pieces[idx][j] != arr[i]) return false;\n        }\n        return true;\n    }\n};"}],"tagList":["数组","哈希表"],"level":"Easy"}},{"problemName":"1641.统计字典序元音字符串的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1641.统计字典序元音字符串的数目.json","problemData":{"id":"1761","name":"1641.统计字典序元音字符串的数目","url":"https://leetcode.cn/problems/count-sorted-vowel-strings","desc":"给你一个整数 n，请返回长度为 n 、仅由元音 (a, e, i, o, u) 组成且按 字典序排列 的字符串数量。","solutions":[{"script":"cpp","time":0,"memory":5.9,"desc":"dp[i][j]表示i个字符长度时j字符为首有几种。","code":"class Solution {\npublic:\n    int countVowelStrings(int n) {\n        int dp[55][5] = {0};\n        for (int j = 0; j < 5; j++) dp[1][j] = 1;\n        for (int i = 2; i <= n; i++) {\n            int v = 0;\n            for (int j = 0; j < 5; j++) {\n                v += dp[i - 1][j];\n                dp[i][j] = v;\n            }\n        }\n        return accumulate(dp[n], dp[n] + 5, 0);\n    }\n};","date":"2023-03-29"},{"script":"python","time":20,"memory":14.8,"desc":"同上。","code":"class Solution:\n    def countVowelStrings(self, n: int) -> int:\n        dp = [[0] * 5 for _ in range(55)]\n        for j in range(5):\n            dp[1][j] = 1\n        for i in range(2, n+1):\n            v = 0\n            for j in range(5):\n                v += dp[i-1][j]\n                dp[i][j] = v\n        return sum(dp[n])","date":"2023-03-29"},{"script":"rust","time":0,"memory":2.1,"desc":"同上。","code":"impl Solution {\n    pub fn count_vowel_strings(n: i32) -> i32 {\n        let n = n as usize;\n        let mut dp = vec![vec![0; 5]; 55];\n        for j in 0..5 {\n            dp[1][j] = 1;\n        }\n        for i in 2..=n {\n            let mut v = 0;\n            for j in 0..5 {\n                v += dp[i - 1][j];\n                dp[i][j] = v\n            }\n        }\n        dp[n].iter().sum()\n    }\n}","date":"2023-03-29"}],"tagList":["数学","动态规划","组合数学"],"level":"Medium"}},{"problemName":"1646.获取生成数组中的最大值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1646.获取生成数组中的最大值.json","problemData":{"id":"1769","name":"1646.获取生成数组中的最大值","url":"https://leetcode.cn/problems/get-maximum-in-generated-array","desc":"返回生成数组 nums 中的 最大 值。","solutions":[{"date":"2021-08-23","time":80,"memory":39.1,"script":"typescript","desc":"循环分别计算每个值。","code":"function getMaximumGenerated(n: number): number {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  let ans = 1;\n  const arr = new Array(n + 1);\n  arr[0] = 0;\n  arr[1] = 1;\n  for (let i = 1; 2 * i + 1 <= n; i++) {\n    ans = Math.max(ans, (arr[i * 2] = arr[i]));\n    ans = Math.max(ans, (arr[i * 2 + 1] = arr[i] + arr[i + 1]));\n  }\n  return ans;\n}"}],"tagList":["数组","模拟"],"level":"Easy"}},{"problemName":"1652.拆炸弹.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1652.拆炸弹.json","problemData":{"id":"1755","name":"1652.拆炸弹","url":"https://leetcode.cn/problems/defuse-the-bomb","desc":"给你 循环 数组 code 和整数密钥 k ，请你返回解密后的结果来拆除炸弹！。","solutions":[{"date":"2022-09-24","time":0,"memory":8.2,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    vector<int> decrypt(vector<int>& code, int k) {\n        int n = code.size();\n        vector<int> ans(n, 0);\n        for (int i = 0; i < n; i++) {\n            if (k > 0) {\n                for (int j = (i + 1) % n, cnt = 0; cnt < k; cnt++, j = (j + 1) % n) ans[i] += code[j];\n            } else if (k < 0) {\n                for (int j = (i - 1 + n) % n, cnt = 0; cnt < -k; cnt++, j = (j - 1 + n) % n) ans[i] += code[j];\n            }\n        }\n        return ans;\n    }\n};"},{"script":"python","time":53,"memory":16.42,"desc":"遍历。","code":"class Solution:\n    def decrypt(self, code: List[int], k: int) -> List[int]:\n        n = len(code)\n        if k == 0: return [0] * n\n        def get(idx: int) -> int:\n            res = 0\n            next = idx\n            for _ in range(abs(k)):\n                next = ((1 if k > 0 else -1) + next + n) % n\n                res += code[next]\n            return res\n        return [get(i) for i in range(n)]","date":"2024-05-05"},{"script":"python","time":53,"memory":16.42,"desc":"遍历。","code":"class Solution:\n    def decrypt(self, code: List[int], k: int) -> List[int]:\n        n = len(code)\n        if k == 0: return [0] * n\n        def get(idx: int) -> int:\n            res = 0\n            next = idx\n            for _ in range(abs(k)):\n                next = ((1 if k > 0 else -1) + next + n) % n\n                res += code[next]\n            return res\n        return [get(i) for i in range(n)]","date":"2024-05-05"}],"tagList":["数组","滑动窗口"],"level":"Easy"}},{"problemName":"1653.使字符串平衡的最少删除次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1653.使字符串平衡的最少删除次数.json","problemData":{"id":"1756","name":"1653.使字符串平衡的最少删除次数","url":"https://leetcode.cn/problems/minimum-deletions-to-make-string-balanced","desc":"请你返回使 s 平衡 的 最少 删除次数。","solutions":[{"script":"cpp","time":64,"memory":21.6,"desc":"遍历到b的时候不做处理，遍历到a的时候考虑删除当前a或者删除前面的b。","code":"class Solution {\npublic:\n    int minimumDeletions(string s) {\n        int dp = 0, b = 0;\n        for (auto &c : s) {\n            if (c == 'a') dp = min(dp + 1, b);\n            else b += 1;\n        }\n        return dp;\n    }\n};","date":"2023-03-06"},{"script":"python","time":300,"memory":15.5,"desc":"同上。","code":"class Solution:\n    def minimumDeletions(self, s: str) -> int:\n        dp, b = 0, 0\n        for c in s:\n            if c == 'a':\n                dp = min(dp+1, b)\n            else:\n                b += 1\n        return dp","date":"2023-03-06"},{"script":"rust","time":16,"memory":2.2,"desc":"同上。","code":"impl Solution {\n        pub fn minimum_deletions(s: String) -> i32 {\n            let (mut dp, mut b) = (0, 0);\n            for c in s.chars() {\n                if c == 'a' {\n                    dp = b.min(dp + 1);\n                } else {\n                    b += 1;\n                }\n            }\n            dp\n        }\n    }","date":"2023-03-06"}],"tagList":["栈","字符串","动态规划"],"level":"Medium"}},{"problemName":"1654.到家的最少跳跃次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1654.到家的最少跳跃次数.json","problemData":{"id":"1757","name":"1654.到家的最少跳跃次数","url":"https://leetcode.cn/problems/minimum-jumps-to-reach-home","desc":"给你一个整数数组 forbidden ，其中 forbidden[i] 是跳蚤不能跳到的位置，同时给你整数 a， b 和 x ，请你返回跳蚤到家的最少跳跃次数。如果没有恰好到达 x 的可行方案，请你返回 -1 。","solutions":[{"script":"cpp","time":60,"memory":18.09,"desc":"bfs。","code":"class Solution {\npublic:\n    typedef pair<int, bool> Node;\n    int minimumJumps(vector<int>& forbidden, int a, int b, int x) {\n        unordered_set<int> s(forbidden.begin(), forbidden.end());\n        queue<Node> q;\n        q.push(make_pair(0, false));\n        unordered_map<int, int> m;\n        m[0] |= 0b01;\n        int size = 1, step = 0;\n        while (q.size()) {\n            auto cur = q.front();\n            q.pop();\n            if (cur.first == x) return step;\n            if (cur.first < 4000 && (m[cur.first + a] & 0b01) == 0 && !s.count(cur.first + a)) {\n                m[cur.first + a] |= 0b01;\n                q.push(make_pair(cur.first + a, false));\n            }\n            if (cur.first - b >= 0 && !cur.second && (m[cur.first - b] & 0b10) == 0 && !s.count(cur.first - b)) {\n                m[cur.first - b] |= 0b10;\n                q.push(make_pair(cur.first - b, true));\n            }\n            size -= 1;\n            if (size == 0) {\n                size = q.size();\n                step += 1;\n            }\n        }\n        return -1;\n    }\n};","date":"2023-08-30"},{"script":"python","time":120,"memory":16.05,"desc":"同上。","code":"class Solution:\n    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:\n        s = set(forbidden)\n        q = deque()\n        q.append((0, False))\n        m = Counter()\n        m[0] |= 0b01\n        size = 1\n        step = 0\n        while len(q):\n            cur = q.popleft()\n            if cur[0] == x:\n                return step\n            if cur[0] < 4000 and (m[cur[0] + a] & 0b01) == 0 and not cur[0] + a in s:\n                m[cur[0] + a] |= 0b01\n                q.append((cur[0]+a, False))\n            if cur[0] - b >= 0 and not cur[1] and (m[cur[0] - b] & 0b10) == 0 and not cur[0] - b in s:\n                m[cur[0] - b] |= 0b10\n                q.append((cur[0]-b, True))\n            size -= 1\n            if size == 0:\n                size = len(q)\n                step += 1\n        return -1","date":"2023-08-30"},{"script":"rust","time":12,"memory":2.24,"desc":"同上。","code":"impl Solution {\n    pub fn minimum_jumps(forbidden: Vec<i32>, a: i32, b: i32, x: i32) -> i32 {\n        let mut s = std::collections::HashSet::<i32>::new();\n        for num in forbidden {\n            s.insert(num);\n        }\n        let mut q = std::collections::VecDeque::<(i32, bool)>::new();\n        q.push_back((0, false));\n        let mut m = std::collections::HashMap::<i32, i32>::new();\n        m.insert(0, 0b01);\n        let mut size = 1;\n        let mut step = 0;\n        while let Some(cur) = q.pop_front() {\n            if cur.0 == x {\n                return step;\n            }\n            if cur.0 < 4000\n                && (*m.get(&(cur.0 + a)).unwrap_or(&0) & 0b01) == 0\n                && !s.contains(&(cur.0 + a))\n            {\n                let item = m.entry(cur.0 + a).or_insert(0);\n                *item |= 0b01;\n                q.push_back((cur.0 + a, false));\n            }\n            if cur.0 - b >= 0\n                && !cur.1\n                && (*m.get(&(cur.0 - b)).unwrap_or(&0) & 0b10) == 0\n                && !s.contains(&(cur.0 - b))\n            {\n                let item = m.entry(cur.0 - b).or_insert(0);\n                *item |= 0b10;\n                q.push_back((cur.0 - b, true));\n            }\n            size -= 1;\n            if size == 0 {\n                size = q.len();\n                step += 1;\n            }\n        }\n        -1\n    }\n}","date":"2023-08-30"}],"tagList":["广度优先搜索","数组","动态规划"],"level":"Medium"}},{"problemName":"1656.设计有序流.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1656.设计有序流.json","problemData":{"id":"1775","name":"1656.设计有序流","url":"https://leetcode.cn/problems/design-an-ordered-stream","desc":"设计一个流，以 任意 顺序获取 n 个 (id, value) 对，并在多次调用时 按 id 递增的顺序 返回一些值。","solutions":[{"date":"2022-08-16","time":32,"memory":2.8,"script":"rust","desc":"遍历。","code":"struct OrderedStream {\n    ptr: usize,\n    n: usize,\n    list: Vec<String>,\n}\nimpl OrderedStream {\n    fn new(n: i32) -> Self {\n        let n = n as usize;\n        let mut list = Vec::<String>::with_capacity(n);\n        for _ in 0..n {\n            list.push(String::new());\n        }\n        Self { ptr: 0, list, n }\n    }\n    fn insert(&mut self, id_key: i32, value: String) -> Vec<String> {\n        self.list[(id_key - 1) as usize] = value;\n        let mut ans = Vec::new();\n        while self.ptr < self.n && self.list[self.ptr].len() == 5 {\n            ans.push(self.list[self.ptr].clone());\n            self.ptr += 1;\n        }\n        ans\n    }\n}"}],"tagList":["设计","数组","哈希表","数据流"],"level":"Easy"}},{"problemName":"1657.确定两个字符串是否接近.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1657.确定两个字符串是否接近.json","problemData":{"id":"1777","name":"1657.确定两个字符串是否接近","url":"https://leetcode.cn/problems/determine-if-two-strings-are-close","desc":"给你两个字符串，word1 和 word2 。如果 word1 和 word2 接近 ，就返回 true ；否则，返回 false 。","solutions":[{"script":"python","time":128,"memory":16.86,"desc":"排序。","code":"class Solution:\n    def closeStrings(self, word1: str, word2: str) -> bool:\n        c1 = Counter(word1)\n        c2 = Counter(word2)\n        return sorted(c1.keys()) == sorted(c2.keys()) and sorted(c1.values()) == sorted(c2.values())","date":"2023-11-30"}],"tagList":["哈希表","字符串","计数","排序"],"level":"Medium"}},{"problemName":"1658.将x减到0的最小操作数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1658.将x减到0的最小操作数.json","problemData":{"id":"1776","name":"1658.将x减到0的最小操作数","url":"https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero","desc":"给你一个整数数组 nums 和一个整数 x 。如果可以将 x 恰好 减到 0 ，返回 最小操作数 。","solutions":[{"date":"2021-07-22","time":192,"memory":60.9,"script":"typescript","desc":"前缀和。","code":"function minOperations(nums: number[], x: number): number {\n  const sumsL = [0];\n  const sumsR = [0];\n  const n = nums.length;\n  for (let i = 0; i < n; i++) sumsL.push(nums[i] + sumsL[i]);\n  for (let i = 0; i < n; i++) sumsR.push(nums[n - 1 - i] + sumsR[i]);\n  let ans = Infinity;\n  for (let i = 0; i <= n; i++) {\n    const num = sumsL[i];\n    const need = x - num;\n    if (need < 0) break;\n    let l = 0;\n    let r = sumsR.length - 1;\n    let mid!: number;\n    while (l <= r) {\n      mid = (l + r) >> 1;\n      const midNum = sumsR[mid];\n      if (midNum < need) l = mid + 1;\n      else if (midNum > need) r = mid - 1;\n      else break;\n    }\n    if (need === sumsR[mid] && i + mid <= n) {\n      ans = Math.min(ans, i + mid);\n    }\n  }\n  return ans === Infinity ? -1 : ans;\n}"},{"date":"2023-01-07","time":404,"memory":164.3,"script":"cpp","desc":"哈希存储。","code":"class Solution {\npublic:\n    int minOperations(vector<int>& nums, int x) {\n        unordered_map<int, int> lmap;\n        lmap[0] = 0;\n        int ans = 0x7fffffff, n = nums.size();\n        for (int i = 0, sum = 0; i < n; i++) {\n            sum += nums[i];\n            if (sum == x) ans = min(ans, i + 1);\n            if (!lmap.count(sum)) lmap[sum] = i + 1;\n        }\n        for (int i = n - 1, sum = 0; i >= 0; i--) {\n            sum += nums[i];\n            if (sum > x) break;\n            if (!lmap.count(x - sum)) continue;\n            if (lmap[x - sum] + n - i > n) continue;\n            ans = min(ans, lmap[x - sum] + n - i);\n        }\n        return ans == 0x7fffffff ? -1 : ans;\n    }\n};"},{"date":"2023-01-07","time":128,"memory":96.3,"script":"cpp","desc":"滑动窗口。","code":"class Solution {\npublic:\n    int minOperations(vector<int>& nums, int x) {\n        int ans = 0x7fffffff, n = nums.size(), r = 0, rsum = accumulate(nums.begin(), nums.end(), 0);\n        if (rsum < x) return -1;\n        while (r < n && rsum > x) rsum -= nums[r++];\n        if (rsum == x) ans = n - r;\n        for (int l = 0, lsum = 0; l < n; l++) {\n            lsum += nums[l];\n            while (r < n && (l + 1 + n - r > n || lsum + rsum > x)) rsum -= nums[r++];\n            if (lsum + rsum == x) ans = min(ans, l + 1 + n - r);\n        }\n        return ans == 0x7fffffff ? -1 : ans;\n    }\n};"},{"date":"2023-01-07","time":20,"memory":2.8,"script":"rust","desc":"同上。","code":"impl Solution {\n    pub fn min_operations(nums: Vec<i32>, x: i32) -> i32 {\n        let mut ans = i32::MAX;\n        let n = nums.len();\n        let (mut r, mut rsum) = (0, nums.iter().fold(0, |sum, cur| sum + cur));\n        if rsum < x {\n            return -1;\n        }\n        while r < n && rsum > x {\n            rsum -= nums[r];\n            r += 1;\n        }\n        if rsum == x {\n            ans = (n - r) as i32;\n        }\n        let (mut l, mut lsum) = (0, 0);\n        while l < n {\n            lsum += nums[l];\n            while r < n && (l + 1 + n - r > n || lsum + rsum > x) {\n                rsum -= nums[r];\n                r += 1;\n            }\n            if lsum + rsum == x {\n                ans = ans.min((l + 1 + n - r) as i32);\n            }\n            l += 1;\n        }\n        if ans == i32::MAX {\n            -1\n        } else {\n            ans\n        }\n    }\n}"}],"tagList":["数组","哈希表","二分查找","前缀和","滑动窗口"],"level":"Medium"}},{"problemName":"1662.检查两个字符串数组是否相等.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1662.检查两个字符串数组是否相等.json","problemData":{"id":"1781","name":"1662.检查两个字符串数组是否相等","url":"https://leetcode.cn/problems/check-if-two-string-arrays-are-equivalent","desc":"给你两个字符串数组 word1 和 word2 。如果两个数组表示的字符串相同，返回 true ；否则，返回 false 。","solutions":[{"date":"2022-11-01","time":4,"memory":11,"script":"cpp","desc":"双指针遍历。","code":"class Solution {\npublic:\n    bool arrayStringsAreEqual(vector<string>& word1, vector<string>& word2) {\n        int w1 = 0, l1 = 0, w2 = 0, l2 = 0;\n        while (l1 < word1.size() && l2 < word2.size()) {\n            if (word1[l1][w1++] != word2[l2][w2++]) return false;\n            if (w1 == word1[l1].size()) w1 = 0, l1++;\n            if (w2 == word2[l2].size()) w2 = 0, l2++;\n        }\n        return l1 == word1.size() && l2 == word2.size();\n    }\n};"}],"tagList":["数组","字符串"],"level":"Easy"}},{"problemName":"1663.具有给定数值的最小字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1663.具有给定数值的最小字符串.json","problemData":{"id":"1782","name":"1663.具有给定数值的最小字符串","url":"https://leetcode.cn/problems/smallest-string-with-a-given-numeric-value","desc":"给你两个整数 n 和 k 。返回 长度 等于 n 且 数值 等于 k 的 字典序最小 的字符串。","solutions":[{"script":"cpp","time":8,"memory":6.4,"desc":"遍历。","code":"class Solution {\npublic:\n    string greatestLetter(string s) {\n        string ans = \"\";\n        int map[128] = {0};\n        for (auto &c : s) {\n            map[c]++;\n            if (isupper(c) && map[tolower(c)] && (ans == \"\" || ans[0] < c) ||\n                islower(c) && map[toupper(c)] && (ans == \"\" || ans[0] < toupper(c))) ans = toupper(c);\n        }\n        return ans;\n    }\n};","date":"2023-01-27"},{"script":"python","time":56,"memory":15,"desc":"同上。","code":"class Solution:\ndef greatestLetter(self, s: str) -> str:\n    ans = \"\"\n    sset = set()\n    for i, c in enumerate(s):\n        sset.add(c)\n        if c.isupper() and c.lower() in sset and (ans == \"\" or ans[0] < c) or c.islower() and c.upper() in sset and (ans == \"\" or ans[0] < c.upper()):\n             ans = c.upper()\n    return ans","date":"2023-01-27"},{"script":"rust","time":4,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn greatest_letter(s: String) -> String {\n        let s = s.chars().collect::<Vec<char>>();\n        let mut ans = 0usize;\n        let mut map = [0; 128];\n        for c in s {\n            map[c as usize] += 1;\n            let upper_c = c.to_uppercase().next().unwrap() as usize;\n            let lower_c = c.to_lowercase().next().unwrap() as usize;\n            if map[upper_c] > 0 && map[lower_c] > 0 && ans < upper_c {\n                ans = upper_c;\n            }\n        }\n        if ans == 0 {\n            \"\".to_string()\n        } else {\n            String::from(ans as u8 as char)\n        }\n    }\n}","date":"2023-01-27"}],"tagList":["贪心","字符串"],"level":"Medium"}},{"problemName":"1664.生成平衡数组的方案数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1664.生成平衡数组的方案数.json","problemData":{"id":"1783","name":"1664.生成平衡数组的方案数","url":"https://leetcode.cn/problems/ways-to-make-a-fair-array","desc":"如果一个数组满足奇数下标元素的和与偶数下标元素的和相等，该数组就是一个 平衡数组 。请你返回删除操作后，剩下的数组 nums 是 平衡数组 的 方案数 。","solutions":[{"script":"cpp","time":108,"memory":92,"desc":"遍历。","code":"class Solution {\npublic:\n    int waysToMakeFair(vector<int>& nums) {\n        int l[2] = {0}, r[2] = {0}, ans = 0;\n        for (int i = 0; i < nums.size(); i++) r[i % 2] += nums[i];\n        for (int i = 0; i < nums.size(); i++) {\n            r[i % 2] -= nums[i];\n            if (l[0] + r[1] == l[1] + r[0]) ans++;\n            l[i % 2] += nums[i];\n        }\n        return ans;\n    }\n};","date":"2023-01-28"},{"script":"python","time":328,"memory":19.7,"desc":"同上。","code":"class Solution:\ndef waysToMakeFair(self, nums: List[int]) -> int:\n    l = [0] * 2\n    r = [0] * 2\n    ans = 0\n    for i, num in enumerate(nums):\n        r[i % 2] += num\n    for i, num in enumerate(nums):\n        r[i % 2] -= num\n        if l[0] + r[1] == l[1] + r[0]:\n            ans += 1\n        l[i % 2] += num\n    return ans","date":"2023-01-28"},{"script":"rust","time":8,"memory":2.5,"desc":"同上。","code":"impl Solution {\n    pub fn ways_to_make_fair(nums: Vec<i32>) -> i32 {\n        let mut l = [0; 2];\n        let mut r = [0; 2];\n        let mut ans = 0;\n        for i in 0..nums.len() {\n            r[i % 2] += nums[i];\n        }\n        for i in 0..nums.len() {\n            r[i % 2] -= nums[i];\n            if l[0] + r[1] == l[1] + r[0] {\n                ans += 1;\n            }\n            l[i % 2] += nums[i];\n        }\n        ans\n    }\n}","date":"2023-01-28"}],"tagList":["数组","前缀和"],"level":"Medium"}},{"problemName":"1668.最大重复子字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1668.最大重复子字符串.json","problemData":{"id":"1764","name":"1668.最大重复子字符串","url":"https://leetcode.cn/problems/maximum-repeating-substring","desc":"给你一个字符串 sequence 和 word ，请你返回 最大重复值 k 。","solutions":[{"date":"2022-11-04","time":0,"memory":6.3,"script":"cpp","desc":"走的步数相当于 1+2+..+n，把其中某几个节点替换成-，当 sum 超过 target 时，如果相减是偶数，那就可以直接使用，如果是奇数则一直累加到相减是偶数。","code":"class Solution {\npublic:\n    int reachNumber(int target) {\n        target = abs(target);\n        int sum = 0, cnt = 1;\n        while (sum < target || (sum - target) % 2 != 0) sum += cnt++;\n        return cnt - 1;\n    }\n};"}],"tagList":["字符串","动态规划","字符串匹配"],"level":"Easy"}},{"problemName":"1669.合并两个链表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1669.合并两个链表.json","problemData":{"id":"1765","name":"1669.合并两个链表","url":"https://leetcode.cn/problems/merge-in-between-linked-lists","desc":"给你两个链表 list1 和 list2 ，它们包含的元素分别为 n 个和 m 个。请你将 list1 中下标从 a 到 b 的全部节点都删除，并将list2 接在被删除节点的位置。","solutions":[{"script":"cpp","time":260,"memory":92.2,"desc":"双指针。","code":"class Solution {\npublic:\n    ListNode* mergeInBetween(ListNode* list1, int a, int b, ListNode* list2) {\n        ListNode *p1 = list1, *p2 = list2, *tmp;\n        for (int i = 0; i < a - 1; i++) p1 = p1->next;\n        tmp = p1->next;\n        p1->next = list2;\n        p1 = tmp;\n        while (p2->next) p2 = p2->next;\n        for (int i = 0; i < b - a; i++) p1 = p1->next;\n        p2->next = p1->next;\n        return list1;\n    }\n};","date":"2023-01-30"},{"script":"python","time":372,"memory":21.8,"desc":"同上。","code":"class Solution:\n    def mergeInBetween(self, list1: ListNode, a: int, b: int, list2: ListNode) -> ListNode:\n        p1, p2 = list1, list2\n        for _ in range(a - 1):\n            p1 = p1.next\n        tmp = p1.next\n        p1.next = list2\n        p1 = tmp\n        while p2.next:\n            p2 = p2.next\n        for _ in range(b - a):\n            p1 = p1.next\n        p2.next = p1.next\n        return list1","date":"2023-01-30"},{"script":"rust","time":52,"memory":3.6,"desc":"同上。","code":"impl Solution {\n    pub fn merge_in_between(\n        list1: Option<Box<ListNode>>,\n        a: i32,\n        b: i32,\n        list2: Option<Box<ListNode>>,\n    ) -> Option<Box<ListNode>> {\n        let mut list = Vec::<i32>::new();\n        let mut p1 = &list1;\n        let mut p2 = &list2;\n        for _ in 0..a {\n            list.push(p1.as_ref().unwrap().val);\n            p1 = &p1.as_ref().unwrap().next;\n        }\n        while let Some(ref node) = p2 {\n            list.push(node.val);\n            p2 = &node.next;\n        }\n        for _ in a..=b {\n            p1 = &p1.as_ref().unwrap().next;\n        }\n        while let Some(ref node) = p1 {\n            list.push(node.val);\n            p1 = &node.next;\n        }\n        let mut ans = Box::new(ListNode::new(0));\n        let mut p = &mut ans;\n        for num in list {\n            let mut node = p.as_mut();\n            node.next = Some(Box::new(ListNode::new(num)));\n            p = node.next.as_mut().unwrap();\n        }\n        ans.next\n    }\n}","date":"2023-01-30"}],"tagList":["链表"],"level":"Medium"}},{"problemName":"1670.设计前中后队列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1670.设计前中后队列.json","problemData":{"id":"1767","name":"1670.设计前中后队列","url":"https://leetcode.cn/problems/design-front-middle-back-queue","desc":"请你设计一个队列，支持在前，中，后三个位置的 push 和 pop 操作。","solutions":[{"date":"2021-03-14","time":144,"memory":45.1,"script":"typescript","desc":"利用两个数组维护中间值。","code":"class FrontMiddleBackQueue {\n  get frontLen() {\n    return this.front.length;\n  }\n  get backLen() {\n    return this.back.length;\n  }\n  get len() {\n    return this.frontLen + this.backLen;\n  }\n  private front: number[] = [];\n  private back: number[] = [];\n  pushFront(val: number): void {\n    this.front.unshift(val);\n    this.check();\n  }\n  pushMiddle(val: number): void {\n    this.front.push(val);\n    this.check();\n  }\n  pushBack(val: number): void {\n    this.back.push(val);\n    this.check();\n  }\n  popFront(): number {\n    if (this.len === 0) return -1;\n    const num = this.frontLen === 0 ? this.back.shift()! : this.front.shift()!;\n    this.check();\n    return num;\n  }\n  popMiddle(): number {\n    if (this.len === 0) return -1;\n    const num = this.frontLen === 0 || this.len & 1 ? this.back.shift()! : this.front.pop()!;\n    this.check();\n    return num;\n  }\n  popBack(): number {\n    if (this.len === 0) return -1;\n    const num = this.backLen === 0 ? this.front.pop()! : this.back.pop()!;\n    this.check();\n    return num;\n  }\n  private check() {\n    if (this.frontLen > this.backLen) {\n      this.back.unshift(this.front.pop()!);\n    }\n    if (this.backLen > this.frontLen + 1) {\n      this.front.push(this.back.shift()!);\n    }\n  }\n}"},{"date":"2022-03-03","time":28,"memory":20.4,"script":"cpp","desc":"维护两个双端队列。","code":"class FrontMiddleBackQueue {\n   public:\n    deque<int> q1, q2;\n    FrontMiddleBackQueue() {}\n    void balance() {\n        if (empty()) return;\n        while (q1.size() > q2.size()) {\n            q2.push_front(q1.back());\n            q1.pop_back();\n        }\n        while (q1.size() < q2.size() - 1) {\n            q1.push_back(q2.front());\n            q2.pop_front();\n        }\n    }\n    void pushFront(int val) {\n        q1.push_front(val);\n        balance();\n    }\n    void pushMiddle(int val) {\n        if (q1.size() == q2.size())\n            q1.push_back(val);\n        else\n            q2.push_front(val);\n        balance();\n    }\n    void pushBack(int val) {\n        q2.push_back(val);\n        balance();\n    }\n    int popFront() {\n        if (empty()) return -1;\n        int res;\n        if (q1.size()) {\n            res = q1.front();\n            q1.pop_front();\n        } else {\n            res = q2.front();\n            q2.pop_front();\n        }\n        balance();\n        return res;\n    }\n    int popMiddle() {\n        if (empty()) return -1;\n        int res;\n        if (q1.size() == q2.size()) {\n            res = q1.back();\n            q1.pop_back();\n        } else {\n            res = q2.front();\n            q2.pop_front();\n        }\n        balance();\n        return res;\n    }\n    int popBack() {\n        if (empty()) return -1;\n        int res = q2.back();\n        q2.pop_back();\n        balance();\n        return res;\n    }\n    int empty() { return q1.size() + q2.size() == 0; }\n};"},{"script":"python","time":68,"memory":16.81,"desc":"两个双端队列1670. 设计前中后队列。","code":"class FrontMiddleBackQueue:\n    def __init__(self):\n        self.len = 0\n        self.q1 = deque()\n        self.q2 = deque()\n    def pushFront(self, val: int) -> None:\n        self.q1.appendleft(val)\n        self.after(1)\n    def pushMiddle(self, val: int) -> None:\n        self.q2.appendleft(val)\n        self.after(1)\n    def pushBack(self, val: int) -> None:\n        self.q2.append(val)\n        self.after(1)\n    def after(self, offset: int) -> None:\n        self.len += offset\n        if len(self.q1) + 2 == len(self.q2): self.q1.append(self.q2.popleft())\n        elif len(self.q1) == len(self.q2) + 1: self.q2.appendleft(self.q1.pop()) \n    def popFront(self) -> int:\n        if self.len == 0: return -1\n        val = self.q2.pop() if self.len == 1 else self.q1.popleft()\n        self.after(-1)\n        return val\n    def popMiddle(self) -> int:\n        if self.len == 0: return -1\n        val = self.q1.pop() if self.len % 2 == 0 else self.q2.popleft()\n        self.after(-1)\n        return val\n    def popBack(self) -> int:\n        if self.len == 0: return -1\n        val = self.q2.pop()\n        self.after(-1)\n        return val","date":"2023-11-28"}],"tagList":["设计","队列","数组","链表","数据流"],"level":"Medium"}},{"problemName":"1671.得到山形数组的最少删除次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1671.得到山形数组的最少删除次数.json","problemData":{"id":"1766","name":"1671.得到山形数组的最少删除次数","url":"https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array","desc":"给你整数数组 nums​ ，请你返回将 nums 变成 山形状数组 的​ 最少 删除次数。","solutions":[{"script":"python","time":2260,"memory":17.11,"desc":"对两边求最长子序列。","code":"def getList(nums: List[int]) -> List[int]:\n        n = len(nums)\n        dp = [1] * n\n        for i in range(n):\n            for j in range(i):\n                if nums[i] > nums[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return dp\n    \n    class Solution:\n        def minimumMountainRemovals(self, nums: List[int]) -> int:\n            n = len(nums)\n            prev = getList(nums)\n            next = getList(nums[::-1])[::-1]\n            return n - max(prev[i] + next[i] - 1 if prev[i] > 1 and next[i] > 1 else 0 for i in range(n))","date":"2023-12-22"}],"tagList":["贪心","数组","二分查找","动态规划"],"level":"Hard"}},{"problemName":"1672.最富有客户的资产总量.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1672.最富有客户的资产总量.json","problemData":{"id":"1791","name":"1672.最富有客户的资产总量","url":"https://leetcode.cn/problems/richest-customer-wealth","desc":"客户的 资产总量 就是他们在各家银行托管的资产数量之和。最富有客户就是 资产总量 最大的客户。","solutions":[{"date":"2022-04-14","time":4,"memory":7.5,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    int maximumWealth(vector<vector<int>> &accounts) {\n        int ans = -1;\n        ;\n        for (auto &account : accounts) {\n            int sum = 0;\n            for (auto &data : account) sum += data;\n            ans = max(ans, sum);\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","矩阵"],"level":"Easy"}},{"problemName":"1673.找出最具竞争力的子序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1673.找出最具竞争力的子序列.json","problemData":{"id":"1792","name":"1673.找出最具竞争力的子序列","url":"https://leetcode.cn/problems/find-the-most-competitive-subsequence","desc":"给你一个整数数组 nums 和一个正整数 k ，返回长度为 k 且最具 竞争力 的 nums 子序列。","solutions":[{"script":"python","time":149,"memory":28.95,"desc":"单调栈。","code":"class Solution:\n    def mostCompetitive(self, nums: List[int], k: int) -> List[int]:\n        res = []\n        for i in range(len(nums)):\n            while res and res[-1] > nums[i] and len(nums) - i > k - len(res):\n                res.pop()\n            res.append(nums[i])\n        return res[:k]","date":"2024-05-24"}],"tagList":["栈","贪心","数组","单调栈"],"level":"Medium"}},{"problemName":"1678.设计Goal解析器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1678.设计Goal解析器.json","problemData":{"id":"1797","name":"1678.设计Goal解析器","url":"https://leetcode.cn/problems/goal-parser-interpretation","desc":"给你字符串 command ，返回 Goal 解析器 对 command 的解释结果。","solutions":[{"date":"2022-11-06","time":4,"memory":6,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    string interpret(string command) {\n        int n = command.size();\n        string ans = \"\";\n        for (int i = 0; i < n; i++) {\n            if (command[i] == 'G') ans += \"G\";\n            else if (command[i] == '(' && command[i + 1] == ')') ans += \"o\", i += 1;\n            else  ans += \"al\", i += 3;\n        }\n        return ans;\n    }\n};"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"1681.最小不兼容性.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1681.最小不兼容性.json","problemData":{"id":"1799","name":"1681.最小不兼容性","url":"https://leetcode.cn/problems/minimum-incompatibility","desc":"给你一个整数数组 nums​​​ 和一个整数 k 。你需要将这个数组划分到 k 个相同大小的子集中，使得同一个子集里面没有两个相同的元素。一个子集的 不兼容性 是该子集里面最大值和最小值的差。请你返回将数组分成 k 个子集后，各子集 不兼容性 的 和 的 最小值 ，如果无法分成分成 k 个子集，返回 -1 。","solutions":[{"script":"cpp","time":1852,"memory":303.8,"desc":"状态压缩+记忆化搜索。","code":"#define MAX 8\nclass Solution {\npublic:\n    int minimumIncompatibility(vector<int>& nums, int k) {\n        int n = nums.size(), m[17] = {0};\n        for (auto &num : nums) {\n            m[num]++;\n            if (m[num] > k) return -1;\n        }\n        if (k == n) return 0;\n        sort(nums.begin(), nums.end());\n\n        // cout << \"nums : \";\n        // for (auto &num : nums) cout << num << \", \";\n        // cout << endl;\n\n        // int dp[k + 1][1 << n];\n        // memset(dp, 0, sizeof(dp));\n        // for (int i = 1; i <= k; i++) {\n        //     int res = 0x3f3f3f3f;\n        // }\n\n        // return dp[k][1 << n];\n\n        unordered_map<int, unordered_map<int, int>> cache;\n        function<int(int, int)> dfs = [&](int cur, int used) {\n            // cout << \"==> cur = \" << cur << \", used = \" << bitset<MAX>(used).to_string() << endl;\n            if (cur == k) return 0;\n            if (cache[cur][used]) return cache[cur][used];\n            // cout << \"in\" << endl;\n            int res = 0x3f3f3f3f;\n            auto lists = comp(n / k, n, used, nums);\n\n            // cout << \"lists = \";\n            // for (auto &list : lists) {\n            //     cout << \"[\";\n            //     for (auto &num : list) {\n            //         cout << num << \", \";\n            //     }\n            //     cout << \"], \";\n            // }\n            // cout << endl;\n\n            for (auto &list : lists) {\n                int next_used = used, nmin = INT_MAX, nmax = INT_MIN;\n                for (auto &i : list) {\n                    nmin = min(nmin, nums[i]);\n                    nmax = max(nmax, nums[i]);\n                    next_used |= 1 << i;\n                }\n                auto next = dfs(cur + 1, next_used);\n                // cout << \"nmin = \" << nmin << \", nmax = \" << nmax << endl;\n                // cout << \"res = \" << res << \", dfs = \" << next << endl;\n                res = min(res,  next + nmax - nmin);\n            }\n\n            // cout << \"==> cur = \" << cur << \", used = \" << bitset<MAX>(used).to_string() << \", res = \" << res << endl;\n\n            return cache[cur][used] = res;\n        };\n        return dfs(0, 0);\n    }\n    vector<vector<int>> comp(int cnt, int total, int used, vector<int>& nums) {\n        // cout << \"comp \" << cnt << \", \" << total << \", \" << bitset<MAX>(used).to_string() << endl;\n\n        vector<vector<int>> res;\n        vector<int> list;\n        function<void(int, int)> dfs = [&](int idx, int sum) {\n\n            // cout << \"dfs \" << idx << \", \" << sum << \", list = \";\n            // for (auto &item : list) cout << item << \", \";\n            // cout << endl;\n\n            if (total - idx < sum) return;\n            else if (sum == 0) res.push_back(list);\n            else {\n                int cur_num = nums[idx];\n                bool is_used = used & (1 << idx);\n                if (!is_used) {\n                    list.push_back(idx);\n\n                    int next_idx = idx + 1;\n                    while (next_idx < total && nums[next_idx] == nums[idx]) next_idx++;\n                    dfs(next_idx, sum - 1);\n\n                    list.pop_back();\n                }\n\n                int next_idx = idx + 1;\n                while (next_idx < total && nums[idx] == nums[next_idx] && !is_used) next_idx++;\n                dfs(next_idx, sum);\n            }\n        };\n        dfs(0, cnt);\n        return res;\n    }\n};","date":"2023-06-28"}],"tagList":["位运算","数组","动态规划","状态压缩"],"level":"Hard"}},{"problemName":"1684.统计一致字符串的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1684.统计一致字符串的数目.json","problemData":{"id":"1786","name":"1684.统计一致字符串的数目","url":"https://leetcode.cn/problems/count-the-number-of-consistent-strings","desc":"请你返回 words 数组中 一致字符串 的数目。","solutions":[{"date":"2022-11-08","time":32,"memory":29.4,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    int countConsistentStrings(string allowed, vector<string>& words) {\n        int list[26] = {0};\n        for (auto &c : allowed) list[c - 'a'] = 1;\n        int ans = 0;\n        for (auto &s : words) {\n            bool f = true;\n            for (auto &c : s) {\n                if (list[c - 'a'] == 0) {\n                    f = false;\n                    break;\n                }\n            }\n            if (f) ans++;\n        }\n        return ans;\n    }\n};"}],"tagList":["位运算","数组","哈希表","字符串"],"level":"Easy"}},{"problemName":"1686.石子游戏VI.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1686.石子游戏VI.json","problemData":{"id":"1788","name":"1686.石子游戏VI","url":"https://leetcode.cn/problems/stone-game-vi","desc":"所有石子都被取完后，得分较高的人为胜者。如果两个玩家得分相同，那么为平局。两位玩家都会采用 最优策略 进行游戏。","solutions":[{"script":"python","time":241,"memory":27.69,"desc":"优先拿分数总和最大的。","code":"class Solution:\n    def stoneGameVI(self, aliceValues: List[int], bobValues: List[int]) -> int:\n        values = sorted((av + bv, av, bv) for av, bv in zip(aliceValues, bobValues))\n        asum = sum(item[1] for item in values[-1::-2])\n        bsum = sum(item[2] for item in values[-2::-2])\n        if asum > bsum: return 1\n        if asum < bsum: return -1\n        return 0","date":"2024-02-02"}],"tagList":["贪心","数组","数学","博弈","排序","堆（优先队列）"],"level":"Medium"}},{"problemName":"1687.从仓库到码头运输箱子.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1687.从仓库到码头运输箱子.json","problemData":{"id":"1789","name":"1687.从仓库到码头运输箱子","url":"https://leetcode.cn/problems/delivering-boxes-from-storage-to-ports","desc":"请你返回将所有箱子送到相应码头的 最少行程 次数。","solutions":[{"date":"2022-12-05","time":440,"memory":149.6,"script":"cpp","desc":"前缀和统计从第一个点到当前点总共的路径数，利用单调队列快速求。","code":"#include <iostream>\n#include <deque>\n#include <vector>\n// bestlyg\n# define X dpirst\n# define Y second\n# define lb(x) ((x) & (-x))\n# define mem(a,b) memset(a,b,sizeodp(a))\n# define debug dpreopen(\"r.txt\",\"r\",stdin)\n# define pi pair<int,int>\n\n#ifdef DEBUG\n#define log(dprm, args...) {    printf(dprm, ##args); }\n#else\n#define log(dprm, args...)\n#endif\ntypedef long long ll;\nusing namespace std;\n\nclass Solution {\npublic:\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {\n        int n = boxes.size();\n        vector<ll> dp(n + 1, 0), sums_w(n + 1, 0), sums_p(n + 1, 0);\n        deque<int> q;\n        q.push_back(0);\n        for (int i = 1; i <= n; i++) {\n            sums_w[i] = sums_w[i - 1] + boxes[i - 1][1];\n            if (i != n) sums_p[i] = sums_p[i - 1] + (boxes[i][0] != boxes[i - 1][0] ? 1 : 0);\n            while (q.size() && (sums_w[i] - sums_w[q.front()] > maxWeight || i - q.front() > maxBoxes)) q.pop_front();\n            if (q.size()) dp[i] = dp[q.front()] + sums_p[i - 1] - sums_p[q.front()] + 2;\n            if (i != n) while (q.size() && dp[q.back()] - sums_p[q.back()] >= dp[i] - sums_p[i]) q.pop_back();\n            q.push_back(i);\n        }\n        return dp[n];\n    }\n};"}],"tagList":["线段树","队列","数组","动态规划","前缀和","单调队列","堆（优先队列）"],"level":"Hard"}},{"problemName":"1688.比赛中的配对次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1688.比赛中的配对次数.json","problemData":{"id":"1806","name":"1688.比赛中的配对次数","url":"https://leetcode.cn/problems/count-of-matches-in-tournament","desc":"返回在比赛中进行的配对次数，直到决出获胜队伍为止。","solutions":[{"date":"2022-01-26","time":0,"memory":6,"script":"cpp","desc":"遍历一遍，统计每次的次数。","code":"class Solution {\n   public:\n    int numberOfMatches(int n) {\n        int cnt = 0;\n        while (n > 1) {\n            cnt += n / 2;\n            n = ceil(n / 2.0);\n        }\n        return cnt;\n    }\n};"}],"tagList":["数学","模拟"],"level":"Easy"}},{"problemName":"1690.石子游戏VII.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1690.石子游戏VII.json","problemData":{"id":"1808","name":"1690.石子游戏VII","url":"https://leetcode.cn/problems/stone-game-vii","desc":"给你一个整数数组 stones ，其中 stones[i] 表示 从左边开始 的第 i 个石头的值，如果爱丽丝和鲍勃都 发挥出最佳水平 ，请返回他们 得分的差值 。","solutions":[{"date":"2024-02-03","script":"python","time":4980,"memory":349.04,"desc":"dfs。","code":"class Solution:\n    def stoneGameVII(self, stones: List[int]) -> int:\n        n = len(stones)\n        dp = [[0] * n for _ in range(n)]\n        sums = [0]\n        for stone in stones: sums.append(sums[-1] + stone)\n        @cache\n        def dfs(l: int, r: int, f: int) -> int:\n            if l == r: return 0\n            v1 = sums[r + 1] - sums[l + 1]\n            v2 = sums[r] - sums[l]\n            res1 = -dfs(l + 1, r, -f) \n            res2 = -dfs(l, r - 1, -f) \n            # print(f'l = {l}, r = {r}, f = {f}, v1 = {v1}, v2 = {v2} res1 = {res1}, res2 = {res2}, res = {f * max(res1 + v1, res2 + v2)}')\n            return max(res1 + v1, res2 + v2)\n        return dfs(0, n - 1, 1)"}],"tagList":["数组","数学","动态规划","博弈"],"level":"Medium"}},{"problemName":"1691.堆叠长方体的最大高度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1691.堆叠长方体的最大高度.json","problemData":{"id":"1367","name":"1691.堆叠长方体的最大高度","url":"https://leetcode.cn/problems/maximum-height-by-stacking-cuboids","desc":"返回 堆叠长方体 cuboids 可以得到的 最大高度 。","solutions":[{"date":"2022-12-10","time":12,"memory":8.9,"script":"cpp","desc":"dp[i]表示 i 作为最后一个点的时候的最大高度。","code":"class Solution {\npublic:\n    int maxHeight(vector<vector<int>>& cuboids) {\n        int n = cuboids.size(), ans = 0;\n        vector<int> dp(n);\n        sort(cuboids.begin(), cuboids.end(), [](const vector<int> &a, const vector<int> &b){\n            return a[0] + a[1] + a[2] > b[0] + b[1] + b[2];\n        });\n        for (auto &item : cuboids) sort(item.begin(), item.end());\n        for (int i = 0; i < n; i++) {\n            dp[i] = cuboids[i][2];\n            for (int j = 0; j < i; j++) {\n                if (cuboids[j][0] < cuboids[i][0] || cuboids[j][1] < cuboids[i][1] || cuboids[j][2] < cuboids[i][2]) continue;\n                dp[i] = max(dp[i], dp[j] + cuboids[i][2]);\n            }\n            ans = max(ans, dp[i]);\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","动态规划","排序"],"level":"Hard"}},{"problemName":"1694.重新格式化电话号码.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1694.重新格式化电话号码.json","problemData":{"id":"1812","name":"1694.重新格式化电话号码","url":"https://leetcode.cn/problems/reformat-phone-number","desc":"返回格式化后的电话号码。","solutions":[{"date":"2022-10-01","time":12,"memory":11.9,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    string reformatNumber(string number) {\n        string tmp = \"\", ans = \"\";\n        for (auto &c : number) {\n            if (c != '-' && c != ' ') tmp += c;\n        }\n        int len = tmp.size(), idx = 0;\n        while (len > 4) {\n            ans += to_string(tmp[idx++] - '0') + to_string(tmp[idx++] - '0') + to_string(tmp[idx++] - '0') + \"-\";\n            len -= 3;\n        }\n        if (len == 4) {\n            ans += to_string(tmp[idx++] - '0') + to_string(tmp[idx++] - '0') + \"-\" + to_string(tmp[idx++] - '0') + to_string(tmp[idx++] - '0');\n        } else {\n            while (idx < tmp.size()) ans += to_string(tmp[idx++] - '0');\n        }\n        return ans;\n    }\n};"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"1696.跳跃游戏VI.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1696.跳跃游戏VI.json","problemData":{"id":"1814","name":"1696.跳跃游戏VI","url":"https://leetcode.cn/problems/jump-game-vi","desc":"你的目标是到达数组最后一个位置（下标为 n - 1 ），你的 得分 为经过的所有数字之和。请你返回你能得到的 最大得分 。","solutions":[{"script":"python","time":192,"memory":28.7,"desc":"单调队列。","code":"class Solution:\n    def maxResult(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [0] * n\n        q = deque()\n        for i in range(n):\n            dp[i] += nums[i]\n            while q and q[0] < i - k: q.popleft()\n            if q: dp[i] += dp[q[0]]\n            while q and dp[q[-1]] <= dp[i]: q.pop()\n            q.append(i)\n            # print(f'i = {i}, q = {q}, dp = {dp}')\n        return dp[-1]","date":"2024-02-05"}],"tagList":["队列","数组","动态规划","单调队列","堆（优先队列）"],"level":"Medium"}},{"problemName":"1700.无法吃午餐的学生数量.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1601-1700/1700.无法吃午餐的学生数量.json","problemData":{"id":"1802","name":"1700.无法吃午餐的学生数量","url":"https://leetcode.cn/problems/number-of-students-unable-to-eat-lunch","desc":"请你返回无法吃午餐的学生数量。","solutions":[{"date":"2022-10-19","time":0,"memory":8,"script":"cpp","desc":"模拟。","code":"class Solution {\npublic:\n    int countStudents(vector<int>& students, vector<int>& sandwiches) {\n        int n = sandwiches.size(), list[2] = {0};\n        queue<int> q1, q2;\n        for (auto &s : students) q1.push(s), list[s]++;;\n        for (auto &s : sandwiches) q2.push(s);\n        while (q2.size()) {\n            int size = q2.size();\n            while (q1.size() && q1.front() == q2.front()) list[q1.front()]--, q1.pop(), q2.pop();\n            if (q2.size()) q1.push(q1.front()), q1.pop();\n            if (q2.size() && list[q2.front()] == 0) break;\n        }\n        return q1.size();\n    }\n};"},{"date":"2022-10-19","time":4,"memory":8.4,"script":"cpp","desc":"模拟。","code":"class Solution {\npublic:\n    int countStudents(vector<int>& students, vector<int>& sandwiches) {\n        int list[2] = {0};\n        for (auto &s : students) list[s]++;\n        for (int i = 0; i < sandwiches.size() && list[sandwiches[i]]; i++) list[sandwiches[i]]--;\n        return list[0] + list[1];\n    }\n};"}],"tagList":["栈","队列","数组","模拟"],"level":"Easy"}}]},{"dirName":"1701-1800","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\1701-1800","problems":[{"problemName":"1702.修改后的最大二进制字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1702.修改后的最大二进制字符串.json","problemData":{"id":"1804","name":"1702.修改后的最大二进制字符串","url":"https://leetcode.cn/problems/maximum-binary-string-after-change","desc":"请你返回执行上述操作任意次以后能得到的 最大二进制字符串 。","solutions":[{"script":"python","time":61,"memory":17.39,"desc":"遍历。","code":"class Solution:\n    def maximumBinaryString(self, binary: str) -> str:\n        count = binary.count('0')\n        if not count: return binary\n        first_idx = binary.index('0')\n        pren = first_idx + count - 1\n        return '1' * pren + '0' + '1' * (len(binary) - pren - 1)","date":"2024-04-10"}],"tagList":["贪心","字符串"],"level":"Medium"}},{"problemName":"1703.得到连续K个1的最少相邻交换次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1703.得到连续K个1的最少相邻交换次数.json","problemData":{"id":"1805","name":"1703.得到连续K个1的最少相邻交换次数","url":"https://leetcode.cn/problems/minimum-adjacent-swaps-for-k-consecutive-ones","desc":"请你返回使 nums 中包含 k 个 连续 1 的 最少 交换次数。","solutions":[{"date":"2022-12-23","time":564,"memory":122.5,"script":"cpp","desc":"[参考链接](https://leetcode.cn/problems/minimum-adjacent-swaps-for-k-consecutive-ones/solution/tu-jie-zhuan-huan-cheng-zhong-wei-shu-ta-iz4v/)。","code":"class Solution {\npublic:\n    int minMoves(vector<int>& nums, int k) {\n        int ans = 0x7fffffff;\n        vector<int> ilist, slist(1, 0);\n        for (int i = 0, cnt = 0; i < nums.size(); i++) {\n            if (nums[i] == 1) {\n                ilist.push_back(i - cnt++);\n                slist.push_back(slist.back() + ilist.back());\n            }\n        }\n        for (int i = 0; i + k <= ilist.size(); i++)\n            ans = min(ans, slist[i + k] + slist[i] - 2 * slist[i + k / 2] - k % 2 * ilist[i + k / 2]);\n        return ans;\n    }\n};"}],"tagList":["贪心","数组","前缀和","滑动窗口"],"level":"Hard"}},{"problemName":"1704.判断字符串的两半是否相似.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1704.判断字符串的两半是否相似.json","problemData":{"id":"1823","name":"1704.判断字符串的两半是否相似","url":"https://leetcode.cn/problems/determine-if-string-halves-are-alike","desc":"如果 a 和 b 相似，返回 true ；否则，返回 false 。","solutions":[{"date":"2022-11-11","time":8,"memory":6.6,"script":"cpp","desc":"双指针遍历。","code":"class Solution {\npublic:\n    bool halvesAreAlike(string s) {\n        unordered_set<char> sset{ 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\n        int n = s.size(), cnt = 0;\n        for (int l = 0, r = s.size() / 2; r < s.size(); l++, r++) {\n            if (sset.count(s[l])) cnt++;\n            if (sset.count(s[r])) cnt--;\n        }\n        return cnt == 0;\n    }\n};"}],"tagList":["字符串","计数"],"level":"Easy"}},{"problemName":"1705.吃苹果的最大数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1705.吃苹果的最大数目.json","problemData":{"id":"1824","name":"1705.吃苹果的最大数目","url":"https://leetcode.cn/problems/maximum-number-of-eaten-apples","desc":"给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。","solutions":[{"date":"2021-12-24","time":16,"memory":15.6,"script":"cpp","desc":"异或得到两个唯一数的值，根据首个不同的位数，分别异或。","code":"class Solution {\n   public:\n    vector<int> singleNumbers(vector<int> &nums) {\n        int val = 0;\n        for (auto &num : nums) val ^= num;\n        vector<int> ans(2, 0);\n        int bit = 0;\n        while ((val & 1 << bit) == 0) bit++;\n        bit = 1 << bit;\n        for (auto &num : nums) {\n            if (num & bit)\n                ans[0] ^= num;\n            else\n                ans[1] ^= num;\n        }\n        return ans;\n    }\n};"}],"tagList":["贪心","数组","堆（优先队列）"],"level":"Medium"}},{"problemName":"1706.球会落何处.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1706.球会落何处.json","problemData":{"id":"1324","name":"1706.球会落何处","url":"https://leetcode.cn/problems/where-will-the-ball-fall","desc":"返回一个大小为 n 的数组 answer ，其中 answer[i] 是球放在顶部的第 i 列后从底部掉出来的那一列对应的下标，如果球卡在盒子里，则返回 -1 。","solutions":[{"date":"2022-02-24","time":28,"memory":13,"script":"cpp","desc":"dfs。","code":"class Solution {\n   public:\n    int n, m, check[100][100][4] = {0}, mmap[100][100][4] = {0};\n    int dfs(vector<vector<int>>& grid, int row, int col, int idx) {\n        if (mmap[row][col][idx]) return mmap[row][col][idx];\n        int ans = -1;\n        check[row][col][idx] = 1;\n\n        if (grid[row][col] == 1) {\n            if ((idx == 0 || idx == 3) && col < m - 1 &&\n                check[row][col + 1][1] == 0) {\n                ans = dfs(grid, row, col + 1, 1);\n            } else if ((idx == 1 || idx == 2) && row < n - 1 &&\n                       check[row + 1][col][0] == 0) {\n                ans = dfs(grid, row + 1, col, 0);\n            }\n        } else {\n            if ((idx == 0 || idx == 1) && col > 0 &&\n                check[row][col - 1][3] == 0) {\n                ans = dfs(grid, row, col - 1, 3);\n            } else if ((idx == 2 || idx == 3) && row < n - 1 &&\n                       check[row + 1][col][0] == 0) {\n                ans = dfs(grid, row + 1, col, 0);\n            }\n        }\n\n        check[row][col][idx] = 0;\n        return mmap[row][col][idx] = ans;\n    }\n    vector<int> findBall(vector<vector<int>>& grid) {\n        n = grid.size();\n        m = grid[0].size();\n        vector<int> ans(m);\n        for (int col = 0; col < m; col++) {\n            if (grid[n - 1][col] == 1) {\n                mmap[n - 1][col][1] = mmap[n - 1][col][2] = col + 1;\n            } else {\n                mmap[n - 1][col][2] = mmap[n - 1][col][3] = col + 1;\n            }\n        }\n        for (int col = 0; col < m; col++) {\n            int val = dfs(grid, 0, col, 0);\n            if (val > 0) val -= 1;\n            ans[col] = val;\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","矩阵","模拟"],"level":"Medium"}},{"problemName":"1707.与数组中元素的最大异或值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1707.与数组中元素的最大异或值.json","problemData":{"id":"1826","name":"1707.与数组中元素的最大异或值","url":"https://leetcode.cn/problems/maximum-xor-with-an-element-from-array","desc":"返回一个整数数组 answer 作为查询的答案，其中 answer.length == queries.length 且 answer[i] 是第 i 个查询的答案。","solutions":[{"date":"2021-05-23","time":3000,"memory":122.9,"script":"typescript","desc":"构建字典树，排序后计算最大可能异或值。","code":"class Trie {\n  left: Trie | null = null;\n  right: Trie | null = null;\n  val: number | null = null;\n}\nfunction maximizeXor(nums: number[], queries: number[][]): number[] {\n  const root = new Trie();\n  const add = (num: number) => {\n    let node = root;\n    for (let i = 31; i >= 0; i--) {\n      const val = (num >> i) & 1;\n      if (val === 1) node = node.right ?? (node.right = new Trie());\n      else node = node.left ?? (node.left = new Trie());\n      node.val = num;\n    }\n  };\n  const select = (num: number): number => {\n    let node = root;\n    for (let i = 31; i >= 0; i--) {\n      const val = (num >> i) & 1;\n      if (val === 1) node = node.left ?? node.right!;\n      else node = node.right ?? node.left!;\n    }\n    return node.val!;\n  };\n  nums.sort((a, b) => a - b);\n  const queryMap = new Map<number[], number>();\n  queries.forEach((v, i) => queryMap.set(v, i));\n  queries.sort(([, a], [, b]) => a - b);\n  const ans: number[] = [];\n  for (const query of queries) {\n    const [x, m] = query;\n    while (nums.length > 0 && nums[0] <= m) add(nums.shift()!);\n    const index = queryMap.get(query)!;\n    ans[index] = root.left === null && root.right === null ? -1 : x ^ select(x);\n  }\n  return ans;\n}"}],"tagList":["位运算","字典树","数组"],"level":"Hard"}},{"problemName":"1710.卡车上的最大单元数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1710.卡车上的最大单元数.json","problemData":{"id":"1829","name":"1710.卡车上的最大单元数","url":"https://leetcode.cn/problems/maximum-units-on-a-truck","desc":"返回卡车可以装载 单元 的 最大 总数。","solutions":[{"date":"2022-11-15","time":44,"memory":15.6,"script":"cpp","desc":"排序后遍历。","code":"class Solution {\npublic:\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\n        sort(boxTypes.begin(), boxTypes.end(), [](auto &a, auto &b){ return a[1] > b[1]; });\n        int ans = 0, cur = 0;\n        while (truckSize && cur < boxTypes.size()) {\n            if (boxTypes[cur][0] >= truckSize) {\n                ans += truckSize * boxTypes[cur][1];\n                truckSize = 0;\n            } else {\n                truckSize -= boxTypes[cur][0];\n                ans += boxTypes[cur][0] * boxTypes[cur][1];\n            }\n            cur++;\n        }\n        return ans;\n    }\n};"}],"tagList":["贪心","数组","排序"],"level":"Easy"}},{"problemName":"1711.大餐计数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1711.大餐计数.json","problemData":{"id":"1830","name":"1711.大餐计数","url":"https://leetcode.cn/problems/count-good-meals","desc":"给你一个整数数组 deliciousness ，其中 deliciousness[i] 是第 i​​​​​​​​​​​​​​ 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 大餐 的数量。","solutions":[{"date":"2021-07-07","time":304,"memory":50.4,"script":"typescript","desc":"对每个值进行查看 2 的幂可能性。","code":"function countPairs(deliciousness: number[]): number {\n  const MOD = 10 ** 9 + 7;\n  const LIST_2: number[] = [];\n  for (let i = 1, max = 2 ** 21; i <= max; i <<= 1) LIST_2.push(i);\n  const map: Record<number, number> = {};\n  let ans = 0;\n  for (const num of deliciousness) {\n    for (const num2 of LIST_2) if (num2 >= num) ans = (ans + (map[num2 - num] ?? 0)) % MOD;\n    map[num] = (map[num] ?? 0) + 1;\n  }\n  return ans;\n}"}],"tagList":["数组","哈希表"],"level":"Medium"}},{"problemName":"1716.计算力扣银行的钱.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1716.计算力扣银行的钱.json","problemData":{"id":"1817","name":"1716.计算力扣银行的钱","url":"https://leetcode.cn/problems/calculate-money-in-leetcode-bank","desc":"给你 n ，请你返回在第 n 天结束的时候他在力扣银行总共存了多少块钱。","solutions":[{"date":"2022-01-16","time":16,"memory":16.3,"script":"cpp","desc":"随机数。","code":"class Solution {\n   public:\n    vector<int> arr;\n    Solution(ListNode* head) {\n        srand(time(0));\n        ListNode* p = head;\n        while (p) {\n            arr.push_back(p->val);\n            p = p->next;\n        }\n    }\n\n    int getRandom() { return arr[rand() % arr.size()]; }\n};"},{"date":"2022-01-16","time":24,"memory":16.2,"script":"cpp","desc":"水塘抽样。","code":"class Solution {\n   public:\n    ListNode *node;\n    Solution(ListNode *head) {\n        srand(time(0));\n        node = head;\n    }\n\n    int getRandom() {\n        int ans, i = 1;\n        for (ListNode *p = node; p; p = p->next, i++) {\n            if (rand() % i == 0) ans = p->val;\n        }\n        return ans;\n    }\n};"}],"tagList":["数学"],"level":"Easy"}},{"problemName":"1719.重构一棵树的方案数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1719.重构一棵树的方案数.json","problemData":{"id":"1820","name":"1719.重构一棵树的方案数","url":"https://leetcode.cn/problems/number-of-ways-to-reconstruct-a-tree","desc":"请你返回 ways。","solutions":[{"date":"2022-02-16","time":728,"memory":159.7,"script":"cpp","desc":"找到根节点后，遍历所有节点找到其父节点。","code":"class Solution {\n   public:\n    int checkWays(vector<vector<int>>& pairs) {\n        unordered_map<int, unordered_set<int>> m;\n        int root = pairs[0][0];\n        // 装载pair到map中，同时记录相邻最多的节点\n        for (auto& pair : pairs) {\n            m[pair[0]].emplace(pair[1]);\n            m[pair[1]].emplace(pair[0]);\n            if (m[root].size() < m[pair[0]].size()) root = pair[0];\n            if (m[root].size() < m[pair[1]].size()) root = pair[1];\n        }\n        // 如果最多的节点没法覆盖所有其他节点，那就无法生成树\n        if (m[root].size() != m.size() - 1) return 0;\n        int ans = 1;\n        // 遍历所有子节点\n        for (auto& [node, list] : m) {\n            if (node == root) continue;\n            // 寻找当前子节点的最小父节点， 拥有比当前节点更多的相邻数，\n            // 且子节点的所有相邻也与父节点相邻\n            int degree = list.size(), parent = -1, parent_degree = INT_MAX;\n            for (auto& node : list) {\n                if (m[node].size() < parent_degree &&\n                    m[node].size() >= degree) {\n                    parent = node;\n                    parent_degree = m[node].size();\n                }\n            }\n            // 找不到父节点就不可能成树\n            if (parent == -1) return 0;\n            for (auto& node : list) {\n                if (node == parent) continue;\n                if (!m[parent].count(node)) return 0;\n            }\n            // 如果连接数相同说明父子可以替换\n            if (parent_degree == degree) ans = 2;\n        }\n        return ans;\n    }\n};"}],"tagList":["树","图"],"level":"Hard"}},{"problemName":"1720.解码异或后的数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1720.解码异或后的数组.json","problemData":{"id":"1839","name":"1720.解码异或后的数组","url":"https://leetcode.cn/problems/decode-xored-array","desc":"请解码返回原数组 arr 。可以证明答案存在并且是唯一的。","solutions":[{"date":"2021-05-06","time":144,"memory":45.1,"script":"typescript","desc":"利用异或读取下一个值。","code":"function decode(encoded: number[], first: number): number[] {\n  return [first, ...encoded.map(num => (first = num ^ first))];\n}"}],"tagList":["位运算","数组"],"level":"Easy"}},{"problemName":"1723.完成所有工作的最短时间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1723.完成所有工作的最短时间.json","problemData":{"id":"1825","name":"1723.完成所有工作的最短时间","url":"https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs","desc":"返回分配方案中尽可能 最小 的 最大工作时间 。","solutions":[{"date":"2021-05-08","time":3336,"memory":39.8,"script":"typescript","desc":"回溯。","code":"function minimumTimeRequired(jobs: number[], k: number): number {\n  const len = jobs.length;\n  if (len === k) return Math.max(...jobs);\n  const workers: number[] = new Array(k).fill(0);\n  let min = Infinity;\n  const distribute = (jobIndex: number = 0) => {\n    if (jobIndex === len) {\n      min = Math.min(min, Math.max(...workers));\n      return;\n    }\n    for (let i = 0; i < k; i++) {\n      if (i > 0 && workers[i] === workers[i - 1]) continue;\n      workers[i] += jobs[jobIndex];\n      distribute(jobIndex + 1);\n      workers[i] -= jobs[jobIndex];\n    }\n  };\n  distribute();\n  return min;\n}"}],"tagList":["位运算","数组","动态规划","回溯","状态压缩"],"level":"Hard"}},{"problemName":"1725.可以形成最大正方形的矩形数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1725.可以形成最大正方形的矩形数目.json","problemData":{"id":"1843","name":"1725.可以形成最大正方形的矩形数目","url":"https://leetcode.cn/problems/number-of-rectangles-that-can-form-the-largest-square","desc":"请你统计有多少个矩形能够切出边长为 maxLen 的正方形，并返回矩形 数目 。","solutions":[{"date":"2022-02-05","time":36,"memory":17.9,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    int countGoodRectangles(vector<vector<int>>& rectangles) {\n        int len = INT_MIN, ans = 0;\n        for (auto& data : rectangles) len = max(len, min(data[0], data[1]));\n        for (auto& data : rectangles)\n            if (len <= data[0] && len <= data[1]) ans++;\n        return ans;\n    }\n};"}],"tagList":["数组"],"level":"Easy"}},{"problemName":"1726.同积元组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1726.同积元组.json","problemData":{"id":"1364","name":"1726.同积元组","url":"https://leetcode.cn/problems/tuple-with-same-product","desc":"给你一个由 不同 正整数组成的数组 nums ，请你返回满足 a * b = c * d 的元组 (a, b, c, d) 的数量。其中 a、b、c 和 d 都是 nums 中的元素，且 a != b != c != d 。","solutions":[{"script":"python","time":716,"memory":43.15,"desc":"遍历后计数。","code":"class Solution:\n    def tupleSameProduct(self, nums: List[int]) -> int:\n        n = len(nums)\n        map = Counter()\n        for i in range(n):\n            for j in range(i + 1, n):\n                map[nums[i] * nums[j]] += 1\n        return sum(v * (v - 1) * 4 for v in map.values())\n","date":"2023-10-19"}],"tagList":["数组","哈希表","计数"],"level":"Medium"}},{"problemName":"1732.找到最高海拔.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1732.找到最高海拔.json","problemData":{"id":"1833","name":"1732.找到最高海拔","url":"https://leetcode.cn/problems/find-the-highest-altitude","desc":"给你一个长度为 n  的整数数组  gain ，其中 gain[i]  是点 i  和点 i + 1  的 净海拔高度差（0 <= i < n）。请你返回 最高点的海拔 。","solutions":[{"date":"2022-11-19","time":4,"memory":7.8,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    int largestAltitude(vector<int>& gain) {\n        int cur = 0, ans = 0;\n        for (int i = 0; i < gain.size(); i++) {\n            cur += gain[i];\n            ans = max(ans, cur);\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","前缀和"],"level":"Easy"}},{"problemName":"1734.解码异或后的排列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1734.解码异或后的排列.json","problemData":{"id":"1835","name":"1734.解码异或后的排列","url":"https://leetcode.cn/problems/decode-xored-permutation","desc":"给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。","solutions":[{"date":"2021-05-11","time":392,"memory":71.4,"script":"typescript","desc":"已知 1~n 的所有值异或结果进行求首值。","code":"function decode(encoded: number[]): number[] {\n  const n = encoded.length + 1;\n  let xorNum = 1;\n  for (let i = 2; i <= n; i++) xorNum ^= i;\n  for (let i = 1; i < n - 1; i += 2) xorNum ^= encoded[i];\n  return [xorNum, ...encoded.map(v => (xorNum ^= v))];\n}"}],"tagList":["位运算","数组"],"level":"Medium"}},{"problemName":"1736.替换隐藏数字得到的最晚时间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1736.替换隐藏数字得到的最晚时间.json","problemData":{"id":"1858","name":"1736.替换隐藏数字得到的最晚时间","url":"https://leetcode.cn/problems/latest-time-by-replacing-hidden-digits","desc":"给你一个字符串 time ，返回你可以得到的最晚有效时间。","solutions":[{"date":"2021-07-24","time":64,"memory":39.3,"script":"typescript","desc":"判断每一位的最大值。","code":"function maximumTime(time: string): string {\n  let [h1, h2, , m1, m2] = time;\n  if (h1 === '?') {\n    if (h2 === '?') {\n      h1 = '2';\n      h2 = '3';\n    } else {\n      const num = +h2;\n      if (num <= 3) h1 = '2';\n      else h1 = '1';\n    }\n  }\n  if (h2 === '?') {\n    if (h1 === '2') h2 = '3';\n    else h2 = '9';\n  }\n  if (m1 === '?') m1 = '5';\n  if (m2 === '?') m2 = '9';\n  return `${h1}${h2}:${m1}${m2}`;\n}"}],"tagList":["贪心","字符串"],"level":"Easy"}},{"problemName":"1738.找出第K大的异或坐标值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1738.找出第K大的异或坐标值.json","problemData":{"id":"1860","name":"1738.找出第K大的异或坐标值","url":"https://leetcode.cn/problems/find-kth-largest-xor-coordinate-value","desc":"请你找出 matrix 的所有坐标中第 k 大的值（k 的值从 1 开始计数）。","solutions":[{"date":"2021-05-19","time":736,"memory":105.1,"script":"typescript","desc":"前缀和。","code":"function kthLargestValue(matrix: number[][], k: number): number {\n  const rowLen = matrix.length;\n  const colLen = matrix[0].length;\n  const prefixSumList: number[][] = new Array(rowLen + 1)\n    .fill(0)\n    .map(_ => new Array(colLen + 1).fill(0));\n  const list: number[] = [];\n  for (let row = 1; row <= rowLen; row++) {\n    for (let col = 1; col <= colLen; col++) {\n      list.push(\n        (prefixSumList[row][col] =\n          prefixSumList[row - 1][col] ^\n          prefixSumList[row][col - 1] ^\n          prefixSumList[row - 1][col - 1] ^\n          matrix[row - 1][col - 1])\n      );\n    }\n  }\n  return list.sort((a, b) => b - a)[k - 1];\n}"},{"script":"python","time":770,"memory":61.8,"desc":"前缀和存储异或值后，利用堆排序。","code":"class Solution:\n    def kthLargestValue(self, matrix: List[List[int]], k: int) -> int:\n        n, m = len(matrix), len(matrix[0])\n        sums = [[0] * (m + 1) for _ in range(n + 1)]\n        q = []\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                sums[i][j] = sums[i - 1][j] ^ sums[i][j - 1] ^ sums[i - 1][j - 1] ^ matrix[i - 1][j - 1]\n                heappush(q, -sums[i][j])\n        for _ in range(k - 1): heappop(q)\n        return -q[0]","date":"2024-05-26"}],"tagList":["位运算","数组","分治","矩阵","前缀和","快速选择","排序","堆（优先队列）"],"level":"Medium"}},{"problemName":"1739.放置盒子.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1739.放置盒子.json","problemData":{"id":"1861","name":"1739.放置盒子","url":"https://leetcode.cn/problems/building-boxes","desc":"给你一个整数 n ，返回接触地面的盒子的 最少 可能数量。","solutions":[{"date":"2022-12-25","time":4,"memory":5.9,"script":"cpp","desc":"找规律。","code":"class Solution {\npublic:\n    int minimumBoxes(int n) {\n        int sum = 0, cur = 1, ans = 0, prev = 0;\n        while (sum + prev + cur < n) sum = sum + prev + cur, prev += cur, ans += cur++;\n        return ans + comp(n - sum, cur);\n    }\n    int comp(int num, int cur) {\n        int ans = 1;\n        for (int sum = 0, i = 1; sum + i < num; i++) sum += i, ans++;\n        return ans;\n    }\n};"}],"tagList":["贪心","数学","二分查找"],"level":"Hard"}},{"problemName":"1742.盒子中小球的最大数量.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1742.盒子中小球的最大数量.json","problemData":{"id":"1844","name":"1742.盒子中小球的最大数量","url":"https://leetcode.cn/problems/maximum-number-of-balls-in-a-box","desc":"给你两个整数 lowLimit 和 highLimit ，返回放有最多小球的盒子中的小球数量。","solutions":[{"date":"2022-11-23","time":8,"memory":5.8,"script":"cpp","desc":"模拟。","code":"class Solution {\n public:\n     int countBalls(int lowLimit, int highLimit) {\n         int ans = 0, list[46] = {0};\n         for (int num = lowLimit; num <= highLimit; num++) ans = max(ans, ++list[t(num)]);\n         return ans;\n     }\n     int t(int num) {\n         int ans = 0;\n         for (; num; num /= 10) ans += num % 10;\n         return ans;\n     }\n };"}],"tagList":["哈希表","数学","计数"],"level":"Easy"}},{"problemName":"1743.从相邻元素对还原数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1743.从相邻元素对还原数组.json","problemData":{"id":"1866","name":"1743.从相邻元素对还原数组","url":"https://leetcode.cn/problems/restore-the-array-from-adjacent-pairs","desc":"存在一个由 n 个不同元素组成的整数数组 nums ，返回 原始数组 nums 。","solutions":[{"date":"2021-07-25","time":332,"memory":88.3,"script":"typescript","desc":"map 储存一个数两边的值。","code":"function restoreArray(adjacentPairs: number[][]): number[] {\n  const map = new Map<number, number[]>();\n  for (const [n1, n2] of adjacentPairs) {\n    let l1 = map.get(n1);\n    if (!l1) map.set(n1, (l1 = []));\n    let l2 = map.get(n2);\n    if (!l2) map.set(n2, (l2 = []));\n    l1.push(n2);\n    l2.push(n1);\n  }\n  const ans: number[] = [];\n  for (const [n, l] of map.entries())\n    if (l.length === 1) {\n      ans.push(n);\n      break;\n    }\n  ans.push(map.get(ans[ans.length - 1])![0]);\n  while (map.get(ans[ans.length - 1])!.length !== 1) {\n    const last = ans[ans.length - 1];\n    const list = map.get(last)!;\n    const prev = ans[ans.length - 2];\n    const next = list[0] === prev ? list[1] : list[0];\n    ans.push(next);\n  }\n  return ans;\n}"}],"tagList":["数组","哈希表"],"level":"Medium"}},{"problemName":"1744.你能在你最喜欢的那天吃到你最喜欢的糖果吗？.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1744.你能在你最喜欢的那天吃到你最喜欢的糖果吗？.json","problemData":{"id":"1872","name":"1744.你能在你最喜欢的那天吃到你最喜欢的糖果吗？","url":"https://leetcode.cn/problems/can-you-eat-your-favorite-candy-on-your-favorite-day","desc":"给你一个下标从 0 开始的正整数数组  candiesCount ，其中  candiesCount[i]  表示你拥有的第  i  类糖果的数目。同时给你一个二维数组  queries ，其中  queries[i] = [favoriteTypei, favoriteDayi, dailyCapi] 。请你返回得到的数组 answer 。","solutions":[{"date":"2021-06-01","time":240,"memory":73,"script":"typescript","desc":"计算总共能吃到的糖数。","code":"function canEat(candiesCount: number[], queries: number[][]): boolean[] {\n  const sum = candiesCount.reduce<number[]>((list, cur, i, arr) => {\n    list[i] = (i === 0 ? 0 : list[i - 1]) + cur;\n    return list;\n  }, []);\n  const check = ([type, day, count]: number[]): boolean => {\n    const x1 = day + 1;\n    const y1 = (day + 1) * count;\n    const x2 = type === 0 ? 1 : sum[type - 1] + 1;\n    const y2 = sum[type];\n    return !(x1 > y2 || y1 < x2);\n  };\n  return queries.map(check);\n}"}],"tagList":["数组","前缀和"],"level":"Medium"}},{"problemName":"1748.唯一元素的和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1748.唯一元素的和.json","problemData":{"id":"1848","name":"1748.唯一元素的和","url":"https://leetcode.cn/problems/sum-of-unique-elements","desc":"给你一个整数数组 nums 。数组中唯一元素是那些只出现 恰好一次 的元素。请你返回 nums 中唯一元素的 和 。","solutions":[{"date":"2022-02-06","time":4,"memory":7.6,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    int sumOfUnique(vector<int>& nums) {\n        int check[110] = {0}, ans = 0;\n        for (int i = 0, n = nums.size(); i < n; ++i) {\n            ++check[nums[i]];\n            if (check[nums[i]] == 2)\n                ans -= nums[i];\n            else if (check[nums[i]] == 1)\n                ans += nums[i];\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","计数"],"level":"Easy"}},{"problemName":"1749.任意子数组和的绝对值的最大值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1749.任意子数组和的绝对值的最大值.json","problemData":{"id":"1849","name":"1749.任意子数组和的绝对值的最大值","url":"https://leetcode.cn/problems/maximum-absolute-sum-of-any-subarray","desc":"请你找出 nums 中 和的绝对值 最大的任意子数组（可能为空），并返回该 最大值 。","solutions":[{"script":"cpp","time":76,"memory":39.4,"desc":"遍历,统计最大值和最小值。","code":"class Solution {\npublic:\n    int maxAbsoluteSum(vector<int>& nums) {\n        int nmin = 0, nmax = 0, res = 0;\n        for (auto &num : nums) {\n            nmin = min(num, nmin + num);\n            nmax = max(0, nmax + num);\n            res = max(res, max(abs(nmin), abs(nmax)));\n        }\n        return res;\n    }\n};","date":"2023-08-08"},{"script":"python","time":212,"memory":26.04,"desc":"同上。","code":"class Solution:\n    def maxAbsoluteSum(self, nums: List[int]) -> int:\n        nmin = nmax = res = 0\n        for num in nums:\n            nmin, nmax = min(num, nmin + num), max(0, nmax + num)\n            res = max(res, max(abs(nmin), abs(nmax)))\n        return res","date":"2023-08-08"},{"script":"rust","time":8,"memory":3.01,"desc":"同上。","code":"impl Solution {\n    pub fn max_absolute_sum(nums: Vec<i32>) -> i32 {\n        let (mut nmin, mut nmax, mut res) = (0, 0, 0);\n        for num in nums {\n            nmin = num.min(nmin + num);\n            nmax = 0.max(nmax + num);\n            res = res.max(nmin.abs()).max(nmax.abs())\n        }\n        res\n    }\n}","date":"2023-08-08"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"1750.删除字符串两端相同字符后的最短长度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1750.删除字符串两端相同字符后的最短长度.json","problemData":{"id":"1850","name":"1750.删除字符串两端相同字符后的最短长度","url":"https://leetcode.cn/problems/minimum-length-of-string-after-deleting-similar-ends","desc":"请你返回对字符串 s 执行上面操作任意次以后（可能 0 次），能得到的 最短长度 。","solutions":[{"date":"2022-12-28","time":16,"memory":12.5,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    int minimumLength(string s) {\n        int l = 0, r = s.size() - 1;\n        while (l < r && s[l] == s[r]) {\n            auto c = s[l];\n            while (l <= r && s[l] == c) l++;\n            while (l <= r && s[r] == c) r--;\n        }\n        return r - l + 1;\n    }\n};"}],"tagList":["双指针","字符串"],"level":"Medium"}},{"problemName":"1752.检查数组是否经排序和轮转得到.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1752.检查数组是否经排序和轮转得到.json","problemData":{"id":"1878","name":"1752.检查数组是否经排序和轮转得到","url":"https://leetcode.cn/problems/check-if-array-is-sorted-and-rotated","desc":"给你一个数组 nums 。nums 的源数组中，所有元素与 nums 相同，但按非递减顺序排列。如果  nums 能够由源数组轮转若干位置（包括 0 个位置）得到，则返回 true ；否则，返回 false 。","solutions":[{"date":"2022-11-27","time":4,"memory":8.2,"script":"cpp","desc":"最多只有一次逆向，且只有一次逆向的时候首值要大于尾值。","code":"class Solution {\npublic:\n    bool check(vector<int>& nums) {\n        int n = nums.size();\n        bool f = false;\n        for (int i = 1; i < n; i++) {\n            if (nums[i] < nums[i - 1]) {\n                if (f) return false;\n                f = true;\n            }\n        }\n        return !f || nums[0] >= nums[n - 1];\n    }\n};"}],"tagList":["数组"],"level":"Easy"}},{"problemName":"1753.移除石子的最大得分.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1753.移除石子的最大得分.json","problemData":{"id":"1879","name":"1753.移除石子的最大得分","url":"https://leetcode.cn/problems/maximum-score-from-removing-stones","desc":"给你三个整数 a 、b 和 c ，返回可以得到的 最大分数 。","solutions":[{"date":"2021-04-11","time":96,"memory":39.4,"script":"typescript","desc":"排序后先使 bc 尽可能保持一致再进行相除。","code":"function maximumScore(a: number, b: number, c: number): number {\n  if (a > b) [a, b] = [b, a];\n  if (a > c) [a, c] = [c, a];\n  if (b > c) [b, c] = [c, b];\n  const num1 = Math.min(a, c - b);\n  a -= num1;\n  c -= num1;\n  if (a === 0) return num1 + b;\n  else return num1 + (a >> 1) + b;\n}"},{"date":"2022-12-21","time":96,"memory":5.7,"script":"cpp","desc":"堆。","code":"class Solution {\npublic:\n    int maximumScore(int a, int b, int c) {\n        priority_queue<int> q;\n        q.push(a);\n        q.push(b);\n        q.push(c);\n        int ans = 0;\n        while (q.size() >= 2) {\n            int num1 = q.top(); q.pop();\n            int num2 = q.top(); q.pop();\n            ans += 1;\n            if (num1 > 1) q.push(num1 - 1);\n            if (num2 > 1) q.push(num2 - 1);\n        }\n        return ans;\n    }\n};"},{"date":"2022-12-21","time":0,"memory":5.7,"script":"cpp","desc":"尽可能匹配。","code":"class Solution {\npublic:\n    int maximumScore(int a, int b, int c) {\n        sort_v(a, b, c);\n        if (a + b <= c) return a + b;\n        return (a + b + c) / 2;\n    }\n    void sort_v(int &a, int &b, int &c) {\n        if (a > c) swap(a, c);\n        if (b > c) swap(b, c);\n        if (a > b) swap(a, b);\n    }\n};"}],"tagList":["贪心","数学","堆（优先队列）"],"level":"Medium"}},{"problemName":"1754.构造字典序最大的合并字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1754.构造字典序最大的合并字符串.json","problemData":{"id":"1880","name":"1754.构造字典序最大的合并字符串","url":"https://leetcode.cn/problems/largest-merge-of-two-strings","desc":"返回你可以构造的字典序 最大 的合并字符串 merge 。","solutions":[{"date":"2022-12-24","time":8,"memory":9.3,"script":"cpp","desc":"后缀比较。","code":"class Solution {\npublic:\n    string largestMerge(string word1, string word2) {\n        string ans = \"\";\n        int i1 = 0, i2 = 0, n1 = word1.size(), n2 = word2.size();\n        function<bool(int, int)> check = [&](int i1, int i2) -> bool {\n            while (i1 < n1 && i2 < n2 && word1[i1] == word2[i2]) i1++, i2++;\n            if (i2 == n2 && i1 == n1) return true;\n            if (i2 == n2 && i1 != n1) return true;\n            if (i2 != n2 && i1 == n1) return false;\n            return word1[i1] > word2[i2];\n        };\n        while (i1 < n1 || i2 < n2) {\n            if (i2 == n2 || word1[i1] > word2[i2]) ans += word1[i1++];\n            else if (i1 == n1 || word1[i1] < word2[i2]) ans += word2[i2++];\n            else {\n                bool f = check(i1, i2);\n                while (i1 < n1 && i2 < n2 && word1[i1] == word2[i2])\n                    if (f) ans += word1[i1++];\n                    else ans += word2[i2++];\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["贪心","双指针","字符串"],"level":"Medium"}},{"problemName":"1758.生成交替二进制字符串的最少操作数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1758.生成交替二进制字符串的最少操作数.json","problemData":{"id":"1884","name":"1758.生成交替二进制字符串的最少操作数","url":"https://leetcode.cn/problems/minimum-changes-to-make-alternating-binary-string","desc":"给你一个仅由字符 '0' 和 '1' 组成的字符串 s 。一步操作中，你可以将任一 '0' 变成 '1' ，或者将 '1' 变成 '0' 。返回使 s 变成 交替字符串 所需的 最少 操作数。","solutions":[{"date":"2022-11-29","time":12,"memory":7.7,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    int minOperations(string s) {\n        int cnt1 = 0, cnt2 = 0, cur = 1;\n        for (auto &c : s) {\n            if (c - '0' == cur) cnt1++;\n            else cnt2++;\n            cur ^= 1;\n        }\n        return min(cnt1, cnt2);\n    }\n};"},{"date":"2022-11-29","time":0,"memory":6.8,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    int minOperations(string s) {\n        int n = s.size(), cnt = 0, cur = 1;\n        for (int i = 0; i < n; i++, cur^=1) {\n            if (s[i] - '0' == cur) cnt++;\n        }\n        return min(cnt, n - cnt);\n    }\n};"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"1759.统计同质子字符串的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1759.统计同质子字符串的数目.json","problemData":{"id":"1885","name":"1759.统计同质子字符串的数目","url":"https://leetcode.cn/problems/count-number-of-homogenous-substrings","desc":"给你一个字符串 s ，返回 s 中 同构子字符串 的数目。","solutions":[{"date":"2022-12-26","time":20,"memory":11.3,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    int countHomogenous(string s) {\n        int n = s.size(), ans = 0, mod = 1e9 + 7;\n        for (int i = 0; i < n; i++) {\n            long long cnt = 1, start = i;\n            while (i + 1 < n && s[i + 1] == s[start]) i++, cnt++;\n            ans = (ans + (1 + cnt) * cnt / 2) % mod;\n        }\n        return ans;\n    }\n};"}],"tagList":["数学","字符串"],"level":"Medium"}},{"problemName":"1760.袋子里最少数目的球.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1760.袋子里最少数目的球.json","problemData":{"id":"1886","name":"1760.袋子里最少数目的球","url":"https://leetcode.cn/problems/minimum-limit-of-balls-in-a-bag","desc":"给你一个整数数组 nums ，你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。","solutions":[{"date":"2021-07-21","time":260,"memory":49.4,"script":"typescript","desc":"对最大值进行二分查找。","code":"function minimumSize(nums: number[], maxOperations: number): number {\n  return search();\n  function search(l = 1, r = Math.max(...nums)): number {\n    if (l === r) return l;\n    const mid = (l + r) >> 1;\n    if (count(mid) <= maxOperations) r = mid;\n    else l = mid + 1;\n    return search(l, r);\n  }\n  function count(size: number): number {\n    return nums.reduce((total, num) => total + ~~(num / size) + +!!(num % size) - 1, 0);\n  }\n}"},{"date":"2022-12-20","time":164,"memory":54.7,"script":"cpp","desc":"二分查找。","code":"class Solution {\npublic:\n    int minimumSize(vector<int>& nums, int maxOperations) {\n        int nmin = 1, nmax = 1000000000, nmid;\n        while (nmin < nmax) {\n            nmid = (nmin + nmax) / 2;\n            if (comp(nums, nmid) <= maxOperations) nmax = nmid;\n            else nmin = nmid + 1;\n        }\n        return nmin;\n    }\n    int comp(vector<int> &nums, int val) {\n        int ans = 0;\n        for (auto &num : nums) {\n            if (num <= val) continue;\n            ans += ceil(1.0 * num / val) - 1;\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","二分查找"],"level":"Medium"}},{"problemName":"1761.一个图中连通三元组的最小度数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1761.一个图中连通三元组的最小度数.json","problemData":{"id":"1887","name":"1761.一个图中连通三元组的最小度数","url":"https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph","desc":"请你返回所有连通三元组中度数的 最小值 ，如果图中没有连通三元组，那么返回 -1 。","solutions":[{"script":"cpp","time":1896,"memory":53.2,"desc":"枚举。","code":"class Solution {\npublic:\n    int minTrioDegree(int n, vector<vector<int>>& edges) {\n        vector<unordered_set<int>> nodes(n);\n        for (auto &edge : edges) {\n            nodes[edge[0] - 1].insert(edge[1] - 1);\n            nodes[edge[1] - 1].insert(edge[0] - 1);\n        }\n        int res = INT_MAX;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (!nodes[i].count(j)) continue;\n                for (int k = j + 1; k < n; k++) {\n                    if (!nodes[i].count(k) || !nodes[j].count(k)) continue;\n                    res = min(res, (int)nodes[i].size() + (int)nodes[j].size() + (int)nodes[k].size() - 6);\n                }\n            }\n        }\n        return res == INT_MAX ? -1 : res;\n    }\n};","date":"2023-08-31"},{"script":"python","time":4360,"memory":40.23,"desc":"同上。","code":"class Solution:\n    def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:\n        nodes = [set() for _ in range(n)]\n        for [n0, n1] in edges:\n            nodes[n0-1].add(n1-1)\n            nodes[n1-1].add(n0-1)\n        res = inf\n        for i in range(n):\n            for j in range(i + 1, n):\n                if not j in nodes[i]:\n                    continue\n                for k in range(j + 1, n):\n                    if not k in nodes[i] or not k in nodes[j]:\n                        continue\n                    res = min(res, len(nodes[i]) +\n                              len(nodes[j]) + len(nodes[k]) - 6)\n        return res if res != inf else -1","date":"2023-08-31"},{"script":"rust","time":12,"memory":2.24,"desc":"同上。","code":"impl Solution {\n    pub fn min_trio_degree(n: i32, edges: Vec<Vec<i32>>) -> i32 {\n        let n = n as usize;\n        let mut nodes = vec![std::collections::HashSet::new(); n];\n        for edge in edges {\n            let (n0, n1) = (edge[0] as usize - 1, edge[1] as usize - 1);\n            nodes[n0].insert(n1);\n            nodes[n1].insert(n0);\n        }\n        let mut res = i32::MAX;\n        for i in 0..n {\n            for j in i + 1..n {\n                if nodes[i].contains(&j) {\n                    for k in j + 1..n {\n                        if nodes[i].contains(&k) && nodes[j].contains(&k) {\n                            res = res\n                                .min((nodes[i].len() + nodes[j].len() + nodes[k].len() - 6) as i32)\n                        }\n                    }\n                }\n            }\n        }\n        if res == i32::MAX {\n            -1\n        } else {\n            res\n        }\n    }\n}","date":"2023-08-31"}],"tagList":["图"],"level":"Hard"}},{"problemName":"1763.最长的美好子字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1763.最长的美好子字符串.json","problemData":{"id":"1873","name":"1763.最长的美好子字符串","url":"https://leetcode.cn/problems/longest-nice-substring","desc":"给你一个字符串 s ，请你返回 s 最长的 美好子字符串 。如果有多个答案，请你返回 最早 出现的一个。如果不存在美好子字符串，请你返回一个空字符串。","solutions":[{"date":"2022-02-01","time":8,"memory":6.1,"script":"cpp","desc":"遍历所有起点和终点。","code":"class Solution {\n   public:\n    int arr[256];\n    int check(string &str, int start, int end) {\n        memset(arr, 0, sizeof(int) * 256);\n        for (int i = start; i <= end; i++) {\n            arr[str[i]] = 1;\n        }\n        for (int i = 'A'; i <= 'Z'; i++) {\n            if (arr[i] && !arr[i + 32]) return 0;\n        }\n        for (int i = 'a'; i <= 'z'; i++) {\n            if (arr[i] && !arr[i - 32]) return 0;\n        }\n        return 1;\n    }\n    string longestNiceSubstring(string s) {\n        string ans = \"\";\n        for (int i = 0; i < s.size(); i++) {\n            for (int j = 0; j < i; j++) {\n                if (check(s, j, i) && i - j + 1 > ans.size())\n                    ans = s.substr(j, i - j + 1);\n            }\n        }\n        return ans;\n    }\n};"},{"date":"2022-02-01","time":12,"memory":6,"script":"cpp","desc":"遍历所有起点和终点。","code":"class Solution {\n   public:\n    int arr[26];\n    int check(string &str, int start, int end) {\n        memset(arr, 0, sizeof(int) * 26);\n        for (int i = start; i <= end; i++) {\n            if (str[i] >= 'a')\n                arr[str[i] - 'a'] |= 0b10;\n            else\n                arr[str[i] - 'A'] |= 0b01;\n        }\n        for (int i = 0; i < 26; i++) {\n            if (arr[i] != 0 && arr[i] != 3) return 0;\n        }\n        return 1;\n    }\n    string longestNiceSubstring(string s) {\n        string ans = \"\";\n        for (int i = 0; i < s.size(); i++) {\n            for (int j = 0; j < i; j++) {\n                if (check(s, j, i) && i - j + 1 > ans.size())\n                    ans = s.substr(j, i - j + 1);\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["位运算","哈希表","字符串","分治","滑动窗口"],"level":"Easy"}},{"problemName":"1764.通过连接另一个数组的子数组得到一个数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1764.通过连接另一个数组的子数组得到一个数组.json","problemData":{"id":"1874","name":"1764.通过连接另一个数组的子数组得到一个数组","url":"https://leetcode.cn/problems/form-array-by-concatenating-subarrays-of-another-array","desc":"给你一个长度为 n 的二维整数数组 groups ，同时给你一个整数数组 nums 。如果你可以找出这样的 n 个子数组，请你返回 true ，否则返回 false 。","solutions":[{"date":"2022-12-17","time":100,"memory":71.7,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    bool canChoose(vector<vector<int>>& groups, vector<int>& nums) {\n        auto check = [&](int igroup, int inum) -> bool {\n            int i = 0;\n            for (; i < groups[igroup].size() && inum < nums.size(); i++, inum++)\n                if (groups[igroup][i] != nums[inum]) return false;\n            return i == groups[igroup].size();\n        };\n        int j = 0;\n        for (int i = 0; i < groups.size(); i++) {\n            while (j < nums.size() && (nums[j] != groups[i][0] || !check(i, j))) j++;\n            if (j == nums.size()) return false;\n            j += groups[i].size();\n        }\n        return true;\n    }\n};"}],"tagList":["贪心","数组","双指针","字符串匹配"],"level":"Medium"}},{"problemName":"1765.地图中的最高点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1765.地图中的最高点.json","problemData":{"id":"1876","name":"1765.地图中的最高点","url":"https://leetcode.cn/problems/map-of-highest-peak","desc":"请你返回一个大小为 m x n 的整数矩阵 height ，其中 height[i][j] 是格子 (i, j) 的高度。如果有多种解法，请返回 任意一个 。","solutions":[{"date":"2022-01-29","time":284,"memory":105.6,"script":"cpp","desc":"bfs。","code":"class Solution {\n   public:\n    struct node {\n        int row, col;\n    };\n    int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    vector<vector<int>> highestPeak(vector<vector<int>> &isWater) {\n        int m = isWater.size(), n = isWater[0].size();\n        vector<vector<int>> ans(m, vector(n, -1));\n        queue<node> q;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (isWater[i][j] == 1) {\n                    q.push((node){i, j});\n                    ans[i][j] = 0;\n                }\n            }\n        }\n        while (q.size()) {\n            node v = q.front();\n            q.pop();\n            for (int i = 0; i < 4; i++) {\n                int nrow = v.row + dirs[i][0], ncol = v.col + dirs[i][1];\n                if (nrow < 0 || ncol < 0 || nrow >= m || ncol >= n ||\n                    ans[nrow][ncol] != -1)\n                    continue;\n                ans[nrow][ncol] = ans[v.row][v.col] + 1;\n                q.push((node){nrow, ncol});\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["广度优先搜索","数组","矩阵"],"level":"Medium"}},{"problemName":"1766.互质树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1766.互质树.json","problemData":{"id":"1875","name":"1766.互质树","url":"https://leetcode.cn/problems/tree-of-coprimes","desc":"请你返回一个大小为 n 的数组 ans ，其中 ans[i]是离节点 i 最近的祖先节点且满足 nums[i] 和 nums[ans[i]] 是 互质的 ，如果不存在这样的祖先节点，ans[i] 为 -1 。","solutions":[{"script":"python","time":1017,"memory":66.86,"desc":"预处理后dfs。","code":"primes = [0 for _ in range(51)]\n    for num1 in range(1, 51):\n        for num2 in range(1, 51):\n            if gcd(num1, num2) == 1:\n                primes[num1] |= 1 << num2\n                primes[num2] |= 1 << num1\n    \n    class Solution:\n        def getCoprimes(self, nums: List[int], edges: List[List[int]]) -> List[int]:\n            n = len(nums)\n            nodes = [[] for _ in range(n)]\n            for n1, n2 in edges:\n                nodes[n1].append(n2)\n                nodes[n2].append(n1)\n            ans = [-1 for _ in range(n)]\n            def dfs(node: int, arr: List[Tuple[int, int]], parent: int, level: int):\n                num1 = nums[node]\n                cur = (-1, -1)\n                for num2 in range(1, 51):\n                    if arr[num2][0] != -1 and primes[num1] & (1 << num2) and (cur[1] == -1 or arr[num2][1] > cur[1]):\n                        cur = arr[num2]\n                ans[node] = cur[0]\n                oldv = arr[num1]\n                arr[num1] = (node, level)\n                for child in nodes[node]:\n                    if child != parent:\n                        dfs(child, arr, node, level + 1)\n                arr[num1] = oldv\n            dfs(0, [(-1, -1) for _ in range(51)], -1, 0)\n            return ans","date":"2024-04-11"}],"tagList":["树","深度优先搜索","数组","数学","数论"],"level":"Hard"}},{"problemName":"1768.交替合并字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1768.交替合并字符串.json","problemData":{"id":"1894","name":"1768.交替合并字符串","url":"https://leetcode.cn/problems/merge-strings-alternately","desc":"返回 合并后的字符串 。","solutions":[{"date":"2022-10-23","time":0,"memory":6.1,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    string mergeAlternately(string word1, string word2) {\n        string ans = \"\";\n        for (int i1 = 0, i2 = 0; i1 < word1.size() || i2 < word2.size(); i1++, i2++) {\n            if (i1 < word1.size()) ans += word1[i1];\n            if (i2 < word2.size()) ans += word2[i2];\n        }\n        return ans;\n    }\n};"}],"tagList":["双指针","字符串"],"level":"Easy"}},{"problemName":"1769.移动所有球到每个盒子所需的最小操作数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1769.移动所有球到每个盒子所需的最小操作数.json","problemData":{"id":"1895","name":"1769.移动所有球到每个盒子所需的最小操作数","url":"https://leetcode.cn/problems/minimum-number-of-operations-to-move-all-balls-to-each-box","desc":"返回一个长度为 n 的数组 answer ，其中 answer[i] 是将所有小球移动到第 i 个盒子所需的 最小 操作数。","solutions":[{"date":"2022-12-02","time":76,"memory":8.6,"script":"cpp","desc":"先统计右侧所有的点和数量，每次移动时快速计算左侧 1 数量和右侧 1 数量。","code":"class Solution {\npublic:\n    vector<int> minOperations(string boxes) {\n        int n = boxes.size(),\n            lsum = 0, lcnt = 0,\n            rsum = 0, rcnt = 0;\n        vector<int> list(n);\n        for (int i = 0; i < n; i++) {\n            if (boxes[i] == '1') {\n                rsum += i;\n                rcnt += 1;\n            }\n        }\n        list[0] = rsum;\n        for (int i = 1; i < n; i++) {\n            if (boxes[i - 1] == '1') rcnt--, lcnt++;\n            rsum -= rcnt;\n            lsum += lcnt;\n            list[i] = lsum + rsum;\n        }\n        return list;\n    }\n};"}],"tagList":["数组","字符串"],"level":"Medium"}},{"problemName":"1773.统计匹配检索规则的物品数量.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1773.统计匹配检索规则的物品数量.json","problemData":{"id":"1899","name":"1773.统计匹配检索规则的物品数量","url":"https://leetcode.cn/problems/count-items-matching-a-rule","desc":"统计并返回 匹配检索规则的物品数量 。","solutions":[{"date":"2022-10-29","time":68,"memory":30.2,"script":"cpp","desc":"模拟。","code":"class Solution {\npublic:\n    int countMatches(vector<vector<string>>& items, string ruleKey, string ruleValue) {\n        return accumulate(items.begin(), items.end(), 0, [&](int sum, vector<string> &s){\n            int idx = ruleKey == \"type\" ? 0 : ruleKey == \"color\" ? 1 : 2;\n            if (s[idx] == ruleValue) sum += 1;\n            return sum;\n        });\n    }\n};"}],"tagList":["数组","字符串"],"level":"Easy"}},{"problemName":"1774.最接近目标价格的甜点成本.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1774.最接近目标价格的甜点成本.json","problemData":{"id":"1900","name":"1774.最接近目标价格的甜点成本","url":"https://leetcode.cn/problems/closest-dessert-cost","desc":"返回最接近 target 的甜点成本。如果有多种方案，返回 成本相对较低 的一种。","solutions":[{"date":"2022-12-04","time":76,"memory":9.4,"script":"cpp","desc":"dfs。","code":"class Solution {\npublic:\n    int closestCost(vector<int>& baseCosts, vector<int>& toppingCosts, int target) {\n        int ans = baseCosts[0], n = toppingCosts.size();\n        function<void(int, int)> dfs = [&](int cur, int idx) {\n            if (abs(cur - target) < abs(ans - target) || abs(cur - target) == abs(ans - target) && cur < ans) ans = cur;\n            if (idx == n) return;\n            dfs(cur, idx + 1);\n            dfs(cur + toppingCosts[idx], idx + 1);\n            dfs(cur + toppingCosts[idx] * 2, idx + 1);\n        };\n        for (auto &cost : baseCosts) dfs(cost, 0);\n        return ans;\n    }\n};"}],"tagList":["数组","动态规划","回溯"],"level":"Medium"}},{"problemName":"1775.通过最少操作次数使数组的和相等.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1775.通过最少操作次数使数组的和相等.json","problemData":{"id":"1901","name":"1775.通过最少操作次数使数组的和相等","url":"https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations","desc":"请你返回使 nums1 中所有数的和与 nums2 中所有数的和相等的最少操作次数。","solutions":[{"date":"2022-12-07","time":116,"memory":111.3,"script":"cpp","desc":"统计每个数的个数后遍历。","code":"class Solution {\npublic:\n    int minOperations(vector<int>& nums1, vector<int>& nums2) {\n        int n1 = nums1.size(), sum1 = accumulate(nums1.begin(), nums1.end(), 0), l1[7] = {0},\n            n2 = nums2.size(), sum2 = accumulate(nums2.begin(), nums2.end(), 0), l2[7] = {0};\n        for (auto &num : nums1) l1[num]++;\n        for (auto &num : nums2) l2[num]++;\n        if (sum1 > sum2) swap(n1, n2), swap(sum1, sum2), swap(l1, l2);\n        if (sum1 == sum2) return 0;\n        if (!(n2 >= n1 && n2 <= n1 * 6 || n1 >= n2 && n1 <= n2 * 6)) return -1;\n        int ans = 0;\n        for (int i = 1; i <= 6; i++) ans += comp(l1, l2, i, sum1, sum2);\n        return ans;\n    }\n    int comp(int *l1, int *l2, int num, int &sum1, int &sum2) {\n        int ans = 0;\n        for (int i = 6; i > num; i--) {\n            while (l1[num] && i - num + sum1 <= sum2) ans++, l1[num]--, sum1 += i - num;\n            while (l2[7 - num] && i - num + sum1 <= sum2) ans++, l2[7 - num]--, sum2 -= i - num;\n        }\n        return ans;\n    }\n};"}],"tagList":["贪心","数组","哈希表","计数"],"level":"Medium"}},{"problemName":"1779.找到最近的有相同X或Y坐标的点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1779.找到最近的有相同X或Y坐标的点.json","problemData":{"id":"1888","name":"1779.找到最近的有相同X或Y坐标的点","url":"https://leetcode.cn/problems/find-nearest-point-that-has-the-same-x-or-y-coordinate","desc":"请返回距离你当前位置 曼哈顿距离 最近的 有效 点的下标（下标从 0 开始）。","solutions":[{"date":"2022-12-01","time":132,"memory":57.8,"script":"cpp","desc":"枚举所有点。","code":"class Solution {\npublic:\n    int nearestValidPoint(int x, int y, vector<vector<int>>& points) {\n        int ans = -1, dans = 0x3f3f3f3f;\n        for (int i = 0; i < points.size(); i++) {\n            int ix = points[i][0], iy = points[i][1], d = abs(ix - x) + abs(iy - y);\n            if (ix != x && iy != y) continue;\n            if (dans > d) ans = i, dans = d;\n        }\n        return ans;\n    }\n};"}],"tagList":["数组"],"level":"Easy"}},{"problemName":"1780.判断一个数字是否可以表示成三的幂的和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1780.判断一个数字是否可以表示成三的幂的和.json","problemData":{"id":"1889","name":"1780.判断一个数字是否可以表示成三的幂的和","url":"https://leetcode.cn/problems/check-if-number-is-a-sum-of-powers-of-three","desc":"给你一个整数 n ，如果你可以将 n 表示成若干个不同的三的幂之和，请你返回 true ，否则请返回 false 。","solutions":[{"date":"2022-12-09","time":0,"memory":5.7,"script":"cpp","desc":"如果是由 3 的幂组成，那一定是可以模 3 等于 0 或者减一模 3 等于 0。","code":"class Solution {\npublic:\n    bool checkPowersOfThree(int n) {\n        if (n % 3 != 0) n--;\n        for (; n && n % 3 == 0; n--)\n            while (n % 3 == 0) n /= 3;\n        return !n;\n    }\n};"},{"date":"2022-12-09","time":0,"memory":5.7,"script":"cpp","desc":"优化后为模 3 为 0 或 1。","code":"class Solution {\npublic:\n    bool checkPowersOfThree(int n) {\n        while (n) {\n            if (n % 3 == 2) return false;\n            n /= 3;\n        }\n        return true;\n    }\n};"}],"tagList":["数学"],"level":"Medium"}},{"problemName":"1781.所有子字符串美丽值之和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1781.所有子字符串美丽值之和.json","problemData":{"id":"1890","name":"1781.所有子字符串美丽值之和","url":"https://leetcode.cn/problems/sum-of-beauty-of-all-substrings","desc":"给你一个字符串 s ，请你返回它所有子字符串的 美丽值 之和。","solutions":[{"date":"2022-12-12","time":372,"memory":34.7,"script":"cpp","desc":"暴力枚举。","code":"class Solution {\npublic:\n    int beautySum(string s) {\n        int ans = 0, n = s.size(), dp[505][505][26] = {0};\n        for (int i = 0; i < n; i++) {\n            dp[i][i][s[i] - 'a'] = 1;\n            for (int j = i - 1; j >= 0; j--) {\n                for (int k = 0; k < 26; k++) dp[i][j][k] = dp[i][j + 1][k];\n                dp[i][j][s[j] - 'a']++;\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                int nmin = 500, nmax = 0;\n                for (int k = 0; k < 26; k++) {\n                    if (dp[i][j][k] == 0) continue;\n                    nmin = min(nmin, dp[i][j][k]);\n                    nmax = max(nmax, dp[i][j][k]);\n                }\n                // cout << \"j = \" << j << \", i = \" << i << \", min = \" << nmin << \", max = \" << nmax << endl;\n                ans += nmax - nmin;\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["哈希表","字符串","计数"],"level":"Medium"}},{"problemName":"1782.统计点对的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1782.统计点对的数目.json","problemData":{"id":"1891","name":"1782.统计点对的数目","url":"https://leetcode.cn/problems/count-pairs-of-nodes","desc":"请你返回一个数组 answers ，其中 answers.length == queries.length 且 answers[j] 是第 j 个查询的答案。","solutions":[{"script":"cpp","time":836,"memory":181.42,"desc":"两个节点的边总和为 n[a]+n[b]-m[a][b] 要减去共有的边，先统计两个节点边和大于目标值的个数。","code":"class Solution {\npublic:\n    vector<int> countPairs(int n, vector<vector<int>>& edges, vector<int>& queries) {\n        vector<int> nodes(n, 0);\n        unordered_map<int, unordered_map<int, int>> m;\n        for (auto &edge : edges) {\n            int x = edge[0] - 1, y = edge[1] - 1;\n            if (x > y) swap(x, y);\n            nodes[x] += 1;\n            nodes[y] += 1;\n            m[x][y] += 1;\n        }\n        vector<int> res, list = nodes;\n        sort(list.begin(), list.end());\n        for (auto &query : queries) {\n            int val = 0;\n            for (int i = 0; i < n; i++) {\n                int target = query - list[i], l = i + 1, r = n;\n                while (l < r) {\n                    int m = (l + r) / 2;\n                    if (list[m] > target) r = m;\n                    else l = m + 1;\n                }\n                val += n - l;\n            }\n            for (auto &item1 : m) {\n                int x = item1.first;\n                for (auto &item2 : item1.second) {\n                    int y = item2.first, cnt = item2.second;\n                    if (nodes[x] + nodes[y] > query && nodes[x] + nodes[y] - cnt <= query) val -= 1;\n                }\n            }\n            res.push_back(val);\n        }\n        return res;\n    }\n};","date":"2023-08-23"}],"tagList":["图","数组","双指针","二分查找","排序"],"level":"Hard"}},{"problemName":"1784.检查二进制字符串字段.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1784.检查二进制字符串字段.json","problemData":{"id":"1910","name":"1784.检查二进制字符串字段","url":"https://leetcode.cn/problems/check-if-binary-string-has-at-most-one-segment-of-ones","desc":"给你一个二进制字符串 s ，该字符串 不含前导零 。如果 s 包含 零个或一个由连续的 '1' 组成的字段 ，返回 true​​​ 。否则，返回 false 。如果 s  中   由连续若干个  '1' 组成的字段   数量不超过 1，返回 true​​​ 。否则，返回 false 。","solutions":[{"date":"2022-10-03","time":0,"memory":6,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    bool checkOnesSegment(string s) {\n        int cnt = 0, n = s.size();\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '0') continue;\n            while (i + 1 < n && s[i + 1] == '1') i++;\n            if (++cnt > 1) return false;\n        }\n        return true;\n    }\n};"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"1785.构成特定和需要添加的最少元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1785.构成特定和需要添加的最少元素.json","problemData":{"id":"1911","name":"1785.构成特定和需要添加的最少元素","url":"https://leetcode.cn/problems/minimum-elements-to-add-to-form-a-given-sum","desc":"返回使数组元素总和等于 goal 所需要向数组中添加的 最少元素数量 ，添加元素 不应改变 数组中 abs(nums[i]) <= limit 这一属性。","solutions":[{"date":"2022-12-16","time":100,"memory":71.7,"script":"cpp","desc":"向上取整。","code":"class Solution {\npublic:\n    int minElements(vector<int>& nums, int limit, int goal) {\n        long long v = goal;\n        for (auto &num : nums) v -= num;\n        v = abs(v);\n        return ceil(1.0 * v / limit);\n    }\n};"},{"date":"2022-12-16","time":92,"memory":50.5,"script":"typescript","desc":"向上取整。","code":"function minElements(nums: number[], limit: number, goal: number): number {\n  return Math.ceil(Math.abs(nums.reduce((sum, num) => sum - num, goal)) / limit);\n}"}],"tagList":["贪心","数组"],"level":"Medium"}},{"problemName":"1790.仅执行一次字符串交换能否使两个字符串相等.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1790.仅执行一次字符串交换能否使两个字符串相等.json","problemData":{"id":"1915","name":"1790.仅执行一次字符串交换能否使两个字符串相等","url":"https://leetcode.cn/problems/check-if-one-string-swap-can-make-strings-equal","desc":"如果对 其中一个字符串 执行 最多一次字符串交换 就可以使两个字符串相等，返回 true ；否则，返回 false 。","solutions":[{"date":"2022-10-11","time":0,"memory":6.1,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    bool areAlmostEqual(string s1, string s2) {\n        int list[26] = {0}, n = s1.size();\n        for (auto &c : s1) list[c - 'a']++;\n        for (auto &c : s2) if (list[c - 'a']-- == 0) return false;\n        int tag = -1;\n        bool changed = false;\n        for (int i = 0; i < n; i++) {\n            if (s1[i] == s2[i]) continue;\n            if (changed) return false;\n            if (tag == -1) { tag = i; continue; }\n            else if (s1[tag] == s2[i] && s2[tag] == s1[i]) changed = true;\n            else return false;\n        }\n        return true;\n    }\n};"}],"tagList":["哈希表","字符串","计数"],"level":"Easy"}},{"problemName":"1791.找出星型图的中心节点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1791.找出星型图的中心节点.json","problemData":{"id":"1916","name":"1791.找出星型图的中心节点","url":"https://leetcode.cn/problems/find-center-of-star-graph","desc":"给你一个二维整数数组 edges ，其中  edges[i] = [ui, vi] 表示在节点 ui 和 vi 之间存在一条边。请你找出并返回  edges 所表示星型图的中心节点。","solutions":[{"date":"2022-02-18","time":144,"memory":65.7,"script":"cpp","desc":"直接判断前两个边中，存在相同的点。","code":"class Solution {\n   public:\n    int findCenter(vector<vector<int>>& edges) {\n        return edges[0][0] == edges[1][0] || edges[0][0] == edges[1][1]\n                   ? edges[0][0]\n                   : edges[0][1];\n    }\n};"}],"tagList":["图"],"level":"Easy"}},{"problemName":"1792.最大平均通过率.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1792.最大平均通过率.json","problemData":{"id":"1917","name":"1792.最大平均通过率","url":"https://leetcode.cn/problems/maximum-average-pass-ratio","desc":"请你返回在安排这 extraStudents 个学生去对应班级后的 最大 平均通过率。","solutions":[{"script":"cpp","time":844,"memory":85.8,"desc":"堆，按增长幅度排序。","code":"class Solution {\n    public:\n        typedef pair<int, int> node;\n        double maxAverageRatio(vector<vector<int>>& classes, int extraStudents) {\n            double ans = 0.0;\n            auto cmp = [&](node x, node y) -> bool {\n                double v1 = 1.0 * (x.first + 1) / (x.second + 1) - 1.0 * x.first / x.second,\n                       v2 = 1.0 * (y.first + 1) / (y.second + 1) - 1.0 * y.first / y.second;\n                return v1 < v2;\n            };\n            priority_queue<node, vector<node>, decltype(cmp)> q(cmp);\n            for (auto &item : classes) q.push(make_pair(item[0], item[1]));\n            while (extraStudents--) {\n                node item = q.top(); q.pop();\n                item.first += 1;\n                item.second += 1;\n                q.push(item);\n            }\n            while (q.size()) {\n                node item = q.top(); q.pop();\n                ans += 1.0 * item.first / item.second;\n            }\n            return ans / classes.size();\n        }\n    };","date":"2023-02-19"},{"script":"python","time":8748,"memory":48.4,"desc":"同上。","code":"class Node:\n    def __init__(self, x: int, y: int):\n        self.x = x\n        self.y = y\n\n    def __lt__(self, o: 'Node') -> bool:\n        v1 = (self.x + 1) / (self.y + 1) - self.x / self.y\n        v2 = (o.x + 1) / (o.y + 1) - o.x / o.y\n        return v1 > v2\n\nclass Solution:\n    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -> float:\n        heap = [Node(item[0], item[1]) for item in classes]\n        heapify(heap)\n        for _ in range(extraStudents):\n            heapreplace(heap, Node(heap[0].x + 1, heap[0].y + 1))\n        return sum(item.x / item.y for item in heap) / len(classes)","date":"2023-02-19"},{"script":"rust","time":424,"memory":10,"desc":"同上。","code":"#[derive(Clone, PartialEq, Eq, Ord)]\nstruct Node {\n    x: i32,\n    y: i32,\n}\nimpl Node {\n    fn new(x: i32, y: i32) -> Self {\n        Node { x, y }\n    }\n    fn inc_val(&self) -> f64 {\n        ((self.x + 1) as f64) / ((self.y + 1) as f64) - (self.x as f64) / (self.y as f64)\n    }\n    fn val(&self) -> f64 {\n        (self.x as f64) / (self.y as f64)\n    }\n}\nimpl PartialOrd for Node {\n    fn partial_cmp(&self, o: &Self) -> Option<std::cmp::Ordering> {\n        self.inc_val().partial_cmp(&o.inc_val())\n    }\n}\nimpl Solution {\n    pub fn max_average_ratio(classes: Vec<Vec<i32>>, extra_students: i32) -> f64 {\n        use std::collections::BinaryHeap;\n        let mut heap = BinaryHeap::<Node>::new();\n        for item in classes.iter() {\n            heap.push(Node::new(item[0], item[1]));\n        }\n        for _ in 0..extra_students {\n            let mut node = heap.pop().unwrap();\n            node.x += 1;\n            node.y += 1;\n            heap.push(node);\n        }\n        let mut res: f64 = 0.0;\n        while let Some(node) = heap.pop() {\n            res += node.val();\n        }\n        res / classes.len() as f64\n    }\n}","date":"2023-02-19"}],"tagList":["贪心","数组","堆（优先队列）"],"level":"Medium"}},{"problemName":"1793.好子数组的最大分数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1793.好子数组的最大分数.json","problemData":{"id":"1918","name":"1793.好子数组的最大分数","url":"https://leetcode.cn/problems/maximum-score-of-a-good-subarray","desc":"请你返回 好 子数组的最大可能 分数 。","solutions":[{"script":"python","time":266,"memory":27.5,"desc":"先求出每个下标当最小值的范围，再对范围判断是否存在k。","code":"class Solution:\n    def maximumScore(self, nums: List[int], k: int) -> int:\n        k += 1\n        nums = [inf] + nums + [inf]\n        s = []\n        n = len(nums)\n        arr1 = [0] * n\n        arr2 = [n - 1] * n\n        for i in range(1, n - 1):\n            while s and nums[s[-1]] > nums[i]:\n                arr2[s.pop()] = i\n            if s: arr1[i] = s[-1]\n            s.append(i)\n        ans = 0\n        for i in range(1, n - 1):\n            left = arr1[i]\n            right = arr2[i]\n            if left < k < right:\n                ans = max(ans, (right - left - 1) * nums[i])\n        return ans","date":"2024-03-19"}],"tagList":["栈","数组","双指针","二分查找","单调栈"],"level":"Hard"}},{"problemName":"1796.字符串中第二大的数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1796.字符串中第二大的数字.json","problemData":{"id":"1904","name":"1796.字符串中第二大的数字","url":"https://leetcode.cn/problems/second-largest-digit-in-a-string","desc":"给你一个混合字符串 s ，请你返回 s 中 第二大 的数字，如果不存在第二大的数字，请你返回 -1 。","solutions":[{"date":"2022-12-03","time":0,"memory":6.5,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    int secondHighest(string s) {\n        int n1 = -1, n2 = -1;\n        for (auto &c : s) {\n            if (!isdigit(c)) continue;\n            int num = c - '0';\n            if (n1 == -1) n1 = num;\n            else if (num > n1) n2 = n1, n1 = num;\n            else if (num == n1) continue;\n            else if (n2 == -1) n2 = num;\n            else if (num > n2) n2 = num;\n        }\n        return n2;\n    }\n};"}],"tagList":["哈希表","字符串"],"level":"Easy"}},{"problemName":"1797.设计一个验证系统.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1797.设计一个验证系统.json","problemData":{"id":"1905","name":"1797.设计一个验证系统","url":"https://leetcode.cn/problems/design-authentication-manager","desc":"你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。","solutions":[{"script":"cpp","time":80,"memory":29.4,"desc":"哈希存储。","code":"class AuthenticationManager {\npublic:\n    int timeToLive;\n    unordered_map<string, int> m;\n    AuthenticationManager(int timeToLive): timeToLive(timeToLive) {}\n    \n    void generate(string tokenId, int currentTime) {\n        m[tokenId] = currentTime;\n    }\n    \n    void renew(string tokenId, int currentTime) {\n        if (!m.count(tokenId)) return;\n        if (currentTime - m[tokenId] >= timeToLive) m.erase(tokenId);\n        else m[tokenId] = currentTime;\n    }\n    \n    int countUnexpiredTokens(int currentTime) {\n        int ans = 0;\n        for (auto &item : m) {\n            if (currentTime - item.second < timeToLive) ans++;\n        }\n        return ans;\n    }\n};","date":"2023-02-09"},{"script":"python","time":220,"memory":16.5,"desc":"同上。","code":"class AuthenticationManager:\n    def __init__(self, timeToLive: int):\n        self.timeToLive = timeToLive\n        self.m = defaultdict()\n\n    def generate(self, tokenId: str, currentTime: int) -> None:\n        self.m[tokenId] = currentTime\n\n    def renew(self, tokenId: str, currentTime: int) -> None:\n        if not tokenId in self.m:\n            return\n        if currentTime - self.m[tokenId] >= self.timeToLive:\n            self.m.pop(tokenId)\n        else:\n            self.m[tokenId] = currentTime\n\n    def countUnexpiredTokens(self, currentTime: int) -> int:\n        ans = 0\n        for v in self.m.values():\n            if currentTime - v < self.timeToLive:\n                ans += 1\n        return ans","date":"2023-02-09"},{"script":"rust","time":20,"memory":3.6,"desc":"同上。","code":"use std::collections::HashMap;\nstruct AuthenticationManager {\n    timeToLive: i32,\n    m: HashMap<String, i32>,\n}\n\nimpl AuthenticationManager {\n    fn new(timeToLive: i32) -> Self {\n        Self {\n            timeToLive,\n            m: HashMap::new(),\n        }\n    }\n    fn generate(&mut self, token_id: String, current_time: i32) {\n        if !self.m.contains_key(&token_id) {\n            self.m.insert(token_id, current_time);\n        } else {\n            *self.m.get_mut(&token_id).unwrap() = current_time;\n        }\n    }\n\n    fn renew(&mut self, token_id: String, current_time: i32) {\n        if self.m.contains_key(&token_id) {\n            let item = self.m.get_mut(&token_id).unwrap();\n            if current_time - *item >= self.timeToLive {\n                self.m.remove(&token_id);\n            } else {\n                *item = current_time;\n            }\n        }\n    }\n\n    fn count_unexpired_tokens(&self, current_time: i32) -> i32 {\n        let mut ans = 0;\n        self.m\n            .iter()\n            .map(|(_, v)| v)\n            .filter(|v| current_time - *v < self.timeToLive)\n            .collect::<Vec<&i32>>()\n            .len() as i32\n    }\n}","date":"2023-02-09"}],"tagList":["设计","哈希表","链表","双向链表"],"level":"Medium"}},{"problemName":"1799.N次操作后的最大分数和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1799.N次操作后的最大分数和.json","problemData":{"id":"1906","name":"1799.N次操作后的最大分数和","url":"https://leetcode.cn/problems/maximize-score-after-n-operations","desc":"请你返回 n 次操作后你能获得的分数和最大为多少。","solutions":[{"date":"2022-12-22","time":52,"memory":7.6,"script":"cpp","desc":"不能贪心，利用二进制状态压缩考虑每一种情况进行动态规划。","code":"class Solution {\npublic:\n    int gcd(int a, int b) {\n        if (b == 0) return a;\n        return gcd(b, a % b);\n    }\n    int cnt1(int num) {\n        int cnt = 0;\n        for (; num; num >>= 1) if (num & 1) cnt++;\n        return cnt;\n    }\n    int mgcd[20][20], dp[20000] = {0};\n    int maxScore(vector<int>& nums) {\n        int n = nums.size(), allused = (1 << n) - 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                mgcd[i][j] = mgcd[j][i] = gcd(nums[i], nums[j]);\n            }\n        }\n        for (int used = 1; used <= allused; used++) {\n            int cnt = cnt1(used);\n            if (cnt & 1) continue;\n            for (int i = 0; i < n; i++) {\n                if ((used & (1 << i)) == 0) continue;\n                for (int j = i + 1; j < n; j++) {\n                    if ((used & (1 << j)) == 0) continue;\n                    dp[used] = max(dp[used], dp[used ^ (1 << i) ^ (1 << j)] + cnt / 2 * mgcd[i][j]);\n                }\n            }\n        }\n        return dp[allused];\n    }\n};"}],"tagList":["位运算","数组","数学","动态规划","回溯","状态压缩","数论"],"level":"Hard"}},{"problemName":"1800.最大升序子数组和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1701-1800/1800.最大升序子数组和.json","problemData":{"id":"1927","name":"1800.最大升序子数组和","url":"https://leetcode.cn/problems/maximum-ascending-subarray-sum","desc":"给你一个正整数组成的数组 nums ，返回 nums 中一个 升序 子数组的最大可能元素和。","solutions":[{"date":"2022-10-07","time":0,"memory":8.1,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    int maxAscendingSum(vector<int>& nums) {\n        int ans = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            int sum = nums[i];\n            while (i + 1 < nums.size() && nums[i + 1] > nums[i]) sum += nums[++i];\n            ans = max(ans, sum);\n        }\n        return ans;\n    }\n};"}],"tagList":["数组"],"level":"Easy"}}]},{"dirName":"1801-1900","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\1801-1900","problems":[{"problemName":"1801.积压订单中的订单总数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1801.积压订单中的订单总数.json","problemData":{"id":"1928","name":"1801.积压订单中的订单总数","url":"https://leetcode.cn/problems/number-of-orders-in-the-backlog","desc":"给你一个二维整数数组 orders ，输入所有订单后，返回积压订单中的 订单总数 。由于数字可能很大，所以需要返回对 109 + 7 取余的结果。","solutions":[{"date":"2021-04-11","time":332,"memory":59.5,"script":"typescript","desc":"利用买大顶堆和卖小顶堆维护最值。","code":"class Heap<T = number> {\n  private arr: T[] = [];\n  get isEmpty() {\n    return this.size === 0;\n  }\n  get size() {\n    return this.arr.length;\n  }\n  get top() {\n    return this.arr[0];\n  }\n  constructor(private compare: (t1: T, t2: T) => number) {}\n  add(num: T): void {\n    this.arr.push(num);\n    this.shiftUp(this.size - 1);\n  }\n  remove(): T {\n    const num = this.arr.shift()!;\n    if (this.size) {\n      this.arr.unshift(this.arr.pop()!);\n      this.shiftDown(0);\n    }\n    return num;\n  }\n  private shiftUp(index: number): void {\n    if (index === 0) return;\n    const parentIndex = (index - 1) >> 1;\n    if (this.compare(this.arr[index], this.arr[parentIndex]) > 0) {\n      [this.arr[index], this.arr[parentIndex]] = [this.arr[parentIndex], this.arr[index]];\n      this.shiftUp(parentIndex);\n    }\n  }\n  private shiftDown(index: number): void {\n    let childrenIndex = index * 2 + 1;\n    if (childrenIndex > this.size - 1) return;\n    if (\n      childrenIndex + 1 <= this.size - 1 &&\n      this.compare(this.arr[childrenIndex + 1], this.arr[childrenIndex]) > 0\n    ) {\n      childrenIndex++;\n    }\n    if (this.compare(this.arr[childrenIndex], this.arr[index]) > 0) {\n      [this.arr[childrenIndex], this.arr[index]] = [this.arr[index], this.arr[childrenIndex]];\n      this.shiftDown(childrenIndex);\n    }\n  }\n  *[Symbol.iterator](): IterableIterator<T> {\n    for (const t of this.arr) {\n      yield t;\n    }\n  }\n}\nfunction getNumberOfBacklogOrders(orders: number[][]): number {\n  const buyHeap = new Heap<number[]>(([t1], [t2]) => t1 - t2);\n  const sellHeap = new Heap<number[]>(([t1], [t2]) => t2 - t1);\n  const add = (order: number[]) => {\n    (order[2] === 0 ? buyHeap : sellHeap).add(order);\n    while (buyHeap.size > 0 && sellHeap.size > 0 && buyHeap.top[0] >= sellHeap.top[0]) {\n      const buyTop = buyHeap.top;\n      const sellTop = sellHeap.top;\n      if (buyTop[1] > sellTop[1]) {\n        sellHeap.remove();\n        buyTop[1] -= sellTop[1];\n      } else if (buyTop[1] < sellTop[1]) {\n        buyHeap.remove();\n        sellTop[1] -= buyTop[1];\n      } else {\n        sellHeap.remove();\n        buyHeap.remove();\n      }\n    }\n  };\n  orders.forEach(order => add(order));\n  let ans = 0;\n  for (const [, c] of buyHeap) ans += c;\n  for (const [, c] of sellHeap) ans += c;\n  return ans % (10 ** 9 + 7);\n}"},{"date":"2023-01-02","time":188,"memory":57.2,"script":"cpp","desc":"模拟。","code":"typedef pair<int, int> node;\n#define X              first\n#define Y              second\nstruct cmp {\n    int type;\n    cmp(int type): type(type) {}\n    bool operator()(node &a, node &b) {\n        if (type) return a.X < b.X;\n        else return a.X > b.X;\n    }\n};\nint mod = 1e9 + 7;\nclass Solution {\npublic:\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\n        priority_queue<node, vector<node>, cmp> buyq(cmp(1));\n        priority_queue<node, vector<node>, cmp> sellq(cmp(0));\n        for (auto &order : orders) {\n            if (order[2] == 0) {\n                node cur = make_pair(order[0], order[1]);\n                while (cur.Y && sellq.size() && sellq.top().X <= cur.X) {\n                    if (sellq.top().Y > cur.Y) {\n                        auto v = sellq.top();\n                        sellq.pop();\n                        v.Y -= cur.Y;\n                        sellq.push(v);\n                        cur.Y = 0;\n                    } else if (sellq.top().Y < cur.Y) {\n                        cur.Y -= sellq.top().Y;\n                        sellq.pop();\n                    } else {\n                        cur.Y = 0;\n                        sellq.pop();\n                    }\n                }\n                if (cur.Y) buyq.push(cur);\n            } else {\n                node cur = make_pair(order[0], order[1]);\n                while (cur.Y && buyq.size() && buyq.top().X >= cur.X) {\n                    if (buyq.top().Y > cur.Y) {\n                        auto v = buyq.top();\n                        buyq.pop();\n                        v.Y -= cur.Y;\n                        buyq.push(v);\n                        cur.Y = 0;\n                    } else if (buyq.top().Y < cur.Y) {\n                        cur.Y -= buyq.top().Y;\n                        buyq.pop();\n                    } else {\n                        cur.Y = 0;\n                        buyq.pop();\n                    }\n                }\n                if (cur.Y) sellq.push(cur);\n            }\n        }\n        int ans = 0;\n        while (buyq.size()) ans = (ans + buyq.top().Y) % mod, buyq.pop();\n        while (sellq.size()) ans = (ans + sellq.top().Y) % mod, sellq.pop();\n        return ans;\n    }\n};"},{"date":"2023-01-02","time":200,"memory":57.2,"script":"cpp","desc":"同上。","code":"typedef pair<int, int> node;\n#define X              first\n#define Y              second\nstruct cmp {\n    int type;\n    cmp(int type): type(type) {}\n    bool operator()(node &a, node &b) {\n        if (type) return a.X < b.X;\n        else return a.X > b.X;\n    }\n};\nint mod = 1e9 + 7;\nclass Solution {\npublic:\n    int getNumberOfBacklogOrders(vector<vector<int>>& orders) {\n        priority_queue<node, vector<node>, cmp> buyq(cmp(1));\n        priority_queue<node, vector<node>, cmp> sellq(cmp(0));\n        for (auto &order : orders) {\n            auto &q1 = order[2] == 0 ? sellq : buyq,\n                 &q2 = order[2] == 0 ? buyq  : sellq;\n            node cur = make_pair(order[0], order[1]);\n            while (cur.Y && q1.size() && (order[2] == 0 ? q1.top().X <= cur.X : q1.top().X >= cur.X)) {\n                if (q1.top().Y > cur.Y) {\n                    auto v = q1.top();\n                    q1.pop();\n                    v.Y -= cur.Y;\n                    q1.push(v);\n                    cur.Y = 0;\n                } else if (q1.top().Y < cur.Y) {\n                    cur.Y -= q1.top().Y;\n                    q1.pop();\n                } else {\n                    cur.Y = 0;\n                    q1.pop();\n                }\n            }\n            if (cur.Y) q2.push(cur);/\n        }\n        int ans = 0;\n        while (buyq.size()) ans = (ans + buyq.top().Y) % mod, buyq.pop();\n        while (sellq.size()) ans = (ans + sellq.top().Y) % mod, sellq.pop();\n        return ans;\n    }\n};"},{"date":"2023-01-02","time":24,"memory":9.5,"script":"rust","desc":"同上。","code":"use std::{cmp::Ordering, collections::BinaryHeap};\nstruct Node(i32, i32, bool);\nimpl PartialEq for Node {\n    fn eq(&self, other: &Self) -> bool {\n        self.0 == other.0\n    }\n}\nimpl Eq for Node {}\nimpl Ord for Node {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        if self.2 {\n            self.0.cmp(&other.0)\n        } else {\n            other.0.cmp(&self.0)\n        }\n    }\n}\nimpl PartialOrd for Node {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        if self.2 {\n            self.0.partial_cmp(&other.0)\n        } else {\n            other.0.partial_cmp(&self.0)\n        }\n    }\n}\nconst mode: i32 = 1000000000 + 7;\nimpl Solution {\n    pub fn get_number_of_backlog_orders(orders: Vec<Vec<i32>>) -> i32 {\n        let mut buy_heap = BinaryHeap::<Node>::new();\n        let mut sell_heap = BinaryHeap::<Node>::new();\n        for order in orders {\n            if order[2] == 0 {\n                let mut cur = Node(order[0], order[1], order[2] == 0);\n                while cur.1 > 0 && !buy_heap.is_empty() && buy_heap.peek().unwrap().0 <= cur.0 {\n                    if buy_heap.peek().unwrap().1 > cur.1 {\n                        let mut node = buy_heap.pop().unwrap();\n                        node.1 -= cur.1;\n                        buy_heap.push(node);\n                        cur.1 = 0;\n                    } else if buy_heap.peek().unwrap().1 < cur.1 {\n                        cur.1 -= buy_heap.pop().unwrap().1;\n                    } else {\n                        cur.1 = 0;\n                        buy_heap.pop();\n                    }\n                }\n                if cur.1 > 0 {\n                    sell_heap.push(cur);\n                };\n            } else {\n                let mut cur = Node(order[0], order[1], order[2] == 0);\n                while cur.1 > 0 && !sell_heap.is_empty() && sell_heap.peek().unwrap().0 >= cur.0 {\n                    if sell_heap.peek().unwrap().1 > cur.1 {\n                        let mut node = sell_heap.pop().unwrap();\n                        node.1 -= cur.1;\n                        sell_heap.push(node);\n                        cur.1 = 0;\n                    } else if sell_heap.peek().unwrap().1 < cur.1 {\n                        cur.1 -= sell_heap.pop().unwrap().1;\n                    } else {\n                        cur.1 = 0;\n                        sell_heap.pop();\n                    }\n                }\n                if cur.1 > 0 {\n                    buy_heap.push(cur);\n                };\n            }\n        }\n        let mut ans = 0;\n        while !buy_heap.is_empty() {\n            ans = (ans + buy_heap.pop().unwrap().1) % mode;\n        }\n        while !sell_heap.is_empty() {\n            ans = (ans + sell_heap.pop().unwrap().1) % mode;\n        }\n        ans\n    }\n}"}],"tagList":["数组","模拟","堆（优先队列）"],"level":"Medium"}},{"problemName":"1802.有界数组中指定下标处的最大值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1802.有界数组中指定下标处的最大值.json","problemData":{"id":"1929","name":"1802.有界数组中指定下标处的最大值","url":"https://leetcode.cn/problems/maximum-value-at-a-given-index-in-a-bounded-array","desc":"返回你所构造的数组中的 nums[index] 。","solutions":[{"date":"2023-01-04","time":8,"memory":5.8,"script":"cpp","desc":"双指针。","code":"class Solution {\npublic:\n    int maxValue(int n, int index, int maxSum) {\n        int ans = 1, sum = n, l = index, r = index;\n        while (sum + r - l + 1 <= maxSum && !(r == n - 1 && l == 0)) {\n            sum += r - l + 1;\n            ans += 1;\n            r = min(n - 1, r + 1);\n            l = max(0, l - 1);\n        }\n        if (r == n - 1 && l == 0 && sum < maxSum) ans += (maxSum - sum) / n;\n        return ans;\n    }\n};"},{"date":"2023-01-04","time":8,"memory":2.1,"script":"rust","desc":"同上。","code":"impl Solution {\n    pub fn max_value(n: i32, index: i32, max_sum: i32) -> i32 {\n        let (mut ans, mut sum, mut l, mut r) = (1, n, index, index);\n        while sum + r - l + 1 <= max_sum && !(l == 0 && r == n - 1) {\n            sum += r - l + 1;\n            ans += 1;\n            l = (l - 1).max(0);\n            r = (r + 1).min(n - 1);\n        }\n        if l == 0 && r == n - 1 && sum < max_sum {\n            ans += (max_sum - sum) / n;\n        }\n        ans\n    }\n}"},{"date":"2023-01-04","time":28,"memory":5.7,"script":"cpp","desc":"二分。","code":"class Solution {\npublic:\n    int maxValue(int n, int index, int maxSum) {\n        int l = 1, r = maxSum;\n        while (l < r) {\n            int m = (l + r + 1) / 2;\n            if (check(n, index, m) <= maxSum) l = m;\n            else r = m - 1;\n        }\n        return l;\n    }\n    long long check(long long n, long long index, long long val) {\n        long long ans = val;\n        if (val - index >= 1) ans += (val - index + val - 1) * index / 2;\n        else ans += (1 + val - 1) * (val - 1) / 2 + (index - (val - 1));\n        if (n - 1 - index <= val - 1) ans += (val - (n - 1 - index) + val - 1) * (n - 1 - index) / 2;\n        else ans += (1 + val - 1) * (val - 1) / 2 + (n - 1 - index - (val - 1));\n        return ans;\n    }\n};"},{"date":"2023-01-04","time":0,"memory":1.9,"script":"rust","desc":"同上。","code":"impl Solution {\n    pub fn max_value(n: i32, index: i32, max_sum: i32) -> i32 {\n        let (mut l, mut r) = (1, max_sum);\n        while l < r {\n            let m = (l + r + 1) / 2;\n            if Solution::check(n, index, m) <= max_sum  as i64{\n                l = m;\n            } else {\n                r = m - 1;\n            }\n        }\n        l\n    }\n    fn check(n: i32, index: i32, val: i32) -> i64 {\n        let (n, index, val) = (n as i64, index as i64, val as i64);\n        let mut ans = val;\n        if val - index >= 1 {\n            ans += (val - index + val - 1) * index / 2;\n        } else {\n            ans += (1 + val - 1) * (val - 1) / 2 + (index - (val - 1));\n        }\n        if n - 1 - index <= val - 1 {\n            ans += (val - (n - 1 - index) + val - 1) * (n - 1 - index) / 2;\n        } else {\n            ans += (1 + val - 1) * (val - 1) / 2 + (n - 1 - index - (val - 1));\n        };\n        ans\n    }\n}"}],"tagList":["贪心","二分查找"],"level":"Medium"}},{"problemName":"1803.统计异或值在范围内的数对有多少.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1803.统计异或值在范围内的数对有多少.json","problemData":{"id":"1907","name":"1803.统计异或值在范围内的数对有多少","url":"https://leetcode.cn/problems/count-pairs-with-xor-in-a-range","desc":"给你一个整数数组 nums （下标 从 0 开始 计数）以及两个整数：low 和 high ，请返回 漂亮数对 的数目。","solutions":[{"date":"2023-01-05","time":7316,"memory":47.1,"script":"typescript","desc":"暴力模拟。","code":"function countPairs(nums: number[], low: number, high: number): number {\n  const n = nums.length;\n  let ans = 0;\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      const v = nums[i] ^ nums[j];\n      if (v >= low && v <= high) ans++;\n    }\n  }\n  return ans;\n}"},{"date":"2023-01-05","time":432,"memory":132.2,"script":"cpp","desc":"字典树，按位遍历，对于当前点找和 target 前缀一样，当前位小的数量。","code":"#include <vector>\n#include <numeric>\n#include <iostream>\n#include <unordered_map>\n// bestlyg\n#define X first\n#define Y second\n#define lb(x) ((x) & (-x))\n#define mem(a,b) memset(a,b,sizeof(a))\n#define debug freopen(\"input\",\"r\",stdin)\n#define PII pair<int,int>\n\n#ifdef DEBUG\n#define log(frm, args...) {    printf(frm, ##args);}\n#else\n#define log(frm, args...)\n#endif\n\ntypedef long long ll;\nusing namespace std;\n\nclass UnionFind {\npublic:\n    int n;\n    vector<int> data, cnt;\n    UnionFind(int n): n(n), data(vector<int>(n, 0)), cnt(vector<int>(n, 1)) {\n        iota(data.begin(), data.end(), 0);\n    }\n    int size(int v) { return cnt[find(v)]; }\n    int find(int v) {\n        if (data[v] == v) return v;\n        return data[v] = find(data[v]);\n    }\n    void uni(int v1, int v2) {\n        int p1 = find(v1), p2 = find(v2);\n        if (p1 != p2) {\n            cnt[p1] += cnt[p2];\n            data[p2] = p1;\n        }\n    }\n    bool same(int v1, int v2) { return find(v1) == find(v2); }\n};\nint pos2Idx(int x, int y, int size) { return x * size + y; }\nvoid idx2Pos(int idx, int size, int &x, int &y) { x = idx / size; y = idx % size; }\nvector<vector<int>> dirs = { {0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n// START\n\nconst int MAX = 14;\nstruct TrieNode {\n    int sum, val;\n    TrieNode *children[2];\n    TrieNode(int val): sum(0), val(val) { children[0] = children[1] = nullptr; }\n    ~TrieNode() {\n        delete children[0];\n        delete children[1];\n    }\n};\nstruct Trie {\n    TrieNode *root;\n    Trie(): root(new TrieNode(0)) {}\n    void add(int num) {\n        TrieNode *p = root;\n        for (int i = MAX; i >= 0; i--) {\n            int tag = (num >> i) & 1;\n            TrieNode *next = p->children[tag];\n            if (next == nullptr) next = p->children[tag] = new TrieNode(tag);\n            p = next;\n            p->sum += 1;\n        }\n    }\n    int get(int num, int x) {\n        TrieNode *p = root;\n        int sum = 0;\n        for (int i = MAX; i >= 0; i--) {\n            int tag = (num >> i) & 1;\n            if ((x >> i) & 1) {\n                if (p->children[tag] != nullptr) sum += p->children[tag]->sum;\n                if (p->children[tag ^ 1] == nullptr) return sum;\n                p = p->children[tag ^ 1];\n            } else {\n                if (p->children[tag] == nullptr) return sum;\n                p = p->children[tag];\n            }\n        }\n        sum += p->sum;\n        return sum;\n    }\n    ~Trie() {\n        log(\"~trie\n\");\n        delete root;\n    }\n};\nclass Solution {\npublic:\n    int comp(vector<int> &nums, int num) {\n        Trie trie;\n        int ans = 0;\n        for (int i = 1; i < nums.size(); i++) {\n            trie.add(nums[i - 1]);\n            ans += trie.get(nums[i], num);\n        }\n        return ans;\n    }\n    int countPairs(vector<int>& nums, int low, int high) {\n        return comp(nums, high) - comp(nums, low - 1);\n    }\n};\n\n// END\n#ifdef LOCAL\nint main() {\n    Solution s;\n    // vector<int> nums = {1,4,2,7};\n    // int low = 2;\n    // int high = 6;\n    vector<int> nums = {9,8,4,2,1};\n    int low = 5;\n    int high = 14;\n    cout << s.countPairs(nums, low, high) << endl;\n    return 0;\n}\n#endif"},{"date":"2023-01-05","time":132,"memory":4.6,"script":"rust","desc":"同上。","code":"pub use std::{cell::RefCell, rc::Rc};\nconst MAX: i32 = 14;\nstruct TrieNode {\n    sum: i32,\n    children: [Option<Rc<RefCell<TrieNode>>>; 2],\n}\nimpl TrieNode {\n    fn new() -> TrieNode {\n        TrieNode {\n            sum: 0,\n            children: [None, None],\n        }\n    }\n}\nstruct Trie {\n    root: Option<Rc<RefCell<TrieNode>>>,\n}\nimpl Trie {\n    fn new() -> Trie {\n        Trie {\n            root: Some(Rc::new(RefCell::new(TrieNode::new()))),\n        }\n    }\n    fn add(&self, num: i32) {\n        let mut p = self.root.clone().unwrap();\n        let mut i = MAX;\n        while i >= 0 {\n            let tag = ((num >> i) & 1) as usize;\n            let mut next: Option<Rc<RefCell<TrieNode>>> = None;\n            if p.as_ref().borrow().children[tag].is_none() {\n                let node = Rc::new(RefCell::new(TrieNode::new()));\n                p.borrow_mut().children[tag] = Some(node.clone());\n                next = Some(node.clone());\n            } else {\n                let node = p.as_ref().borrow().children[tag].clone();\n                next = node\n            }\n            p = next.unwrap();\n            p.borrow_mut().sum += 1;\n            i -= 1;\n        }\n    }\n    fn get(&self, num: i32, x: i32) -> i32 {\n        let mut p = self.root.clone().unwrap();\n        let mut sum = 0;\n        let mut i = MAX;\n        while i >= 0 {\n            let tag = ((num >> i) & 1) as usize;\n            if ((x >> i) & 1) == 1 {\n                if p.as_ref().borrow().children[tag].is_some() {\n                    let child = p.as_ref().borrow().children[tag].clone();\n                    sum += child.unwrap().as_ref().borrow().sum;\n                }\n                if p.as_ref().borrow().children[tag ^ 1].is_none() {\n                    return sum;\n                }\n                let next = p.as_ref().borrow().children[tag ^ 1].clone();\n                p = next.unwrap();\n            } else {\n                if p.as_ref().borrow().children[tag].is_none() {\n                    return sum;\n                }\n                let next = p.as_ref().borrow().children[tag].clone();\n                p = next.unwrap();\n            }\n            i -= 1;\n        }\n        sum += p.as_ref().borrow().sum;\n        sum\n    }\n}\nimpl Solution {\n    fn comp(nums: &Vec<i32>, num: i32) -> i32 {\n        let trie = Trie::new();\n        let mut ans = 0;\n        for i in 1..nums.len() {\n            trie.add(nums[i - 1]);\n            ans += trie.get(nums[i], num);\n        }\n        ans\n    }\n    pub fn count_pairs(nums: Vec<i32>, low: i32, high: i32) -> i32 {;\n        Solution::comp(&nums, high) - Solution::comp(&nums, low - 1)\n    }\n}"},{"date":"2023-01-05","time":436,"memory":2.2,"script":"rust","desc":"暴力。","code":"impl Solution {\n    pub fn count_pairs(nums: Vec<i32>, low: i32, high: i32) -> i32 {\n        let mut ans = 0;\n        for i in 0..nums.len() {\n            for j in i + 1..nums.len() {\n                let val = nums[i] ^ nums[j];\n                if val >= low && val <= high {\n                    ans += 1;\n                }\n            }\n        }\n        ans\n    }\n}"}],"tagList":["位运算","字典树","数组"],"level":"Hard"}},{"problemName":"1805.字符串中不同整数的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1805.字符串中不同整数的数目.json","problemData":{"id":"1933","name":"1805.字符串中不同整数的数目","url":"https://leetcode.cn/problems/number-of-different-integers-in-a-string","desc":"给你一个字符串 word ，该字符串由数字和小写英文字母组成。返回对 word 完成替换后形成的 不同 整数的数目。","solutions":[{"date":"2022-03-17","time":0,"memory":6.4,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    int numDifferentIntegers(string word) {\n        unordered_set<string> s;\n        int idx = 0, n = word.size();\n        while (idx < n) {\n            while (idx < n && isalpha(word[idx])) idx++;\n            if (idx == n) break;\n            string num = \"\";\n            for (; isdigit(word[idx]); idx++) {\n                if (num == \"\" && word[idx] == '0') continue;\n                num += word[idx];\n            }\n            s.insert(num);\n        }\n        return s.size();\n    }\n};"},{"date":"2022-12-06","time":0,"memory":6.3,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    int numDifferentIntegers(string word) {\n        unordered_set<string> s;\n        for (int i = 0, n = word.size(); i < n; i++) {\n            if (!isdigit(word[i])) continue;\n            int start = i;\n            while (i < n && isdigit(word[i])) i++;\n            while (start + 1 < i && word[start] == '0') start++;\n            s.insert(word.substr(start, i - start));\n        }\n        return s.size();\n    }\n};"}],"tagList":["哈希表","字符串"],"level":"Easy"}},{"problemName":"1806.还原排列的最少操作步数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1806.还原排列的最少操作步数.json","problemData":{"id":"1935","name":"1806.还原排列的最少操作步数","url":"https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation","desc":"给你一个偶数 n​​​​​​ ，已知存在一个长度为 n 的排列 perm ，其中 perm[i] == i​（下标 从 0 开始 计数）。","solutions":[{"date":"2023-01-09","time":32,"memory":6.4,"script":"cpp","desc":"模拟。","code":"class Solution {\npublic:\n    int reinitializePermutation(int n) {\n        vector<int> list1(n), list2(n);\n        for (int i = 0; i < n; i++) list1[i] = i;\n        int ans = 1;\n        for (; ; ans += 1, list1 = list2) {\n            int f = true;\n            for (int i = 0; i < n; i++) {\n                if (i % 2 == 0) list2[i] = list1[i / 2];\n                else list2[i] = list1[n / 2 + (i - 1) / 2];\n                if (list2[i] != i) f = false;\n            }\n            if (f) break;\n        }\n        return ans;\n    }\n};"},{"date":"2023-01-09","time":8,"memory":2.3,"script":"rust","desc":"同上。","code":"impl Solution {\n    pub fn reinitialize_permutation(n: i32) -> i32 {\n        let n = n as usize;\n        let (mut l1, mut l2) = ((0..n).collect::<Vec<_>>(),vec![0;n] );\n        let mut ans = 1;\n        loop {\n            let mut f = true;\n            for i in 0..n {\n                if i % 2 == 0 {\n                    l2[i] = l1[i / 2];\n                } else {\n                    l2[i] = l1[n / 2 + (i - 1) / 2];\n                }\n                if l2[i] != i {\n                    f = false;\n                }\n            }\n            if f {\n                break;\n            }\n            ans += 1;\n            l1 = l2.clone();\n        }\n        ans\n    }\n}"}],"tagList":["数组","数学","模拟"],"level":"Medium"}},{"problemName":"1807.替换字符串中的括号内容.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1807.替换字符串中的括号内容.json","problemData":{"id":"1934","name":"1807.替换字符串中的括号内容","url":"https://leetcode.cn/problems/evaluate-the-bracket-pairs-of-a-string","desc":"给你一个字符串 s ，它包含一些括号对，每个括号中包含一个 非空 的键。请你返回替换 所有 括号对后的结果字符串。","solutions":[{"script":"cpp","time":368,"memory":114.3,"desc":"遍历。","code":"class Solution {\npublic:\n    string evaluate(string s, vector<vector<string>>& knowledge) {\n        unordered_map<string, string> m;\n        for (auto &item : knowledge) m[item[0]] = item[1];\n        string ans = \"\";\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] != '(') ans += s[i];\n            else {\n                cout << \"i = \" << i << endl;\n                int start = i + 1;\n                while (s[i] != ')') i++;\n                string key = s.substr(start, i - start);\n                if (!m.count(key)) ans += \"?\";\n                else ans += m[key];\n            }\n        }\n        return ans;\n    }\n};","date":"2023-01-12"},{"script":"rust","time":76,"memory":33.9,"desc":"同上。","code":"use std::collections::HashMap;\nimpl Solution {\n    pub fn evaluate(s: String, knowledge: Vec<Vec<String>>) -> String {\n        let s = s.chars().collect::<Vec<char>>();\n        let mut ans = String::new();\n        let mut m = HashMap::<String, String>::new();\n        for item in knowledge {\n            m.insert(item[0].clone(), item[1].clone());\n        }\n        let default_value = \"?\".to_string();\n        let mut i = 0;\n        while i < s.len() {\n            if s[i] != '(' {\n                ans.push(s[i]);\n            } else {\n                let start = i + 1;\n                while s[i] != ')' {\n                    i += 1;\n                }\n                let key = s[start..i].iter().collect::<String>();\n                let s: &String = m.get(&key).unwrap_or_else(||&default_value);\n                ans.push_str(s);\n            }\n            i += 1;\n        }\n        ans\n    }\n}","date":"2023-01-12"}],"tagList":["数组","哈希表","字符串"],"level":"Medium"}},{"problemName":"1812.判断国际象棋棋盘中一个格子的颜色.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1812.判断国际象棋棋盘中一个格子的颜色.json","problemData":{"id":"1920","name":"1812.判断国际象棋棋盘中一个格子的颜色","url":"https://leetcode.cn/problems/determine-color-of-a-chessboard-square","desc":"如果所给格子的颜色是白色，请你返回 true，如果是黑色，请返回 false 。","solutions":[{"date":"2022-12-08","time":0,"memory":5.8,"script":"cpp","desc":"判断行列。","code":"class Solution {\npublic:\n    bool squareIsWhite(string coordinates) {\n        return (coordinates[1] - '0' - 1 ^ ((coordinates[0] - 'a') & 1)) & 1;\n    }\n};"},{"date":"2022-12-08","time":0,"memory":5.8,"script":"cpp","desc":"判断行列。","code":"class Solution {\npublic:\n    bool squareIsWhite(string coordinates) {\n        return ((coordinates[0] - 'a') & 1) == ((coordinates[1] - '0') & 1);\n    }\n};"}],"tagList":["数学","字符串"],"level":"Easy"}},{"problemName":"1813.句子相似性III.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1813.句子相似性III.json","problemData":{"id":"1923","name":"1813.句子相似性III","url":"https://leetcode.cn/problems/sentence-similarity-iii","desc":"给你两个句子 sentence1 和 sentence2 ，如果 sentence1 和 sentence2 是相似的，请你返回 true ，否则返回 false 。","solutions":[{"script":"cpp","time":0,"memory":6.4,"desc":"双指针递归。","code":"class Solution {\npublic:\n    bool areSentencesSimilar(string sentence1, string sentence2) {\n        vector<string> l1 = split(sentence1), l2 = split(sentence2);\n        return compare(l1, l2, 0, 0, false);\n    }\n    bool compare(vector<string> &l1, vector<string> &l2, int i1, int i2, bool inserted) {\n        if (i1 == l1.size() && i2 == l2.size()) return true;\n        if (i2 == l2.size() || i1 == l1.size()) return !inserted;\n        if (l1[i1] == l2[i2]) return compare(l1, l2, i1 + 1, i2 + 1, inserted);\n        if (inserted) return false;\n        int next = i1;\n        while ((next = indexof(l1, next + 1, l2[i2])) != -1)\n            if (compare(l1, l2, next, i2, true)) return true;\n        next = i2;\n        while ((next = indexof(l2, next + 1, l1[i1])) != -1)\n            if (compare(l1, l2, i1, next, true)) return true;\n        return false;\n    }\n    int indexof(vector<string> &l, int start, string &s) {\n        for (int i = start; i < l.size(); i++)\n            if (l[i] == s) return i;\n        return -1;\n    }\n    vector<string> split(string &s) {\n        vector<string> ans;\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == ' ') continue;\n            string cur = \"\";\n            while (i < s.size() && s[i] != ' ') cur += s[i++];\n            ans.push_back(cur);\n        }\n        return ans;\n    }\n};","date":"2023-01-16"},{"script":"rust","time":0,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn are_sentences_similar(sentence1: String, sentence2: String) -> bool {\n        let l1 = sentence1.split(\" \").collect::<Vec<&str>>();\n        let l2 = sentence2.split(\" \").collect::<Vec<&str>>();\n        Solution::compare(&l1, &l2, 0, 0, false)\n    }\n    fn compare(l1: &Vec<&str>, l2: &Vec<&str>, i1: usize, i2: usize, inserted: bool) -> bool {\n        if i1 == l1.len() && i2 == l2.len() {\n            true\n        } else if i1 == l1.len() || i2 == l2.len() {\n            !inserted\n        } else if l1[i1].cmp(l2[i2]).is_eq() {\n            Solution::compare(l1, l2, i1 + 1, i2 + 1, inserted)\n        } else if inserted {\n            false\n        } else {\n            let mut next = i1;\n            loop {\n                let res = Solution::indexof(l1, next + 1, l2[i2]);\n                if res == -1 {\n                    break;\n                }\n                let res = res as usize;\n                if Solution::compare(l1, l2, res, i2, true) {\n                    return true;\n                }\n                next = res;\n            }\n            let mut next = i2;\n            loop {\n                let res = Solution::indexof(l2, next + 1, l1[i1]);\n                if res == -1 {\n                    break;\n                }\n                let res = res as usize;\n                if Solution::compare(l1, l2, i1, res, true) {\n                    return true;\n                }\n                next = res;\n            }\n            false\n        }\n    }\n    fn indexof(l: &Vec<&str>, start: usize, s: &str) -> i32 {\n        let mut i = start;\n        while i < l.len() {\n            if l[i].cmp(s).is_eq() {\n                return i as i32;\n            }\n            i += 1;\n        }\n        return -1;\n    }\n}","date":"2023-01-16"}],"tagList":["数组","双指针","字符串"],"level":"Medium"}},{"problemName":"1814.统计一个数组中好对子的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1814.统计一个数组中好对子的数目.json","problemData":{"id":"1925","name":"1814.统计一个数组中好对子的数目","url":"https://leetcode.cn/problems/count-nice-pairs-in-an-array","desc":"请你返回好下标对的数目。","solutions":[{"script":"cpp","time":84,"memory":55.5,"desc":"双指针递归。","code":"const int mod = 1e9 + 7;\nclass Solution {\npublic:\n    int countNicePairs(vector<int>& nums) {\n        unordered_map<int, int> m;\n        int ans = 0;\n        for (auto &num : nums) ans = (ans + m[num - rev(num)]++) % mod;\n        return ans;\n    }\n    int rev(int num) {\n        int ans = 0;\n        for (; num; num /= 10) ans = ans * 10 + num % 10;\n        return ans;\n    }\n};","date":"2023-01-17"},{"script":"rust","time":24,"memory":3.7,"desc":"同上。","code":"use std::collections::HashMap;\nconst MOD: i32 = 1000000007;\nimpl Solution {\n    pub fn count_nice_pairs(nums: Vec<i32>) -> i32 {\n        let mut m = HashMap::<i32, i32>::new();\n        let mut ans = 0;\n        for num in nums {\n            let k = num - Solution::rev(num);\n            let v = if m.contains_key(&k) {\n                m.get_mut(&k).unwrap()\n            } else {\n                m.insert(k, 0);\n                m.get_mut(&k).unwrap()\n            };\n            ans = (ans + *v) % MOD;\n            *v += 1;\n        }\n        ans\n    }\n    fn rev(num: i32) -> i32 {\n        let mut num = num;\n        let mut ans = 0;\n        while num != 0 {\n            ans = ans * 10 + num % 10;\n            num /= 10;\n        }\n        ans\n    }\n}","date":"2023-01-17"},{"script":"python","time":260,"memory":23.1,"desc":"双指针递归。","code":"class Solution:\ndef countNicePairs(self, nums: List[int]) -> int:\n    m = Counter()\n    ans = 0\n    for num in nums:\n        k = num - int(str(num)[::-1])\n        ans += m[k]\n        m[k] += 1\n    return int(ans % (1e9 + 7))","date":"2023-01-17"}],"tagList":["数组","哈希表","数学","计数"],"level":"Medium"}},{"problemName":"1815.得到新鲜甜甜圈的最多组数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1815.得到新鲜甜甜圈的最多组数.json","problemData":{"id":"1924","name":"1815.得到新鲜甜甜圈的最多组数","url":"https://leetcode.cn/problems/maximum-number-of-groups-getting-fresh-donuts","desc":"你可以随意安排每批顾客到来的顺序。请你返回在此前提下，最多 有多少组人会感到开心。","solutions":[{"script":"cpp","time":4,"memory":8.1,"desc":"先统计1个组无余数，2个组组合无余数，剩下的记忆化搜索。","code":"class Solution {\npublic:\n    unordered_map<int, int> cache;\n    int maxHappyGroups(int batchSize, vector<int>& groups) {\n        map<int, int> m;\n        int sum = 0;\n        for (int i = 0; i < groups.size(); i++) {\n            int num = groups[i] % batchSize;\n            if (num == 0) sum++;\n            else if (m[batchSize - num]) m[batchSize - num]--, sum++;\n            else m[num]++;\n        }\n        return sum + dfs(m, batchSize, 0);\n    }\n    int dfs(map<int, int> &m, int batchSize, int surplus) {\n        int cachek = trans(m);\n        if (cache[cachek]) return cache[cachek];\n        int res = 0;\n        for (auto &item : m) {\n            if (item.second == 0) continue;\n            item.second--;\n            res = max(res, (surplus == 0) + dfs(m, batchSize, (batchSize - item.first + surplus) % batchSize));\n            item.second++;\n        }\n        return cache[cachek] = res;\n    }\n    int trans(map<int, int> &m) {\n        int ans = 0, i = 0;\n        for (auto &item : m) ans |= item.second << (4 * i++);\n        return ans;\n    }\n};","date":"2023-01-22"},{"script":"python","time":64,"memory":15.8,"desc":"同上。","code":"from sortedcontainers import SortedDict\nclass Solution:\n    def maxHappyGroups(self, batchSize: int, groups: List[int]) -> int:\n        cache = defaultdict()\n        m = SortedDict()\n        nsum = 0\n        for group in groups:\n            num = group % batchSize\n            if num == 0:\n                nsum += 1\n            elif (batchSize - num) in m and m[batchSize - num] > 0:\n                m[batchSize - num] -= 1\n                nsum += 1\n            else:\n                item = m.setdefault(num, 0)\n                m[num] = item + 1\n        def trans(m: SortedDict):\n            ans = 0\n            i = 0\n            for item in m.values():\n                ans |= item << (4 * i)\n                i += 1\n            return ans\n        def dfs(m: SortedDict, surplus: int):\n            cachek = trans(m)\n            if cachek in cache:\n                return cache[cachek]\n            res = 0\n            for k in m.keys():\n                if m[k] == 0:\n                    continue\n                m[k] -= 1\n                res = max(res, (surplus == 0) +\n                          dfs(m, (batchSize - k + surplus) % batchSize))\n                m[k] += 1\n            cache[cachek] = res\n            return res\n        return nsum + dfs(m, 0)","date":"2023-01-22"},{"script":"rust","time":0,"memory":2.1,"desc":"同上。","code":"use std::collections::{BTreeMap, HashMap};\nimpl Solution {\n    pub fn max_happy_groups(batch_size: i32, groups: Vec<i32>) -> i32 {\n        let mut m = BTreeMap::<i32, i32>::new();\n        let mut sum = 0;\n        for group in groups {\n            let num = group % batch_size;\n            if num == 0 {\n                sum += 1;\n            } else if m.contains_key(&(batch_size - num)) && m[&(batch_size - num)] > 0 {\n                let item = m.get_mut(&(batch_size - num)).unwrap();\n                *item -= 1;\n                sum += 1;\n            } else {\n                let item = m.entry(num).or_insert(0);\n                *item += 1;\n            }\n        }\n        let mut cache = HashMap::<i32, i32>::new();\n        sum + Solution::dfs(m, &mut cache, batch_size, 0)\n    }\n    fn trans(m: &BTreeMap<i32, i32>) -> i32 {\n        let mut ans = 0;\n        let mut i = 0;\n        for (_, v) in m.iter() {\n            ans |= v << (4 * i);\n            i += 1;\n        }\n        ans\n    }\n    fn dfs(\n        m: BTreeMap<i32, i32>,\n        cache: &mut HashMap<i32, i32>,\n        batch_size: i32,\n        surplus: i32,\n    ) -> i32 {\n        let cachek = Solution::trans(&m);\n        if cache.contains_key(&cachek) {\n            *cache.get(&cachek).unwrap()\n        } else {\n            let mut res = 0;\n            for (k, v) in m.iter() {\n                if *v != 0 {\n                    let mut next_m = m.clone();\n                    *next_m.get_mut(k).unwrap() -= 1;\n                    res = res.max(\n                        i32::from(surplus == 0)\n                            + Solution::dfs(\n                                next_m,\n                                cache,\n                                batch_size,\n                                (batch_size - *k + surplus) % batch_size,\n                            ),\n                    );\n                }\n            }\n            cache.insert(cachek, res);\n            res\n        }\n    }\n}","date":"2023-01-22"}],"tagList":["位运算","记忆化搜索","数组","动态规划","状态压缩"],"level":"Hard"}},{"problemName":"1816.截断句子.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1816.截断句子.json","problemData":{"id":"1944","name":"1816.截断句子","url":"https://leetcode.cn/problems/truncate-sentence","desc":"给你一个句子 s​​​​​​ 和一个整数 k​​​​​​ ，请你将 s​​ 截断 ​，​​​ 使截断后的句子仅含 前 k​​​​​​ 个单词。返回 截断 s​​​​​​ 后得到的句子。","solutions":[{"date":"2021-12-06","time":72,"memory":39.2,"script":"typescript","desc":"分割后重组。","code":"function truncateSentence(s: string, k: number): string {\n  return s.split(' ').slice(0, k).join(' ');\n}"},{"date":"2021-12-06","time":72,"memory":39.2,"script":"typescript","desc":"遍历。","code":"function truncateSentence(s: string, k: number): string {\n  for (let cnt = 0, i = 0; i < s.length; i++) {\n    if (s[i] === ' ') {\n      if (++cnt === k) return s.substring(0, i);\n    }\n  }\n  return s;\n}"},{"date":"2021-12-06","time":4,"memory":6.1,"script":"c","desc":"遍历。","code":"char * truncateSentence(char * s, int k){\n    for (int cnt = 0, i = 0; i < strlen(s); i++) {\n        if (s[i] == ' ' && ++cnt == k) {\n            char *ans = (char *)calloc(i + 1, sizeof(char));\n            strncpy(ans, s, i);\n            return ans;\n        }\n    }\n    return s;\n}"}],"tagList":["数组","字符串"],"level":"Easy"}},{"problemName":"1817.查找用户活跃分钟数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1817.查找用户活跃分钟数.json","problemData":{"id":"1945","name":"1817.查找用户活跃分钟数","url":"https://leetcode.cn/problems/finding-the-users-active-minutes","desc":"请你统计用户活跃分钟数的分布情况，统计结果是一个长度为 k 且 下标从 1 开始计数 的数组 answer ，对于每个 j（1 <= j <= k），answer[j] 表示 用户活跃分钟数 等于 j 的用户数。","solutions":[{"script":"cpp","time":208,"memory":83.4,"desc":"遍历。","code":"class Solution {\npublic:\n    vector<int> findingUsersActiveMinutes(vector<vector<int>>& logs, int k) {\n        vector<int> list(k, 0);\n        unordered_map<int, unordered_set<int>> m;\n        for (auto &log : logs) m[log[0]].insert(log[1]);\n        for (auto &user : m) list[user.second.size() - 1]++;\n        return list;\n    }\n};","date":"2023-01-20"},{"script":"rust","time":60,"memory":4.9,"desc":"同上。","code":"impl Solution {\n    pub fn finding_users_active_minutes(logs: Vec<Vec<i32>>, k: i32) -> Vec<i32> {\n        use std::collections::{HashMap, HashSet};\n        let mut ans = vec![0; k as usize];\n        let mut m = HashMap::<i32, HashSet<i32>>::new();\n        for log in logs {\n            let s = m.entry(log[0]).or_insert(HashSet::new());\n            s.insert(log[1]);\n        }\n        for (_, v) in m {\n            ans[v.len() - 1] += 1;\n        }\n        ans\n    }\n}","date":"2023-01-20"},{"script":"python","time":132,"memory":20.5,"desc":"同上。","code":"class Solution:\ndef findingUsersActiveMinutes(self, logs: List[List[int]], k: int) -> List[int]:\n    ans = [0 for _ in range(k)]\n    m = {}\n    for log in logs:\n        s = m.setdefault(log[0], set())\n        s.add(log[1])\n    for (_, v) in m.items():\n        ans[len(v) - 1] += 1\n    return ans","date":"2023-01-20"}],"tagList":["数组","哈希表"],"level":"Medium"}},{"problemName":"1818.绝对差值和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1818.绝对差值和.json","problemData":{"id":"1946","name":"1818.绝对差值和","url":"https://leetcode.cn/problems/minimum-absolute-sum-difference","desc":"给你两个正整数数组 nums1 和 nums2 ，数组的长度都是 n 。在替换数组 nums1 中最多一个元素 之后 ，返回最小绝对差值和。","solutions":[{"date":"2021-07-14","time":224,"memory":55.9,"script":"typescript","desc":"对每一位进行查找最近值。","code":"function minAbsoluteSumDiff(nums1: number[], nums2: number[]): number {\n  const len = nums1.length;\n  const nums: number[] = new Array(len).fill(0).map((_, i) => Math.abs(nums1[i] - nums2[i]));\n  nums1.sort((a, b) => a - b);\n  const sum = nums.reduce((total, cur) => total + cur, 0);\n  let ans = sum;\n  for (let i = 0; i < len; i++) ans = Math.min(ans, sum - nums[i] + findMin(i));\n  return ans % (10 ** 9 + 7);\n  function findMin(index: number): number {\n    const num2 = nums2[index];\n    let left = 0;\n    let right = len - 1;\n    while (left < right) {\n      const mid = (left + right) >> 1;\n      const midNum = nums1[mid];\n      if (midNum < num2) left = mid + 1;\n      else if (midNum > num2) right = mid - 1;\n      else {\n        left = mid;\n        break;\n      }\n    }\n    return Math.min(\n      Math.abs(nums1[left] - num2),\n      left > 0 ? Math.abs(nums1[left - 1] - num2) : Infinity,\n      left < len - 1 ? Math.abs(nums1[left + 1] - num2) : Infinity\n    );\n  }\n}"}],"tagList":["数组","二分查找","有序集合","排序"],"level":"Medium"}},{"problemName":"1819.序列中不同最大公约数的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1819.序列中不同最大公约数的数目.json","problemData":{"id":"1947","name":"1819.序列中不同最大公约数的数目","url":"https://leetcode.cn/problems/number-of-different-subsequences-gcds","desc":"计算并返回 nums 的所有 非空 子序列中 不同 最大公约数的 数目 。","solutions":[{"date":"2022-01-07","time":1948,"memory":67.2,"script":"typescript","desc":"对于每个可能出现的最大公约数 i 进行统计，所有数中的 i 的倍数和的最大公约数是否为 i，是则存在。","code":"function gcd(a: number, b: number) {\n  if (b) return gcd(b, a % b);\n  return a;\n}\nfunction countDifferentSubsequenceGCDs(nums: number[]): number {\n  const set = new Set(nums);\n  const max = Math.max(...nums);\n  let ans = 0;\n  for (let i = 1; i <= max; i++) {\n    let val = -1;\n    for (let j = i; j <= max; j += i) {\n      if (!set.has(j)) continue;\n      if (val == -1) val = j;\n      else val = gcd(val, j);\n    }\n    if (val == i) ans++;\n  }\n  return ans;\n}"},{"date":"2022-01-07","time":292,"memory":70.1,"script":"cpp","desc":"对于每个可能出现的最大公约数 i 进行统计，所有数中的 i 的倍数和的最大公约数是否为 i，是则存在。","code":"class Solution {\n   public:\n    int gcd(int a, int b) {\n        if (b) return gcd(b, a % b);\n        return a;\n    }\n    int countDifferentSubsequenceGCDs(vector<int>& nums) {\n        int cnts[200005] = {0}, maxn = 0, ans = 0;\n        for (auto& num : nums) {\n            cnts[num] = 1;\n            maxn = max(maxn, num);\n        }\n        for (int i = 1; i <= maxn; i++) {\n            int val = -1;\n            for (int j = i; j <= maxn; j += i) {\n                if (!cnts[j]) continue;\n                if (val == -1)\n                    val = j;\n                else\n                    val = gcd(val, j);\n            }\n            if (val == i) ans++;\n        }\n        return ans;\n    }\n};"},{"script":"cpp","time":1156,"memory":114.2,"desc":"对每个数进行判断是否可能是最大公约数。","code":"class Solution {\npublic:\n    int gcd(int a, int b) {\n        if (!b)return a;\n        return gcd(b, a % b);\n    }\n    int countDifferentSubsequenceGCDs(vector<int>& nums) {\n        int n = nums.size(), ans = 0, nmax = 0;\n        unordered_set<int> s;\n        for (auto &num : nums) {\n            nmax = max(nmax, num);\n            s.insert(num);\n        }\n        vector<bool> l(nmax + 1, false);\n        for (int i = 1; i <= nmax; i++) {\n            if (s.count(i)) {\n                ans++;\n                continue;\n            }\n            int cur = -1;\n            for (int j = 2; i * j <= nmax && cur != i; j++) {\n                if (!s.count(i * j)) continue;\n                if (cur == -1) cur = i * j;\n                else cur = gcd(cur, i * j);\n            }\n            if (cur == i) ans++;\n        }\n        return ans;\n    }\n};","date":"2023-01-14"},{"script":"rust","time":60,"memory":3.2,"desc":"同上。","code":"impl Solution {\n    fn gcd(a: i32, b: i32) -> i32 {\n        if b == 0 {\n            a\n        } else {\n            Solution::gcd(b, a % b)\n        }\n    }\n    pub fn count_different_subsequence_gc_ds(nums: Vec<i32>) -> i32 {\n        let mut max = 0;\n        let mut ans = 0;\n        let mut l = [false; 200005];\n        for num in nums {\n            max = max.max(num);\n            l[num as usize] = true;\n        }\n        for i in 1..=max {\n            if l[i as usize] {\n                ans += 1;\n                continue;\n            }\n            let mut j = 2;\n            let mut cur = -1;\n            while j * i <= max && cur != i {\n                let num = i * j;\n                if l[num as usize] {\n                    cur = if cur == -1 {\n                        num\n                    } else {\n                        Solution::gcd(cur, num)\n                    }\n                }\n                j += 1;\n            }\n            if cur == i {\n                ans += 1;\n            }\n        }\n        ans\n    }\n}","date":"2023-01-14"}],"tagList":["数组","数学","计数","数论"],"level":"Hard"}},{"problemName":"1822.数组元素积的符号.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1822.数组元素积的符号.json","problemData":{"id":"1950","name":"1822.数组元素积的符号","url":"https://leetcode.cn/problems/sign-of-the-product-of-an-array","desc":"给你一个整数数组 nums 。令 product 为数组 nums 中所有元素值的乘积。","solutions":[{"date":"2022-10-27","time":4,"memory":9.9,"script":"cpp","desc":"遍历检查有几个负数。","code":"class Solution {\npublic:\n    int arraySign(vector<int>& nums) {\n        int cnt = 0;\n        for (auto &num : nums) {\n            if (num == 0) return 0;\n            else if (num < 0) cnt ^= 1;\n        }\n        return cnt ? -1 : 1;\n    }\n};"}],"tagList":["数组","数学"],"level":"Easy"}},{"problemName":"1823.找出游戏的获胜者.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1823.找出游戏的获胜者.json","problemData":{"id":"1951","name":"1823.找出游戏的获胜者","url":"https://leetcode.cn/problems/find-the-winner-of-the-circular-game","desc":"给你参与游戏的小伙伴总数 n ，和一个整数 k ，返回游戏的获胜者。","solutions":[{"date":"2022-05-04","time":0,"memory":5.4,"script":"cpp","desc":"遍历。","code":"int findTheWinner(int n, int k) {\n    int list[n], current = n - 1;\n    for (int i = 0; i < n; i++) list[i] = i + 1;\n    list[n - 1] = 0;\n    for (int jump = 0; n > 1; n--) {\n        jump = (k - 1) % n;\n        while (jump > 0) current = list[current], jump--;\n        list[current] = list[list[current]];\n    }\n    return current + 1;\n}"},{"date":"2022-05-04","time":0,"memory":1.9,"script":"go","desc":"遍历。","code":"func findTheWinner(n int, k int) int {\n    list := make([]int, n)\n    for i := 0; i < n; i++ {\n        list[i] = i + 1\n    }\n    list[n-1] = 0\n    current := n - 1\n    for jump := 0; n > 1; n-- {\n        jump = (k - 1) % n\n        for ; jump > 0; jump-- {\n            current = list[current]\n        }\n        list[current] = list[list[current]]\n    }\n    return current + 1\n}"}],"tagList":["递归","队列","数组","数学","模拟"],"level":"Medium"}},{"problemName":"1824.最少侧跳次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1824.最少侧跳次数.json","problemData":{"id":"1952","name":"1824.最少侧跳次数","url":"https://leetcode.cn/problems/minimum-sideway-jumps","desc":"这只青蛙从点 0 处跑道 2 出发，并想到达点 n 处的 任一跑道 ，请你返回 最少侧跳次数 。","solutions":[{"script":"cpp","time":584,"memory":313.1,"desc":"dp。","code":"#define MAX 0x3f3f3f3f\nclass Solution {\npublic:\n    int minSideJumps(vector<int>& obstacles) {\n        int n = obstacles.size();\n        vector<vector<int>> dp(n, vector<int>(4, MAX));\n        dp[0][2] = 0;\n        dp[0][1] = dp[0][3] = 1;\n        for (int i = 1; i < n; i++) {\n            if (obstacles[i] != 1) dp[i][1] = dp[i - 1][1];\n            if (obstacles[i] != 2) dp[i][2] = dp[i - 1][2];\n            if (obstacles[i] != 3) dp[i][3] = dp[i - 1][3];\n            if (obstacles[i - 1] == 1) dp[i][1] = min(dp[i][2], dp[i][3]) + 1;\n            if (obstacles[i - 1] == 2) dp[i][2] = min(dp[i][1], dp[i][3]) + 1;\n            if (obstacles[i - 1] == 3) dp[i][3] = min(dp[i][1], dp[i][2]) + 1;\n        }\n        return min({dp[n - 1][1], dp[n - 1][2], dp[n - 1][3]});\n    }\n};","date":"2023-01-21"},{"script":"rust","time":100,"memory":30.7,"desc":"同上。","code":"impl Solution {\n    pub fn min_side_jumps(obstacles: Vec<i32>) -> i32 {\n        let n = obstacles.len();\n        let mut dp = vec![vec![0x3f3f3f3f; 4]; n];\n        dp[0][1] = 1;\n        dp[0][2] = 0;\n        dp[0][3] = 1;\n        for i in 1..n {\n            if obstacles[i] != 1 {\n                dp[i][1] = dp[i - 1][1];\n            }\n            if obstacles[i] != 2 {\n                dp[i][2] = dp[i - 1][2];\n            }\n            if obstacles[i] != 3 {\n                dp[i][3] = dp[i - 1][3];\n            }\n            if obstacles[i - 1] == 1 {\n                dp[i][1] = dp[i][2].min(dp[i][3]) + 1;\n            }\n            if obstacles[i - 1] == 2 {\n                dp[i][2] = dp[i][1].min(dp[i][3]) + 1;\n            }\n            if obstacles[i - 1] == 3 {\n                dp[i][3] = dp[i][1].min(dp[i][2]) + 1;\n            }\n        }\n        dp[n - 1][1].min(dp[n - 1][2]).min(dp[n - 1][3])\n    }\n}\n","date":"2023-01-21"},{"script":"python","time":1964,"memory":88,"desc":"同上。","code":"class Solution:\ndef minSideJumps(self, obstacles: List[int]) -> int:\n    n = len(obstacles)\n    dp = [[0x3f3f3f3f for _ in range(4)] for _ in range(n)]\n    dp[0][2] = 0\n    dp[0][1] = dp[0][3] = 1\n    for i in range(1, n):\n        if obstacles[i] != 1:\n            dp[i][1] = dp[i - 1][1]\n        if obstacles[i] != 2:\n            dp[i][2] = dp[i - 1][2]\n        if obstacles[i] != 3:\n            dp[i][3] = dp[i - 1][3]\n        if obstacles[i - 1] == 1:\n            dp[i][1] = min(dp[i][2], dp[i][3]) + 1\n        if obstacles[i - 1] == 2:\n            dp[i][2] = min(dp[i][1], dp[i][3]) + 1\n        if obstacles[i - 1] == 3:\n            dp[i][3] = min(dp[i][1], dp[i][2]) + 1\n    return min(dp[n - 1][1], dp[n - 1][2], dp[n - 1][3])","date":"2023-01-21"}],"tagList":["贪心","数组","动态规划"],"level":"Medium"}},{"problemName":"1825.求出MK平均值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1825.求出MK平均值.json","problemData":{"id":"1953","name":"1825.求出MK平均值","url":"https://leetcode.cn/problems/finding-mk-average","desc":"请你实现 MKAverage 类。","solutions":[{"script":"cpp","time":796,"memory":144.8,"desc":"有序集合，维护有序性,s1表示前k个，s3表示后k个，s2表示中间m-2k个。","code":"class MKAverage {\npublic:\n    multiset<int> s1, s2, s3;\n    queue<int> q;\n    long long sum = 0, m, k;\n    MKAverage(int m, int k) {\n        this->m = m;\n        this->k = k;\n    }\n \n    int calculateMKAverage() {\n        if (q.size() < m) return -1;\n        return sum / (m - 2 * k);\n    }\n \n    void addElement(int num) {\n        q.push(num);\n        if (q.size() <= m) {\n            s2.insert(num);\n            sum += num;\n            if (q.size() == m) {\n                while (s2.size() > m - 2 * k && s3.size() < k) {\n                    s3.insert(*s2.rbegin());\n                    sum -= *s2.rbegin();\n                    s2.erase(prev(s2.end()));\n                }\n                while (s2.size() > m - 2 * k && s1.size() < k) {\n                    s1.insert(*s2.begin());\n                    sum -= *s2.begin();\n                    s2.erase(s2.begin());\n                }\n            }\n        } else {\n            if (num < *s2.begin()) {\n                s2.insert(*s1.rbegin());\n                sum += *s1.rbegin();\n                s1.insert(num);\n                s1.erase(prev(s1.end()));\n            } else if (num >= *s3.begin()) {\n                s2.insert(*s3.begin());\n                sum += *s3.begin();\n                s3.insert(num);\n                s3.erase(s3.begin());\n            } else {\n                s2.insert(num);\n                sum += num;\n            }\n            int eraseVal = q.front();\n            q.pop();\n            if (s1.count(eraseVal)) {\n                s1.erase(s1.find(eraseVal));\n                s1.insert(*s2.begin());\n                sum -= *s2.begin();\n                s2.erase(s2.begin());\n            } else if (s3.count(eraseVal)) {\n                s3.erase(s3.find(eraseVal));\n                s3.insert(*s2.rbegin());\n                sum -= *s2.rbegin();\n                s2.erase(prev(s2.end()));\n            } else {\n                s2.erase(s2.find(eraseVal));\n                sum -= eraseVal;\n            }\n        }\n    }\n    void print(string title) {\n        cout << \"===\" << title << \"===\" << endl;\n        cout << \"sum = \" << sum << endl;\n        cout << \"s1 : \";\n        for (auto &num : s1) cout << num << \", \";\n        cout << endl;\n        cout << \"s2 : \";\n        for (auto &num : s2) cout << num << \", \";\n        cout << endl;\n        cout << \"s3 : \";\n        for (auto &num : s3) cout << num << \", \";\n        cout << endl;\n    }\n};","date":"2023-01-18"},{"script":"rust","time":64,"memory":35.1,"desc":"同上。","code":"use std::collections::BTreeMap;\nuse std::collections::VecDeque;\n\nstruct MulitSet<T: Ord + Copy + Clone> {\n    length: usize,\n    tree: BTreeMap<T, usize>,\n}\nimpl<T: Ord + Copy + Clone> MulitSet<T> {\n    fn new() -> Self {\n        MulitSet {\n            length: 0,\n            tree: BTreeMap::new(),\n        }\n    }\n    fn contains(&self, k: &T) -> bool {\n        self.tree.contains_key(k)\n    }\n    fn len(&self) -> usize {\n        self.length\n    }\n    fn insert(&mut self, key: T) {\n        *self.tree.entry(key).or_insert(0) += 1;\n        self.length += 1;\n    }\n    fn remove(&mut self, key: &T) {\n        let item = self.tree.get_mut(&key).unwrap();\n        if *item > 1 {\n            *item -= 1;\n        } else {\n            self.tree.remove(key);\n        }\n        self.length -= 1;\n    }\n    fn peek_first(&mut self) -> T {\n        *self.tree.iter().next().unwrap().0\n    }\n    fn peek_last(&mut self) -> T {\n        *self.tree.iter().rev().next().unwrap().0\n    }\n    fn pop_first(&mut self) -> T {\n        let key = self.peek_first();\n        self.remove(&key);\n        key\n    }\n    fn pop_last(&mut self) -> T {\n        let key = self.peek_last();\n        self.remove(&key);\n        key\n    }\n}\nstruct MKAverage {\n    m: i32,\n    k: i32,\n    sum: i64,\n    q: VecDeque<i32>,\n    s1: MulitSet<i32>,\n    s2: MulitSet<i32>,\n    s3: MulitSet<i32>,\n}\nimpl MKAverage {\n    fn new(m: i32, k: i32) -> Self {\n        Self {\n            m,\n            k,\n            sum: 0,\n            q: VecDeque::new(),\n            s1: MulitSet::<i32>::new(),\n            s2: MulitSet::<i32>::new(),\n            s3: MulitSet::<i32>::new(),\n        }\n    }\n\n    fn calculate_mk_average(&self) -> i32 {\n        if (self.q.len() as i32) < self.m {\n            -1\n        } else {\n            (self.sum / (self.m - 2 * self.k) as i64) as i32\n        }\n    }\n\n    fn add_element(&mut self, num: i32) {\n        let m = self.m as usize;\n        let k = self.k as usize;\n        self.q.push_back(num);\n        if self.q.len() <= m {\n            self.s2.insert(num);\n            self.sum += num as i64;\n            if self.q.len() == m {\n                for _ in 0..k {\n                    let num = self.s2.pop_last();\n                    self.sum -= num as i64;\n                    self.s3.insert(num);\n\n                    let num = self.s2.pop_first();\n                    self.sum -= num as i64;\n                    self.s1.insert(num);\n                }\n            }\n        } else {\n            if num < self.s2.peek_first() {\n                self.s1.insert(num);\n                self.sum += self.s1.peek_last() as i64;\n                self.s2.insert(self.s1.pop_last());\n            } else if num >= self.s3.peek_first() {\n                self.s3.insert(num);\n                self.sum += self.s3.peek_first() as i64;\n                self.s2.insert(self.s3.pop_first());\n            } else {\n                self.sum += num as i64;\n                self.s2.insert(num);\n            }\n            let pop_value = self.q.pop_front().unwrap();\n            if self.s1.contains(&pop_value) {\n                self.s1.remove(&pop_value);\n                self.sum -= self.s2.peek_first() as i64;\n                self.s1.insert(self.s2.pop_first());\n            } else if self.s3.contains(&pop_value) {\n                self.s3.remove(&pop_value);\n                self.sum -= self.s2.peek_last() as i64;\n                self.s3.insert(self.s2.pop_last());\n            } else {\n                self.sum -= pop_value as i64;\n                self.s2.remove(&pop_value);\n            }\n        }\n    }\n}","date":"2023-01-18"},{"script":"python","time":1748,"memory":45.4,"desc":"同上。","code":"from queue import Queue\nfrom sortedcontainers import SortedList\nclass MKAverage:\n    def __init__(self, m: int, k: int):\n        self.m = m\n        self.k = k\n        self.sum = 0\n        self.q = Queue()\n        self.s1 = SortedList()\n        self.s2 = SortedList()\n        self.s3 = SortedList()\n\n    def calculateMKAverage(self) -> int:\n        if self.q.qsize() < self.m:\n            return -1\n        else:\n            return self.sum // (self.m - self.k * 2)\n\n    def addElement(self, num: int) -> None:\n        self.q.put(num)\n        if self.q.qsize() <= self.m:\n            self.s2.add(num)\n            self.sum += num\n            if self.q.qsize() == self.m:\n                for _ in range(self.k):\n                    self.sum -= self.s2[-1]\n                    self.s3.add(self.s2.pop())\n\n                    self.sum -= self.s2[0]\n                    self.s1.add(self.s2.pop(0))\n        else:\n            if num < self.s2[0]:\n                self.s1.add(num)\n                self.sum += self.s1[-1]\n                self.s2.add(self.s1.pop())\n            elif num >= self.s3[0]:\n                self.s3.add(num)\n                self.sum += self.s3[0]\n                self.s2.add(self.s3.pop(0))\n            else:\n                self.sum += num\n                self.s2.add(num)\n            removeVal = self.q.get()\n            if self.s1.count(removeVal):\n                self.s1.discard(removeVal)\n                self.sum -= self.s2[0]\n                self.s1.add(self.s2.pop(0))\n            elif self.s3.count(removeVal):\n                self.s3.discard(removeVal)\n                self.sum -= self.s2[-1]\n                self.s3.add(self.s2.pop())\n            else:\n                self.sum -= removeVal\n                self.s2.discard(removeVal)","date":"2023-01-18"}],"tagList":["设计","队列","数据流","有序集合","堆（优先队列）"],"level":"Hard"}},{"problemName":"1827.最少操作使数组递增.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1827.最少操作使数组递增.json","problemData":{"id":"1938","name":"1827.最少操作使数组递增","url":"https://leetcode.cn/problems/minimum-operations-to-make-the-array-increasing","desc":"请你返回使 nums 严格递增 的 最少 操作次数。","solutions":[{"date":"2022-12-11","time":16,"memory":15.3,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    int minOperations(vector<int>& nums) {\n        int ans = 0;\n        for (int i = 1; i < nums.size(); i++) {\n            if (nums[i] <= nums[i - 1]) {\n                ans += nums[i - 1] - nums[i] + 1;\n                nums[i] = nums[i - 1] + 1;\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["贪心","数组"],"level":"Easy"}},{"problemName":"1828.统计一个圆中点的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1828.统计一个圆中点的数目.json","problemData":{"id":"1939","name":"1828.统计一个圆中点的数目","url":"https://leetcode.cn/problems/queries-on-number-of-points-inside-a-circle","desc":"请你返回一个数组 answer ，其中 answer[j]是第 j 个查询的答案。","solutions":[{"script":"cpp","time":92,"memory":15.8,"desc":"遍历。","code":"class Solution {\npublic:\n    vector<int> countPoints(vector<vector<int>>& points, vector<vector<int>>& queries) {\n        auto d = [&](vector<int> &a, vector<int> &b) {\n            return pow(abs(a[0] - b[0]), 2) + pow(abs(a[1] - b[1]), 2);\n        };\n        vector<int> ans(queries.size(), 0);\n        for (int i = 0; i < queries.size(); i++) {\n            for (auto &p : points) {\n                if (d(p, queries[i]) <= pow(queries[i][2], 2)) ans[i]++;\n            }\n        }\n        return ans;\n    }\n};","date":"2023-01-24"},{"script":"python","time":2832,"memory":15.2,"desc":"同上。","code":"class Solution:\n    def countPoints(self, points: List[List[int]], queries: List[List[int]]) -> List[int]:\n        ans = [0] * len(queries)\n        def d(a, b): return pow(abs(a[0] - b[0]), 2) + pow(abs(a[1] - b[1]), 2)\n        for i in range(0, len(queries)):\n            for p in points:\n                if d(p, queries[i]) <= pow(queries[i][2], 2):\n                    ans[i] += 1\n        return ans","date":"2023-01-24"},{"script":"rust","time":20,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn count_points(points: Vec<Vec<i32>>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        let d =\n            |a: &Vec<i32>, b: &Vec<i32>| (a[0] - b[0]).abs().pow(2) + (a[1] - b[1]).abs().pow(2);\n        let mut ans = vec![0; queries.len()];\n        for i in 0..queries.len() {\n            for p in points.iter() {\n                if d(&queries[i], p) <= queries[i][2].pow(2) {\n                    ans[i] += 1;\n                }\n            }\n        }\n        ans\n    }\n}","date":"2023-01-24"}],"tagList":["几何","数组","数学"],"level":"Medium"}},{"problemName":"1832.判断句子是否为全字母句.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1832.判断句子是否为全字母句.json","problemData":{"id":"1960","name":"1832.判断句子是否为全字母句","url":"https://leetcode.cn/problems/check-if-the-sentence-is-pangram","desc":"请你返回一个 布尔数组  answer ，其中  answer.length == queries.length ，当  queries[j]  的查询结果为  true  时， answer 第  j  个值为  true ，否则为  false 。","solutions":[{"date":"2022-12-14","time":480,"memory":108.3,"script":"cpp","desc":"先按照 limit 对 queries 排序，再进行离线查询，对于满足 limit 的边进行并查集联合，最后判断是否是同一个并查集中。","code":"#include <vector>\n// bestlyg\n#define X first\n#define Y second\n#define lb(x) ((x) & (-x))\n#define mem(a,b) memset(a,b,sizeof(a))\n#define debug freopen(\"input\",\"r\",stdin)\n#define PII pair<int,int>\n\n#ifdef DEBUG\n#define log(frm, args...) {    printf(frm, ##args);}\n#else\n#define log(frm, args...)\n#endif\n\ntypedef long long ll;\nusing namespace std;\n\nclass UnionFind {\npublic:\n    int n;\n    vector<int> data, cnt;\n    UnionFind(int n): n(n), data(vector<int>(n, 0)), cnt(vector<int>(n, 1)) {\n        iota(data.begin(), data.end(), 0);\n    }\n    int size(int v) { return cnt[find(v)]; }\n    int find(int v) {\n        if (data[v] == v) return v;\n        return data[v] = find(data[v]);\n    }\n    void uni(int v1, int v2) {\n        int p1 = find(v1), p2 = find(v2);\n        if (p1 != p2) {\n            cnt[p1] += cnt[p2];\n            data[p2] = p1;\n        }\n    }\n    bool same(int v1, int v2) { return find(v1) == find(v2); }\n};\nint pos2Idx(int x, int y, int size) { return x * size + y; }\nvoid idx2Pos(int idx, int size, int &x, int &y) { x = idx / size; y = idx % size; }\nvector<vector<int>> dirs = { {0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n// START\nclass Solution {\npublic:\n    vector<bool> distanceLimitedPathsExist(int n, vector<vector<int>>& edgeList, vector<vector<int>>& queries) {\n        vector<int> qlist(queries.size());\n        vector<bool> ans(queries.size(), false);\n        iota(qlist.begin(), qlist.end(), 0);\n        sort(qlist.begin(), qlist.end(), [&](auto &i1, auto &i2){ return queries[i1][2] < queries[i2][2]; });\n        sort(edgeList.begin(), edgeList.end(), [&](auto &a, auto &b){ return a[2] < b[2]; });\n        UnionFind uf(n);\n        int j = 0;\n        for (auto &i : qlist) {\n            auto &q = queries[i];\n            for (; j < edgeList.size() && edgeList[j][2] < q[2]; j++) uf.uni(edgeList[j][0], edgeList[j][1]);\n            ans[i] = uf.same(q[0], q[1]);\n        }\n        return ans;\n    }\n};\n// END\n#ifdef LOCAL\nint main() {\n    return 0;\n}\n#endif"}],"tagList":["哈希表","字符串"],"level":"Easy"}},{"problemName":"1833.雪糕的最大数量.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1833.雪糕的最大数量.json","problemData":{"id":"1961","name":"1833.雪糕的最大数量","url":"https://leetcode.cn/problems/maximum-ice-cream-bars","desc":"给你价格数组 costs 和现金量 coins ，请你计算并返回 Tony 用 coins 现金能够买到的雪糕的 最大数量 。","solutions":[{"date":"2021-07-02","time":280,"memory":52.6,"script":"typescript","desc":"每次取最小 cost。","code":"function maxIceCream(costs: number[], coins: number): number {\n  costs.sort((a, b) => a - b);\n  let ans = 0;\n  for (const cost of costs) {\n    if (coins >= cost) {\n      ans++;\n      coins -= cost;\n    } else break;\n  }\n  return ans;\n}"}],"tagList":["贪心","数组","排序"],"level":"Medium"}},{"problemName":"1838.最高频元素的频数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1838.最高频元素的频数.json","problemData":{"id":"1966","name":"1838.最高频元素的频数","url":"https://leetcode.cn/problems/frequency-of-the-most-frequent-element","desc":"排序后，从后往前逐个比较。","solutions":[{"date":"2021-07-19","time":232,"memory":54,"script":"typescript","desc":"前缀和。","code":"function maxFrequency(nums: number[], k: number): number {\n  nums.sort((a, b) => a - b);\n  const len = nums.length;\n  let ans = 1;\n  let right = len - 1;\n  let left = right - 1;\n  while (left >= 0) {\n    const num = nums[right];\n    while (left >= 0) {\n      const v = num - nums[left];\n      if (k < v) break;\n      k -= v;\n      left--;\n    }\n    ans = Math.max(ans, right-- - left);\n    k += (right - left) * (nums[right + 1] - nums[right]);\n  }\n  return ans;\n}"}],"tagList":["贪心","数组","二分查找","前缀和","排序","滑动窗口"],"level":"Medium"}},{"problemName":"1851.包含每个查询的最小区间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1851.包含每个查询的最小区间.json","problemData":{"id":"1977","name":"1851.包含每个查询的最小区间","url":"https://leetcode.cn/problems/minimum-interval-to-include-each-query","desc":"给你一个二维整数数组 intervals ，其中 intervals[i] = [lefti, righti] 表示第 i 个区间开始于 lefti 、结束于 righti（包含两侧取值，闭区间）。区间的 长度 定义为区间中包含的整数数目，更正式地表达是 righti - lefti + 1 。再给你一个整数数组 queries 。第 j 个查询的答案是满足 lefti <= queries[j] <= righti 的 长度最小区间 i 的长度 。如果不存在这样的区间，那么答案是 -1 。以数组形式返回对应查询的所有答案。","solutions":[{"script":"cpp","time":440,"memory":106.5,"desc":"排序后用堆记录区间最值。","code":"#define SORT(list, fn) sort(list.begin(), list.end(), [&](auto &v1, auto &v2){ fn });\nclass Solution {\npublic:\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\n        vector<int> res(queries.size(), -1);\n        SORT(intervals, {\n            return v1[0] != v2[0] ? v1[0] < v2[0] : v1[1] < v2[1];\n        });\n        vector<int> idxs;\n        for (int i = 0; i < queries.size(); i++) idxs.push_back(i);\n        SORT(idxs, {\n            return queries[v1] < queries[v2];\n        });\n        auto cmp = [&](int i1, int i2) {\n            int n1 = intervals[i1][1] - intervals[i1][0] + 1,\n                n2 = intervals[i2][1] - intervals[i2][0] + 1;\n            return n2 < n1;\n        };\n        priority_queue<int, vector<int>, decltype(cmp)> q(cmp);\n        int iidx = 0;\n        for (auto &idx : idxs) {\n            int cur = queries[idx];\n            while (iidx < intervals.size() && intervals[iidx][0] <= cur) {\n                q.push(iidx++);\n            }\n            while (q.size() && intervals[q.top()][1] < cur) {\n                q.pop();\n            }\n            if (q.size()) {\n                auto &interval = intervals[q.top()];\n                res[idx] = interval[1] - interval[0] + 1;\n            }\n        }\n        return res;\n    }\n};","date":"2023-07-18"},{"script":"python","time":944,"memory":64.9,"desc":"同上。","code":"class Solution:\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\n        class CmpNode:\n            def __init__(self, idx: int) -> None:\n                self.idx = idx\n\n            def __lt__(self, o: 'CmpNode') -> bool:\n                n1 = intervals[self.idx][1] - intervals[self.idx][0] + 1\n                n2 = intervals[o.idx][1] - intervals[o.idx][0] + 1\n                return n1 < n2\n        res = [-1 for _ in range(len(queries))]\n        intervals.sort(key=lambda v: v[0])\n        idxs = [i for i in range(len(queries))]\n        idxs.sort(key=lambda v: queries[v])\n        q: List[CmpNode] = []\n        iidx = 0\n        for idx in idxs:\n            cur = queries[idx]\n            while iidx < len(intervals) and intervals[iidx][0] <= cur:\n                heappush(q, CmpNode(iidx))\n                iidx += 1\n            while len(q) and intervals[q[0].idx][1] < cur:\n                heappop(q)\n            if len(q):\n                interval = intervals[q[0].idx]\n                res[idx] = interval[1] - interval[0] + 1\n        return res","date":"2023-07-18"},{"script":"rust","time":88,"memory":12.1,"desc":"同上。","code":"#[derive(Clone, PartialEq, Eq, Ord)]\nstruct Node<'a> {\n    idx: usize,\n    intervals: &'a Vec<Vec<i32>>,\n}\nimpl<'a> Node<'a> {\n    fn new(idx: usize, intervals: &'a Vec<Vec<i32>>) -> Self {\n        Node { idx, intervals }\n    }\n    fn len(&self) -> i32 {\n        self.intervals[self.idx][1] - self.intervals[self.idx][0] + 1\n    }\n}\nimpl PartialOrd for Node<'_> {\n    fn partial_cmp(&self, o: &Self) -> Option<std::cmp::Ordering> {\n        o.len().partial_cmp(&self.len())\n    }\n}\n\nimpl Solution {\n    pub fn min_interval(mut intervals: Vec<Vec<i32>>, queries: Vec<i32>) -> Vec<i32> {\n        let mut res = vec![-1; queries.len()];\n        intervals.sort_by_key(|v| v[0]);\n        let mut idxs = vec![0; queries.len()]\n            .into_iter()\n            .enumerate()\n            .map(|v| v.0)\n            .collect::<Vec<_>>();\n        idxs.sort_by_key(|i| queries[*i]);\n        let mut q = std::collections::BinaryHeap::<Node>::new();\n        let mut iidx = 0;\n        for idx in idxs {\n            let cur = queries[idx];\n            while iidx < intervals.len() && intervals[iidx][0] <= cur {\n                q.push(Node::new(iidx, &intervals));\n                iidx += 1;\n            }\n            while !q.is_empty() && intervals[q.peek().unwrap().idx][1] < cur {\n                q.pop();\n            }\n            if !q.is_empty() {\n                res[idx] = q.peek().unwrap().len();\n            }\n        }\n        res\n    }\n}","date":"2023-07-18"}],"tagList":["数组","二分查找","排序","扫描线","堆（优先队列）"],"level":"Hard"}},{"problemName":"1856.子数组最小乘积的最大值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1856.子数组最小乘积的最大值.json","problemData":{"id":"1985","name":"1856.子数组最小乘积的最大值","url":"https://leetcode.cn/problems/maximum-subarray-min-product","desc":"给你一个正整数数组  nums ，请你返回  nums  任意   非空子数组   的最小乘积   的   最大值  。","solutions":[{"date":"2021-07-19","time":352,"memory":67.2,"script":"typescript","desc":"单调栈，获取两边的最大值，由于 js 最多表示 53 位，需要用 bigint。","code":"function maxSumMinProduct(nums: number[]): number {\n  const n = nums.length;\n  const l = new Array(n).fill(-1);\n  const r = new Array(n).fill(n);\n  const stack: number[] = [];\n  const sums: number[] = [0];\n  let sum = 0;\n  for (let i = 0; i < n; i++) {\n    const num = nums[i];\n    sums.push((sum += num));\n    while (stack.length && nums[stack[stack.length - 1]] >= num) r[stack.pop()!] = i;\n    if (stack.length) l[i] = stack[stack.length - 1];\n    stack.push(i);\n  }\n  let ans = 0n;\n  for (let i = 0; i < n; i++) {\n    const num = (BigInt(sums[r[i]]) - BigInt(sums[l[i] + 1])) * BigInt(nums[i]);\n    ans = ans > num ? ans : num;\n  }\n  ans %= BigInt(10 ** 9 + 7);\n  return Number(ans);\n}"}],"tagList":["栈","数组","前缀和","单调栈"],"level":"Medium"}},{"problemName":"1877.数组中最大数对和的最小值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1877.数组中最大数对和的最小值.json","problemData":{"id":"1988","name":"1877.数组中最大数对和的最小值","url":"https://leetcode.cn/problems/minimize-maximum-pair-sum-in-array","desc":"请你在最优数对划分的方案下，返回最小的 最大数对和 。","solutions":[{"date":"2021-07-20","time":332,"memory":53.2,"script":"typescript","desc":"贪心，排序后收尾相加。","code":"function minPairSum(nums: number[]): number {\n  const n = nums.length;\n  const arr = new Array(n / 2).fill(0);\n  nums.sort((a, b) => a - b);\n  for (let i = 0; i < n / 2; i++) arr[i] = nums[i] + nums[n - 1 - i];\n  return Math.max(...arr);\n}"}],"tagList":["贪心","数组","双指针","排序"],"level":"Medium"}},{"problemName":"1893.检查是否区域内所有整数都被覆盖.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1893.检查是否区域内所有整数都被覆盖.json","problemData":{"id":"2005","name":"1893.检查是否区域内所有整数都被覆盖","url":"https://leetcode.cn/problems/check-if-all-the-integers-in-a-range-are-covered","desc":"给你一个二维整数数组  ranges  和两个整数  left  和  right 。每个  ranges[i] = [starti, endi]  表示一个从  starti  到  endi  的   闭区间  。如果闭区间  [left, right]  内每个整数都被  ranges  中   至少一个   区间覆盖，那么请你返回  true ，否则返回  false 。","solutions":[{"date":"2021-07-23","time":100,"memory":40.8,"script":"typescript","desc":"合并相近区间。","code":"function isCovered(ranges: number[][], left: number, right: number): boolean {\n  ranges.sort(([l1, r1], [l2, r2]) => (l1 === l2 ? r1 - r2 : l1 - l2));\n  const rangeList: number[][] = [];\n  for (const range of ranges) {\n    if (rangeList.length === 0) {\n      rangeList.push(range);\n      continue;\n    }\n    const [l1, r1] = rangeList.pop()!;\n    const [l2, r2] = range;\n    if (l2 >= l1 && r2 <= r1) rangeList.push([l1, r1]);\n    else if (r1 < l2 - 1) rangeList.push([l1, r1], [l2, r2]);\n    else rangeList.push([l1, r2]);\n  }\n  for (const [l, r] of rangeList) {\n    if (left >= l && right <= r) return true;\n  }\n  return false;\n}"}],"tagList":["数组","哈希表","前缀和"],"level":"Easy"}},{"problemName":"1894.找到需要补充粉笔的学生编号.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1801-1900/1894.找到需要补充粉笔的学生编号.json","problemData":{"id":"2006","name":"1894.找到需要补充粉笔的学生编号","url":"https://leetcode.cn/problems/find-the-student-that-will-replace-the-chalk","desc":"请你返回需要 补充 粉笔的学生 编号 。","solutions":[{"date":"2021-09-10","time":1052,"memory":49.6,"script":"typescript","desc":"循环相减。","code":"function chalkReplacer(chalk: number[], k: number): number {\n  const sum = chalk.reduce((total, cur) => total + cur, 0);\n  while (k >= sum) k -= sum;\n  let idx = 0;\n  while (k >= chalk[idx]) k -= chalk[idx++];\n  return idx;\n}"},{"date":"2021-09-10","time":796,"memory":54.2,"script":"typescript","desc":"二分+前缀和。","code":"function chalkReplacer(chalk: number[], k: number): number {\n  let sum = 0;\n  const sums: number[] = [0];\n  const n = chalk.length;\n  for (let i = 0; i < n; i++) sums.push((sum += chalk[i]));\n  while (k >= sum) k -= sum;\n  return find(k) - 1;\n  function find(num: number) {\n    let l = 0;\n    let r = n;\n    while (l < r) {\n      const mid = (l + r) >> 1;\n      if (sums[mid] > num) r = mid;\n      else l = mid + 1;\n    }\n    return l;\n  }\n}"}],"tagList":["数组","二分查找","前缀和","模拟"],"level":"Medium"}}]},{"dirName":"1901-2000","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\1901-2000","problems":[{"problemName":"1901.寻找峰值II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1901-2000/1901.寻找峰值II.json","problemData":{"id":"2047","name":"1901.寻找峰值II","url":"https://leetcode.cn/problems/find-a-peak-element-ii","desc":"给你一个 从 0 开始编号 的 m x n 矩阵 mat ，其中任意两个相邻格子的值都 不相同 。找出 任意一个 峰值 mat[i][j] 并 返回其位置 [i,j] 。","solutions":[{"script":"python","time":48,"memory":43.8,"desc":"二分row，对每层进行找最大值。","code":"class Solution:\n    def findPeakGrid(self, mat: List[List[int]]) -> List[int]:\n        n = len(mat)\n        l, r = 0, n - 1\n        while l <= r:\n            i = (l + r) // 2\n            j = mat[i].index(max(mat[i]))\n            if i - 1 >= 0 and mat[i][j] < mat[i - 1][j]: r = i - 1\n            elif i + 1 < n and mat[i][j] < mat[i + 1][j]: l = i + 1\n            else: return [i, j]","date":"2023-12-19"}],"tagList":["数组","二分查找","矩阵"],"level":"Medium"}},{"problemName":"1911.最大子序列交替和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1901-2000/1911.最大子序列交替和.json","problemData":{"id":"2022","name":"1911.最大子序列交替和","url":"https://leetcode.cn/problems/maximum-alternating-subsequence-sum","desc":"一个下标从 0 开始的数组的 交替和 定义为 偶数 下标处元素之 和 减去 奇数 下标处元素之 和 。给你一个数组 nums ，请你返回 nums 中任意子序列的 最大交替和 。","solutions":[{"script":"cpp","time":328,"memory":149.5,"desc":"dp[i][j]表示以nums[i]结尾的时候，奇数和偶数时的最大结果。","code":"class Solution {\npublic:\n    typedef long long ll;\n    ll maxAlternatingSum(vector<int>& nums) {\n        int n = nums.size();\n        vector<vector<ll>> dp(n, vector<ll>(2, 0));\n        dp[0][0] = nums[0];\n        for (int i = 1; i < n; i++) {\n            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + nums[i]);\n            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - nums[i]);\n        }\n        return dp[n - 1][0];\n    }\n};","date":"2023-07-11"},{"script":"python","time":1092,"memory":30.2,"desc":"同上。","code":"class Solution:\n    def maxAlternatingSum(self, nums: List[int]) -> int:\n        even = nums[0]\n        odd = 0\n        for i in range(1, len(nums)):\n            even, odd = max(even, odd + nums[i]), max(odd, even - nums[i])\n        return even","date":"2023-07-11"},{"script":"rust","time":12,"memory":2.8,"desc":"同上。","code":"impl Solution {\n    pub fn max_alternating_sum(nums: Vec<i32>) -> i64 {\n        let mut odd = 0;\n        let mut even = nums[0] as i64;\n        for i in 1..nums.len() {\n            even = even.max(odd + nums[i] as i64);\n            odd = odd.max(even - nums[i] as i64);\n        }\n        even\n    }\n}","date":"2023-07-11"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"1921.消灭怪物的最大数量.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1901-2000/1921.消灭怪物的最大数量.json","problemData":{"id":"2049","name":"1921.消灭怪物的最大数量","url":"https://leetcode.cn/problems/eliminate-maximum-number-of-monsters","desc":"返回在你输掉游戏前可以消灭的怪物的 最大 数量。","solutions":[{"script":"cpp","time":104,"memory":86.8,"desc":"排序。","code":"class Solution {\npublic:\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\n        vector<double> arr;\n        for (int i = 0; i < dist.size(); i++) arr.push_back(1.0 * dist[i] / speed[i]);\n        sort(arr.begin(), arr.end());\n        for (int i = 0; i < dist.size(); i++) {\n            if (i >= arr[i]) return i;\n        }\n        return dist.size();\n    }\n};","date":"2023-09-03"},{"script":"python","time":168,"memory":30.3,"desc":"同上。","code":"class Solution:\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\n        arr = [dist[i] / speed[i] for i in range(len(dist))]\n        arr.sort()\n        for i in range(len(dist)):\n            if i >= arr[i]: return i\n        return len(dist)","date":"2023-09-03"},{"script":"rust","time":32,"memory":4.1,"desc":"同上。","code":"impl Solution {\n    pub fn eliminate_maximum(dist: Vec<i32>, speed: Vec<i32>) -> i32 {\n        let mut arr = vec![];\n        for i in 0..dist.len() {\n            arr.push(dist[i] as f64 / speed[i] as f64);\n        }\n        arr.sort_by(|a, b| a.partial_cmp(b).unwrap());\n        for i in 0..dist.len() {\n            if i as f64 >= arr[i] {\n                return i as i32;\n            }\n        }\n        dist.len() as i32\n    }\n}","date":"2023-09-03"}],"tagList":["贪心","数组","排序"],"level":"Medium"}},{"problemName":"1944.队列中可以看到的人数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1901-2000/1944.队列中可以看到的人数.json","problemData":{"id":"1305","name":"1944.队列中可以看到的人数","url":"https://leetcode.cn/problems/number-of-visible-people-in-a-queue","desc":"请你返回一个长度为 n 的数组 answer ，其中 answer[i] 是第 i 个人在他右侧队列中能 看到 的 人数 。","solutions":[{"script":"python","time":140,"memory":30.22,"desc":"单调栈。","code":"class Solution:\n    def canSeePersonsCount(self, heights: List[int]) -> List[int]:\n        n = len(heights)\n        ans = [0] * n\n        s = []\n        for i in range(n):\n            while s and heights[s[-1]] < heights[i]: ans[s.pop()] += 1\n            if s: ans[s[-1]] += 1\n            s.append(i)\n        return ans","date":"2024-01-05"}],"tagList":["栈","数组","单调栈"],"level":"Hard"}},{"problemName":"1945.字符串转化后的各位数字之和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1901-2000/1945.字符串转化后的各位数字之和.json","problemData":{"id":"2076","name":"1945.字符串转化后的各位数字之和","url":"https://leetcode.cn/problems/sum-of-digits-of-string-after-convert","desc":"给你一个由小写字母组成的字符串 s ，以及一个整数 k 。返回执行上述操作后得到的结果整数。","solutions":[{"date":"2022-12-15","time":0,"memory":5.9,"script":"cpp","desc":"模拟。","code":"class Solution {\npublic:\n    int getLucky(string s, int k) {\n        int num = format(s);\n        for (int i = 1; i < k; i++) num = toNum(num);\n        return num;\n    }\n    int format(string &s) {\n        int ans = 0;\n        for (auto &c : s) ans = ans + toNum(c - 'a' + 1);\n        return ans;\n    }\n    int toNum(int num) {\n        int ans = 0;\n        for (; num; num /= 10) ans = ans + num % 10;\n        return ans;\n    }\n};"},{"date":"2022-12-15","time":64,"memory":44.3,"script":"typescript","desc":"模拟。","code":"function getLucky(s: string, k: number): number {\n  return new Array(k).fill(0).reduce(\n    cur =>\n      cur\n        .split('')\n        .map(v => Number(v))\n        .reduce((sum, cur) => sum + cur, 0)\n        .toString(),\n    s\n      .split('')\n      .map(c => c.codePointAt(0)! - 'a'.codePointAt(0)! + 1)\n      .join('')\n  );\n}"}],"tagList":["字符串","模拟"],"level":"Easy"}},{"problemName":"1953.你可以工作的最大周数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1901-2000/1953.你可以工作的最大周数.json","problemData":{"id":"2084","name":"1953.你可以工作的最大周数","url":"https://leetcode.cn/problems/maximum-number-of-weeks-for-which-you-can-work","desc":"返回在不违反上面规则的情况下你 最多 能工作多少周。","solutions":[{"script":"python","time":529,"memory":17.4,"desc":"贪心，如果最大任务可以完成，那么所有任务都可以完成，否则只能完成剩下任务和部分最大任务。","code":"class Solution:\n    def numberOfWeeks(self, milestones: List[int]) -> int:\n        nmax = max(milestones)\n        nsum = sum(milestones) - nmax\n        return nmax + nsum if nmax <= nsum + 1 else nsum * 2 + 1","date":"2024-05-16"}],"tagList":["贪心","数组"],"level":"Medium"}},{"problemName":"1954.收集足够苹果的最小花园周长.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1901-2000/1954.收集足够苹果的最小花园周长.json","problemData":{"id":"1295","name":"1954.收集足够苹果的最小花园周长","url":"https://leetcode.cn/problems/minimum-garden-perimeter-to-collect-enough-apples","desc":"给你一个整数 neededApples ，请你返回土地的 最小周长 ，使得 至少 有 neededApples 个苹果在土地 里面或者边缘上。","solutions":[{"script":"python","time":740,"memory":16.88,"desc":"枚举每条边。","code":"class Solution:\n    def minimumPerimeter(self, neededApples: int) -> int:\n        cur = sum = 0\n        while sum < neededApples:\n            cur += 1\n            sum += 4 * (cur + 2 * cur) * cur\n        return 8 * cur","date":"2023-12-24"}],"tagList":["数学","二分查找"],"level":"Medium"}},{"problemName":"1958.检查操作是否合法.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1901-2000/1958.检查操作是否合法.json","problemData":{"id":"2080","name":"1958.检查操作是否合法","url":"https://leetcode.cn/problems/check-if-move-is-legal","desc":"给你两个整数 rMove 和 cMove 以及一个字符 color ，表示你正在执行操作的颜色（白或者黑），如果将格子 (rMove, cMove) 变成颜色 color 后，是一个 合法 操作，那么返回 true ，如果不是合法操作返回 false 。","solutions":[{"script":"python","time":45,"memory":16.27,"desc":"遍历所有方向。","code":"n = 8\ndirs2 = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n\nclass Solution:\n    def checkMove(self, board: List[List[str]], rMove: int, cMove: int, color: str) -> bool:\n        recolor = 'W' if color == 'B' else 'B'\n        for dir in dirs2:\n            nx, ny = rMove + dir[0], cMove + dir[1]\n            cnt = 0\n            while 0 <= nx < n and 0 <= ny < n:\n                if board[nx][ny] == recolor:\n                    cnt += 1\n                elif board[nx][ny] == color:\n                    if cnt >= 1: return True\n                    break\n                elif board[nx][ny] == '.':\n                    break\n                nx += dir[0]\n                ny += dir[1]\n        return False","date":"2024-07-07"}],"tagList":["数组","枚举","矩阵"],"level":"Medium"}},{"problemName":"1962.移除石子使总数最小.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1901-2000/1962.移除石子使总数最小.json","problemData":{"id":"2094","name":"1962.移除石子使总数最小","url":"https://leetcode.cn/problems/remove-stones-to-minimize-the-total","desc":"返回执行 k 次操作后，剩下石子的 最小 总数。","solutions":[{"script":"python","time":708,"memory":28.59,"desc":"heap。","code":"class Solution:\n    def minStoneSum(self, piles: List[int], k: int) -> int:\n        q = list(-v for v in piles)\n        heapify(q)\n        res = sum(piles)\n        for _ in range(k):\n            v = -heappop(q)\n            res -= floor(v / 2)\n            heappush(q, -(v - floor(v / 2)))\n        return res","date":"2023-12-23"}],"tagList":["贪心","数组","堆（优先队列）"],"level":"Medium"}},{"problemName":"1969.数组元素的最小非零乘积.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1901-2000/1969.数组元素的最小非零乘积.json","problemData":{"id":"2100","name":"1969.数组元素的最小非零乘积","url":"https://leetcode.cn/problems/minimum-non-zero-product-of-the-array-elements","desc":"请你算出进行以上操作 任意次 以后，nums 能得到的 最小非零 乘积。","solutions":[{"script":"python","time":51,"memory":16.3,"desc":"除去最大值，其他值都能两两匹配成最大值减1和1，快速计算。","code":"def quick_mul(a: int, b: int, mod: int) -> int:\n        ans = 0\n        temp = a\n        while b:\n            if b & 1: ans = (ans + temp) % mod\n            temp = (temp + temp) % mod\n            b >>= 1\n        return ans\n    \n    def quick_pow(a: int, b: int, mod: int) -> int:\n        ans = 1\n        temp = a\n        while b:\n            if b & 1: ans = quick_mul(ans, temp, mod)\n            temp = quick_mul(temp, temp, mod)\n            b >>= 1\n        return ans\n    \n    class Solution:\n        def minNonZeroProduct(self, p: int) -> int:\n            num = 2 ** p - 1\n            mod = 10 ** 9 + 7\n            return quick_pow(num - 1, num // 2, mod) * num % mod","date":"2024-03-20"}],"tagList":["贪心","递归","数学"],"level":"Medium"}},{"problemName":"1971.寻找图中是否存在路径.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1901-2000/1971.寻找图中是否存在路径.json","problemData":{"id":"2121","name":"1971.寻找图中是否存在路径","url":"https://leetcode.cn/problems/find-if-path-exists-in-graph","desc":"请你确定是否存在从顶点 source 开始，到顶点 destination 结束的 有效路径 。","solutions":[{"date":"2022-12-19","time":304,"memory":109.9,"script":"cpp","desc":"并查集。","code":"class UnionFind {\npublic:\n    int n;\n    vector<int> data, cnt;\n    UnionFind(int n): n(n), data(vector<int>(n, 0)), cnt(vector<int>(n, 1)) {\n        iota(data.begin(), data.end(), 0);\n    }\n    int size(int v) { return cnt[find(v)]; }\n    int find(int v) {\n        if (data[v] == v) return v;\n        return data[v] = find(data[v]);\n    }\n    void uni(int v1, int v2) {\n        int p1 = find(v1), p2 = find(v2);\n        if (p1 != p2) cnt[p1] += cnt[p2], data[p2] = p1;\n    }\n    bool same(int v1, int v2) { return find(v1) == find(v2); }\n};\nclass Solution {\npublic:\n    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {\n        UnionFind uf(n);\n        for (auto &edge : edges) uf.uni(edge[0], edge[1]);\n        return uf.same(source, destination);\n    }\n};"}],"tagList":["深度优先搜索","广度优先搜索","并查集","图"],"level":"Easy"}},{"problemName":"1976.到达目的地的方案数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1901-2000/1976.到达目的地的方案数.json","problemData":{"id":"2090","name":"1976.到达目的地的方案数","url":"https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination","desc":"请返回花费 最少时间 到达目的地的 路径数目 。","solutions":[{"script":"python","time":59,"memory":23.55,"desc":"最短路遍历时同时记录当前的最大cnt。","code":"class Solution:\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\n        nodes = [[] for _ in range(n)]\n        for n1, n2, time in roads:\n            nodes[n1].append((n2, time))\n            nodes[n2].append((n1, time))\n        time_map = [inf] * n\n        time_map[0] = 0\n        cnt_map = [0] * n\n        cnt_map[0] = 1\n        heap = [(0, 0)]\n        while heap:\n            time, node = heappop(heap)\n            if time > time_map[node]: continue\n            for child, time2 in nodes[node]:\n                next_time = time + time2\n                if next_time == time_map[child]:\n                    cnt_map[child] = (cnt_map[node] + cnt_map[child]) % (10 ** 9 + 7)\n                elif next_time < time_map[child]:\n                    time_map[child] = next_time\n                    cnt_map[child] = cnt_map[node]\n                    heappush(heap, (next_time, child))\n        return cnt_map[n - 1]","date":"2024-03-05"}],"tagList":["图","拓扑排序","动态规划","最短路"],"level":"Medium"}},{"problemName":"1984.学生分数的最小差值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1901-2000/1984.学生分数的最小差值.json","problemData":{"id":"2112","name":"1984.学生分数的最小差值","url":"https://leetcode.cn/problems/minimum-difference-between-highest-and-lowest-of-k-scores","desc":"给你一个 下标从 0 开始 的整数数组 nums ，其中 nums[i] 表示第 i 名学生的分数。另给你一个整数 k 。从数组中选出任意 k 名学生的分数，使这 k 个分数间 最高分 和 最低分 的 差值 达到 最小化 。 返回可能的 最小差值 。","solutions":[{"date":"2022-02-11","time":12,"memory":13.2,"script":"cpp","desc":"排序后遍历。","code":"class Solution {\n   public:\n    int minimumDifference(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        int ans = INT_MAX;\n        for (int l = 0, r = k - 1; r < nums.size(); l++, r++)\n            ans = min(ans, nums[r] - nums[l]);\n        return ans;\n    }\n};"}],"tagList":["数组","排序","滑动窗口"],"level":"Easy"}},{"problemName":"1991.找到数组的中间位置.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1901-2000/1991.找到数组的中间位置.json","problemData":{"id":"2102","name":"1991.找到数组的中间位置","url":"https://leetcode.cn/problems/find-the-middle-index-in-array","desc":"请你返回满足上述条件 最左边 的 middleIndex ，如果不存在这样的中间位置，请你返回 -1 。","solutions":[{"date":"2021-12-23","time":0,"memory":12.1,"script":"cpp","desc":"前缀和。","code":"class Solution {\n   public:\n    int findMiddleIndex(vector<int>& nums) {\n        int sum = 0;\n        for (auto& num : nums) sum += num;\n        int pre = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (sum - nums[i] == pre) return i;\n            pre += nums[i];\n            sum -= nums[i];\n        }\n        return -1;\n    }\n};"}],"tagList":["数组","前缀和"],"level":"Easy"}},{"problemName":"1993.树上的操作.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1901-2000/1993.树上的操作.json","problemData":{"id":"2104","name":"1993.树上的操作","url":"https://leetcode.cn/problems/operations-on-tree","desc":"给你一棵 n 个节点的树，编号从 0 到 n - 1 ，以父节点数组 parent 的形式给出，其中 parent[i] 是第 i 个节点的父节点。树的根节点为 0 号节点，所以 parent[0] = -1 ，因为它没有父节点。你想要设计一个数据结构实现树里面对节点的加锁，解锁和升级操作。","solutions":[{"script":"python","time":52,"memory":15.61,"desc":"模拟。","code":"class Node:\n    def __init__(self, val: int):\n        self.val = val\n        self.parent = None\n        self.children = []\n        self.lock_state = 0\n\n    def lock(self, user: int) -> bool:\n        if self.lock_state:\n            return False\n        self.lock_state = user\n        return True\n\n    def unlock(self, user: int) -> bool:\n        if self.lock_state != user:\n            return False\n        self.lock_state = 0\n        return True\n\n    def unlock_children(self) -> bool:\n        for node in self.children:\n            node.lock_state = 0\n            node.unlock_children()\n\n    def is_lock(self) -> bool:\n        return self.lock_state != 0\n\n    def is_parent_unlock(self) -> bool:\n        return not self.parent or not self.parent.is_lock() and self.parent.is_parent_unlock()\n\n    def exist_children_lock(self) -> bool:\n        return any(child.is_lock() or child.exist_children_lock() for child in self.children)\n\n\nclass LockingTree:\n    def __init__(self, parent: List[int]):\n        self.nodes = [Node(i) for i in range(len(parent))]\n        self.root = self.nodes[0]\n        for i in range(1, len(parent)):\n            self.nodes[i].parent = self.nodes[parent[i]]\n            self.nodes[parent[i]].children.append(self.nodes[i])\n\n    def lock(self, num: int, user: int) -> bool:\n        return self.nodes[num].lock(user)\n\n    def unlock(self, num: int, user: int) -> bool:\n        return self.nodes[num].unlock(user)\n\n    def upgrade(self, num: int, user: int) -> bool:\n        node = self.nodes[num]\n        if not node.is_lock() and node.is_parent_unlock() and node.exist_children_lock():\n            node.lock(user)\n            node.unlock_children()\n            return True\n        return False","date":"2023-09-23"}],"tagList":["树","深度优先搜索","广度优先搜索","设计","数组","哈希表"],"level":"Medium"}},{"problemName":"1994.好子集的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1901-2000/1994.好子集的数目.json","problemData":{"id":"2105","name":"1994.好子集的数目","url":"https://leetcode.cn/problems/the-number-of-good-subsets","desc":"请你返回 nums 中不同的 好 子集的数目对 109 + 7 取余 的结果。","solutions":[{"date":"2022-02-22","time":220,"memory":179.2,"script":"cpp","desc":"dfs 遍历，对于所有可重合因子进行遍历，可在每个方案中增加 1 的可能性，每个方案都可以选择任意一个 1 或者不选择，总可能性为 pow(2, cnt1)。","code":"int mod = 1e9 + 7;\n#define MAX 40\n\nunordered_map<int, int> m = {\n    {23, 0b00000000010000000000000000000000},\n    {19, 0b00000000000001000000000000000000},\n    {17, 0b00000000000000010000000000000000},\n    {15, 0b00000000000000000000000000010100},\n    {14, 0b00000000000000000000000001000010},\n    {13, 0b00000000000000000001000000000000},\n    {30, 0b00000000000000000000000000010110},\n    {11, 0b00000000000000000000010000000000},\n    {29, 0b00010000000000000000000000000000},\n    {10, 0b00000000000000000000000000010010},\n    {26, 0b00000000000000000001000000000010},\n    {7, 0b00000000000000000000000001000000},\n    {6, 0b00000000000000000000000000000110},\n    {5, 0b00000000000000000000000000010000},\n    {22, 0b00000000000000000000010000000010},\n    {3, 0b00000000000000000000000000000100},\n    {21, 0b00000000000000000000000001000100},\n    {2, 0b00000000000000000000000000000010},\n    {1, 0b00000000000000000000000000000001},\n};\nint mod = 1e9 + 7;\n\n#define MAX 40\n\nclass Solution {\n   public:\n    int arr[MAX] = {0}, num1;\n    int numberOfGoodSubsets(vector<int> &nums) {\n        for (auto &num : nums) {\n            if (m.count(num)) arr[num]++;\n        }\n        num1 = qpow(2, arr[1]);\n        long long ans = 0;\n        for (int num = 2; num < MAX; num++) {\n            if (arr[num]) dfs(ans, num, m[num], arr[num]);\n        }\n        return ans % mod;\n    }\n    void dfs(long long &ans, int num, int bits, long long sum) {\n        ans = (ans + sum * num1) % mod;\n        for (int nnum = num + 1; nnum < MAX; nnum++) {\n            if (arr[nnum] == 0 || m[nnum] & bits) continue;\n            dfs(ans, nnum, bits | m[nnum], sum * arr[nnum] % mod);\n        }\n    }\n    int qpow(int a, int b) {\n        long long ans = 1, tmp = a;\n        while (b) {\n            if (b & 1) ans = (ans * tmp) % mod;\n            tmp = (tmp * tmp) % mod;\n            b >>= 1;\n        }\n        return ans;\n    }\n};"}],"tagList":["位运算","数组","数学","动态规划","状态压缩"],"level":"Hard"}},{"problemName":"1995.统计特殊四元组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1901-2000/1995.统计特殊四元组.json","problemData":{"id":"2122","name":"1995.统计特殊四元组","url":"https://leetcode.cn/problems/count-special-quadruplets","desc":"给你一个 下标从 0 开始 的整数数组 nums ，返回满足下述条件的 不同 四元组 (a, b, c, d) 的 数目。","solutions":[{"date":"2021-12-29","time":136,"memory":10.2,"script":"cpp","desc":"内嵌四循环。","code":"class Solution {\n   public:\n    int countQuadruplets(vector<int>& nums) {\n        int n = nums.size(), ans = 0;\n        for (int i1 = 0; i1 < n; i1++) {\n            for (int i2 = i1 + 1; i2 < n; i2++) {\n                for (int i3 = i2 + 1; i3 < n; i3++) {\n                    for (int i4 = i3 + 1; i4 < n; i4++) {\n                        if (nums[i1] + nums[i2] + nums[i3] == nums[i4]) ans++;\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};"},{"date":"2021-12-29","time":56,"memory":13.9,"script":"cpp","desc":"内嵌三循环。","code":"class Solution {\n   public:\n    int countQuadruplets(vector<int>& nums) {\n        unordered_map<int, int> m;\n        int n = nums.size(), ans = 0;\n        for (int i3 = n - 1; i3 >= 0; i3--) {\n            m.clear();\n            for (int i4 = i3 + 1; i4 < n; i4++) {\n                int key = nums[i4] - nums[i3];\n                if (m.count(key))\n                    m[key]++;\n                else\n                    m[key] = 1;\n            }\n            for (int i1 = 0; i1 < i3; i1++) {\n                for (int i2 = i1 + 1; i2 < i3; i2++) {\n                    int key = nums[i1] + nums[i2];\n                    if (m.count(key)) {\n                        ans += m[key];\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};"},{"date":"2021-12-29","time":60,"memory":10.6,"script":"cpp","desc":"背包问题，前 i 个数能和为 j 的所使用的个数为 k。","code":"class Solution {\n   public:\n    int countQuadruplets(vector<int>& nums) {\n        int n = nums.size(), dp[n + 1][310][4], ans = 0;\n        memset(dp, 0, sizeof(int) * (n + 1) * 310 * 4);\n        dp[0][0][0] = 1;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < 310; j++) {\n                for (int k = 0; k < 4; k++) {\n                    dp[i][j][k] += dp[i - 1][j][k];\n                    if (j >= nums[i - 1] && k >= 1)\n                        dp[i][j][k] += dp[i - 1][j - nums[i - 1]][k - 1];\n                }\n            }\n        }\n        for (int i = 3; i < n; i++) ans += dp[i][nums[i]][3];\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","枚举"],"level":"Easy"}},{"problemName":"1996.游戏中弱角色的数量.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1901-2000/1996.游戏中弱角色的数量.json","problemData":{"id":"2123","name":"1996.游戏中弱角色的数量","url":"https://leetcode.cn/problems/the-number-of-weak-characters-in-the-game","desc":"返回 弱角色 的数量。","solutions":[{"date":"2022-01-28","time":696,"memory":169.1,"script":"cpp","desc":"排序后用堆比较。","code":"class Solution {\n   public:\n    int numberOfWeakCharacters(vector<vector<int>> &properties) {\n        int ans = 0;\n        map<int, vector<int>> m;\n        priority_queue<int, vector<int>, greater<int>> q;\n        for (auto &data : properties) m[data[0]].push_back(data[1]);\n        for (auto &data : m) {\n            sort(data.second.begin(), data.second.end(), greater<int>());\n            while (q.size() && q.top() < data.second[0]) q.pop(), ans++;\n            for (auto &num : data.second) q.push(num);\n        }\n        return ans;\n    }\n};"}],"tagList":["栈","贪心","数组","排序","单调栈"],"level":"Medium"}},{"problemName":"1997.访问完所有房间的第一天.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1901-2000/1997.访问完所有房间的第一天.json","problemData":{"id":"2124","name":"1997.访问完所有房间的第一天","url":"https://leetcode.cn/problems/first-day-where-you-have-been-in-all-the-rooms","desc":"请返回你访问完所有房间的第一天的日期编号。题目数据保证总是存在这样的一天。","solutions":[{"script":"python","time":289,"memory":39.05,"desc":"dp[i][0]表示第i个数,第一次奇数访问的天数，dp[i][1]表示第i个数,第一次偶数访问的天数。","code":"class Solution:\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\n        n = len(nextVisit)\n        dp = [[0, 1] for _ in range(n)]\n        mod = 10 ** 9 + 7\n        for i in range(1, n):\n            dp[i][0] = (dp[i - 1][1] + 1) % mod\n            dp[i][1] = (dp[i][0] * 2 + 1 - dp[nextVisit[i]][0]) % mod\n        return dp[n - 1][0]","date":"2024-03-28"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"2000.反转单词前缀.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/1901-2000/2000.反转单词前缀.json","problemData":{"id":"2128","name":"2000.反转单词前缀","url":"https://leetcode.cn/problems/reverse-prefix-of-word","desc":"给你一个下标从 0 开始的字符串 word 和一个字符 ch 。找出 ch 第一次出现的下标 i ，反转 word 中从下标 0 开始、直到下标 i 结束（含下标 i ）的那段字符。如果 word 中不存在字符 ch ，则无需进行任何操作。","solutions":[{"date":"2022-02-03","time":0,"memory":6.1,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    string reversePrefix(string word, char ch) {\n        int idx = 0;\n        while (idx < word.size() && word[idx] != ch) idx++;\n        if (idx == word.size()) return word;\n        string ans = word.substr(0, idx + 1);\n        reverse(ans.begin(), ans.end());\n        ans += word.substr(idx + 1, word.size() - idx - 1);\n        return ans;\n    }\n};"},{"date":"2022-02-03","time":0,"memory":6.2,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    string reversePrefix(string word, char ch) {\n        int idx = 0;\n        while (idx < word.size() && word[idx] != ch) idx++;\n        if (idx == word.size()) return word;\n        string ans = \"\";\n        for (int i = idx; i >= 0; i--) ans += word[i];\n        for (int i = idx + 1; i < word.size(); i++) ans += word[i];\n        return ans;\n    }\n};"}],"tagList":["双指针","字符串"],"level":"Easy"}}]},{"dirName":"2001-2100","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\2001-2100","problems":[{"problemName":"2001.可互换矩形的组数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2001.可互换矩形的组数.json","problemData":{"id":"2129","name":"2001.可互换矩形的组数","url":"https://leetcode.cn/problems/number-of-pairs-of-interchangeable-rectangles","desc":"计算并返回 rectangles 中有多少对 可互换 矩形。","solutions":[{"date":"2022-01-07","time":500,"memory":134.5,"script":"cpp","desc":"统计最简比例的个数。","code":"int gcd(int a, int b) {\n    if (b) return gcd(b, a % b);\n    return a;\n}\nclass Solution {\n   public:\n    struct Data {\n        int a, b;\n        Data(int a, int b) : a(a), b(b) {\n            int c = gcd(a, b);\n            this->a /= c;\n            this->b /= c;\n        }\n        bool operator<(const Data &obj) const {\n            if (a != obj.a) return a < obj.a;\n            return b < obj.b;\n        }\n    };\n    long long interchangeableRectangles(vector<vector<int>> &rectangles) {\n        map<Data, int> m;\n        long long ans = 0;\n        for (auto &x : rectangles) {\n            Data d(x[0], x[1]);\n            ans += m[d];\n            m[d] += 1;\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","数学","计数","数论"],"level":"Medium"}},{"problemName":"2003.每棵子树内缺失的最小基因值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2003.每棵子树内缺失的最小基因值.json","problemData":{"id":"2131","name":"2003.每棵子树内缺失的最小基因值","url":"https://leetcode.cn/problems/smallest-missing-genetic-value-in-each-subtree","desc":"请你返回一个数组 ans ，长度为 n ，其中 ans[i] 是以节点 i 为根的子树内 缺失 的 最小 基因值。","solutions":[{"script":"python","time":812,"memory":172.67,"desc":"dfs时用set存储所有值。","code":"class Solution:\n    def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:\n        n = len(parents)\n        nodes = [[] for i in range(n)]\n        for i in range(1, n): nodes[parents[i]].append(i)\n        ans = [1 for _ in range(n)]\n        def dfs(idx: int) -> (int, Set[int]):\n            last = 1\n            s = set([nums[idx]])\n            for child in nodes[idx]:\n                resLast, resSet = dfs(child)\n                last = max(last, resLast)\n                if len(resSet) > len(s):\n                    resSet |= s\n                    s = resSet\n                else:\n                    s |= resSet\n            while last in s: last += 1\n            ans[idx] = last\n            return last, s\n        dfs(0)\n        return ans","date":"2023-10-31"},{"script":"python","time":452,"memory":66.3,"desc":"自底向上，只遍历存在1的树。","code":"class Solution:\n    def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:\n        n = len(parents)\n        nodes = [[] for i in range(n)]\n        for i in range(1, n): nodes[parents[i]].append(i)\n        ans = [1 for _ in range(n)]\n        used = [False for _ in range(n)]\n        s = set()\n        def dfs(idx: int):\n            if used[idx]: return\n            used[idx] = True\n            s.add(nums[idx])\n            for child in nodes[idx]: dfs(child)\n        \n        cur = nums.index(1) if 1 in nums else -1\n        last = 1\n        while cur != -1:\n            dfs(cur)\n            while last in s: last += 1\n            ans[cur] = last\n            cur = parents[cur]\n        return ans","date":"2023-10-31"}],"tagList":["树","深度优先搜索","并查集","动态规划"],"level":"Hard"}},{"problemName":"2006.差的绝对值为K的数对数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2006.差的绝对值为K的数对数目.json","problemData":{"id":"2116","name":"2006.差的绝对值为K的数对数目","url":"https://leetcode.cn/problems/count-number-of-pairs-with-absolute-difference-k","desc":"给你一个整数数组 nums 和一个整数 k ，请你返回数对 (i, j) 的数目，满足 i < j 且 |nums[i] - nums[j]| == k 。","solutions":[{"date":"2022-02-09","time":4,"memory":12.1,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    int countKDifference(vector<int>& nums, int k) {\n        int m[300] = {0}, ans = 0;\n        for (auto& num : nums) {\n            ans += m[num + k + 100] + m[num - k + 100];\n            m[num + 100]++;\n        }\n        return ans;\n    }\n};"},{"date":"2022-02-09","time":8,"memory":14,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    int countKDifference(vector<int>& nums, int k) {\n        unordered_map<int, int> m;\n        int ans = 0;\n        for (auto& num : nums) {\n            ans += m[num + k] + m[num - k];\n            m[num]++;\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","计数"],"level":"Easy"}},{"problemName":"2007.从双倍数组中还原原数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2007.从双倍数组中还原原数组.json","problemData":{"id":"2117","name":"2007.从双倍数组中还原原数组","url":"https://leetcode.cn/problems/find-original-array-from-doubled-array","desc":"给你一个数组 changed ，如果 change 是 双倍 数组，那么请你返回 original数组，否则请返回空数组。original 的元素可以以 任意 顺序返回。","solutions":[{"script":"python","time":194,"memory":32.71,"desc":"哈希存储后遍历。","code":"class Solution:\n    def findOriginalArray(self, changed: List[int]) -> List[int]:\n        map = Counter(changed)\n        arr = sorted(map.keys())\n        res = []\n        for num in arr:\n            if map[num] == 0: continue\n            if num == 0:\n                if map[num] % 2 != 0: return []\n                res += [0] * (map[num] // 2)\n                continue\n            if map[num] > map[num * 2]: return []\n            map[num * 2] -= map[num]\n            res += [num] * map[num]\n        return res","date":"2024-04-18"}],"tagList":["贪心","数组","哈希表","排序"],"level":"Medium"}},{"problemName":"2008.出租车的最大盈利.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2008.出租车的最大盈利.json","problemData":{"id":"2118","name":"2008.出租车的最大盈利","url":"https://leetcode.cn/problems/maximum-earnings-from-taxi","desc":"给你 n 和 rides ，请你返回在最优接单方案下，你能盈利 最多 多少元。","solutions":[{"script":"python","time":700,"memory":31.9,"desc":"二分+动态规划记录当前点的最大值。","code":"class Solution:\n    def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -> int:\n        rides.sort(key = lambda o: (o[1], o[0], o[2]))\n        dp = [0] * (len(rides) + 1)\n        for i in range(len(rides)):\n            start, end, tip = rides[i]\n            l = -1\n            r = i - 1\n            while l < r:\n                m = (l + r + 1) // 2\n                if rides[m][1] <= start: l = m\n                else: r = m - 1\n            dp[i + 1] = max(dp[i], dp[l + 1] + end - start + tip)\n        return dp[-1]","date":"2023-12-08"}],"tagList":["数组","哈希表","二分查找","动态规划","排序"],"level":"Medium"}},{"problemName":"2009.使数组连续的最少操作数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2009.使数组连续的最少操作数.json","problemData":{"id":"2119","name":"2009.使数组连续的最少操作数","url":"https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-continuous","desc":"给你一个整数数组 nums 。每一次操作中，你可以将 nums 中 任意 一个元素替换成 任意 整数。请你返回使 nums 连续 的 最少 操作次数。","solutions":[{"script":"python","time":736,"memory":34.4,"desc":"排序后，对一个点当作左侧点进行。","code":"class Solution:\n    def minOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        arr = sorted(set(nums))\n        ans = inf\n        for i in range(len(arr)):\n            l = i\n            r = len(arr)\n            while l < r:\n                m = (l + r) // 2\n                if arr[m] > arr[i] + n - 1: r = m\n                else: l = m + 1\n            ans = min(ans, n - len(arr) + len(arr) - (l - i))\n        return ans","date":"2024-04-08"}],"tagList":["数组","哈希表","二分查找","滑动窗口"],"level":"Hard"}},{"problemName":"2011.执行操作后的变量值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2011.执行操作后的变量值.json","problemData":{"id":"2137","name":"2011.执行操作后的变量值","url":"https://leetcode.cn/problems/final-value-of-variable-after-performing-operations","desc":"给你一个字符串数组 operations ，这是由操作组成的一个列表，返回执行所有操作后， X 的 最终值 。","solutions":[{"date":"2022-12-23","time":4,"memory":13.6,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    int finalValueAfterOperations(vector<string>& operations) {\n        int ans = 0;\n        for (auto &s : operations) if (s[1] == '+') ans++; else ans--;\n        return ans;\n    }\n};"}],"tagList":["数组","字符串","模拟"],"level":"Easy"}},{"problemName":"2013.检测正方形.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2013.检测正方形.json","problemData":{"id":"2139","name":"2013.检测正方形","url":"https://leetcode.cn/problems/detect-squares","desc":"给你一个在 X-Y 平面上的点构成的数据流。设计一个满足下述要求的算法：添加 一个在数据流中的新点到某个数据结构中。可以添加 重复 的点，并会视作不同的点进行处理。给你一个查询点，请你从数据结构中选出三个点，使这三个点和查询点一同构成一个 面积为正 的 轴对齐正方形 ，统计 满足该要求的方案数目。","solutions":[{"date":"2022-01-26","time":228,"memory":91.7,"script":"cpp","desc":"统计每个点出现的次数。","code":"class DetectSquares {\n   public:\n    unordered_map<int, unordered_map<int, int>> m;\n    DetectSquares() {}\n    void add(vector<int> point) { m[point[0]][point[1]]++; }\n    int count(vector<int> point) {\n        int ans = 0, x1 = point[0], y1 = point[1];\n        for (auto &data : m[x1]) {\n            int x2 = x1, y2 = data.first, cnt2 = data.second,\n                edge = abs(y1 - y2);\n            if (y2 == y1) continue;\n            ans += cnt2 * m[x1 - edge][y1] * m[x2 - edge][y2];\n            ans += cnt2 * m[x1 + edge][y1] * m[x2 + edge][y2];\n        }\n        return ans;\n    }\n};"}],"tagList":["设计","数组","哈希表","计数"],"level":"Medium"}},{"problemName":"2016.增量元素之间的最大差值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2016.增量元素之间的最大差值.json","problemData":{"id":"2144","name":"2016.增量元素之间的最大差值","url":"https://leetcode.cn/problems/maximum-difference-between-increasing-elements","desc":"给你一个下标从 0 开始的整数数组 nums ，该数组的大小为 n ，请你计算 nums[j] - nums[i] 能求得的 最大差值 ，其中 0 <= i < j < n 且 nums[i] < nums[j] 。返回 最大差值 。如果不存在满足要求的 i 和 j ，返回 -1 。","solutions":[{"date":"2022-02-26","time":4,"memory":8,"script":"cpp","desc":"遍历，记录最小值。","code":"class Solution {\n   public:\n    int maximumDifference(vector<int>& nums) {\n        int minnum = nums[0], ans = INT_MIN;\n        for (auto& num : nums) {\n            if (num > minnum) {\n                ans = max(ans, num - minnum);\n            }\n            minnum = min(minnum, num);\n        }\n        return ans == INT_MIN ? -1 : ans;\n    }\n};"}],"tagList":["数组"],"level":"Easy"}},{"problemName":"2022.将一维数组转变成二维数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2022.将一维数组转变成二维数组.json","problemData":{"id":"2132","name":"2022.将一维数组转变成二维数组","url":"https://leetcode.cn/problems/convert-1d-array-into-2d-array","desc":"请你根据上述过程返回一个 m x n 的二维数组。","solutions":[{"date":"2022-01-04","time":112,"memory":95.1,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    vector<vector<int>> construct2DArray(vector<int>& original, int m, int n) {\n        int len = original.size();\n        vector<vector<int>> ans;\n        if (m * n != len) return ans;\n        for (int i = 0; i < m; i++) {\n            vector<int> item;\n            for (int j = 0; j < n; j++) {\n                item.push_back(original[i * n + j]);\n            }\n            ans.push_back(item);\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","矩阵","模拟"],"level":"Easy"}},{"problemName":"2024.考试的最大困扰度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2024.考试的最大困扰度.json","problemData":{"id":"2134","name":"2024.考试的最大困扰度","url":"https://leetcode.cn/problems/maximize-the-confusion-of-an-exam","desc":"请你返回在不超过 k 次操作的情况下，最大 连续 'T' 或者 'F' 的数目。","solutions":[{"date":"2022-03-29","time":24,"memory":11.7,"script":"cpp","desc":"双指针维护中间 k。","code":"class Solution {\n   public:\n    int maxConsecutiveAnswers(string answerKey, int k) {\n        return max(check('T', answerKey, k), check('F', answerKey, k));\n    }\n    int check(char ch, string str, int k) {\n        int n = str.size(), l = 0, r = 0, ans = 0;\n        do {\n            while (r < n && k > 0) {\n                while (r < n && str[r] == ch) r++;\n                k--;\n                if (r < n) r++;\n                while (r < n && str[r] == ch) r++;\n            }\n            ans = max(ans, r - l);\n            while (l < n && k <= 0) {\n                if (str[l] != ch) k++;\n                l++;\n            }\n        } while (r < n);\n        return ans;\n    }\n};"}],"tagList":["字符串","二分查找","前缀和","滑动窗口"],"level":"Medium"}},{"problemName":"2027.转换字符串的最少操作次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2027.转换字符串的最少操作次数.json","problemData":{"id":"2154","name":"2027.转换字符串的最少操作次数","url":"https://leetcode.cn/problems/minimum-moves-to-convert-string","desc":"返回将 s 中所有字符均转换为 'O' 需要执行的 最少 操作次数。","solutions":[{"date":"2022-12-27","time":0,"memory":6.2,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    int minimumMoves(string s) {\n        int ans = 0;\n        for (int i = 0; i < s.size(); i++)\n            if (s[i] == 'X') ans++, i += 2;\n        return ans;\n    }\n};"}],"tagList":["贪心","字符串"],"level":"Easy"}},{"problemName":"2028.找出缺失的观测数据.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2028.找出缺失的观测数据.json","problemData":{"id":"2155","name":"2028.找出缺失的观测数据","url":"https://leetcode.cn/problems/find-missing-observations","desc":"返回一个长度为 n 的数组，包含所有缺失的观测数据，且满足这 n + m 次投掷的 平均值 是 mean 。如果存在多组符合要求的答案，只需要返回其中任意一组即可。如果不存在答案，返回一个空数组。","solutions":[{"date":"2022-03-27","time":112,"memory":120.7,"script":"cpp","desc":"找到平均值进行分摊。","code":"class Solution {\n   public:\n    vector<int> missingRolls(vector<int>& rolls, int mean, int n) {\n        int sum = (n + rolls.size()) * mean;\n        vector<int> ans;\n        for (auto& roll : rolls) sum -= roll;\n        if (n * 6 < sum || n > sum) return ans;\n        int avg = sum / n, surplus = sum - (n - 1) * avg;\n        for (int i = 0; i < n - 1; i++) {\n            int num = avg;\n            if (surplus > 6) {\n                num++;\n                surplus--;\n            }\n            ans.push_back(num);\n            sum -= num;\n        }\n        ans.push_back(sum);\n        return ans;\n    }\n};"},{"script":"python","time":89,"memory":20.9,"desc":"模拟构造。","code":"class Solution:\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\n        m = len(rolls)\n        nsum = (m + n) * mean\n        ssum = nsum - sum(rolls)\n        if ssum / n > 6 or ssum < n: return []\n        res = [ssum // n] * n\n        for i in range(ssum % n): res[i] += 1\n        return res","date":"2024-05-27"}],"tagList":["数组","数学","模拟"],"level":"Medium"}},{"problemName":"2029.石子游戏IX.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2029.石子游戏IX.json","problemData":{"id":"2156","name":"2029.石子游戏IX","url":"https://leetcode.cn/problems/stone-game-ix","desc":"Alice 和 Bob 再次设计了一款新的石子游戏。假设两位玩家均采用 最佳 决策。如果 Alice 获胜，返回 true ；如果 Bob 获胜，返回 false 。","solutions":[{"date":"2022-01-20","time":140,"memory":124.2,"script":"cpp","desc":"把所有数模 3 取值，分别判断当有偶数个 0 和奇数个 0 的情况下必胜条件。","code":"class Solution {\n   public:\n    bool stoneGameIX(vector<int>& stones) {\n        int cnts[3] = {0};\n        for (auto& num : stones) cnts[num % 3]++;\n        return cnts[0] % 2 == 0 ? cnts[1] >= 1 && cnts[2] >= 1\n                                : abs(cnts[2] - cnts[1]) >= 3;\n    }\n};"},{"date":"2022-01-20","time":112,"memory":52.6,"script":"typescript","desc":"同上。","code":"function stoneGameIX(stones: number[]): boolean {\n  const cnts: number[] = new Array(3).fill(0);\n  for (const num of stones) cnts[num % 3]++;\n  return cnts[0] % 2 == 0 ? cnts[1] * cnts[2] >= 1 : Math.abs(cnts[2] - cnts[1]) >= 3;\n}"}],"tagList":["贪心","数组","数学","计数","博弈"],"level":"Medium"}},{"problemName":"2032.至少在两个数组中出现的值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2032.至少在两个数组中出现的值.json","problemData":{"id":"2159","name":"2032.至少在两个数组中出现的值","url":"https://leetcode.cn/problems/two-out-of-three","desc":"给你三个整数数组 nums1、nums2 和 nums3 ，请你构造并返回一个 元素各不相同的 数组，且由 至少 在 两个 数组中出现的所有值组成。","solutions":[{"date":"2022-12-29","time":20,"memory":26,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    vector<int> twoOutOfThree(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3) {\n        unordered_set<int> ans, s1, s2;\n        for (auto &num : nums1) s1.insert(num);\n        for (auto &num : nums2) {\n            if (s1.count(num)) ans.insert(num);\n            s2.insert(num);\n        }\n        for (auto &num : nums3) {\n            if (s1.count(num) || s2.count(num)) ans.insert(num);\n        }\n        return vector<int>(ans.begin(), ans.end());\n    }\n};"}],"tagList":["位运算","数组","哈希表"],"level":"Easy"}},{"problemName":"2034.股票价格波动.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2034.股票价格波动.json","problemData":{"id":"2161","name":"2034.股票价格波动","url":"https://leetcode.cn/problems/stock-price-fluctuation","desc":"请你设计一个算法，实现：更新 股票在某一时间戳的股票价格，如果有之前同一时间戳的价格，这一操作将   更正   之前的错误价格。找到当前记录里 最新股票价格  。最新股票价格   定义为时间戳最晚的股票价格。找到当前记录里股票的 最高价格  。找到当前记录里股票的 最低价格  。","solutions":[{"date":"2022-01-23","time":692,"memory":79.2,"script":"typescript","desc":"维护堆内下标。","code":"class Node {\n  constructor(\n    public timestamp: number,\n    public price: number,\n    public imax: number,\n    public imin: number\n  ) {}\n}\nclass Heap<Node> {\n  private arr: Node[] = [];\n  get isEmpty() {\n    return this.size === 0;\n  }\n  get size() {\n    return this.arr.length;\n  }\n  get top() {\n    return this.arr[0];\n  }\n  constructor(private compare: (t1: Node, t2: Node) => number, private idx_field: string) {}\n  add(num: Node): void {\n    this.arr.push(num);\n    this.shiftUp(this.size - 1);\n  }\n  remove(): Node {\n    const num = this.arr.shift()!;\n    if (this.size) {\n      this.arr.unshift(this.arr.pop()!);\n      this.shiftDown(0);\n    }\n    return num;\n  }\n  shiftUp(index: number): void {\n    if (index === 0) return;\n    const parentIndex = (index - 1) >> 1;\n    if (this.compare(this.arr[index], this.arr[parentIndex]) > 0) {\n      this.arr[index][this.idx_field] = parentIndex;\n      this.arr[parentIndex][this.idx_field] = index;\n      [this.arr[index], this.arr[parentIndex]] = [this.arr[parentIndex], this.arr[index]];\n      this.shiftUp(parentIndex);\n    }\n  }\n  shiftDown(index: number): void {\n    let childrenIndex = index * 2 + 1;\n    if (childrenIndex > this.size - 1) return;\n    if (\n      childrenIndex + 1 <= this.size - 1 &&\n      this.compare(this.arr[childrenIndex + 1], this.arr[childrenIndex]) > 0\n    ) {\n      childrenIndex++;\n    }\n    if (this.compare(this.arr[childrenIndex], this.arr[index]) > 0) {\n      this.arr[index][this.idx_field] = childrenIndex;\n      this.arr[childrenIndex][this.idx_field] = index;\n      [this.arr[childrenIndex], this.arr[index]] = [this.arr[index], this.arr[childrenIndex]];\n      this.shiftDown(childrenIndex);\n    }\n  }\n  *[Symbol.iterator](): IterableIterator<Node> {\n    for (const t of this.arr) {\n      yield t;\n    }\n  }\n}\n\nclass StockPrice {\n  heap_max = new Heap<Node>((t1, t2) => t1.price - t2.price, 'imax');\n  heap_min = new Heap<Node>((t1, t2) => t2.price - t1.price, 'imin');\n  map = new Map<number, Node>();\n  time_max = -1;\n  update(timestamp: number, price: number): void {\n    this.time_max = Math.max(this.time_max, timestamp);\n    const cnt = this.map.size;\n    let node = this.map.get(timestamp);\n    if (node) {\n      node.price = price;\n      this.heap_max.shiftUp(node.imax);\n      this.heap_max.shiftDown(node.imax);\n      this.heap_min.shiftUp(node.imin);\n      this.heap_min.shiftDown(node.imin);\n    } else {\n      this.map.set(timestamp, (node = new Node(timestamp, price, cnt, cnt)));\n      this.heap_max.add(node);\n      this.heap_min.add(node);\n    }\n  }\n  current(): number {\n    return this.map.get(this.time_max)!.price;\n  }\n  maximum(): number {\n    return this.heap_max.top.price;\n  }\n  minimum(): number {\n    return this.heap_min.top.price;\n  }\n}"},{"script":"python","time":1140,"memory":57.04,"desc":"有序集合。","code":"from sortedcontainers import SortedDict\nclass StockPrice:\n\n    def __init__(self):\n        self.cur_time = -1\n        self.cur_price = 0\n        self.time_map = SortedDict()\n        self.max_map = SortedDict()\n        self.min_map = SortedDict()\n\n    def update_map(self, map, key, d):\n        if key not in map: map[key] = 0\n        map[key] += d\n        if map[key] == 0: del map[key]\n\n    def update(self, timestamp: int, price: int) -> None:\n        if timestamp in self.time_map: \n            cur_price = self.time_map[timestamp]\n            self.update_map(self.max_map, cur_price, -1)\n            self.update_map(self.min_map, cur_price, -1)\n        self.update_map(self.max_map, price, 1)\n        self.update_map(self.min_map, price, 1)\n        self.time_map[timestamp] = price\n        if self.cur_time <= timestamp:\n            self.cur_time = timestamp\n            self.cur_price = price\n\n    def current(self) -> int:\n        return self.cur_price\n\n    def maximum(self) -> int:\n        return self.max_map.keys()[-1]\n\n    def minimum(self) -> int:\n        return self.min_map.keys()[0]\n","date":"2023-10-08"}],"tagList":["设计","哈希表","数据流","有序集合","堆（优先队列）"],"level":"Medium"}},{"problemName":"2037.使每位学生都有座位的最少移动次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2037.使每位学生都有座位的最少移动次数.json","problemData":{"id":"2148","name":"2037.使每位学生都有座位的最少移动次数","url":"https://leetcode.cn/problems/minimum-number-of-moves-to-seat-everyone","desc":"请你返回使所有学生都有座位坐的 最少移动次数 ，并确保没有两位学生的座位相同。","solutions":[{"date":"2022-12-31","time":8,"memory":17.5,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    int minMovesToSeat(vector<int>& seats, vector<int>& students) {\n        sort(seats.begin(), seats.end());\n        sort(students.begin(), students.end());\n        int ans = 0;\n        for (int i = 0; i < seats.size(); i++) ans += abs(seats[i] - students[i]);\n        return ans;\n    }\n};"},{"date":"2022-12-31","time":0,"memory":2,"script":"rust","desc":"遍历。","code":"impl Solution {\n    pub fn min_moves_to_seat(seats: Vec<i32>, students: Vec<i32>) -> i32 {\n        let mut seats = seats;\n        let mut students = students;\n        seats.sort();\n        students.sort();\n        let mut ans = 0;\n        for i in 0..seats.len() {\n            ans += (seats[i] - students[i]).abs();\n        }\n        ans\n    }\n}"}],"tagList":["贪心","数组","排序"],"level":"Easy"}},{"problemName":"2038.如果相邻两个颜色均相同则删除当前颜色.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2038.如果相邻两个颜色均相同则删除当前颜色.json","problemData":{"id":"2149","name":"2038.如果相邻两个颜色均相同则删除当前颜色","url":"https://leetcode.cn/problems/remove-colored-pieces-if-both-neighbors-are-the-same-color","desc":"假设 Alice 和 Bob 都采用最优策略，如果 Alice 获胜，请返回 true，否则 Bob 获胜，返回 false。","solutions":[{"date":"2022-03-22","time":32,"memory":13,"script":"cpp","desc":"统计 ab 的数量进行比较。","code":"class Solution {\n   public:\n    bool winnerOfGame(string colors) {\n        int a = 0, b = 0;\n        for (int i = 1; i < colors.size() - 1; i++) {\n            if (colors[i] == 'A' && colors[i - 1] == 'A' &&\n                colors[i + 1] == 'A')\n                a++;\n            else if (colors[i] == 'B' && colors[i - 1] == 'B' &&\n                     colors[i + 1] == 'B')\n                b++;\n        }\n        return a > b;\n    }\n};"}],"tagList":["贪心","数学","字符串","博弈"],"level":"Medium"}},{"problemName":"2039.网络空闲的时刻.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2039.网络空闲的时刻.json","problemData":{"id":"2151","name":"2039.网络空闲的时刻","url":"https://leetcode.cn/problems/the-time-when-the-network-becomes-idle","desc":"请返回计算机网络变为 空闲 状态的 最早秒数 。","solutions":[{"date":"2022-03-20","time":540,"memory":185.9,"script":"cpp","desc":"bfs 后统计每个的时长。","code":"class Solution {\n   public:\n    struct node {\n        int idx;\n        vector<int> next;\n    };\n    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {\n        int n = patience.size();\n        vector<node> list(n);\n        for (int i = 0; i < n; i++) list[i].idx = i;\n        for (auto& edge : edges) {\n            list[edge[0]].next.push_back(edge[1]);\n            list[edge[1]].next.push_back(edge[0]);\n        }\n        int ans = 0;\n        queue<int> q;\n        q.push(0);\n        vector<bool> check(list.size(), false);\n        check[0] = true;\n        int cur_time = 1, size = 1;\n        while (q.size()) {\n            int idx = q.front();\n            q.pop();\n            for (auto& next : list[idx].next) {\n                if (check[next]) continue;\n                check[next] = true;\n                q.push(next);\n                int time = cur_time * 2, pat = patience[list[next].idx];\n                // 超出一遍等待， 按最后一个算\n                if (time > pat)\n                    time += time % pat == 0 ? time - pat : time - time % pat;\n                ans = max(ans, time);\n            }\n            if (--size == 0) {\n                size = q.size();\n                cur_time++;\n            }\n        }\n\n        return ans + 1;\n    }\n};"}],"tagList":["广度优先搜索","图","数组"],"level":"Medium"}},{"problemName":"2042.检查句子中的数字是否递增.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2042.检查句子中的数字是否递增.json","problemData":{"id":"2168","name":"2042.检查句子中的数字是否递增","url":"https://leetcode.cn/problems/check-if-numbers-are-ascending-in-a-sentence","desc":"给你一个表示句子的字符串 s ，你需要检查 s 中的 全部 数字是否从左到右严格递增（即，除了最后一个数字，s 中的 每个 数字都严格小于它 右侧 的数字）。","solutions":[{"date":"2023-01-03","time":0,"memory":6.1,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    bool areNumbersAscending(string s) {\n        int prev = 0;\n        for (int i = 0; i < s.size(); i++) {\n            if (!isdigit(s[i])) continue;\n            int num = 0;\n            while (i < s.size() && isdigit(s[i])) num = num * 10 + s[i++] - '0';\n            if (prev >= num) return false;\n            prev = num;\n        }\n        return true;\n    }\n};"},{"date":"2023-01-03","time":0,"memory":2.2,"script":"rust","desc":"同上。","code":"impl Solution {\n    pub fn are_numbers_ascending(s: String) -> bool {\n        let s: Vec<char> = s.chars().collect();\n        let mut i = 0;\n        let mut prev = 0;\n        while i < s.len() {\n            if s[i].is_digit(10) {\n                let mut num = 0;\n                while i < s.len() && s[i].is_digit(10) {\n                    num = num * 10 + (s[i] as i32 - '0' as i32);\n                    i += 1;\n                }\n                if prev >= num {\n                    return false;\n                }\n                prev = num\n            }\n            i += 1;\n        }\n        true\n    }\n}"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"2043.简易银行系统.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2043.简易银行系统.json","problemData":{"id":"2169","name":"2043.简易银行系统","url":"https://leetcode.cn/problems/simple-bank-system","desc":"实现 Bank 类。","solutions":[{"date":"2022-03-18","time":200,"memory":113.9,"script":"cpp","desc":"存储数据后校验。","code":"class Bank {\n   public:\n    int n;\n    vector<long long> accounts;\n    Bank(vector<long long>& balance) {\n        n = balance.size();\n        this->accounts = balance;\n    }\n    bool transfer(int account1, int account2, long long money) {\n        if (!check_account(account1) || !check_account(account2) ||\n            !check_money(account1, money))\n            return false;\n        accounts[account1 - 1] -= money;\n        accounts[account2 - 1] += money;\n        return true;\n    }\n    bool deposit(int account, long long money) {\n        if (!check_account(account)) return false;\n        accounts[account - 1] += money;\n        return true;\n    }\n    bool withdraw(int account, long long money) {\n        if (!check_account(account) || !check_money(account, money))\n            return false;\n        accounts[account - 1] -= money;\n        return true;\n    }\n    bool check_account(int account) { return account >= 1 && account <= n; }\n    bool check_money(int account, long long money) {\n        return accounts[account - 1] >= money;\n    }\n};"}],"tagList":["设计","数组","哈希表","模拟"],"level":"Medium"}},{"problemName":"2044.统计按位或能得到最大值的子集数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2044.统计按位或能得到最大值的子集数目.json","problemData":{"id":"2170","name":"2044.统计按位或能得到最大值的子集数目","url":"https://leetcode.cn/problems/count-number-of-maximum-bitwise-or-subsets","desc":"给你一个整数数组 nums ，请你找出 nums 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 。","solutions":[{"date":"2022-03-15","time":16,"memory":8.1,"script":"cpp","desc":"dfs。","code":"class Solution {\n   public:\n    int ans = 0, nmax = INT_MIN;\n    void add(int num) {\n        if (num >= nmax) {\n            if (num > nmax) ans = 0;\n            ans++;\n            nmax = num;\n        }\n    }\n    int countMaxOrSubsets(vector<int>& nums) {\n        dfs(nums, 0, 0);\n        return ans;\n    }\n    void dfs(vector<int>& nums, int idx, int num) {\n        add(num);\n        if (idx == nums.size()) return;\n        for (int i = idx; i < nums.size(); i++) {\n            dfs(nums, i + 1, num | nums[i]);\n        }\n    }\n};"}],"tagList":["位运算","数组","回溯","枚举"],"level":"Medium"}},{"problemName":"2045.到达目的地的第二短时间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2045.到达目的地的第二短时间.json","problemData":{"id":"2171","name":"2045.到达目的地的第二短时间","url":"https://leetcode.cn/problems/second-minimum-time-to-reach-destination","desc":"给你 n、edges、time 和 change ，返回从节点 1 到节点 n 需要的 第二短时间 。","solutions":[{"date":"2022-01-24","time":400,"memory":67.8,"script":"typescript","desc":"bfs，对于每个节点记录已经遍历过的值，进行剪枝。","code":"class Node {\n  next: Node[] = [];\n  min_time1 = Infinity;\n  min_time2 = Infinity;\n  constructor(public idx: number) {}\n}\nclass Car {\n  constructor(public current: Node, public time = 0) {}\n}\nfunction secondMinimum(n: number, edges: number[][], time: number, change: number): number {\n  const nodes: Record<number, Node> = {};\n  for (let i = 1; i <= n; i++) nodes[i] = new Node(i);\n  for (const [n1, n2] of edges) {\n    const node1 = nodes[n1];\n    const node2 = nodes[n2];\n    node1.next.push(node2);\n    node2.next.push(node1);\n  }\n  nodes[1].min_time1 = 0;\n  const queue: Car[] = [new Car(nodes[1])];\n  const arr: Car[] = [];\n  while (queue.length) {\n    const car = queue.shift()!;\n    const wait_check = Math.floor(car.time / change);\n    const next_time = wait_check % 2 === 0 ? car.time + time : (wait_check + 1) * change + time;\n    for (const next of car.current.next) {\n      if (next_time < next.min_time1) {\n        const ncar = new Car(next, next_time);\n        next.min_time1 = next_time;\n        if (next === nodes[n]) {\n          arr.push(ncar);\n          continue;\n        }\n        queue.push(ncar);\n      } else if (next_time > next.min_time1 && next_time < next.min_time2) {\n        const ncar = new Car(next, next_time);\n        next.min_time2 = next_time;\n        if (next === nodes[n]) {\n          arr.push(ncar);\n          continue;\n        }\n        queue.push(ncar);\n      }\n    }\n  }\n  arr.sort((a, b) => a.time - b.time);\n  const min_car = arr[0];\n  let min21_car: Car | null = null;\n  for (let i = 1; i < arr.length; i++) {\n    if (arr[i].time !== min_car.time) {\n      min21_car = arr[i];\n      break;\n    }\n  }\n  const min22 = getNext(min_car);\n  return Math.min(min21_car?.time ?? Infinity, min22);\n  function getNext(car: Car): number {\n    // 回去\n    let wait_check = Math.floor(car.time / change);\n    let next_time = wait_check % 2 === 0 ? car.time + time : (wait_check + 1) * change + time;\n    // 回来\n    wait_check = Math.floor(next_time / change);\n    next_time = wait_check % 2 === 0 ? next_time + time : (wait_check + 1) * change + time;\n    return next_time;\n  }\n}"}],"tagList":["广度优先搜索","图","最短路"],"level":"Hard"}},{"problemName":"2047.句子中的有效单词数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2047.句子中的有效单词数.json","problemData":{"id":"2173","name":"2047.句子中的有效单词数","url":"https://leetcode.cn/problems/number-of-valid-words-in-a-sentence","desc":"给你一个字符串 sentence ，请你找出并返回 sentence 中 有效单词的数目 。","solutions":[{"date":"2022-01-27","time":4,"memory":7,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    string str;\n    int idx = 0;\n    void scan_blank() {\n        while (idx < str.size() && str[idx] == ' ') idx++;\n    }\n    int check(int start, int end) {\n        if (start == end) return 0;\n        int cnt_line = 0, cnt_tag = 0;\n        for (int i = start; i < end; i++) {\n            char ch = str[i];\n            if (ch == '-') {\n                if (++cnt_line > 1 || i == start || i == end - 1 ||\n                    str[i - 1] < 'a' || str[i - 1] > 'z' || str[i + 1] < 'a' ||\n                    str[i + 1] > 'z')\n                    return 0;\n            } else if (ch == '!' || ch == '.' || ch == ',') {\n                if (++cnt_tag > 1 || i != end - 1) return 0;\n            } else if (ch < 'a' || ch > 'z')\n                return 0;\n        }\n        return 1;\n    }\n    int countValidWords(string sentence) {\n        str = sentence;\n        int ans = 0;\n        do {\n            scan_blank();\n            int start = idx, end = idx;\n            while (end < str.size() && str[end] != ' ') end++;\n            idx = end;\n            if (check(start, end)) ans++;\n        } while (idx < str.size());\n        return ans;\n    }\n};"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"2048.下一个更大的数值平衡数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2048.下一个更大的数值平衡数.json","problemData":{"id":"2174","name":"2048.下一个更大的数值平衡数","url":"https://leetcode.cn/problems/next-greater-numerically-balanced-number","desc":"给你一个整数 n ，请你返回 严格大于 n 的 最小数值平衡数 。","solutions":[{"date":"2022-05-06","script":"cpp","time":4,"memory":7.03,"desc":"打表。","code":"class Solution {\n    public:\n        void getNumber(int d, int ind, vector<int>& buff, vector<int>& arr) {\n            if (d == 0) {\n                vector<int> temp;\n                for (auto x : buff) {\n                    for (int i = 0; i < x; i++) {\n                        temp.push_back(x);\n                    }\n                }\n                do {\n                    int num = 0;\n                    for (auto x : temp) num = num * 10 + x;\n                    arr.push_back(num);\n                } while (next_permutation(temp.begin(), temp.end()));\n                return;\n            }\n            for (int i = ind; i <= d; i++) {\n                if (d - i > i || i == d) {\n                    buff.push_back(i);\n                    getNumber(d - i, i + 1, buff, arr);\n                    buff.pop_back();\n                }\n            }\n        }\n        void getAllNumber(int d, vector<int>& arr) {\n            vector<int> buff;\n            getNumber(d, 1, buff, arr);\n        }\n        int nextBeautifulNumber(int n) {\n            if (n == 0) return 1;\n            int d = floor(log10(n)) + 1;\n            vector<int> arr;\n            getAllNumber(d, arr);\n            getAllNumber(d + 1, arr);\n            int ans = INT_MAX;\n            for (auto x : arr) {\n                if (x > n) ans = min(ans, x);\n            }\n            return ans;\n        }\n};"},{"script":"python","time":3380,"memory":15.98,"desc":"枚举。","code":"class Solution:\n    def nextBeautifulNumber(self, n: int) -> int:\n        while True:\n            n = n + 1\n            arr = [0] * 10\n            for c in str(n):\n                arr[int(c)] += 1\n            f = True\n            for i in range(10):\n                if arr[i] != 0 and arr[i] != i:\n                    f = False\n                    break\n            if f:\n                return n","date":"2023-12-09"}],"tagList":["数学","回溯","枚举"],"level":"Medium"}},{"problemName":"2049.统计最高分的节点数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2049.统计最高分的节点数目.json","problemData":{"id":"2175","name":"2049.统计最高分的节点数目","url":"https://leetcode.cn/problems/count-nodes-with-the-highest-score","desc":"请你返回有 最高得分 节点的 数目 。","solutions":[{"date":"2022-03-11","time":128,"memory":79.6,"script":"cpp","desc":"统计每个点的父节点，左子树个数，右子树个数。","code":"class Solution {\n   public:\n    struct node {\n        int parent, left, right, lcnt, rcnt;\n    };\n    // ans\n    int ans = 0;\n    long long maxnum = -1;\n    void setAns(long long num) {\n        if (num >= maxnum) {\n            if (num > maxnum) ans = 0;\n            ans++;\n            maxnum = num;\n        }\n    }\n    int countHighestScoreNodes(vector<int>& parents) {\n        int n = parents.size();\n        vector<node> list(n);\n        // init\n        for (int i = 0; i < n; i++) {\n            list[i].parent = parents[i];\n            list[i].left = list[i].right = -1;\n            list[i].lcnt = list[i].rcnt = 0;\n        }\n        // load\n        for (int i = 1; i < n; i++) {\n            if (list[list[i].parent].left == -1)\n                list[list[i].parent].left = i;\n            else\n                list[list[i].parent].right = i;\n        }\n        // check\n        int sum = check(list, 0);\n        // res\n        for (int i = 1; i < n; i++) {\n            if (list[i].lcnt == 0 && list[i].rcnt == 0) {\n                setAns((long long)list[0].lcnt + list[0].rcnt);\n                continue;\n            }\n            setAns((long long)format(sum - 1 - list[i].lcnt - list[i].rcnt) *\n                   format(list[i].lcnt) * format(list[i].rcnt));\n        }\n        // res0\n        setAns((long long)format(list[0].lcnt) * format(list[0].rcnt));\n        return ans;\n    }\n    int check(vector<node>& list, int node) {\n        int ans = 0;\n        if (list[node].left != -1) {\n            list[node].lcnt = check(list, list[node].left);\n            ans += list[node].lcnt;\n        }\n        if (list[node].right != -1) {\n            list[node].rcnt = check(list, list[node].right);\n            ans += list[node].rcnt;\n        }\n        return ans + 1;\n    }\n    int format(int num) { return num == 0 ? 1 : num; }\n};"}],"tagList":["树","深度优先搜索","数组","二叉树"],"level":"Medium"}},{"problemName":"2050.并行课程III.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2050.并行课程III.json","problemData":{"id":"2176","name":"2050.并行课程III","url":"https://leetcode.cn/problems/parallel-courses-iii","desc":"请你返回完成所有课程所需要的 最少 月份数。","solutions":[{"script":"cpp","time":636,"memory":222.5,"desc":"拓扑排序+堆。","code":"#define X first\n#define Y second\n#define pii pair<int, int>\nstruct Node {\n    unordered_set<int> p, c;\n};\nclass Solution {\npublic:\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\n        unordered_set<int> start;\n        for (int i = 0; i < n; i++) start.insert(i);\n\n        vector<Node> list(n);\n        for (auto &item : relations) {\n            list[item[0] - 1].c.insert(item[1] - 1);\n            list[item[1] - 1].p.insert(item[0] - 1);\n            start.erase(item[1] - 1);\n        }\n\n        int res = 0;\n        auto cmp = [&](pii a, pii b) -> bool {\n            return b.Y < a.Y;\n        };\n        priority_queue<pii, vector<pii>, decltype(cmp)> q(cmp);\n        for (auto &v : start) {\n            q.push(make_pair(v, time[v]));\n        }\n        while (q.size()) {\n            auto cur = q.top();\n            res = max(res, cur.Y);\n            q.pop();\n            for (auto &c : list[cur.X].c) {\n                list[c].p.erase(cur.X);\n                if (list[c].p.empty()) {\n                    q.push(make_pair(c, cur.Y + time[c]));\n                }\n            }\n        }\n        return res;\n    }\n};","date":"2023-07-28"},{"script":"cpp","time":388,"memory":161.2,"desc":"dfs。","code":"class Solution {\npublic:\n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) {\n        vector<vector<int>> list(n);\n        for (auto &item : relations) {\n            list[item[1] - 1].push_back(item[0] - 1);\n        }\n        unordered_map<int, int> cache;\n        function<int(int)> dfs = [&](int cur) -> int {\n            if (cache[cur]) return cache[cur];\n            int val = 0;\n            for (auto &p : list[cur]) val = max(val, dfs(p));\n            return cache[cur] = val + time[cur];\n        };\n        int res = 0;\n        for (int i = 0; i < n; i++) res = max(res, dfs(i));\n        return res;\n    }\n};","date":"2023-07-28"},{"script":"python","time":296,"memory":141.8,"desc":"同上。","code":"class Solution:\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\n        list = [[] for _ in range(n)]\n        for item in relations:\n            list[item[1]-1].append(item[0]-1)\n\n        @cache\n        def dfs(cur: int) -> int:\n            if len(list[cur]) == 0: return time[cur]\n            return max(dfs(i) for i in list[cur]) + time[cur]\n        return max(dfs(i) for i in range(n))","date":"2023-07-28"},{"script":"rust","time":64,"memory":11.9,"desc":"同上。","code":"impl Solution {\n    pub fn minimum_time(n: i32, relations: Vec<Vec<i32>>, time: Vec<i32>) -> i32 {\n        use std::collections::HashMap;\n        let n = n as usize;\n        let mut list = vec![vec![]; n];\n        for item in relations {\n            let (i0, i1) = (item[0] as usize - 1, item[1] as usize - 1);\n            list[i1].push(i0);\n        }\n        let mut cache = HashMap::<usize, i32>::new();\n        fn dfs(\n            cache: &mut HashMap<usize, i32>,\n            list: &Vec<Vec<usize>>,\n            time: &Vec<i32>,\n            cur: usize,\n        ) -> i32 {\n            if cache.contains_key(&cur) {\n                *cache.get(&cur).unwrap()\n            } else {\n                let res = list[cur]\n                    .iter()\n                    .map(|p| dfs(cache, list, time, *p))\n                    .max()\n                    .unwrap_or(0)\n                    + time[cur];\n                cache.insert(cur, res);\n                res\n            }\n        }\n        (0..n)\n            .into_iter()\n            .map(|i| dfs(&mut cache, &list, &time, i))\n            .max()\n            .unwrap()\n    }\n}","date":"2023-07-28"}],"tagList":["图","拓扑排序","数组","动态规划"],"level":"Hard"}},{"problemName":"2055.蜡烛之间的盘子.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2055.蜡烛之间的盘子.json","problemData":{"id":"2165","name":"2055.蜡烛之间的盘子","url":"https://leetcode.cn/problems/plates-between-candles","desc":"请你返回一个整数数组 answer ，其中 answer[i] 是第 i 个查询的答案。","solutions":[{"date":"2022-03-08","time":380,"memory":135.3,"script":"cpp","desc":"前缀和，二分。","code":"class Solution {\n   public:\n    typedef pair<int, int> node;\n    vector<node> list;\n    int n;\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\n        n = s.size();\n        int prev = 0;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '|') list.push_back(make_pair(i, prev));\n            if (s[i] == '*') prev++;\n        }\n        vector<int> ans;\n        ans.reserve(queries.size());\n        for (auto& query : queries) {\n            int l = bs_l(query[0]), r = bs_r(query[1]), res;\n            if (l == list.size() || r == -1 || list[l].first > query[1] ||\n                l == r)\n                res = 0;\n            else\n                res = list[r].second - list[l].second;\n            ans.push_back(res);\n        }\n\n        return ans;\n    }\n    int bs_l(int idx) {\n        int l = 0, r = list.size(), m;\n        while (l < r) {\n            m = (l + r) >> 1;\n            if (list[m].first >= idx)\n                r = m;\n            else\n                l = m + 1;\n        }\n        return l;\n    }\n    int bs_r(int idx) {\n        int l = -1, r = list.size() - 1, m;\n        while (l < r) {\n            m = (l + r + 1) >> 1;\n            if (list[m].first <= idx)\n                l = m;\n            else\n                r = m - 1;\n        }\n        return l;\n    }\n};"},{"date":"2022-03-08","time":364,"memory":138.9,"script":"cpp","desc":"前缀和，遍历存储每个点的前后蜡烛。","code":"class Solution {\n   public:\n    typedef pair<int, int> node;\n    vector<int> platesBetweenCandles(string s, vector<vector<int>>& queries) {\n        int n = s.size(), prev = 0;\n        vector<node> list;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '|') list.push_back(make_pair(i, prev));\n            if (s[i] == '*') prev++;\n        }\n        vector<int> find_l(n), find_r(n);\n        for (int i = 0, start = 0; i < n; i++) {\n            find_l[i] = start;\n            if (start < list.size() && i == list[start].first) start++;\n        }\n        for (int i = n - 1, start = list.size() - 1; i >= 0; i--) {\n            find_r[i] = start;\n            if (start > -1 && i == list[start].first) start--;\n        }\n        vector<int> ans;\n        ans.reserve(queries.size());\n        for (auto& query : queries) {\n            int l = find_l[query[0]], r = find_r[query[1]], res;\n            if (l == list.size() || r == -1 || list[l].first > query[1] ||\n                l == r)\n                res = 0;\n            else\n                res = list[r].second - list[l].second;\n            ans.push_back(res);\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","字符串","二分查找","前缀和"],"level":"Medium"}},{"problemName":"2079.给植物浇水.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2079.给植物浇水.json","problemData":{"id":"1310","name":"2079.给植物浇水","url":"https://leetcode.cn/problems/watering-plants","desc":"给你一个下标从 0 开始的整数数组 plants ，数组由 n 个整数组成。其中，plants[i] 为第 i 株植物需要的水量。另有一个整数 capacity 表示水罐的容量，返回浇灌所有植物需要的 步数 。","solutions":[{"script":"python","time":40,"memory":16.53,"desc":"模拟。","code":"class Solution:\n    def wateringPlants(self, plants: List[int], capacity: int) -> int:\n        water = capacity\n        res = 0\n        for i in range(len(plants)):\n            if water < plants[i]:\n                water = capacity\n                res += i * 2\n            water -= plants[i]\n            res += 1\n        return res","date":"2024-05-08"}],"tagList":["数组","模拟"],"level":"Medium"}},{"problemName":"2085.统计出现过一次的公共字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2085.统计出现过一次的公共字符串.json","problemData":{"id":"2190","name":"2085.统计出现过一次的公共字符串","url":"https://leetcode.cn/problems/count-common-words-with-one-occurrence","desc":"给你两个字符串数组 words1 和 words2 ，请你返回在两个字符串数组中 都恰好出现一次 的字符串的数目。","solutions":[{"script":"python","time":52,"memory":17.23,"desc":"计数。","code":"class Solution:\n    def countWords(self, words1: List[str], words2: List[str]) -> int:\n        c1 = Counter(words1)\n        c2 = Counter(words2)\n        return sum(v == 1 and c2[k] == 1 for k, v in c1.items())","date":"2024-01-12"}],"tagList":["数组","哈希表","字符串","计数"],"level":"Easy"}},{"problemName":"2100.适合野炊的日子.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2001-2100/2100.适合野炊的日子.json","problemData":{"id":"2205","name":"2100.适合野炊的日子","url":"https://leetcode.cn/problems/find-good-days-to-rob-the-bank","desc":"请你返回一个数组，包含 所有 适合打劫银行的日子（下标从 0 开始）。返回的日子可以 任意 顺序排列。","solutions":[{"date":"2022-03-06","time":116,"memory":84.8,"script":"cpp","desc":"记录当前值左侧最大递增长度和右侧最大递增长度。","code":"class Solution {\n        public:\n         vector<int> goodDaysToRobBank(vector<int>& security, int time) {\n             int n = security.size();\n             vector<int> cnts(n, 0);\n             for (int i = n - 2; i >= 0; i--) {\n                 if (security[i] <= security[i + 1]) {\n                     cnts[i] = cnts[i + 1] + 1;\n                 } else {\n                     cnts[i] = 0;\n                 }\n             }\n             vector<int> ans;\n             int prev = 0;\n             for (int i = 0; i < n; i++) {\n                 if (i > 0 && security[i] <= security[i - 1]) {\n                     prev++;\n                 } else {\n                     prev = 0;\n                 }\n                 if (prev >= time && cnts[i] >= time) {\n                     ans.push_back(i);\n                 }\n             }\n             return ans;\n         }\n     };"}],"tagList":["数组","动态规划","前缀和"],"level":"Medium"}}]},{"dirName":"201-300","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\201-300","problems":[{"problemName":"201.数字范围按位与.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/201.数字范围按位与.json","problemData":{"id":"201","name":"201.数字范围按位与","url":"https://leetcode.cn/problems/bitwise-and-of-numbers-range","desc":"给定范围 [m, n]，其中 0 <= m <= n <= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。","solutions":[{"date":"2020-08-23","time":240,"memory":45.3,"script":"typescript","desc":"把题目转换为公共前缀。","code":"function rangeBitwiseAnd(m: number, n: number): number {\n  let shift = 0;\n  while (m < n) {\n    m >>= 1;\n    n >>= 1;\n    ++shift;\n  }\n  return m << shift;\n}"},{"date":"2022-03-03","time":20,"memory":5.8,"script":"cpp","desc":"只有当两数最高位一致才可能非 0。","code":"class Solution {\n   public:\n    int rangeBitwiseAnd(int left, int right) {\n        int cnt = 0;\n        for (; left != right; cnt++) {\n            left >>= 1;\n            right >>= 1;\n        }\n        return left << cnt;\n    }\n};"}],"tagList":["位运算"],"level":"Medium"}},{"problemName":"202.快乐数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/202.快乐数.json","problemData":{"id":"202","name":"202.快乐数","url":"https://leetcode.cn/problems/happy-number","desc":"编写一个算法来判断一个数 n 是不是快乐数。","solutions":[{"date":"2020-04-30","time":72,"memory":35.2,"script":"javascript","desc":"递归判断，使用 Set 判断是否重复。","code":"/**\n * @param {number} n\n * @return {boolean}\n */\nvar isHappy = function (n) {\n  const set = new Set();\n  return happy(n);\n  function happy(n) {\n    if (set.has(n)) return false;\n    set.add(n);\n    let num = 0;\n    while (n !== 0) {\n      num += (n % 10) ** 2;\n      n = Math.floor(n / 10);\n    }\n    if (num === 1) return true;\n    else return happy(num);\n  }\n};"},{"date":"2021-03-06","time":80,"memory":39.7,"script":"typescript","desc":"循环计算。","code":"function isHappy(n: number): boolean {\n  const set = new Set();\n  while (n !== 1) {\n    if (set.has(n)) return false;\n    set.add(n);\n    let sum = 0;\n    while (n !== 0) {\n      sum += (n % 10) ** 2;\n      n = ~~(n / 10);\n    }\n    n = sum;\n  }\n  return true;\n}"},{"date":"2021-11-19","time":0,"memory":5.3,"script":"c","desc":"快慢指针。","code":"int comp(int n) {\n    int sum = 0, num;\n    while (n) {\n        num = n % 10;\n        sum += num * num;\n        n /= 10;\n    }\n    return sum;\n}\nbool isHappy(int n){\n    int fast = n, slow = n;\n    do{\n        fast = comp(comp(fast));\n        slow = comp(slow);\n    } while(fast != slow);\n    return slow == 1;\n}"},{"date":"2022-03-03","time":4,"memory":6.2,"script":"cpp","desc":"递归，记录当前值是否被遍历过。","code":"class Solution {\n   public:\n    unordered_set<int> s;\n    bool isHappy(int n) {\n        if (s.count(n)) return 0;\n        s.insert(n);\n        int ans = 0;\n        for (; n; n /= 10) ans += pow(n % 10, 2);\n        if (ans == 1) return 1;\n        return isHappy(ans);\n    }\n};"},{"date":"2022-03-03","time":0,"memory":5.6,"script":"cpp","desc":"快慢指针。","code":"class Solution {\n   public:\n    int next(int n) {\n        int ans = 0;\n        for (; n; n /= 10) ans += pow(n % 10, 2);\n        return ans;\n    }\n    bool isHappy(int n) {\n        int slow = n, fast = n;\n        while (fast != 1) {\n            slow = next(slow);\n            fast = next(next(fast));\n            if (slow == fast) break;\n        }\n        return fast == 1;\n    }\n};"}],"tagList":["哈希表","数学","双指针"],"level":"Easy"}},{"problemName":"203.移除链表元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/203.移除链表元素.json","problemData":{"id":"203","name":"203.移除链表元素","url":"https://leetcode.cn/problems/remove-linked-list-elements","desc":"删除链表中等于给定值 val 的所有节点。","solutions":[{"date":"2020-02-13","time":1,"memory":40.1,"script":"java","desc":"创建新链表，遍历节点，若存在符合的值则移除。","code":"class Solution {\n    public ListNode removeElements(ListNode head, int val) {\n        ListNode newHead=new ListNode(0);\n        newHead.next=head;\n        ListNode tem=newHead;\n        while(tem!=null&&tem.next!=null) {\n        \tif(tem.next.val==val) {\n        \t\ttem.next=tem.next.next;\n                continue;\n        \t}\n        \ttem=tem.next;\n        }\n        return newHead.next;\n    }\n}"},{"date":"2021-06-05","time":108,"memory":43.3,"script":"typescript","desc":"初始化空头节点便于运算。","code":"function removeElements(head: ListNode | null, val: number): ListNode | null {\n  if (head === null) return null;\n  const tempHead = new ListNode(0, head);\n  let p: ListNode | null = tempHead;\n  while (p !== null) {\n    let next: ListNode | null = p.next;\n    while (next !== null && next.val === val) next = next.next;\n    p.next = next;\n    p = next;\n  }\n  return tempHead.next;\n}"},{"date":"2021-11-19","time":8,"memory":7.9,"script":"c","desc":"双指针。","code":"struct ListNode* removeElements(struct ListNode* head, int val){\n    if (!head) return NULL;\n    while (head && head->val == val) head = head->next;\n    if (!head) return NULL;\n    struct ListNode *p = head;\n    struct ListNode *work = head;\n    while (work) {\n        work = work->next;\n        while(work && work->val == val) work = work->next;\n        p->next = work;\n        p = p->next;\n    }\n    return head;\n}"}],"tagList":["递归","链表"],"level":"Easy"}},{"problemName":"204.计数质数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/204.计数质数.json","problemData":{"id":"204","name":"204.计数质数","url":"https://leetcode.cn/problems/count-primes","desc":"统计所有小于非负整数 n 的质数的数量。","solutions":[{"date":"2020-12-03","time":136,"memory":52.1,"script":"typescript","desc":"埃氏筛。","code":"function countPrimes(n: number): number {\n  const isPrime = new Array(n).fill(1);\n  let ans = 0;\n  for (let i = 2; i < n; ++i) {\n    if (isPrime[i]) {\n      ans += 1;\n      for (let j = i * i; j < n; j += i) {\n        isPrime[j] = 0;\n      }\n    }\n  }\n  return ans;\n}"},{"date":"2021-08-20","time":256,"memory":109.5,"script":"typescript","desc":"分别统计每个数的倍数快速标记。","code":"function countPrimes(n: number): number {\n  const arr: boolean[] = new Array(n).fill(true);\n  arr[0] = arr[1] = false;\n  for (let i = 2; i <= n - 1; i++) {\n    if (arr[i]) for (let num = 2; num * i < n; num++) arr[num * i] = false;\n  }\n  return arr.filter(Boolean).length;\n}"}],"tagList":["数组","数学","枚举","数论"],"level":"Medium"}},{"problemName":"205.同构字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/205.同构字符串.json","problemData":{"id":"205","name":"205.同构字符串","url":"https://leetcode.cn/problems/isomorphic-strings","desc":"给定两个字符串 s 和 t，判断它们是否是同构的。","solutions":[{"date":"2020-12-27","time":88,"memory":40.8,"script":"typescript","desc":"利用 map 和 set 储存遍历过的值。","code":"function isIsomorphic(s: string, t: string): boolean {\n  const map: Record<string, string> = {};\n  const set = new Set<string>();\n  for (let i = 0, l = s.length; i < l; i++) {\n    const sC = s[i];\n    const tC = t[i];\n    const mapC = map[sC];\n    if (!mapC) {\n      if (set.has(tC)) return false;\n      map[sC] = tC;\n      set.add(tC);\n    } else if (mapC !== tC) return false;\n  }\n  return true;\n}"}],"tagList":["哈希表","字符串"],"level":"Easy"}},{"problemName":"206.反转链表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/206.反转链表.json","problemData":{"id":"206","name":"206.反转链表","url":"https://leetcode.cn/problems/reverse-linked-list","desc":"反转一个单链表。","solutions":[{"date":"2020-02-13","time":0,"memory":37.3,"script":"java","desc":"创建链表，循环头部插入。","code":"class Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head == null || head.next == null)\n\t\t\treturn head;\n\t\tListNode newHead=null;\n\t\twhile(head!=null) {\n\t\t\tListNode tmp=head.next;\n\t\t\thead.next=newHead;\n\t\t\tnewHead=head;\n\t\t\thead=tmp;\n\t\t}\n\t\treturn newHead;\n    }\n}"},{"date":"2021-03-06","time":100,"memory":40,"script":"typescript","desc":"递归。","code":"function reverseList(head: ListNode | null): ListNode | null {\n  if (head === null || head.next === null) return head;\n  const nextList = reverseList(head.next);\n  head.next.next = head;\n  head.next = null;\n  return nextList;\n}"},{"date":"2021-11-19","time":4,"memory":6.6,"script":"c","desc":"递归。","code":"struct ListNode* reverseList(struct ListNode* head){\n    if (head == NULL || head->next == NULL) return head;\n    struct ListNode *next = head->next;\n    struct ListNode *reverse_head = reverseList(next);\n    next->next = head;\n    head->next = NULL;\n    return reverse_head;\n}"},{"date":"2022-03-03","time":8,"memory":8.1,"script":"cpp","desc":"双指针。","code":"class Solution {\n   public:\n    ListNode* reverseList(ListNode* head) {\n        if (!head) return head;\n        ListNode *newHead = nullptr, *tmp;\n        while (head) {\n            tmp = head->next;\n            head->next = newHead;\n            newHead = head;\n            head = tmp;\n        }\n        return newHead;\n    }\n};"}],"tagList":["递归","链表"],"level":"Easy"}},{"problemName":"207.课程表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/207.课程表.json","problemData":{"id":"207","name":"207.课程表","url":"https://leetcode.cn/problems/course-schedule","desc":"请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。","solutions":[{"date":"2020-08-05","script":"typescript","time":96,"memory":40.3,"desc":"归并排序。","code":"function canFinish(numCourses: number, prerequisites: number[][]): boolean {\n    const inDegree:number[] = Array(numCourses).fill(0) //入度的数组\n    const map:any = new Map() \n    for (let i = 0; i < prerequisites.length; i++) {\n        inDegree[prerequisites[i][0]]++ //遍历课程，第一项都是依赖后一项的所以入度都加1\n        if (map.has(prerequisites[i][1])) { //push依赖prerequisites[i][1]的课程\n            map.get(prerequisites[i][1]).push(prerequisites[i][0])\n        } else { //map中没有此课程，添加进去并把value设置成数组用来push依赖prerequisites[i][1]的课程\n            map.set(prerequisites[i][1], [prerequisites[i][0]])\n        }\n    }\n    const queue:number[] = []//数组队列\n    for (let i = 0; i < inDegree.length; i++) {\n        if (inDegree[i] == 0) {//如果入度为0表示可先学习课程push到队列\n            queue.push(i)\n        }\n    }\n    let count:number = 0//选课次数\n    while (queue.length) {\n        const selected = queue.shift()//可选课程\n        count++ \n        const preSelect = map.get(selected) //依赖此课程的所有课程（是个数组）\n            if (preSelect && preSelect.length) {\n                //依赖此课程的课程入度都减1\n                for (let i = 0; i < preSelect.length; i++) {\n                    inDegree[preSelect[i]]--\n                    if (inDegree[preSelect[i]] == 0) {//入度为0可以学习push到队列\n                        queue.push(preSelect[i])\n                    }\n                }\n            }\n    }\n    return count == numCourses\n};"},{"script":"cpp","time":24,"memory":17.9,"desc":"拓扑排序。","code":"class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        int used_count = 0;\n        vector<unordered_set<int>> parr(numCourses);\n        vector<unordered_set<int>> carr(numCourses);\n        for (auto &item : prerequisites)\n            carr[item[0]].insert(item[1]),\n            parr[item[1]].insert(item[0]);\n        vector<int> q;\n        for (int i = 0; i < numCourses; i++) {\n            if (parr[i].empty()) q.push_back(i);\n        }\n        while (q.size()) {\n            int cur = q.back();\n            used_count++;\n            q.pop_back();\n            for (auto &child : carr[cur]) {\n                parr[child].erase(cur);\n                if (parr[child].empty()) q.push_back(child);\n            }\n        }\n        return used_count == numCourses;\n    }\n};","date":"2023-09-09"},{"script":"python","time":48,"memory":16.1,"desc":"同上。","code":"class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        used_count = 0\n        arr = [[set(),set()] for _ in range(numCourses)]\n        for [item1, item2] in prerequisites:\n            arr[item2][0].add(item1)\n            arr[item1][1].add(item2)\n        q = [i for i in range(numCourses) if not len(arr[i][0])]\n        while len(q):\n            cur = q.pop()\n            used_count += 1\n            for child in arr[cur][1]:\n                arr[child][0].remove(cur)\n                if not len(arr[child][0]):\n                    q.append(child)\n        return used_count == numCourses","date":"2023-09-09"},{"script":"rust","time":0,"memory":2.7,"desc":"同上。","code":"impl Solution {\n    pub fn can_finish(num_courses: i32, prerequisites: Vec<Vec<i32>>) -> bool {\n        use std::collections::HashSet;\n        let num_courses = num_courses as usize;\n        let mut used_count = 0;\n        let mut parr: Vec<HashSet<usize>> = vec![Default::default(); num_courses];\n        let mut carr: Vec<HashSet<usize>> = vec![Default::default(); num_courses];\n        for item in prerequisites {\n            let item0 = item[0] as usize;\n            let item1 = item[1] as usize;\n            carr[item0].insert(item1);\n            parr[item1].insert(item0);\n        }\n        let mut q: Vec<usize> = vec![];\n        for i in 0..num_courses {\n            if parr[i].is_empty() {\n                q.push(i);\n            }\n        }\n        while let Some(cur) = q.pop() {\n            used_count += 1;\n            for child in &carr[cur] {\n                parr[*child].remove(&cur);\n                if parr[*child].is_empty() {\n                    q.push(*child);\n                }\n            }\n        }\n        used_count == num_courses\n    }\n}","date":"2023-09-09"}],"tagList":["深度优先搜索","广度优先搜索","图","拓扑排序"],"level":"Medium"}},{"problemName":"208.实现Trie(前缀树).json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/208.实现Trie(前缀树).json","problemData":{"id":"208","name":"208.实现Trie(前缀树)","url":"https://leetcode.cn/problems/implement-trie-prefix-tree","desc":"请你实现 Trie 类。","solutions":[{"date":"2021-04-14","time":248,"memory":55.5,"script":"typescript","desc":"构建前缀树。","code":"class Trie {\n  private children = new Map<string, Trie>();\n  constructor(public char = '', public end = false) {}\n  insert(word: string): void {\n    if (word === '') {\n      this.end = true;\n      return;\n    }\n    const first = word[0];\n    let nextTrieNode = this.children.get(first);\n    if (!nextTrieNode)\n      this.children.set(first, (nextTrieNode = new Trie(first, word.length === 1)));\n    nextTrieNode.insert(word.substr(1));\n  }\n  search(word: string): boolean {\n    if (word === '') return this.end;\n    return !!this.children.get(word[0])?.search(word.substr(1));\n  }\n  startsWith(prefix: string): boolean {\n    if (prefix.length === 1) return this.children.has(prefix);\n    return !!this.children.get(prefix[0])?.startsWith(prefix.substr(1));\n  }\n}"},{"date":"2021-10-25","time":196,"memory":56.4,"script":"typescript","desc":"数组构建 trie。","code":"const MAX_COUNT = 26;\nconst getIdx = (ch: string) => ch.codePointAt(0)! - 'a'.codePointAt(0)!;\nclass TrieNode {\n  end = false;\n  children: TrieNode[] = new Array(MAX_COUNT);\n  constructor(public val: string) {}\n}\nclass Trie {\n  root = new TrieNode('');\n  insert(word: string): void {\n    let node = this.root;\n    for (const ch of word) {\n      const idx = getIdx(ch);\n      if (!node.children[idx]) node.children[idx] = new TrieNode(ch);\n      node = node.children[idx];\n    }\n    node.end = true;\n  }\n  findNode(word: string): TrieNode | null {\n    let node = this.root;\n    for (const ch of word) {\n      const idx = getIdx(ch);\n      if (!node.children[idx]) return null;\n      node = node.children[idx];\n    }\n    return node;\n  }\n  search(word: string): boolean {\n    return !!this.findNode(word)?.end;\n  }\n  startsWith(prefix: string): boolean {\n    return !!this.findNode(prefix);\n  }\n}"},{"date":"2021-10-25","time":244,"memory":55,"script":"typescript","desc":"构建 trie。","code":"class TrieNode {\n  end = false;\n  children: Record<string, TrieNode> = {};\n  constructor(public val: string) {}\n}\nclass Trie {\n  private root = new TrieNode('');\n  insert(word: string): void {\n    let node = this.root;\n    for (const ch of word) {\n      if (!node.children[ch]) node.children[ch] = new TrieNode(ch);\n      node = node.children[ch];\n    }\n    node.end = true;\n  }\n  private findNode(word: string): TrieNode | null {\n    let node = this.root;\n    for (const ch of word) {\n      if (!node.children[ch]) return null;\n      node = node.children[ch];\n    }\n    return node;\n  }\n  search(word: string): boolean {\n    return !!this.findNode(word)?.end;\n  }\n  startsWith(prefix: string): boolean {\n    return !!this.findNode(prefix);\n  }\n}"}],"tagList":["设计","字典树","哈希表","字符串"],"level":"Medium"}},{"problemName":"209.长度最小的子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/209.长度最小的子数组.json","problemData":{"id":"209","name":"209.长度最小的子数组","url":"https://leetcode.cn/problems/minimum-size-subarray-sum","desc":"给定一个含有  n  个正整数的数组和一个正整数  s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。","solutions":[{"date":"2020-06-28","time":68,"memory":36.3,"script":"typescript","desc":"双指针，滑动窗口。","code":"function minSubArrayLen(s: number, nums: number[]): number {\n  const len = nums.length;\n  let i = 0,\n    minLen = Infinity,\n    sum = 0;\n  for (let j = 0; j < len; j++) {\n    sum += nums[j];\n    while (sum >= s) {\n      minLen = Math.min(minLen, j - i + 1);\n      sum -= nums[i++];\n    }\n  }\n  return minLen === Infinity ? 0 : minLen;\n}"},{"date":"2021-12-24","time":4,"memory":10.2,"script":"cpp","desc":"双指针。","code":"class Solution {\n   public:\n    int minSubArrayLen(int target, vector<int>& nums) {\n        int l = 0, r = 0, num = 0, ans = INT_MAX, n = nums.size();\n        while (r < n) {\n            while (r < n && num < target) num += nums[r++];\n            while (l < r && num - nums[l] >= target) num -= nums[l++];\n            if (num >= target) ans = min(ans, r - l);\n            num -= nums[l++];\n        }\n        return ans == INT_MAX ? 0 : ans;\n    }\n};"}],"tagList":["数组","二分查找","前缀和","滑动窗口"],"level":"Medium"}},{"problemName":"210.课程表II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/210.课程表II.json","problemData":{"id":"210","name":"210.课程表II","url":"https://leetcode.cn/problems/course-schedule-ii","desc":"现在你总共有 n 门课需要选，记为  0  到  n-1。在选修某些课程之前需要一些先修课程。  例如，想要学习课程 0 ，你需要先完成课程  1 ，我们用一个匹配来表示他们: [0,1]给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。","solutions":[{"date":"2020-05-17","time":644,"memory":43.5,"script":"javascript","desc":"通过队列出栈无前置课程的课程，依次压栈。","code":"/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @return {number[]}\n */\nvar findOrder = function (numCourses, prerequisites) {\n  const course = [];\n  for (let i = 0; i < numCourses; i++) course[i] = new Course(i);\n  for (const [next, prev] of prerequisites) {\n    course[next].prev.push(course[prev]);\n    course[prev].next.push(course[next]);\n  }\n  const topo = [];\n  const queue = [];\n  for (let i = 0; i < numCourses; i++) if (!course[i].hasPrev()) queue.push(course[i]);\n  let time = 0;\n  let max = numCourses * (numCourses - 1);\n  while (queue.length !== 0) {\n    if (time++ > max) return [];\n    const course = queue.shift();\n    if (course.hasPrev()) {\n      queue.push(course);\n      continue;\n    }\n    topo.push(course);\n    if (!course.hasNext()) continue;\n    for (const next of course.next) {\n      if (!queue.includes(next)) queue.push(next);\n      next.prev = next.prev.filter(v => v !== course);\n    }\n  }\n  if (topo.length !== numCourses) return [];\n  return topo.map(v => v.val);\n};\nclass Course {\n  prev = [];\n  next = [];\n  constructor(val) {\n    this.val = val;\n  }\n  hasPrev() {\n    return this.prev.length !== 0;\n  }\n  hasNext() {\n    return this.next.length !== 0;\n  }\n}"},{"script":"python","time":48,"memory":17.51,"desc":"bfs。","code":"class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        used_count = 0\n        arr = [[set(),set()] for _ in range(numCourses)]\n        for [item1, item2] in prerequisites:\n            arr[item1][0].add(item2)\n            arr[item2][1].add(item1)\n        q = [i for i in range(numCourses) if not len(arr[i][0])]\n        res = []\n        while len(q):\n            cur = q.pop()\n            res.append(cur)\n            for child in arr[cur][1]:\n                arr[child][0].remove(cur)\n                if not len(arr[child][0]):\n                    q.append(child)\n        return res if numCourses == len(res) else []","date":"2023-09-10"}],"tagList":["深度优先搜索","广度优先搜索","图","拓扑排序"],"level":"Medium"}},{"problemName":"211.添加与搜索单词-数据结构设计.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/211.添加与搜索单词-数据结构设计.json","problemData":{"id":"211","name":"211.添加与搜索单词-数据结构设计","url":"https://leetcode.cn/problems/design-add-and-search-words-data-structure","desc":"请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。","solutions":[{"date":"2021-10-19","time":216,"memory":56.6,"script":"typescript","desc":"trie。","code":"class TrieNode {\n  end = false;\n  children: Map<string, TrieNode> = new Map();\n  constructor(public val: string) {}\n}\nclass Trie {\n  private _size = 0;\n  get size() {\n    return this._size;\n  }\n  get empty() {\n    return this._size === 0;\n  }\n  private _root = new TrieNode('');\n  get root() {\n    return this._root;\n  }\n  clear() {\n    this._root = new TrieNode('');\n    this._size = 0;\n  }\n  add(str: string) {\n    return this._add(str);\n  }\n  private _add(str: string, node = this._root) {\n    if (str.length === 0) {\n      this._root.end = true;\n      this._size++;\n      return;\n    }\n    if (str.length === 1) {\n      let endNode = node.children.get(str);\n      if (!endNode) node.children.set(str, (endNode = new TrieNode(str)));\n      if (!endNode.end) {\n        endNode.end = true;\n        this._size++;\n      }\n      return;\n    }\n    const first = str[0];\n    let nextNode = node.children.get(first);\n    if (!nextNode) node.children.set(first, (nextNode = new TrieNode(first)));\n    const nextStr = str.substr(1);\n    this._add(nextStr, nextNode);\n  }\n  contains(str: string) {\n    const endNode = this.findEndNode(str);\n    return endNode ? endNode.end : false;\n  }\n  remove(str: string) {\n    const endNode = this.findEndNode(str);\n    if (endNode && endNode.end) {\n      endNode.end = false;\n      this._size--;\n    }\n  }\n  starsWith(str: string) {\n    return this.findEndNode(str) !== null;\n  }\n  private findEndNode(str: string, node = this._root): TrieNode | null {\n    if (str.length === 0) return this._root;\n    if (str.length === 1) return node.children.get(str) ?? null;\n    const first = str[0];\n    let nextNode = node.children.get(first);\n    if (!nextNode) return null;\n    const nextStr = str.substr(1);\n    return this.findEndNode(nextStr, nextNode);\n  }\n}\n\nclass WordDictionary {\n  private trie = new Trie();\n  addWord(word: string): void {\n    this.trie.add(word);\n  }\n  search(word: string): boolean {\n    return this._search(0, word, this.trie.root);\n  }\n  private _search(idx: number, word: string, node: TrieNode): boolean {\n    const ch = word[idx];\n    if (idx === word.length - 1) {\n      if (ch === '.') return Array.from(node.children.values()).some(node => node.end);\n      const lastNode = node.children.get(ch);\n      return !!lastNode?.end;\n    }\n    if (ch === '.') {\n      for (const nextNode of node.children.values()) {\n        if (this._search(idx + 1, word, nextNode)) return true;\n      }\n      return false;\n    }\n    const nextNode = node.children.get(ch);\n    if (!nextNode) return false;\n    return this._search(idx + 1, word, nextNode);\n  }\n}"}],"tagList":["深度优先搜索","设计","字典树","字符串"],"level":"Medium"}},{"problemName":"212.单词搜索II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/212.单词搜索II.json","problemData":{"id":"212","name":"212.单词搜索II","url":"https://leetcode.cn/problems/word-search-ii","desc":"给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。","solutions":[{"date":"2021-09-16","time":4092,"memory":45.2,"script":"javascript","desc":"字典树。","code":"interface ITrie {\n        size: number;\n        empty: boolean;\n        add: (str: string) => void;\n        remove: (str: string) => void;\n        clear: () => void;\n        contains: (str: string) => boolean;\n        starsWith: (str: string) => boolean;\n      }\n      class TrieNode {\n        end = false;\n        children: Map<string, TrieNode> = new Map();\n        constructor(public val: string) {}\n      }\n      class Trie implements ITrie {\n        private _size = 0;\n        get size() {\n          return this._size;\n        }\n        get empty() {\n          return this._size === 0;\n        }\n        private root = new TrieNode('');\n        clear() {\n          this.root = new TrieNode('');\n          this._size = 0;\n        }\n        add(str: string) {\n          return this._add(str);\n        }\n        private _add(str: string, node = this.root) {\n          if (str.length === 0) {\n            this.root.end = true;\n            this._size++;\n            return;\n          }\n          if (str.length === 1) {\n            let endNode = node.children.get(str);\n            if (!endNode) node.children.set(str, (endNode = new TrieNode(str)));\n            if (!endNode.end) {\n              endNode.end = true;\n              this._size++;\n            }\n            return;\n          }\n          const first = str[0];\n          let nextNode = node.children.get(first);\n          if (!nextNode) node.children.set(first, (nextNode = new TrieNode(first)));\n          const nextStr = str.substr(1);\n          this._add(nextStr, nextNode);\n        }\n        contains(str: string) {\n          const endNode = this.findEndNode(str);\n          return endNode ? endNode.end : false;\n        }\n        remove(str: string) {\n          const endNode = this.findEndNode(str);\n          if (endNode && endNode.end) {\n            endNode.end = false;\n            this._size--;\n          }\n        }\n        starsWith(str: string) {\n          return this.findEndNode(str) !== null;\n        }\n        private findEndNode(str: string, node = this.root): TrieNode | null {\n          if (str.length === 0) return this.root;\n          if (str.length === 1) return node.children.get(str) ?? null;\n          const first = str[0];\n          let nextNode = node.children.get(first);\n          if (!nextNode) return null;\n          const nextStr = str.substr(1);\n          return this.findEndNode(nextStr, nextNode);\n        }\n      }\n      function findWords(board: string[][], words: string[]): string[] {\n        const trie = new Trie();\n        let maxWordLen = 0;\n        words.forEach(word => {\n          trie.add(word);\n          maxWordLen = Math.max(maxWordLen, word.length);\n        });\n        const rowLen = board.length;\n        const colLen = board[0].length;\n        const ans = new Set<string>();\n        const format = (row: number, col: number) => `${row}::${col}`;\n        const set = new Set<string>();\n        const starts: [number, number][] = [];\n        for (let row = 0; row < rowLen; row++) {\n          for (let col = 0; col < colLen; col++) {\n            if (trie.starsWith(board[row][col])) starts.push([row, col]);\n          }\n        }\n        starts.forEach(v => find(...v));\n        return Array.from(ans);\n        function find(row: number, col: number, str: string = ''): void {\n          const formatStr = format(row, col);\n          if (\n            set.has(formatStr) ||\n            str.length > maxWordLen ||\n            ans.size === words.length ||\n            row === -1 ||\n            row === rowLen ||\n            col === -1 ||\n            col === colLen\n          )\n            return;\n          str += board[row][col];\n          if (trie.contains(str)) ans.add(str);\n          set.add(formatStr);\n          find(row, col - 1, str);\n          find(row, col + 1, str);\n          find(row - 1, col, str);\n          find(row + 1, col, str);\n          set.delete(formatStr);\n        }\n      }"}],"tagList":["字典树","数组","字符串","回溯","矩阵"],"level":"Hard"}},{"problemName":"213.打家劫舍II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/213.打家劫舍II.json","problemData":{"id":"213","name":"213.打家劫舍II","url":"https://leetcode.cn/problems/house-robber-ii","desc":"给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，能够偷窃到的最高金额。","solutions":[{"date":"2021-04-15","time":108,"memory":39.5,"script":"typescript","desc":"动态规划，考虑到头尾相接，分别考虑第一个偷和不偷的情况。","code":"function rob(nums: number[]): number {\n  const size = nums.length;\n  if (size === 1) return nums[0];\n  let max = 0;\n  const dp: number[][] = new Array(size).fill(0).map(_ => new Array(2));\n  const traversal = () => {\n    for (let i = 1; i < size; i++) {\n      dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);\n      dp[i][1] = dp[i - 1][0] + nums[i];\n    }\n  };\n  // 第一个不偷\n  dp[0][0] = 0;\n  dp[0][1] = 0;\n  traversal();\n  max = Math.max(dp[size - 1][0], dp[size - 1][1]);\n  // 第一个偷\n  dp[0][1] = nums[0];\n  traversal();\n  max = Math.max(max, dp[size - 1][0]);\n  return max;\n}"},{"date":"2021-09-13","time":84,"memory":41.5,"script":"typescript","desc":"动态规划。","code":"function rob(nums: number[]): number {\n  const n = nums.length;\n  if (n < 3) return Math.max(...nums);\n  /**\n   * 0 => 偷\n   * 1 => 不偷\n   * dp(i,j,k) = 第i个房子是否偷(j)且第一个房子是否偷(k)\n   */\n  const dp = new Array(n).fill(0).map(_ => new Array(2).fill(0).map(_ => new Array(2).fill(0)));\n  dp[0][0][0] = nums[0];\n  dp[1][0][1] = nums[1];\n  dp[1][1][0] = nums[0];\n  for (let i = 2; i < n; i++) {\n    dp[i][0][0] = Math.max(Math.max(dp[i - 2][0][0], dp[i - 2][1][0]) + nums[i], dp[i - 1][1][0]);\n    dp[i][0][1] = Math.max(Math.max(dp[i - 2][0][1], dp[i - 2][1][1]) + nums[i], dp[i - 1][1][1]);\n    dp[i][1][0] = Math.max(dp[i - 1][0][0], dp[i - 1][1][0]);\n    dp[i][1][1] = dp[i - 1][0][1];\n  }\n  return Math.max(dp[n - 1][0][1], dp[n - 1][1][0], dp[n - 1][1][1]);\n}"},{"date":"2021-09-13","time":84,"memory":40.3,"script":"typescript","desc":"动态规划优化。","code":"function rob(nums: number[]): number {\n  const n = nums.length;\n  if (n < 3) return Math.max(...nums);\n  /**\n   * 0 => 偷\n   * 1 => 不偷\n   * dp(i,j,k) = 第i个房子是否偷(j)且第一个房子是否偷(k)\n   */\n  const dp = new Array(3).fill(0).map(_ => new Array(2).fill(0).map(_ => new Array(2).fill(0)));\n  dp[0][0][0] = nums[0];\n  dp[1][0][1] = nums[1];\n  dp[1][1][0] = nums[0];\n  for (let i = 2; i < n; i++) {\n    const idx = i % 3;\n    const prevIdx = (i - 1) % 3;\n    const prevIdx2 = (i - 2) % 3;\n    dp[idx][0][0] = Math.max(\n      Math.max(dp[prevIdx2][0][0], dp[prevIdx2][1][0]) + nums[i],\n      dp[prevIdx][1][0]\n    );\n    dp[idx][0][1] = Math.max(\n      Math.max(dp[prevIdx2][0][1], dp[prevIdx2][1][1]) + nums[i],\n      dp[prevIdx][1][1]\n    );\n    dp[idx][1][0] = Math.max(dp[prevIdx][0][0], dp[prevIdx][1][0]);\n    dp[idx][1][1] = dp[prevIdx][0][1];\n    console.log(i, dp);\n  }\n  const lastIdx = (n - 1) % 3;\n  return Math.max(dp[lastIdx][0][1], dp[lastIdx][1][0], dp[lastIdx][1][1]);\n}"},{"script":"cpp","time":0,"memory":8.26,"desc":"dp[0][j]表示首个不选的时候最大值，dp[1][j]表示首个选的时候最大值。","code":"class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int n = nums.size();\n        vector<vector<int>> dp(n + 1, vector<int>(2, 0));\n        dp[1][1] = nums[0];\n        int res = nums[0];\n        for (int i = 2; i < n + 1; i++) {\n            dp[i][0] = max(dp[i - 1][0], dp[i - 2][0] + nums[i - 1]);\n            if (i != n)  dp[i][1] = max(dp[i - 1][1], dp[i - 2][1] + nums[i - 1]);\n            res = max(res, max(dp[i][0], dp[i][1]));\n        }\n        return res;\n    }\n};\n","date":"2023-09-17"},{"script":"python","time":32,"memory":15.9,"desc":"同上。","code":"class Solution:\n    def rob(self, nums: List[int]) -> int:\n        n = len(nums)\n        dp = [[0, 0] for _ in range(n + 1)]\n        dp[1][1] = nums[0]\n        res = nums[0]\n        for i in range(2, n + 1):\n            dp[i][0] = max(dp[i - 1][0], dp[i - 2][0] + nums[i - 1])\n            if i != n:\n                dp[i][1] = max(dp[i - 1][1], dp[i - 2][1] + nums[i - 1])\n            res = max(res, dp[i][0], dp[i][1])\n        return res","date":"2023-09-17"},{"script":"rust","time":0,"memory":1.93,"desc":"同上。","code":"impl Solution {\n    pub fn rob(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        let mut dp = vec![vec![0; 2]; n + 1];\n        dp[1][1] = nums[0];\n        let mut res = nums[0];\n        for i in 2..n + 1 {\n            dp[i][0] = dp[i - 1][0].max(dp[i - 2][0] + nums[i - 1]);\n            if i != n {\n                dp[i][1] = dp[i - 1][1].max(dp[i - 2][1] + nums[i - 1]);\n            }\n            res = res.max(dp[i][0].max(dp[i][1]))\n        }\n        res\n    }\n}","date":"2023-09-17"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"214.最短回文串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/214.最短回文串.json","problemData":{"id":"214","name":"214.最短回文串","url":"https://leetcode.cn/problems/shortest-palindrome","desc":"给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。","solutions":[{"date":"2020-08-29","time":1164,"memory":40.5,"script":"typescript","desc":"通过判断每个子串是否为回文，如果是则添加后续字串。","code":"function shortestPalindrome(s: string): string {\n  if (isPalindrome(s)) return s;\n  for (let i = s.length - 1; i >= 0; i--) {\n    const subS = s.substring(0, i);\n    if (!isPalindrome(subS)) continue;\n    return s.substr(i).split('').reverse().join('') + s;\n  }\n  return '';\n  function isPalindrome(s: string) {\n    let l = 0;\n    let r = s.length - 1;\n    while (l < r) {\n      if (s[l] !== s[r]) return false;\n      l++;\n      r--;\n    }\n    return true;\n  }\n}"},{"date":"2021-10-15","time":68,"memory":44.4,"script":"typescript","desc":"kmp。","code":"function shortestPalindrome(s: string): string {\n  const n = s.length;\n  let str = s + '#';\n  for (let i = n - 1; i >= 0; i--) str += s[i];\n  const next = [-1];\n  for (let i = 1, j = -1; i < n * 2 + 1; i++) {\n    while (j !== -1 && str[j + 1] !== str[i]) j = next[j];\n    if (str[j + 1] === str[i]) j++;\n    next[i] = j;\n  }\n  const idx = next[2 * n];\n  let ans = s;\n  for (let i = Math.max(0, idx + 1); i < n; i++) ans = s[i] + ans;\n  return ans;\n}"}],"tagList":["字符串","字符串匹配","哈希函数","滚动哈希"],"level":"Hard"}},{"problemName":"215.数组中的第K个最大元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/215.数组中的第K个最大元素.json","problemData":{"id":"215","name":"215.数组中的第K个最大元素","url":"https://leetcode.cn/problems/kth-largest-element-in-an-array","desc":"在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。","solutions":[{"date":"2020-06-29","time":88,"memory":35.9,"script":"typescript","desc":"构建大顶堆即可。","code":"class Heap {\n  get size(): number {\n    return this._elemenets.length;\n  }\n  constructor(private _elemenets: number[]) {\n    this.heapify();\n  }\n  heapify(): void {\n    for (let i = (this.size >> 1) - 1; i >= 0; i--) {\n      this.siftDown(i);\n    }\n  }\n  remove(): number {\n    const root = this._elemenets[0];\n    this._elemenets[0] = this._elemenets.pop() as number;\n    this.siftDown(0);\n    return root;\n  }\n  siftDown(index: number) {\n    const element = this._elemenets[index];\n    const half = this.size >> 1;\n    while (index < half) {\n      let childIndex = (index << 1) + 1;\n      let child = this._elemenets[childIndex];\n      const rightIndex = childIndex + 1;\n      if (rightIndex < this.size && this._elemenets[rightIndex] > child) {\n        child = this._elemenets[(childIndex = rightIndex)];\n      }\n      if (element >= child) break;\n      this._elemenets[index] = child;\n      index = childIndex;\n    }\n    this._elemenets[index] = element;\n  }\n}\nfunction findKthLargest(nums: number[], k: number): number {\n  const heap = new Heap(nums);\n  for (let i = 1; i < k; i++) {\n    heap.remove();\n  }\n  return heap.remove();\n}"}],"tagList":["数组","分治","快速选择","排序","堆（优先队列）"],"level":"Medium"}},{"problemName":"216.组合总和III.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/216.组合总和III.json","problemData":{"id":"216","name":"216.组合总和III","url":"https://leetcode.cn/problems/combination-sum-iii","desc":"找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。","solutions":[{"date":"2020-09-11","time":76,"memory":37.7,"script":"typescript","desc":"回溯递归。","code":"function combinationSum3(k: number, n: number): number[][] {\n  const ans: number[][] = [];\n  const used: number[] = [];\n  dfs(k, n);\n  return ans;\n  function dfs(count: number, sum: number): void {\n    if (count === 1) {\n      if (sum >= 1 && sum <= 9 && sum > used[used.length - 1]) ans.push([...used, sum]);\n      return;\n    }\n    const max = used[used.length - 1] || 0;\n    for (let i = max + 1; i <= 9; i++) {\n      if (used.includes(i)) continue;\n      used.push(i);\n      dfs(count - 1, sum - i);\n      used.pop();\n    }\n  }\n}"},{"script":"python","time":42,"memory":16.42,"desc":"dfs。","code":"class Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        res = []\n        def dfs(num: int, k: int, n: int, arr: List[int]):\n            if k == 0:\n                if arr and n == 0:\n                    res.append(arr[:])\n            elif n < 0: return\n            elif num == 10: return\n            else:\n                arr.append(num)\n                dfs(num + 1, k - 1, n - num, arr)\n                arr.pop()\n                dfs(num + 1, k, n, arr)\n        dfs(1, k, n, [])\n        return res","date":"2024-04-21"}],"tagList":["数组","回溯"],"level":"Medium"}},{"problemName":"217.存在重复元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/217.存在重复元素.json","problemData":{"id":"217","name":"217.存在重复元素","url":"https://leetcode.cn/problems/contains-duplicate","desc":"给定一个整数数组，判断是否存在重复元素。","solutions":[{"date":"2020-12-13","time":100,"memory":44.5,"script":"typescript","desc":"利用 set 去重。","code":"function containsDuplicate(nums: number[]): boolean {\n  return new Set(nums).size !== nums.length;\n}"}],"tagList":["数组","哈希表","排序"],"level":"Easy"}},{"problemName":"218.天际线问题.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/218.天际线问题.json","problemData":{"id":"218","name":"218.天际线问题","url":"https://leetcode.cn/problems/the-skyline-problem","desc":"城市的天际线是从远处观看该城市中所有建筑物形成的轮廓的外部轮廓。给你所有建筑物的位置和高度，请返回由这些建筑物形成的 天际线 。","solutions":[{"date":"2021-07-13","time":392,"memory":46.2,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/the-skyline-problem/solution/js-sao-miao-xian-fa-jian-dan-yi-dong-by-fleetingso/)。","code":"function getSkyline(buildings: number[][]): number[][] {\n  const list: [number, number][] = [];\n  buildings.forEach(([l, r, h]) => list.push([l, -h], [r, h]));\n  list.sort(([i1, h1], [i2, h2]) => (i1 === i2 ? h1 - h2 : i1 - i2));\n  const heights: number[] = [0];\n  const remove = (h: number) => {\n    for (let i = 0, l = heights.length; i < l; i++)\n      if (heights[i] === h) {\n        heights.splice(i, 1);\n        return;\n      }\n  };\n  let ans: number[][] = [];\n  let preH: number | null = null;\n  for (const [idx, h] of list) {\n    if (h < 0) heights.push(-h);\n    else remove(h);\n    let maxH = Math.max(...heights);\n    if (preH !== maxH) ans.push([idx, (preH = maxH)]);\n  }\n  return ans;\n}"}],"tagList":["树状数组","线段树","数组","分治","有序集合","扫描线","堆（优先队列）"],"level":"Hard"}},{"problemName":"219.存在重复元素II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/219.存在重复元素II.json","problemData":{"id":"219","name":"219.存在重复元素II","url":"https://leetcode.cn/problems/contains-duplicate-ii","desc":"给定一个整数数组和一个整数  k，判断数组中是否存在两个不同的索引  i  和  j，使得  nums [i] = nums [j]，并且 i 和 j  的差的 绝对值 至多为 k。","solutions":[{"date":"2021-11-30","time":140,"memory":42.4,"script":"c","desc":"哈希表存储值和下标。","code":"typedef struct hashTable{\n    int key;\n    int idx;\n    UT_hash_handle hh;\n} hashTable;\nbool containsNearbyDuplicate(int* nums, int numsSize, int k){\n    hashTable* map = NULL;\n    for (int i = 0; i < numsSize; i++) {\n        hashTable* temp = NULL;\n        HASH_FIND_INT(map, &nums[i], temp);\n        if (temp) {\n            if (i - temp->idx <= k) return 1;\n            else temp->idx = i;\n        } else {\n            temp = (hashTable*)malloc(sizeof(hashTable));\n            temp->key = nums[i];\n            temp->idx = i;\n            HASH_ADD_INT(map, key, temp);\n        }\n    }\n    return 0;\n}"},{"date":"2022-01-19","time":188,"memory":75.3,"script":"cpp","desc":"哈希存储。","code":"class Solution {\n   public:\n    bool containsNearbyDuplicate(vector<int>& nums, int k) {\n        unordered_map<int, int> m;\n        for (int i = 0; i < nums.size(); i++) {\n            if (m.count(nums[i]) && i - m[nums[i]] <= k) return 1;\n            m[nums[i]] = i;\n        }\n        return 0;\n    }\n};"}],"tagList":["数组","哈希表","滑动窗口"],"level":"Easy"}},{"problemName":"220.存在重复元素III.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/220.存在重复元素III.json","problemData":{"id":"220","name":"220.存在重复元素III","url":"https://leetcode.cn/problems/contains-duplicate-iii","desc":"给你一个整数数组 nums 和两个整数  k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得  abs(nums[i] - nums[j]) <= t ，同时又满足 abs(i - j) <= k 。如果存在则返回 true，不存在返回 false。","solutions":[{"date":"2021-04-17","time":176,"memory":56.9,"script":"typescript","desc":"利用 map 储存后排序计算。","code":"function containsNearbyAlmostDuplicate(nums: number[], k: number, t: number): boolean {\n  if (k === 0) return false;\n  const map = new Map<number, number[]>();\n  for (let i = 0, len = nums.length; i < len; i++) {\n    const num = nums[i];\n    let arr = map.get(num);\n    if (!arr) map.set(num, (arr = []));\n    arr.push(i);\n  }\n  const data = [...map.entries()].sort(([num1], [num2]) => num1 - num2);\n  const check = (arr1: number[], arr2: number[]) =>\n    (arr1[arr1.length] < arr2[0] && Math.abs(arr1[arr1.length] - arr2[0]) <= k) ||\n    (arr2[arr2.length] < arr1[0] && Math.abs(arr2[arr2.length] - arr1[0]) <= k) ||\n    arr1.some(i1 => arr2.some(i2 => Math.abs(i1 - i2) <= k));\n  for (let i = 0, l = data.length; i < l; i++) {\n    const arr1 = data[i][1];\n    if (arr1.some((v, i, arr) => (i === 0 ? false : v - arr[i - 1] <= k))) return true;\n    let index = i - 1;\n    while (index >= 0 && data[i][0] - data[index][0] <= t)\n      if (check(arr1, data[index--][1])) return true;\n  }\n  return false;\n}"},{"date":"2021-08-15","time":864,"memory":46.3,"script":"typescript","desc":"针对每次窗口进行二分排序。","code":"class SortSet {\n  set = new Set<number>();\n  initSuccess = true;\n  constructor(public arr: number[], public k: number) {\n    arr.sort((a, b) => a - b);\n    if (this.check()) {\n      this.initSuccess = false;\n      return;\n    }\n    for (const num of arr) {\n      if (this.set.has(num)) {\n        this.initSuccess = false;\n        break;\n      }\n      this.set.add(num);\n    }\n  }\n  add(num: number): boolean {\n    if (this.set.has(num)) return false;\n    let l = 0;\n    let r = this.arr.length - 1;\n    while (l < r) {\n      const mid = (l + r) >> 1;\n      if (this.arr[mid] >= num) r = mid;\n      else l = mid + 1;\n    }\n    this.arr.splice(this.arr[l] < num ? this.arr.length : l, 0, num);\n    this.set.add(num);\n    return true;\n  }\n  del(num: number): void {\n    let l = 0;\n    let r = this.arr.length - 1;\n    let mid!: number;\n    while (l <= r) {\n      mid = (l + r) >> 1;\n      if (this.arr[mid] > num) r = mid - 1;\n      else if (this.arr[mid] < num) l = mid + 1;\n      else break;\n    }\n    this.arr.splice(mid, 1);\n    this.set.delete(num);\n  }\n  check(): boolean {\n    for (let i = 0; i < this.arr.length - 1; i++) {\n      if (this.arr[i + 1] - this.arr[i] <= this.k) return true;\n    }\n    return false;\n  }\n}\nfunction containsNearbyAlmostDuplicate(nums: number[], k: number, t: number): boolean {\n  const n = nums.length;\n  const set = new SortSet(nums.slice(0, k + 1), t);\n  if (!set.initSuccess) return true;\n  for (let i = k + 1; i < n; i++) {\n    set.del(nums[i - k - 1]);\n    if (!set.add(nums[i])) return true;\n    if (set.check()) return true;\n  }\n  return false;\n}"}],"tagList":["数组","桶排序","有序集合","排序","滑动窗口"],"level":"Hard"}},{"problemName":"221.最大正方形.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/221.最大正方形.json","problemData":{"id":"221","name":"221.最大正方形","url":"https://leetcode.cn/problems/maximal-square","desc":"在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。","solutions":[{"date":"2020-05-08","time":440,"memory":74.3,"script":"javascript","desc":"先把字符串转换为后缀表达式，然后再利用栈计算。","code":"/**\n * @param {character[][]} matrix\n * @return {number}\n */\nvar maximalSquare = function (matrix) {\n  function isAllOne(i, j) {\n    let b = false;\n    try {\n      b = matrix[i + 1][j + 1] === '1' && matrix[i][j + 1] === '1' && matrix[i + 1][j] === '1';\n    } catch (error) {}\n    return b;\n  }\n  let max = 0;\n  for (let i = 0; i < matrix.length; i++) {\n    for (let j = 0; j < matrix[i].length; j++) {\n      if (matrix[i][j] === '0') continue;\n      let width = 1;\n      let size = 1;\n      let temp = [];\n      const queue = [[i, j]];\n      while (queue.length !== 0) {\n        const [nextI, nextJ] = queue.shift();\n        if (!isAllOne(nextI, nextJ)) break;\n        temp.push([nextI, nextJ + 1], [nextI + 1, nextJ], [nextI + 1, nextJ + 1]);\n        if (--size === 0) {\n          queue.push(...temp);\n          size = temp.length;\n          temp.length = 0;\n          width++;\n        }\n      }\n      max = Math.max(max, width);\n    }\n  }\n  return max ** 2;\n};"}],"tagList":["数组","动态规划","矩阵"],"level":"Medium"}},{"problemName":"222.完全二叉树的节点个数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/222.完全二叉树的节点个数.json","problemData":{"id":"222","name":"222.完全二叉树的节点个数","url":"https://leetcode.cn/problems/count-complete-tree-nodes","desc":"给出一个完全二叉树，求出该树的节点个数。","solutions":[{"date":"2020-11-24","time":108,"memory":57.1,"script":"typescript","desc":"深度遍历。","code":"function countNodes(root: TreeNode | null): number {\n  return root === null ? 0 : countNodes(root.left) + countNodes(root.right) + 1;\n}"}],"tagList":["位运算","树","二分查找","二叉树"],"level":"Easy"}},{"problemName":"223.矩形面积.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/223.矩形面积.json","problemData":{"id":"223","name":"223.矩形面积","url":"https://leetcode.cn/problems/rectangle-area","desc":"给你 二维 平面上两个 由直线构成的 矩形，请你计算并返回两个矩形覆盖的总面积。","solutions":[{"date":"2021-09-30","time":140,"memory":44.8,"script":"typescript","desc":"统计 ab 面积和覆盖面积。","code":"function computeArea(\n  ax1: number,\n  ay1: number,\n  ax2: number,\n  ay2: number,\n  bx1: number,\n  by1: number,\n  bx2: number,\n  by2: number\n): number {\n  if (bx1 < ax1)\n    [ax1, ay1, ax2, ay2, bx1, by1, bx2, by2] = [bx1, by1, bx2, by2, ax1, ay1, ax2, ay2];\n  const comp = (x1: number, y1: number, x2: number, y2: number) => (x2 - x1) * (y2 - y1);\n  const areaA = comp(ax1, ay1, ax2, ay2);\n  const areaB = comp(bx1, by1, bx2, by2);\n  if (bx1 > ax2 || by1 > ay2 || by2 < ay1) return areaA + areaB;\n  const areaC = comp(\n    Math.max(ax1, bx1),\n    Math.max(ay1, by1),\n    Math.min(ax2, bx2),\n    Math.min(ay2, by2)\n  );\n  return areaA + areaB - areaC;\n}"}],"tagList":["几何","数学"],"level":"Medium"}},{"problemName":"224.基本计算器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/224.基本计算器.json","problemData":{"id":"224","name":"224.基本计算器","url":"https://leetcode.cn/problems/basic-calculator","desc":"实现一个基本的计算器来计算一个简单的字符串表达式的值字符串表达式可以包含左括号 ( ，右括号 )，加号 + ，减号 -，非负整数和空。","solutions":[{"date":"2020-02-16","time":145,"memory":76.4,"script":"java","desc":"先把字符串转换为后缀表达式，然后再利用栈计算。","code":"class Solution {\n    public int calculate(String s) {\n\t\tStack<String> stack1 = new Stack<String>();\n\t\tStack<String> stack2 = new Stack<String>();\n\t\tint len = s.length();\n\t\tString tem = \"\";\n\t\tfor (int i = 0; i < len; i++) {\n//\t\t\tSystem.out.println(\"tem:\" + tem);\n//\t\t\tSystem.out.println(\"stack1:\" + stack1);\n//\t\t\tSystem.out.println(\"stack2:\" + stack2);\n\t\t\tString ch = s.charAt(i) + \"\";\n\t\t\tif (ch.compareTo(\" \") == 0)\n\t\t\t\tcontinue;\n\t\t\tif (ch.compareTo(\"+\") == 0 || ch.compareTo(\"-\") == 0 || ch.compareTo(\"(\") == 0) {\n\t\t\t\tstack1.push(ch);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ch.compareTo(\")\") == 0) {\n\t\t\t\tstack1.pop();\n\t\t\t\tif (!stack1.isEmpty())\n\t\t\t\t\tstack2.push(stack1.pop());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i != len - 1 && s.charAt(i + 1) >= 48 && s.charAt(i) <= 57) {\n//\t\t\t\tSystem.out.println(1);\n\t\t\t\ttem += ch;\n\t\t\t\tcontinue;\n\t\t\t} else {\n//\t\t\t\tSystem.out.println(2);\n\t\t\t\tif(tem.compareTo(\"\")!=0) {\n\t\t\t\t\tch = tem+ch;\n\t\t\t\t\ttem = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack2.push(ch);\n\t\t\tif (stack1.isEmpty())\n\t\t\t\tcontinue;\n\t\t\tif (stack1.peek().compareTo(\"+\") == 0 || stack1.peek().compareTo(\"-\") == 0) {\n\t\t\t\tstack2.push(stack1.pop());\n\t\t\t}\n\t\t}\n\n//\t\tSystem.out.println(stack2);\n\t\tDeque<String> tokens = new LinkedList<String>();\n\t\twhile (!stack2.isEmpty()) {\n\t\t\ttokens.offerFirst(stack2.pop() + \"\");\n\t\t}\n//\t\tSystem.out.println(tokens);\n\t\treturn evalRPN(tokens);\n//\t\treturn evalRPN(\"\");\n\t}\n\n\tpublic int evalRPN(Deque<String> tokens) {\n\t\tStack<String> stack = new Stack<String>();\n\t\tint a, b;\n\t\tfor (String s : tokens) {\n\t\t\tswitch (s) {\n\t\t\tcase \"+\":\n\t\t\t\ta = Integer.parseInt(stack.pop());\n\t\t\t\tb = Integer.parseInt(stack.pop());\n\t\t\t\tstack.push((a + b) + \"\");\n\t\t\t\tbreak;\n\t\t\tcase \"-\":\n\t\t\t\ta = Integer.parseInt(stack.pop());\n\t\t\t\tb = Integer.parseInt(stack.pop());\n\t\t\t\tstack.push((b - a) + \"\");\n\t\t\t\tbreak;\n\t\t\tcase \"*\":\n\t\t\t\ta = Integer.parseInt(stack.pop());\n\t\t\t\tb = Integer.parseInt(stack.pop());\n\t\t\t\tstack.push((a * b) + \"\");\n\t\t\t\tbreak;\n\t\t\tcase \"/\":\n\t\t\t\ta = Integer.parseInt(stack.pop());\n\t\t\t\tb = Integer.parseInt(stack.pop());\n\t\t\t\tstack.push((b / a) + \"\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstack.push(s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn Integer.parseInt(stack.pop());\n\t}\n\n}"},{"date":"2021-03-10","time":148,"memory":44.9,"script":"typescript","desc":"利用栈依次计算，并转换减法为加法。","code":"const numReg = /\\-?\\d+/;\nconst opReg = /\\+|\\-/;\nconst squareReg = /\\(|\\)/;\nconst opMap: Record<string, (num1: number, num2: number) => number> = {\n  '+': (num1, num2) => num1 + num2,\n  '-': (num1, num2) => num1 - num2,\n  '*': (num1, num2) => num1 * num2,\n  '/': (num1, num2) => num1 / num2,\n};\nconst emptyReg = / /g;\nfunction calculate(s: string): number {\n  s = s.replace(emptyReg, '');\n  const stack: string[] = [];\n  const peek = () => stack[stack.length - 1];\n  if (s[0] === '-') s = '0' + s;\n  const len = s.length;\n  for (let i = 0; i < len; i++) {\n    let c = s[i];\n    if (opReg.test(c) || c === '(') {\n      stack.push(c);\n    } else if (c === ')') {\n      let c = 0;\n      let str = '';\n      while (peek() !== '(') {\n        str = stack.pop()! + str;\n        cpp;\n      }\n      stack.pop();\n      str = (c === 1 ? str : calculate(str)) + '';\n      if (peek() === '-') {\n        stack[stack.length - 1] = '+';\n        str = str.startsWith('-') ? str.substring(1) : '-' + str;\n      }\n      stack.push(str);\n    } else {\n      while (i < len - 1 && numReg.test(s[i + 1])) {\n        c += s[++i];\n      }\n      if (peek() === '-') {\n        c = stack.pop()! + c;\n        if (numReg.test(peek())) stack.push('+');\n      }\n      const top = peek();\n      if (opReg.test(top)) {\n        const op = stack.pop()!;\n        const num1 = stack.pop()!;\n        stack.push(opMap[op](Number(num1), Number(c)) + '');\n      } else {\n        stack.push(c);\n      }\n    }\n  }\n  return stack.length === 1 ? Number(stack[0]) : calculate(stack.join(''));\n}"}],"tagList":["栈","递归","数学","字符串"],"level":"Hard"}},{"problemName":"225.用队列实现栈.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/225.用队列实现栈.json","problemData":{"id":"225","name":"225.用队列实现栈","url":"https://leetcode.cn/problems/implement-stack-using-queues","desc":"使用队列实现栈的下列操作：push(x) -- 元素 x 入栈，pop() -- 移除栈顶元素，top() -- 获取栈顶元素，empty() -- 返回栈是否为空。","solutions":[{"date":"2020-02-16","time":0,"memory":40.8,"script":"java","desc":"使用双端队列构建。","code":"class MyStack {\n    private Deque<Integer> deue;\n    public MyStack() {\n        deue=new LinkedList<Integer>();\n    }\n    public void push(int x) {\n        deue.offerLast(x);\n    }\n    public int pop() {\n    \treturn deue.pollLast();\n    }\n    public int top() {\n        return deue.getLast();\n    }\n    public boolean empty() {\n        return deue.isEmpty();\n    }\n}"},{"date":"2021-11-24","time":0,"memory":5.7,"script":"typescript","desc":"queue。","code":"// #define DEBUG\n#ifdef DEBUG\n#define log(frm, args...)    \\\n    {                        \\\n        printf(frm, ##args); \\\n    }\n#else\n#define log(frm, args...)\n#endif\n\ntypedef struct Node{\n    int val;\n    struct Node *prev, *next;\n} Node;\nNode *createNode(int val){\n    Node *node = (Node *)malloc(sizeof(Node));\n    node->val = val;\n    node->prev = NULL;\n    node->next = NULL;\n    return node;\n}\ntypedef struct {\n    int size;\n    Node *head, *tail;\n} Queue;\nQueue *ceateQueue(){\n    Queue *q = (Queue *)malloc(sizeof(Queue));\n    q->size = 0;\n    q->tail = q->head = NULL;\n    return q;\n}\nvoid enQueue(Queue *q, int val){\n    Node *node = createNode(val);\n    if (q->size == 0) {\n        q->head = q->tail = node;\n    } else {\n        node->prev = q->tail;\n        q->tail->next = node;\n        q->tail = node;\n    }\n    q->size++;\n    log(\"enQueue %d success, head = %d, tail = %d\\n\", val, q->head->val, q->tail->val);\n}\nint isQueueEmpty(Queue *q) {\n    return q->size == 0;\n}\nint queueTop(Queue *q){\n    if (isQueueEmpty(q)) return -1;\n    return q->head->val;\n}\nint deQueue(Queue *q) {\n    if (isQueueEmpty(q)) return -1;\n    if (q->size == 1) {\n        Node *node = q->head;\n        int val = node->val;\n        q->tail = q->head = NULL;\n        free(node);\n        q->size = 0;\n        return val;\n    }\n    Node *node = q->head;\n    node->next->prev = NULL;\n    int val = node->val;\n    q->head = node->next;\n    free(node);\n    q->size--;\n    return val;\n}\nvoid freeQueue(Queue *q){\n    while(q->size) deQueue(q);\n    free(q);\n}\n\ntypedef struct {\n    int size;\n    Queue *q1, *q2;\n} MyStack;\n\nMyStack* myStackCreate() {\n    MyStack *s = (MyStack *)malloc(sizeof(MyStack));\n    s->q1 = ceateQueue();\n    s->q2 = ceateQueue();\n    return s;\n}\n\nvoid myStackPush(MyStack* obj, int x) {\n    log(\"push %d\\n\", x);\n    enQueue(obj->q1, x);\n    log(\"push %d successfully\\n\", x);\n}\n\nint myStackPop(MyStack* obj) {\n    while(obj->q1->size > 1) enQueue(obj->q2, deQueue(obj->q1));\n    int val = deQueue(obj->q1);\n    while(obj->q2->size) enQueue(obj->q1, deQueue(obj->q2));\n    return val;\n}\n\nint myStackTop(MyStack* obj) {\n    return obj->q1->tail->val;\n}\n\nbool myStackEmpty(MyStack* obj) {\n    return obj->q1->size == 0;\n}\n\nvoid myStackFree(MyStack* obj) {\n    freeQueue(obj->q1);\n    freeQueue(obj->q2);\n    free(obj);\n}"},{"script":"python","time":36,"memory":16.42,"desc":"每次循环n-1次使队尾在头部。","code":"class MyStack:\n    def __init__(self):\n        self.q = deque()\n    def push(self, x: int) -> None:\n        self.q.append(x)\n        for _ in range(len(self.q) - 1):\n            self.q.append(self.q.popleft())\n    def pop(self) -> int:\n        return self.q.popleft()\n    def top(self) -> int:\n        return self.q[0]\n    def empty(self) -> bool:\n        return not self.q","date":"2024-03-03"}],"tagList":["栈","设计","队列"],"level":"Easy"}},{"problemName":"226.翻转二叉树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/226.翻转二叉树.json","problemData":{"id":"226","name":"226.翻转二叉树","url":"https://leetcode.cn/problems/invert-binary-tree","desc":"翻转一棵二叉树。","solutions":[{"date":"2020-02-19","time":0,"memory":39.7,"script":"java","desc":"前序遍历","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if(root==null)return root;\n\t\tTreeNode tmpNode=root.left;\n\t\troot.left=root.right;\n\t\troot.right=tmpNode;\n\t\tinvertTree(root.left);\n\t\tinvertTree(root.right);\n\t\treturn root;\n    }\n}"},{"date":"2020-02-19","time":0,"memory":39.8,"script":"java","desc":"后序遍历","code":"public TreeNode invertTree(TreeNode root) {\n    if(root==null)return root;\n    invertTree(root.left);\n    invertTree(root.right);\n    TreeNode tmpNode=root.left;\n    root.left=root.right;\n    root.right=tmpNode;\n    return root;\n}"},{"date":"2020-02-19","time":0,"memory":40.2,"script":"java","desc":"中序遍历","code":"public TreeNode invertTree(TreeNode root) {\n    if(root==null)return root;\n    invertTree(root.left);\n    TreeNode tmpNode=root.left;\n    root.left=root.right;\n    root.right=tmpNode;\n    invertTree(root.left);\n    return root;\n}"},{"date":"2020-02-19","time":0,"memory":40.5,"script":"java","desc":"层序遍历","code":"public TreeNode invertTree(TreeNode root) {\n\t\tif(root==null)return root;\n\t\tQueue<TreeNode> queue=new LinkedList<>();\n\t\tqueue.offer(root);\n\t\twhile(!queue.isEmpty()) {\n\t\t\tTreeNode node = queue.poll();\n\t\t\tTreeNode tmpNode=node.left;\n\t\t\tnode.left=node.right;\n\t\t\tnode.right=tmpNode;\n\t\t\tif(node.left!=null) {\n\t\t\t\tqueue.offer(node.left);\n\t\t\t}\n\t\t\tif(node.right!=null) {\n\t\t\t\tqueue.offer(node.right);\n\t\t\t}\n\t\t}\n\t\treturn root;\n\t}"},{"date":"2020-09-16","time":72,"memory":37.6,"script":"typescript","desc":"递归。","code":"function invertTree(root: TreeNode | null): TreeNode | null {\n  if (root === null) return null;\n  const left = invertTree(root.left);\n  const right = invertTree(root.right);\n  root.right = left;\n  root.left = right;\n  return root;\n}"},{"date":"2021-11-27","time":0,"memory":5.9,"script":"c","desc":"递归。","code":"struct TreeNode* invertTree(struct TreeNode* root){\n    if (!root) return root;\n    struct TreeNode *left = root->left, *right = root->right;\n    // 翻转右树赋值给左点\n    root->left = invertTree(right);\n    // 翻转左树赋值给右点\n    root->right = invertTree(left);\n    return root;\n}"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉树"],"level":"Easy"}},{"problemName":"227.基本计算器II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/227.基本计算器II.json","problemData":{"id":"227","name":"227.基本计算器II","url":"https://leetcode.cn/problems/basic-calculator-ii","desc":"给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。","solutions":[{"date":"2021-03-11","time":148,"memory":50.6,"script":"typescript","desc":"先乘除后加减。","code":"const numReg = /\\-?\\d+/;\nconst opMap: Record<string, (num1: number, num2: number) => number> = {\n  '+': (num1, num2) => num1 + num2,\n  '-': (num1, num2) => num1 - num2,\n  '*': (num1, num2) => num1 * num2,\n  '/': (num1, num2) => ~~(num1 / num2),\n};\nfunction calculate(s: string): number {\n  s = s.replace(/ /g, '');\n  const len = s.length;\n  const stack: string[] = [];\n  const peek = () => stack[stack.length - 1];\n  // 去乘除\n  for (let i = 0; i < len; i++) {\n    let c = s[i];\n    if (c === '*' || c === '/' || c === '+') {\n      stack.push(c);\n    } else if (c === '-') {\n      if (stack.length === 0) stack.push('0');\n      stack.push(c);\n    } else {\n      while (i < len - 1 && numReg.test(s[i + 1])) {\n        c += s[i + 1];\n        i++;\n      }\n      const top = peek();\n      if (stack.length === 0) {\n        stack.push(c);\n      } else if (top === '*' || top === '/') {\n        const op = stack.pop()!;\n        const num1 = +stack.pop()!;\n        const num2 = +c;\n        stack.push(opMap[op](num1, num2) + '');\n      } else if (top === '-') {\n        stack[stack.length - 1] = '+';\n        stack.push(c.startsWith('-') ? c.substr(1) : '-' + c);\n      } else {\n        stack.push(c);\n      }\n    }\n  }\n  // 去加减\n  const newStack: string[] = [];\n  for (const c of stack) {\n    if (numReg.test(c)) {\n      if (newStack[newStack.length - 1] === '+') {\n        const op = newStack.pop()!;\n        const num1 = +newStack.pop()!;\n        const num2 = +c;\n        newStack.push(opMap[op](num1, num2) + '');\n      } else {\n        newStack.push(c);\n      }\n    } else {\n      newStack.push(c);\n    }\n  }\n  return +newStack[0];\n}"}],"tagList":["栈","数学","字符串"],"level":"Medium"}},{"problemName":"228.汇总区间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/228.汇总区间.json","problemData":{"id":"228","name":"228.汇总区间","url":"https://leetcode.cn/problems/summary-ranges","desc":"给定一个无重复元素的有序整数数组 nums 。返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。","solutions":[{"date":"2021-01-10","time":104,"memory":40.2,"script":"typescript","desc":"遍历一遍进行计算。","code":"function summaryRanges(nums: number[]): string[] {\n  const stack: [number, number][] = [];\n  for (const num of nums) {\n    if (stack.length === 0) {\n      stack.push([num, num]);\n    } else {\n      const v = stack[stack.length - 1];\n      if (num === v[1] + 1) {\n        v[1] = num;\n      } else {\n        stack.push([num, num]);\n      }\n    }\n  }\n  return stack.map(([num1, num2]) => (num1 === num2 ? num1 + '' : `${num1}->${num2}`));\n}"},{"script":"cpp","time":0,"memory":6.65,"desc":"遍历。","code":"class Solution {\npublic:\n    vector<string> summaryRanges(vector<int>& nums) {\n        vector<string> res;\n        if (nums.size() == 0) return res;\n        bool prev = false;\n        pair<int, int> cur;\n        for (auto &num : nums) {\n            if (!prev) {\n                prev = true;\n                cur = make_pair(num, num);\n            } else if (cur.second + 1 == num) {\n                cur.second = num;\n            } else {\n                string item = cur.first == cur.second ? to_string(cur.first) : to_string(cur.first) + \"->\" + to_string(cur.second);\n                res.push_back(item);\n                cur = make_pair(num, num);\n            }\n        }\n        if (prev) {\n            string item = cur.first == cur.second ? to_string(cur.first) : to_string(cur.first) + \"->\" + to_string(cur.second);\n            res.push_back(item);\n        }\n        return res;\n    }\n};","date":"2023-08-26"},{"script":"python","time":48,"memory":15.72,"desc":"同上。","code":"class Solution:\n    def summaryRanges(self, nums: List[int]) -> List[str]:\n        if not len(nums):\n            return []\n        res = []\n        prev = False\n        cur = (0, 0)\n        for num in nums:\n            if not prev:\n                prev = True\n                cur = (num, num)\n            elif cur[1] + 1 == num:\n                cur = (cur[0], num)\n            else:\n                item = str(cur[0]) if cur[0] == cur[1] else str(cur[0]) + \"->\" + str(cur[1])\n                res.append(item)\n                cur = (num, num)\n        if prev:\n            item = str(cur[0]) if cur[0] == cur[1] else str(\n                cur[0]) + \"->\" + str(cur[1])\n            res.append(item)\n        return res","date":"2023-08-26"},{"script":"rust","time":0,"memory":2.13,"desc":"同上。","code":"impl Solution {\n    pub fn summary_ranges(nums: Vec<i32>) -> Vec<String> {\n        let mut res = vec![];\n        if !nums.is_empty() {\n            let mut prev = false;\n            let mut cur = (0, 0);\n            for num in nums {\n                if !prev {\n                    prev = true;\n                    cur = (num, num);\n                } else if cur.1 + 1 == num {\n                    cur.1 = num;\n                } else {\n                    let item = if cur.0 == cur.1 {\n                        cur.0.to_string()\n                    } else {\n                        let mut s = String::new();\n                        s.push_str(&cur.0.to_string());\n                        s.push_str(\"->\");\n                        s.push_str(&cur.1.to_string());\n                        s\n                    };\n                    res.push(item);\n                    cur = (num, num);\n                }\n            }\n            if prev {\n                let item = if cur.0 == cur.1 {\n                        cur.0.to_string()\n                } else {\n                    let mut s = String::new();\n                    s.push_str(&cur.0.to_string());\n                    s.push_str(\"->\");\n                    s.push_str(&cur.1.to_string());\n                    s\n                };\n                res.push(item);\n            }\n        }\n        res\n    }\n}","date":"2023-08-26"}],"tagList":["数组"],"level":"Easy"}},{"problemName":"229.多数元素II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/229.多数元素II.json","problemData":{"id":"229","name":"229.多数元素II","url":"https://leetcode.cn/problems/majority-element-ii","desc":"给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。","solutions":[{"date":"2021-10-22","time":88,"memory":41.8,"script":"typescript","desc":"哈希存储。","code":"function majorityElement(nums: number[]): number[] {\n  const map = new Map<number, number>();\n  const n = nums.length;\n  for (const num of nums) {\n    map.set(num, (map.get(num) ?? 0) + 1);\n  }\n  return Array.from(map.entries())\n    .filter(([, v]) => v > n / 3)\n    .map(([k]) => k);\n}"},{"date":"2021-10-22","time":88,"memory":41.5,"script":"typescript","desc":"摩尔投票，超过 n/3 的数最多有 2 个，每三个不同的数进行抵消。","code":"function majorityElement(nums: number[]): number[] {\n  const n = nums.length;\n  let num1 = nums[0];\n  let num2 = nums[0];\n  let val1 = 0;\n  let val2 = 0;\n  for (const num of nums) {\n    if (val1 > 0 && num === num1) {\n      val1++;\n    } else if (val2 > 0 && num === num2) {\n      val2++;\n    } else if (val1 === 0) {\n      num1 = num;\n      val1++;\n    } else if (val2 === 0) {\n      num2 = num;\n      val2++;\n    } else {\n      val1--;\n      val2--;\n    }\n  }\n  let cnt1 = 0;\n  let cnt2 = 0;\n  for (const num of nums) {\n    if (val1 > 0 && num1 === num) cnt1++;\n    if (val2 > 0 && num2 === num) cnt2++;\n  }\n  const ans: number[] = [];\n  if (val1 > 0 && cnt1 > n / 3) ans.push(num1);\n  if (val2 > 0 && cnt2 > n / 3) ans.push(num2);\n  return ans;\n}"},{"date":"2022-01-07","time":12,"memory":15.4,"script":"cpp","desc":"最多只可能有两个数，声明两个变量记录数值和次数，遍历时相互抵消。","code":"class Solution {\n   public:\n    vector<int> majorityElement(vector<int> &nums) {\n        int cnt1 = 0, num1, cnt2 = 0, num2;\n        for (auto &num : nums) {\n            if ((cnt1 == 0 || num1 == num) && num2 != num)\n                num1 = num, cnt1++;\n            else if (cnt2 == 0 || num2 == num)\n                num2 = num, cnt2++;\n            else\n                cnt1--, cnt2--;\n        }\n        cnt1 = cnt2 = 0;\n        for (auto &num : nums) {\n            if (num1 == num)\n                cnt1++;\n            else if (num2 == num)\n                cnt2++;\n        }\n        vector<int> ans;\n        if (cnt1 * 3 > nums.size()) ans.push_back(num1);\n        if (cnt2 * 3 > nums.size()) ans.push_back(num2);\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","计数","排序"],"level":"Medium"}},{"problemName":"230.二叉搜索树中第K小的元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/230.二叉搜索树中第K小的元素.json","problemData":{"id":"230","name":"230.二叉搜索树中第K小的元素","url":"https://leetcode.cn/problems/kth-smallest-element-in-a-bst","desc":"给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。","solutions":[{"date":"2020-02-24","time":1,"memory":41.3,"script":"java","desc":"中序遍历储存值后直接获取第 k 个值。","code":"class Solution {\n    ArrayList<Integer> list = new ArrayList<Integer>();\n    public int kthSmallest(TreeNode root, int k) {\n    \tinorder(root);\n    \treturn list.get(k-1);\n    }\n\tpublic void inorder(TreeNode node) {\n\t\tif (node.left != null)\n\t\t\tinorder(node.left);\n\t\tlist.add(node.val);\n\t\tif (node.right != null)\n\t\t\tinorder(node.right);\n\t}\n}"},{"date":"2021-10-17","time":100,"memory":44.7,"script":"typescript","desc":"中序遍历。","code":"function kthSmallest(root: TreeNode | null, k: number): number {\n  let ans!: number;\n  dfs(root);\n  return ans;\n  function dfs(node: TreeNode | null): void {\n    if (node === null) return;\n    dfs(node.left);\n    if (--k === 0) {\n      ans = node.val;\n      return;\n    }\n    dfs(node.right);\n  }\n}"}],"tagList":["树","深度优先搜索","二叉搜索树","二叉树"],"level":"Medium"}},{"problemName":"231.2的幂.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/231.2的幂.json","problemData":{"id":"231","name":"231.2的幂","url":"https://leetcode.cn/problems/power-of-two","desc":"给定一个整数，编写一个函数来判断它是否是 2 的幂次方。","solutions":[{"date":"2021-04-13","time":100,"memory":39.2,"script":"typescript","desc":"log 去对数后判断是否为整数。","code":"function isPowerOfTwo(n: number): boolean {\n  return Number.isInteger(Math.log2(n));\n}"},{"date":"2021-04-13","time":108,"memory":39.4,"script":"typescript","desc":"判读数的二进制状态是否只存在一个 1。","code":"function isPowerOfTwo(n: number): boolean {\n  return n <= 0\n    ? false\n    : n\n        .toString(2)\n        .split('')\n        .filter(v => v === '1').length === 1;\n}"},{"date":"2021-05-31","time":96,"memory":39.7,"script":"typescript","desc":"利用原生函数判断。","code":"function isPowerOfTwo(n: number): boolean {\n  const num = Math.log2(n);\n  return num === ~~num;\n}"},{"date":"2021-05-31","time":100,"memory":39.6,"script":"typescript","desc":"判断二进制上只有一个 1。","code":"function isPowerOfTwo(n: number): boolean {\n  if (n < 0) return false;\n  let ans = 0;\n  while (n) {\n    if (n & 1) ans++;\n    n >>= 1;\n  }\n  return ans === 1;\n}"}],"tagList":["位运算","递归","数学"],"level":"Easy"}},{"problemName":"232.用栈实现队列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/232.用栈实现队列.json","problemData":{"id":"232","name":"232.用栈实现队列","url":"https://leetcode.cn/problems/implement-queue-using-stacks","desc":"使用栈实现队列的下列操作：push(x) -- 将一个元素放入队列的尾部。pop() -- 从队列首部移除元素。peek() -- 返回队列首部的元素。empty() -- 返回队列是否为空。","solutions":[{"date":"2020-02-16","time":0,"memory":34.2,"script":"java","desc":"使用 java 自带栈结构，使用两个栈，压栈放入 inStack，出栈时若 outStack 为空则先出栈 inStack 压倒 outStack。","code":"class MyQueue {\n\tprivate Stack<Integer> inStack;\n\tprivate Stack<Integer> outStack;\n    public MyQueue() {\n        inStack = new Stack<Integer>();\n\t\toutStack = new Stack<Integer>();\n    }\n\tpublic void push(int x) {\n\t\tinStack.push(x);\n\t}\n\tpublic int pop() {\n\t\tcheckOutStack();\n\t\treturn outStack.pop();\n\t}\n\tpublic int peek() {\n\t\tcheckOutStack();\n\t\treturn outStack.peek();\n\t}\n\tpublic boolean empty() {\n\t\treturn inStack.isEmpty() && outStack.isEmpty();\n\t}\n\tprivate void checkOutStack() {\n\t\tif (outStack.isEmpty()) {\n\t\t\twhile (!inStack.isEmpty()) {\n\t\t\t\toutStack.push(inStack.pop());\n\t\t\t}\n\t\t}\n\t}\n}"},{"date":"2021-03-05","time":84,"memory":39.1,"script":"typescript","desc":"利用两个栈维护。","code":"class MyQueue {\n  private inStack: number[] = [];\n  private outStack: number[] = [];\n  push(x: number): void {\n    this.inStack.push(x);\n  }\n  pop(): number {\n    if (this.empty()) return -Infinity;\n    if (this.outStack.length > 0) {\n      return this.outStack.pop()!;\n    } else {\n      this.inStackToOutStack();\n      return this.pop();\n    }\n  }\n  peek(): number {\n    if (this.empty()) return -Infinity;\n    if (this.outStack.length === 0) this.inStackToOutStack();\n    return this.outStack[this.outStack.length - 1];\n  }\n  empty(): boolean {\n    return this.outStack.length === 0 && this.inStack.length === 0;\n  }\n  inStackToOutStack(): void {\n    while (this.inStack.length > 0) this.outStack.push(this.inStack.pop()!);\n  }\n}"},{"date":"2021-11-24","time":0,"memory":5.7,"script":"typescript","desc":"stack。","code":"typedef struct Stack\n{\n    int size;\n    int len;\n    int *data;\n} Stack;\nStack *createStack(int len)\n{\n    Stack *s = (Stack *)malloc(sizeof(Stack));\n    s->size = 0;\n    s->len = len;\n    s->data = (int *)malloc(sizeof(int) * len);\n    return s;\n}\nvoid push(Stack *s, int val)\n{\n    if (s->size == s->len)\n        return;\n    s->data[s->size++] = val;\n}\nvoid pop(Stack *s)\n{\n    if (s->size == 0)\n        return;\n    s->size--;\n}\nint isEmpty(Stack *s) {\n    return s->size == 0;\n}\nint top(Stack *s)\n{\n    if (s->size == 0) return -1;\n    return s->data[s->size - 1];\n}\nvoid freeStack(Stack *s)\n{\n    free(s->data);\n    free(s);\n}\ntypedef struct {\n    Stack *s1, *s2;\n} MyQueue;\n\n\nMyQueue* myQueueCreate() {\n    MyQueue *q = (MyQueue *)malloc(sizeof(MyQueue));\n    q->s1 = createStack(100);\n    q->s2 = createStack(100);\n    return q;\n}\n\nvoid myQueuePush(MyQueue* obj, int x) {\n    push(obj->s1, x);\n}\nvoid check(MyQueue *obj){\n    if (!obj->s2->size) {\n        while(obj->s1->size) {\n            push(obj->s2, top(obj->s1));\n            pop(obj->s1);\n        }\n    }\n}\nint myQueuePop(MyQueue* obj) {\n    check(obj);\n    int val = top(obj->s2);\n    pop(obj->s2);\n    return val;\n}\n\nint myQueuePeek(MyQueue* obj) {\n    check(obj);\n    return top(obj->s2);\n}\n\nbool myQueueEmpty(MyQueue* obj) {\n    return obj->s1->size + obj->s2->size == 0;\n}\n\nvoid myQueueFree(MyQueue* obj) {\n    freeStack(obj->s1);\n    freeStack(obj->s2);\n    free(obj);\n}"},{"script":"python","time":40,"memory":16.55,"desc":"用两个栈模拟。","code":"class MyQueue:\n    def __init__(self):\n        self.s1 = []\n        self.s2 = []\n    def push(self, x: int) -> None:\n        self.s1.append(x)\n    def pop(self) -> int:\n        self.check()\n        return self.s2.pop()\n    def peek(self) -> int:\n        self.check()\n        return self.s2[-1]\n    def empty(self) -> bool:\n        return not self.s1 and not self.s2\n    def check(self) -> bool:\n        if not self.s2:\n            while self.s1:\n                self.s2.append(self.s1.pop())","date":"2024-03-04"}],"tagList":["栈","设计","队列"],"level":"Easy"}},{"problemName":"233.数字1的个数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/233.数字1的个数.json","problemData":{"id":"233","name":"233.数字1的个数","url":"https://leetcode.cn/problems/number-of-digit-one","desc":"给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。","solutions":[{"date":"2021-08-13","time":72,"memory":39.2,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/number-of-digit-one/solution/shu-zi-1-de-ge-shu-by-leetcode-solution-zopq/)。","code":"function countDigitOne(n: number): number {\n  let num = 1;\n  let ans = 0;\n  while (n >= num) {\n    ans += ~~(n / 10 / num) * num + Math.min(Math.max((n % (num * 10)) - num + 1, 0), num);\n    num *= 10;\n  }\n  return ans;\n}"}],"tagList":["递归","数学","动态规划"],"level":"Hard"}},{"problemName":"234.回文链表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/234.回文链表.json","problemData":{"id":"234","name":"234.回文链表","url":"https://leetcode.cn/problems/palindrome-linked-list","desc":"请判断一个链表是否为回文链表。","solutions":[{"date":"2020-10-23","time":104,"memory":43,"script":"typescript","desc":"快慢指针一次遍历。","code":"function isPalindrome(head: ListNode | null): boolean {\n  if (head === null) return true;\n  let fast: ListNode | null = head;\n  let slow: ListNode | null = head;\n  const cache: number[] = [];\n  while (fast !== null && fast.next !== null) {\n    fast = fast.next.next;\n    cache.push(slow!.val);\n    slow = slow!.next;\n  }\n  if (fast?.next === null) slow = slow!.next;\n  while (slow) {\n    const val = cache.pop();\n    if (slow.val !== val) return false;\n    slow = slow.next;\n  }\n  return true;\n}"},{"date":"2021-08-20","time":260,"memory":66.2,"script":"typescript","desc":"利用字符串保存翻转值。","code":"function isPalindrome(head: ListNode): boolean {\n  let str1 = '';\n  let str2 = '';\n  let p: ListNode | null = head;\n  while (p) {\n    str1 = str1 + p.val;\n    str2 = p.val + str2;\n    p = p.next;\n  }\n  return str1 === str2;\n}"},{"date":"2021-09-22","time":228,"memory":69.9,"script":"javascript","desc":"反转后半部分。","code":"function isPalindrome(head: ListNode): boolean {\n        let slow = head;\n        let fast = head.next;\n        if (!fast) return true;\n        while (fast && fast.next) {\n          slow = slow.next!;\n          fast = fast.next.next;\n        }\n        fast = reverse(slow.next!)[0];\n        slow = head;\n        while (fast) {\n          if (slow.val !== fast.val) return false;\n          slow = slow.next!;\n          fast = fast.next!;\n        }\n        return true;\n        function reverse(node: ListNode): [ListNode, ListNode] {\n          if (node.next === null) return [node, node];\n          const [first, last] = reverse(node.next);\n          last.next = node;\n          node.next = null;\n          return [first, node];\n        }\n      }"},{"date":"2021-09-22","time":152,"memory":60.7,"script":"javascript","desc":"反转后半部分，遍历反转。","code":"function isPalindrome(head: ListNode): boolean {\n        let slow = head;\n        let fast = head.next;\n        if (!fast) return true;\n        while (fast && fast.next) {\n          slow = slow.next!;\n          fast = fast.next.next;\n        }\n        fast = reverse(slow.next!);\n        slow = head;\n        while (fast) {\n          if (slow.val !== fast.val) return false;\n          slow = slow.next!;\n          fast = fast.next!;\n        }\n        return true;\n        function reverse(node: ListNode): ListNode {\n          const head = new ListNode();\n          let p: ListNode | null = node;\n          while (p) {\n            const oldNext = head.next;\n            const next = p.next;\n            head.next = p;\n            p.next = oldNext;\n            p = next;\n          }\n          return head.next!;\n        }\n      }"},{"date":"2021-11-19","time":164,"memory":40.8,"script":"c","desc":"储存数组再遍历。","code":"bool isPalindrome(struct ListNode* head){\n    int nums[100000] = {0}, len = 0;\n    struct ListNode *p = head;\n    while(p){\n        nums[len++] = p->val;\n        p = p->next;\n    }\n    for (int i = 0; i < len / 2; i++) {\n        if (nums[i] != nums[len - 1 - i]) return 0;\n    }\n    return 1;\n}"}],"tagList":["栈","递归","链表","双指针"],"level":"Easy"}},{"problemName":"235.二叉搜索树的最近公共祖先.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/235.二叉搜索树的最近公共祖先.json","problemData":{"id":"235","name":"235.二叉搜索树的最近公共祖先","url":"https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree","desc":"给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。","solutions":[{"date":"2020-02-24","time":6,"memory":41.9,"script":"java","desc":"二分判断如果值在两边则当前点就为公共祖先。","code":"class Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        int val = root.val;\n        if(p.val==val||q.val==val)return root;\n        if(p.val<val&&q.val>val)return root;\n        if(p.val<val&&q.val<val)return lowestCommonAncestor(root.left,p,q);\n        if(p.val>val&&q.val>val)return lowestCommonAncestor(root.right,p,q);\n        return root;\n    }\n}"},{"date":"2020-09-27","time":112,"memory":47.2,"script":"javascript","desc":"根据二叉搜索树的特性进行递归。","code":"/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nvar lowestCommonAncestor = function (root, p, q) {\n  const val = root.val;\n  const pVal = p.val;\n  const qVal = q.val;\n  if ((val < pVal && val > qVal) || (val > pVal && val < qVal) || val === pVal || val === qVal)\n    return root;\n  if (val < pVal && val < qVal) return lowestCommonAncestor(root.right, p, q);\n  if (val > pVal && val > qVal) return lowestCommonAncestor(root.left, p, q);\n};"},{"script":"python","time":53,"memory":19.96,"desc":"通过bst特性进行左右区分。","code":"class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        while root.val < q.val and root.val < p.val or root.val > q.val and root.val > p.val:\n            if root == q or root == p: break\n            root = root.left if root.val > q.val else root.right\n        return root","date":"2024-02-25"}],"tagList":["树","深度优先搜索","二叉搜索树","二叉树"],"level":"Medium"}},{"problemName":"236.二叉树的最近公共祖先.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/236.二叉树的最近公共祖先.json","problemData":{"id":"236","name":"236.二叉树的最近公共祖先","url":"https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree","desc":"给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。","solutions":[{"date":"2020-05-10","time":84,"memory":42.5,"script":"javascript","desc":"通过 js 特性给每个节点添加 parent 属性，遍历是否有相同父节点进行判断。","code":"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} root\n * @param {TreeNode} p\n * @param {TreeNode} q\n * @return {TreeNode}\n */\nvar lowestCommonAncestor = function (root, p, q) {\n  function treeNodeInorder(node) {\n    if (node.left !== null) {\n      node.left.parent = node;\n      treeNodeInorder(node.left);\n    }\n    if (node.right !== null) {\n      node.right.parent = node;\n      treeNodeInorder(node.right);\n    }\n  }\n  treeNodeInorder(root);\n  root.parent = root;\n  let temp = p;\n  const queueP = [temp];\n  while (temp.parent !== root) {\n    queueP.push(temp.parent);\n    temp = temp.parent;\n  }\n  queueP.push(root);\n  temp = q;\n  const queueQ = [temp];\n  while (temp.parent !== root) {\n    queueQ.push(temp.parent);\n    temp = temp.parent;\n  }\n  queueQ.push(root);\n  for (const node of queueP) {\n    if (queueQ.includes(node)) return node;\n  }\n  return root;\n};"},{"script":"python","time":56,"memory":21.32,"desc":"遍历记录父亲和level。","code":"class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        map = {}\n        plevel = qlevel = 0\n        def dfs(node: Optional[TreeNode], level = 0):\n            nonlocal plevel, qlevel\n            if not node: return\n            if node == p: plevel = level\n            if node == q: qlevel = level\n            if node.left:\n                map[node.left] = node\n                dfs(node.left, level + 1)\n            if node.right:\n                map[node.right] = node\n                dfs(node.right, level + 1)\n        dfs(root)\n        if plevel > qlevel:\n            plevel, qlevel = qlevel, plevel\n            p, q = q, p\n        while qlevel > plevel:\n            print(q, qlevel)\n            qlevel -= 1\n            q = map[q]\n        while p != q:\n            p, q = map[p], map[q]\n        return p","date":"2024-02-09"}],"tagList":["树","深度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"237.删除链表中的节点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/237.删除链表中的节点.json","problemData":{"id":"237","name":"237.删除链表中的节点","url":"https://leetcode.cn/problems/delete-node-in-a-linked-list","desc":"请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。","solutions":[{"date":"2020-02-13","time":0,"memory":43,"script":"java","desc":"获取下一个节点的值赋值给当前节点，当前节点的下一个等于下一个节点的下一个。","code":"class Solution {\n    public void deleteNode(ListNode node) {\n\t\tnode.val=node.next.val;\n\t\tnode.next=node.next.next;\n    }\n}"},{"date":"2021-11-02","time":88,"memory":39.7,"script":"typescript","desc":"依次对当前节点赋值后面的节点的值。","code":"function deleteNode(root: ListNode | null): void {\n  if (root === null) return;\n  let p = root;\n  let pre = p;\n  while (p.next) {\n    p.val = p.next.val;\n    pre = p;\n    p = p.next;\n  }\n  pre.next = null;\n}"},{"date":"2021-11-02","time":88,"memory":39.6,"script":"typescript","desc":"与下一节点替换。","code":"function deleteNode(root: ListNode | null): void {\n  if (root === null) return;\n  root.val = root.next.val;\n  root.next = root.next.next;\n}"},{"date":"2021-11-19","time":4,"memory":6.2,"script":"c","desc":"递归。","code":"void deleteNode(struct ListNode* node) {\n    struct ListNode *next = node->next;\n    node->val = next->val;\n    node->next = next->next;\n}"}],"tagList":["链表"],"level":"Medium"}},{"problemName":"238.除自身以外数组的乘积.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/238.除自身以外数组的乘积.json","problemData":{"id":"238","name":"238.除自身以外数组的乘积","url":"https://leetcode.cn/problems/product-of-array-except-self","desc":"给你一个长度为  n  的整数数组  nums，其中  n > 1，返回输出数组  output ，其中 output[i]  等于  nums  中除  nums[i]  之外其余各元素的乘积。","solutions":[{"date":"2020-06-04","time":132,"memory":42.7,"script":"typescript","desc":"虽通过但使用了除法不符合题目要求","code":"function productExceptSelf(nums: number[]): number[] {\n  let zeroIndex = nums.indexOf(0);\n  if (zeroIndex === -1) {\n    let sum = 1;\n    for (const num of nums) sum *= num;\n    return nums.map(v => sum / v);\n  } else if (nums.includes(0, zeroIndex + 1)) {\n    return nums.map(v => 0);\n  } else {\n    let sum = 1;\n    for (const num of nums) sum *= num === 0 ? 1 : num;\n    return nums.map(v => (v === 0 ? sum : 0));\n  }\n}"},{"date":"2020-06-04","time":132,"memory":42.1,"script":"typescript","desc":"储存左值与右值,res[i]=l[i]\\*r[i]","code":"function productExceptSelf(nums: number[]): number[] {\n  const len = nums.length;\n  let l: number[] = [];\n  let r: number[] = [];\n  l[0] = 1;\n  for (let i = 1; i < len; i++) l[i] = l[i - 1] * nums[i - 1];\n  r[len - 1] = 1;\n  for (let i = len - 2; i >= 0; i--) r[i] = r[i + 1] * nums[i + 1];\n  return nums.map((_, i) => l[i] * r[i]);\n}"},{"date":"2020-06-04","time":96,"memory":42,"script":"typescript","desc":"根据题解 2，利用输出数组，先存入左值再累乘右值，使空间变 O(1)","code":"function productExceptSelf(nums: number[]): number[] {\n  const len = nums.length;\n  let ans: number[] = [1];\n  for (let i = 1; i < len; i++) ans[i] = ans[i - 1] * nums[i - 1];\n  let r = nums[len - 1];\n  for (let i = len - 2; i >= 0; i--) {\n    ans[i] *= r;\n    r *= nums[i];\n  }\n  return ans;\n}"}],"tagList":["数组","前缀和"],"level":"Medium"}},{"problemName":"239.滑动窗口最大值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/239.滑动窗口最大值.json","problemData":{"id":"239","name":"239.滑动窗口最大值","url":"https://leetcode.cn/problems/sliding-window-maximum","desc":"给你一个整数数组 nums，有一个大小为  k  的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k  个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。","solutions":[{"date":"2021-01-02","time":4056,"memory":73.1,"script":"typescript","desc":"每次储存最大值进行比较。","code":"function maxSlidingWindow(nums: number[], k: number): number[] {\n  if (k === 1) return nums;\n  const len = nums.length;\n  if (len === k) return [Math.max(...nums)];\n  const ans: number[] = [];\n  let max = -Infinity;\n  let index = 0;\n  for (let i = 0; i < k; i++) {\n    const num = nums[i];\n    if (max < num) {\n      max = num;\n      index = i;\n    }\n  }\n  ans.push(max);\n  for (let i = k; i < len; i++) {\n    if (index <= i - k) {\n      max = -Infinity;\n      for (let j = i - k + 1; j <= i; j++) {\n        const num = nums[j];\n        if (max < num) {\n          max = num;\n          index = j;\n        }\n      }\n    } else {\n      const num = nums[i];\n      if (max < num) {\n        max = num;\n        index = i;\n      }\n    }\n    ans.push(max);\n  }\n  return ans;\n}"},{"date":"2021-01-02","time":324,"memory":72.2,"script":"typescript","desc":"优化题解 1。","code":"function maxSlidingWindow(nums: number[], k: number): number[] {\n  const n = nums.length;\n  const q: number[] = [];\n  for (let i = 0; i < k; i++) {\n    while (q.length && nums[i] >= nums[q[q.length - 1]]) {\n      q.pop();\n    }\n    q.push(i);\n  }\n  const ans = [nums[q[0]]];\n  for (let i = k; i < n; i++) {\n    while (q.length && nums[i] >= nums[q[q.length - 1]]) {\n      q.pop();\n    }\n    q.push(i);\n    while (q[0] <= i - k) {\n      q.shift();\n    }\n    ans.push(nums[q[0]]);\n  }\n  return ans;\n}"},{"date":"2021-05-08","time":5224,"memory":69.8,"script":"typescript","desc":"二分维护数组。","code":"function maxSlidingWindow(nums: number[], k: number): number[] {\n  const win = nums.slice(0, k).sort((a, b) => a - b);\n  const findIndex = (num: number, l = 0, r = k - 1) => {\n    if (l > r) return l;\n    const mid = (l + r) >> 1;\n    const midNum = win[mid];\n    if (midNum < num) return findIndex(num, mid + 1, r);\n    else if (midNum > num) return findIndex(num, l, mid - 1);\n    else return mid;\n  };\n  const add = (num: number) => win.splice(findIndex(num), 0, num);\n  const del = (num: number) => win.splice(findIndex(num), 1);\n  const ans = [win[k - 1]];\n  for (let i = k, l = nums.length; i < l; i++) {\n    add(nums[i]);\n    del(nums[i - k]);\n    ans.push(win[k - 1]);\n  }\n  return ans;\n}"},{"date":"2021-05-08","time":944,"memory":73.8,"script":"typescript","desc":"利用列表维护最大值。","code":"function maxSlidingWindow(nums: number[], k: number): number[] {\n  const list: number[] = [];\n  if (k === 0) return list;\n  const ans: number[] = [];\n  const len = nums.length;\n  let index = 0;\n  while (index < len) {\n    while (list.length !== 0 && list[0] + k <= index) list.shift();\n    const num = nums[index];\n    while (list.length !== 0 && nums[list[list.length - 1]] < num) list.pop();\n    list.push(index++);\n    index >= k && ans.push(nums[list[0]]);\n  }\n  return ans;\n}"},{"date":"2021-07-20","time":4712,"memory":73.3,"script":"typescript","desc":"单调递减队列。","code":"function maxSlidingWindow(nums: number[], k: number): number[] {\n  const n = nums.length;\n  const queue: number[] = [];\n  const ans: number[] = [];\n  for (let i = 0; i < n; i++) {\n    const num = nums[i];\n    while (queue.length && nums[queue[queue.length - 1]] < num) queue.pop();\n    queue.push(i);\n    if (i - queue[0] === k) queue.shift();\n    if (i + 1 < k) continue;\n    ans.push(nums[queue[0]]);\n  }\n  return ans;\n}"}],"tagList":["队列","数组","滑动窗口","单调队列","堆（优先队列）"],"level":"Hard"}},{"problemName":"240.搜索二维矩阵II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/240.搜索二维矩阵II.json","problemData":{"id":"240","name":"240.搜索二维矩阵II","url":"https://leetcode.cn/problems/search-a-2d-matrix-ii","desc":"编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。","solutions":[{"date":"2021-07-24","time":72,"memory":40.8,"script":"typescript","desc":"从右上角开始寻找。","code":"function searchMatrix(matrix: number[][], target: number): boolean {\n  let i = 0;\n  let j = matrix[0].length - 1;\n  while (i < matrix.length && j >= 0) {\n    if (matrix[i][j] > target) j--;\n    else if (matrix[i][j] < target) i++;\n    else return true;\n  }\n  return false;\n}"},{"date":"2021-10-25","time":96,"memory":43.1,"script":"typescript","desc":"拆分查找。","code":"function searchMatrix(matrix: number[][], target: number): boolean {\n  return matrix.flat().includes(target);\n}"},{"date":"2021-10-25","time":72,"memory":41,"script":"typescript","desc":"从右上角开始找，target 就左移，target 大就下移。","code":"function searchMatrix(matrix: number[][], target: number): boolean {\n  const m = matrix.length;\n  const n = matrix[0].length;\n  let row = 0;\n  let col = n - 1;\n  while (row < m && col >= 0) {\n    const num = matrix[row][col];\n    if (num === target) return true;\n    if (num > target) col--;\n    else row++;\n  }\n  return false;\n}"}],"tagList":["数组","二分查找","分治","矩阵"],"level":"Medium"}},{"problemName":"241.为运算表达式设计优先级.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/241.为运算表达式设计优先级.json","problemData":{"id":"241","name":"241.为运算表达式设计优先级","url":"https://leetcode.cn/problems/different-ways-to-add-parentheses","desc":"给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, -  以及  \\* 。","solutions":[{"date":"2021-10-25","time":88,"memory":41.3,"script":"typescript","desc":"对于每个操作符当作根节点计算。","code":"function diffWaysToCompute(expression: string): number[] {\n  return dfs(expression);\n  function split(expression: string, idx: number) {\n    return [expression.substring(0, idx), expression.substring(idx + 1)];\n  }\n  function comp(num1: number, num2: number, op: string): number {\n    switch (op) {\n      case '+':\n        return num1 + num2;\n      case '-':\n        return num1 - num2;\n      case '*':\n        return num1 * num2;\n      default:\n        return num1 + num2;\n    }\n  }\n  function dfs(expression: string): number[] {\n    const n = expression.length;\n    const opIdxs: number[] = [];\n    for (let i = 0; i < n; i++) {\n      const ch = expression[i];\n      if (ch === '+' || ch === '-' || ch === '*') opIdxs.push(i);\n    }\n    if (opIdxs.length === 0) return [+expression];\n    const ans: number[] = [];\n    for (const idx of opIdxs) {\n      const [left, right] = split(expression, idx);\n      for (const num1 of dfs(left)) {\n        for (const num2 of dfs(right)) {\n          ans.push(comp(num1, num2, expression[idx]));\n        }\n      }\n    }\n    return ans;\n  }\n}"},{"date":"2022-07-01","time":8,"memory":12.4,"script":"cpp","desc":"分治。","code":"class Solution {\n   public:\n    unordered_set<char> opset;\n    Solution() {\n        opset.insert('+');\n        opset.insert('-');\n        opset.insert('*');\n    }\n    vector<int> diffWaysToCompute(string expression) {\n        vector<int> ans, oplist;\n        int n = expression.size();\n        for (int i = 0; i < n; i++) {\n            if (opset.count(expression[i])) oplist.push_back(i);\n        }\n        if (oplist.size() == 0)\n            ans.push_back(toNum(expression));\n        else\n            dfs(expression, oplist, ans);\n        return ans;\n    }\n    int toNum(string &expression) {\n        int num = 0, n = expression.size(), i = 0;\n        while (i < n && !opset.count(expression[i]))\n            num = num * 10 + expression[i++] - '0';\n        return num;\n    }\n    void dfs(string &expression, vector<int> &oplist, vector<int> &ans) {\n        for (auto &idx : oplist) {\n            vector<int> llist = diffWaysToCompute(expression.substr(0, idx));\n            vector<int> rlist = diffWaysToCompute(\n                expression.substr(idx + 1, expression.size() - idx));\n            for (auto &num1 : llist) {\n                for (auto &num2 : rlist) {\n                    switch (expression[idx]) {\n                        case '+':\n                            ans.push_back(num1 + num2);\n                            break;\n                        case '-':\n                            ans.push_back(num1 - num2);\n                            break;\n                        case '*':\n                            ans.push_back(num1 * num2);\n                            break;\n                    }\n                }\n            }\n        }\n    }\n};"},{"date":"2022-07-01","time":8,"memory":12.4,"script":"cpp","desc":"分治。","code":"class Solution {\n   public:\n    unordered_set<char> opset;\n    Solution() {\n        opset.insert('+');\n        opset.insert('-');\n        opset.insert('*');\n    }\n    vector<int> diffWaysToCompute(string expression) {\n        vector<int> ans, oplist;\n        int n = expression.size();\n        for (int i = 0; i < n; i++) {\n            if (opset.count(expression[i])) oplist.push_back(i);\n        }\n        if (oplist.size() == 0)\n            ans.push_back(toNum(expression));\n        else\n            dfs(expression, oplist, ans);\n        return ans;\n    }\n    int toNum(string &expression) {\n        int num = 0, n = expression.size(), i = 0;\n        while (i < n && !opset.count(expression[i]))\n            num = num * 10 + expression[i++] - '0';\n        return num;\n    }\n    void dfs(string &expression, vector<int> &oplist, vector<int> &ans) {\n        for (auto &idx : oplist) {\n            vector<int> llist = diffWaysToCompute(expression.substr(0, idx));\n            vector<int> rlist = diffWaysToCompute(\n                expression.substr(idx + 1, expression.size() - idx));\n            for (auto &num1 : llist) {\n                for (auto &num2 : rlist) {\n                    switch (expression[idx]) {\n                        case '+':\n                            ans.push_back(num1 + num2);\n                            break;\n                        case '-':\n                            ans.push_back(num1 - num2);\n                            break;\n                        case '*':\n                            ans.push_back(num1 * num2);\n                            break;\n                    }\n                }\n            }\n        }\n    }\n};"}],"tagList":["递归","记忆化搜索","数学","字符串","动态规划"],"level":"Medium"}},{"problemName":"242.有效的字母异位词.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/242.有效的字母异位词.json","problemData":{"id":"242","name":"242.有效的字母异位词","url":"https://leetcode.cn/problems/valid-anagram","desc":"给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。","solutions":[{"date":"2020-11-22","time":108,"memory":41.4,"script":"typescript","desc":"利用 cache 储存。","code":"function isAnagram(s: string, t: string): boolean {\n  const cache: Record<string, number> = {};\n  const setCache = (c: string) => {\n    cache[c] = 1 + (cache[c] ?? 0);\n  };\n  const delCache = (c: string) => {\n    cache[c]--;\n  };\n  for (const c of s) setCache(c);\n  for (const c of t) delCache(c);\n  return Object.entries(cache).every(([, c]) => c === 0);\n}"}],"tagList":["哈希表","字符串","排序"],"level":"Easy"}},{"problemName":"257.二叉树的所有路径.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/257.二叉树的所有路径.json","problemData":{"id":"257","name":"257.二叉树的所有路径","url":"https://leetcode.cn/problems/binary-tree-paths","desc":"给定一个二叉树，返回所有从根节点到叶子节点的路径。","solutions":[{"date":"2020-09-04","time":88,"memory":39.7,"script":"javascript","desc":"函数式编程，深度优先搜索。","code":"/**\n * @param {TreeNode} root\n * @return {string[]}\n */\nvar binaryTreePaths = function (root) {\n  if (!root) return [];\n  else if (!root.left && !root.right) return [root.val + ''];\n  else\n    return ['left', 'right']\n      .filter(sub => root[sub])\n      .map(sub =>\n        binaryTreePaths(root[sub])\n          .filter(v => v)\n          .map(v => `${root.val}->${v}`)\n      )\n      .flat();\n};"}],"tagList":["树","深度优先搜索","字符串","回溯","二叉树"],"level":"Easy"}},{"problemName":"258.各位相加.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/258.各位相加.json","problemData":{"id":"258","name":"258.各位相加","url":"https://leetcode.cn/problems/add-digits","desc":"给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。","solutions":[{"date":"2022-03-03","time":0,"memory":5.7,"script":"cpp","desc":"递归遍历。","code":"class Solution {\n   public:\n    int addDigits(int num) {\n        if (num < 10) return num;\n        int ans = 0;\n        for (; num; num /= 10) ans += num % 10;\n        return addDigits(ans);\n    }\n};"}],"tagList":["数学","数论","模拟"],"level":"Easy"}},{"problemName":"260.只出现一次的数字III.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/260.只出现一次的数字III.json","problemData":{"id":"260","name":"260.只出现一次的数字III","url":"https://leetcode.cn/problems/single-number-iii","desc":"给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。","solutions":[{"date":"2021-10-31","time":84,"memory":41.2,"script":"typescript","desc":"哈希。","code":"function singleNumber(nums: number[]): number[] {\n  const map = new Map<number, number>();\n  nums.forEach(num => {\n    map.set(num, (map.get(num) ?? 0) + 1);\n  });\n  return Array.from(map.entries())\n    .filter(([, v]) => v === 1)\n    .map(([k]) => k);\n}"},{"date":"2021-10-31","time":76,"memory":40.3,"script":"typescript","desc":"位运算。","code":"function singleNumber(nums: number[]): number[] {\n  const xorNum = nums.reduce((ans, num) => ans ^ num, 0);\n  let i = 0;\n  while ((xorNum & (1 << i)) === 0) i++;\n  let num1 = 0;\n  let num2 = 0;\n  for (const num of nums) {\n    if (num & (1 << i)) num1 ^= num;\n    else num2 ^= num;\n  }\n  return [num1, num2];\n}"},{"script":"python","time":44,"memory":17.14,"desc":"所有数异或后a^b, 找两数不同的1。","code":"class Solution:\n    def singleNumber(self, nums: List[int]) -> List[int]:\n        v = reduce(lambda a, b: a ^ b, nums)\n        v &= -v\n        num1 = num2 = 0\n        for num in nums:\n            if v & num:\n                num1 ^= num\n            else:\n                num2 ^= num\n        return [num1, num2]","date":"2023-10-16"}],"tagList":["位运算","数组"],"level":"Medium"}},{"problemName":"263.丑数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/263.丑数.json","problemData":{"id":"263","name":"263.丑数","url":"https://leetcode.cn/problems/ugly-number","desc":"给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。","solutions":[{"date":"2021-04-11","time":84,"memory":39.3,"script":"typescript","desc":"除以 235 检测是否为 1。","code":"function isUgly(n: number): boolean {\n  return n === 0\n    ? false\n    : 1 ===\n        [2, 3, 5].reduce((num, cur) => {\n          while (!(num % cur)) num /= cur;\n          return num;\n        }, n);\n}"}],"tagList":["数学"],"level":"Easy"}},{"problemName":"264.丑数II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/264.丑数II.json","problemData":{"id":"264","name":"264.丑数II","url":"https://leetcode.cn/problems/ugly-number-ii","desc":"给你一个整数 n ，请你找出并返回第 n 个 丑数 。","solutions":[{"date":"2021-04-11","time":200,"memory":45.3,"script":"typescript","desc":"依次利用 235 乘以堆顶值进行快速计算下一个丑数。","code":"class Heap<T> {\n  private arr: T[] = [];\n  get isEmpty() {\n    return this.size === 0;\n  }\n  get size() {\n    return this.arr.length;\n  }\n  get top() {\n    return this.arr[0];\n  }\n  constructor(private compare: (t1: T, t2: T) => number) {}\n  add(num: T): void {\n    this.arr.push(num);\n    this.shiftUp(this.size - 1);\n  }\n  remove(): T {\n    const num = this.arr.shift()!;\n    if (this.size) {\n      this.arr.unshift(this.arr.pop()!);\n      this.shiftDown(0);\n    }\n    return num;\n  }\n  private shiftUp(index: number): void {\n    if (index === 0) return;\n    const parentIndex = (index - 1) >> 1;\n    if (this.compare(this.arr[index], this.arr[parentIndex]) > 0) {\n      [this.arr[index], this.arr[parentIndex]] = [this.arr[parentIndex], this.arr[index]];\n      this.shiftUp(parentIndex);\n    }\n  }\n  private shiftDown(index: number): void {\n    let childrenIndex = index * 2 + 1;\n    if (childrenIndex > this.size - 1) return;\n    if (\n      childrenIndex + 1 <= this.size - 1 &&\n      this.compare(this.arr[childrenIndex + 1], this.arr[childrenIndex]) > 0\n    ) {\n      childrenIndex++;\n    }\n    if (this.compare(this.arr[childrenIndex], this.arr[index]) > 0) {\n      [this.arr[childrenIndex], this.arr[index]] = [this.arr[index], this.arr[childrenIndex]];\n      this.shiftDown(childrenIndex);\n    }\n  }\n}\nfunction nthUglyNumber(n: number): number {\n  if (n === 1) return 1;\n  let c = 1;\n  const heap = new Heap<number>((t1, t2) => t2 - t1);\n  heap.add(1);\n  while (cpp < n) {\n    const ans = heap.remove();\n    if (ans % 5 === 0) {\n      heap.add(ans * 5);\n    } else if (ans % 3 === 0) {\n      heap.add(ans * 5);\n      heap.add(ans * 3);\n    } else {\n      heap.add(ans * 5);\n      heap.add(ans * 3);\n      heap.add(ans * 2);\n    }\n  }\n  return heap.remove();\n}"}],"tagList":["哈希表","数学","动态规划","堆（优先队列）"],"level":"Medium"}},{"problemName":"268.丢失的数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/268.丢失的数字.json","problemData":{"id":"268","name":"268.丢失的数字","url":"https://leetcode.cn/problems/missing-number","desc":"给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。","solutions":[{"date":"2021-11-06","time":80,"memory":45,"script":"typescript","desc":"哈希。","code":"function missingNumber(nums: number[]): number {\n  const n = nums.length;\n  const set = new Set(nums);\n  for (let num = 0; num <= n; num++) {\n    if (!set.has(num)) return num;\n  }\n  return 0;\n}"},{"date":"2021-11-06","time":80,"memory":40.4,"script":"typescript","desc":"xor 去重。","code":"function missingNumber(nums: number[]): number {\n  const n = nums.length;\n  let num = 0;\n  for (let i = 0; i <= n; i++) num ^= i;\n  for (let i = 0; i < n; i++) num ^= nums[i];\n  return num;\n}"}],"tagList":["位运算","数组","哈希表","数学","二分查找","排序"],"level":"Easy"}},{"problemName":"273.整数转换英文表示.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/273.整数转换英文表示.json","problemData":{"id":"273","name":"273.整数转换英文表示","url":"https://leetcode.cn/problems/integer-to-english-words","desc":"将非负整数 num 转换为其对应的英文表示。","solutions":[{"date":"2021-10-11","time":80,"memory":39.6,"script":"typescript","desc":"分块计算。","code":"function numberToWords(num: number): string {\n  if (num === 0) return 'Zero';\n  const low = ['', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine'];\n  const mid = [\n    'Ten',\n    'Eleven',\n    'Twelve',\n    'Thirteen',\n    'Fourteen',\n    'Fifteen',\n    'Sixteen',\n    'Seventeen',\n    'Eighteen',\n    'Nineteen',\n  ];\n  const high = [\n    '',\n    '',\n    'Twenty',\n    'Thirty',\n    'Forty',\n    'Fifty',\n    'Sixty',\n    'Seventy',\n    'Eighty',\n    'Ninety',\n  ];\n  let ans = '';\n  let mod = 10 ** 9;\n  if (num >= mod) {\n    ans += `${format(Math.floor(num / mod))} Billion `;\n    num %= mod;\n  }\n  mod = 10 ** 6;\n  if (num >= mod) {\n    ans += `${format(Math.floor(num / mod))} Million `;\n    num %= mod;\n  }\n  mod = 10 ** 3;\n  if (num >= mod) {\n    ans += `${format(Math.floor(num / mod))} Thousand `;\n    num %= mod;\n  }\n  if (num > 0) {\n    ans += `${format(num)} `;\n  }\n  return ans.trimEnd();\n  function format(num: number) {\n    let ans = '';\n    if (num >= 100) {\n      ans += `${low[Math.floor(num / 100)]} Hundred `;\n      num %= 100;\n    }\n    const highNum = Math.floor(num / 10);\n    const lowNum = num % 10;\n    if (highNum >= 2) {\n      ans += `${high[highNum]}`;\n      if (lowNum > 0) ans += ` ${low[lowNum]} `;\n    } else if (highNum === 1) {\n      ans += `${mid[num - 10]} `;\n    } else {\n      ans += `${low[num]} `;\n    }\n    return ans.trimEnd();\n  }\n}"}],"tagList":["递归","数学","字符串"],"level":"Hard"}},{"problemName":"274.H指数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/274.H指数.json","problemData":{"id":"274","name":"274.H指数","url":"https://leetcode.cn/problems/h-index","desc":"给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。","solutions":[{"date":"2021-07-11","time":64,"memory":40.5,"script":"typescript","desc":"计数排序，储存每个数出现的次数。","code":"function hIndex(citations: number[]): number {\n  if (citations.every(v => v === 0)) return 0;\n  const max = Math.max(...citations);\n  const arr = new Array(max + 1).fill(0);\n  citations.forEach(num => arr[num]++);\n  let sum = 0;\n  let ans = 0;\n  for (let num = max; num >= 0; num--) {\n    const count = arr[num];\n    if (count === 0) continue;\n    ans = Math.max(ans, Math.min((sum += count), num));\n  }\n  return ans;\n}"},{"script":"python","time":36,"memory":16.2,"desc":"遍历。","code":"class Solution:\n    def hIndex(self, citations: List[int]) -> int:\n        n = len(citations)\n        citations.sort()\n        res = 0\n        for i in range(n):\n            if n - i <= citations[i]: res = max(res, n - i)\n        return res","date":"2023-10-29"}],"tagList":["数组","计数排序","排序"],"level":"Medium"}},{"problemName":"275.H指数II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/275.H指数II.json","problemData":{"id":"275","name":"275.H指数II","url":"https://leetcode.cn/problems/h-index-ii","desc":"给定一位研究者论文被引用次数的数组（被引用次数是非负整数），数组已经按照 升序排列 。编写一个方法，计算出研究者的 h 指数。","solutions":[{"date":"2021-07-12","time":68,"memory":42.7,"script":"typescript","desc":"直接求出最大值。","code":"function hIndex(citations: number[]): number {\n  if (citations.every(v => v === 0)) return 0;\n  const len = citations.length;\n  const max = citations[len - 1];\n  const arr = new Array(max + 1).fill(0);\n  citations.forEach(num => arr[num]++);\n  let sum = 0;\n  let ans = 0;\n  for (let num = max; num >= 0; num--) {\n    const count = arr[num];\n    if (count === 0) continue;\n    ans = Math.max(ans, Math.min((sum += count), num));\n  }\n  return ans;\n}"},{"date":"2021-07-12","time":80,"memory":42.7,"script":"typescript","desc":"二分查找。","code":"function hIndex(citations: number[]): number {\n  const len = citations.length;\n  let left = 0;\n  let right = len - 1;\n  while (left <= right) {\n    const mid = (left + right) >> 1;\n    if (citations[mid] >= len - mid) right = mid - 1;\n    else left = mid + 1;\n  }\n  return len - left;\n}"},{"script":"python","time":40,"memory":21.5,"desc":"二分搜索。","code":"class Solution:\n    def hIndex(self, citations: List[int]) -> int:\n        l = 0\n        r = len(citations)\n        while l < r:\n            m = (l + r) // 2\n            if citations[m] >= len(citations) - m:\n                r = m\n            else:\n                l = m + 1\n        return len(citations) - l","date":"2023-10-30"}],"tagList":["数组","二分查找"],"level":"Medium"}},{"problemName":"278.第一个错误的版本.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/278.第一个错误的版本.json","problemData":{"id":"278","name":"278.第一个错误的版本","url":"https://leetcode.cn/problems/first-bad-version","desc":"实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。","solutions":[{"date":"2021-06-14","time":84,"memory":39.2,"script":"typescript","desc":"二分搜索。","code":"function solution(isBadVersion: (version: number) => boolean): (n: number) => number {\n  return (n: number): number => {\n    const find = (start = 1, end = n): number => {\n      if (start === end) return start;\n      const mid = ~~((start + end) / 2);\n      if (!isBadVersion(mid)) return find(mid + 1, end);\n      else if (mid === 1 || !isBadVersion(mid - 1)) return mid;\n      else return find(start, mid);\n    };\n    return find();\n  };\n}"},{"date":"2021-11-28","time":0,"memory":5.5,"script":"c","desc":"二分。","code":"int firstBadVersion(int n) {\n    long l = 1, r = 2147483647, m;\n    while (l < r) {\n        m = (r + l) / 2;\n        // 每次中间值是错误版本，就右侧值左移当中间值\n        if (isBadVersion(m)) r = m;\n        // 否则就左侧点是成功版本，找中间值的后一个\n        else l = m + 1;\n    }\n    return l;\n}"},{"date":"2021-12-20","time":0,"memory":5.9,"script":"cpp","desc":"二分查找。","code":"class Solution {\n   public:\n    int firstBadVersion(int n) {\n        long long l = 0, r = 0x7fffffff, m;\n        while (l < r) {\n            m = (r + l) / 2;\n            if (isBadVersion(m))\n                r = m;\n            else\n                l = m + 1;\n        }\n        return l;\n    }\n};"}],"tagList":["二分查找","交互"],"level":"Easy"}},{"problemName":"279.完全平方数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/279.完全平方数.json","problemData":{"id":"279","name":"279.完全平方数","url":"https://leetcode.cn/problems/perfect-squares","desc":"给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。","solutions":[{"date":"2021-06-11","time":292,"memory":41.8,"script":"typescript","desc":"背包问题。","code":"function numSquares(n: number): number {\n  let MAX = 1;\n  const dp = new Array(n + 1).fill(Infinity);\n  dp[0] = 0;\n  dp[1] = 1;\n  for (let i = 2; i <= n; i++) {\n    while (MAX ** 2 <= i) MAX++;\n    for (let j = MAX - 1; j >= 1; j--) {\n      const num = j ** 2;\n      if (num > i) continue;\n      const count = ~~(i / num);\n      dp[i] = Math.min(dp[i], dp[i - num * count] + count);\n    }\n  }\n  return dp[n];\n}"},{"date":"2021-07-22","time":200,"memory":41.9,"script":"typescript","desc":"背包问题。","code":"function numSquares(n: number): number {\n  const dp = new Array(n + 1).fill(Infinity);\n  dp[0] = 0;\n  dp[1] = 1;\n  for (let i = 2; i < n + 1; i++) {\n    for (let j = 1; j ** 2 <= i; j++) {\n      dp[i] = Math.min(dp[i - j ** 2] + 1, dp[i]);\n    }\n  }\n  return dp[n];\n}"}],"tagList":["广度优先搜索","数学","动态规划"],"level":"Medium"}},{"problemName":"282.给表达式添加运算符.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/282.给表达式添加运算符.json","problemData":{"id":"282","name":"282.给表达式添加运算符","url":"https://leetcode.cn/problems/expression-add-operators","desc":"给定一个仅包含数字  0-9  的字符串 num 和一个目标值整数 target ，在 num 的数字之间添加 二元 运算符（不是一元）+、-  或  \\* ，返回所有能够得到目标值的表达式。","solutions":[{"date":"2021-10-16","time":7944,"memory":103.7,"script":"typescript","desc":"dfs。","code":"function addOperators(num: string, target: number): string[] {\n  const n = num.length;\n  if (n === 1) {\n    return +num === target ? [num] : [];\n  }\n  const ops = ['+', '-', '*', ''];\n  const ans = new Set<string>();\n  dfs();\n  return Array.from(ans);\n  function dfs(idx = 0, template = '') {\n    if (idx === n) {\n      if (eval(template) === target) ans.add(template);\n      return;\n    }\n    const current = num[idx];\n    template += current;\n    if (idx === n - 1) {\n      dfs(idx + 1, template);\n      return;\n    }\n    for (const op of ops) {\n      if (num[idx] === '0' && op === '') continue;\n      dfs(idx + 1, template + op);\n    }\n    while (idx < n - 1 && current !== '0' && num[idx + 1] === '0') {\n      template += '0';\n      dfs(idx + 2, template);\n      idx += 1;\n    }\n  }\n}"}],"tagList":["数学","字符串","回溯"],"level":"Hard"}},{"problemName":"283.移动零.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/283.移动零.json","problemData":{"id":"283","name":"283.移动零","url":"https://leetcode.cn/problems/move-zeroes","desc":"给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。","solutions":[{"date":"2020-11-19","time":96,"memory":40.7,"script":"typescript","desc":"遍历下标进行删除。","code":"function moveZeroes(nums: number[]): void {\n  const indexes: number[] = [];\n  for (let i = 0, l = nums.length; i < l; i++) {\n    nums[i] === 0 && indexes.unshift(i);\n  }\n  indexes.forEach(v => nums.splice(v, 1));\n  nums.push(...new Array(indexes.length).fill(0));\n}"},{"date":"2020-11-19","time":104,"memory":41.2,"script":"typescript","desc":"双指针。","code":"function moveZeroes(nums: number[]): void {\n  let left = 0;\n  let right = 0;\n  const len = nums.length;\n  const swap = (i1: number, i2: number) => ([nums[i1], nums[i2]] = [nums[i2], nums[i1]]);\n  while (right < len) {\n    if (nums[right] != 0) {\n      swap(left, right);\n      left++;\n    }\n    right++;\n  }\n}"}],"tagList":["数组","双指针"],"level":"Easy"}},{"problemName":"284.窥视迭代器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/284.窥视迭代器.json","problemData":{"id":"284","name":"284.窥视迭代器","url":"https://leetcode.cn/problems/peeking-iterator","desc":"给定一个迭代器类的接口，接口包含两个方法： next()  和  hasNext()。设计并实现一个支持  peek()  操作的顶端迭代器 -- 其本质就是把原本应由  next()  方法返回的元素  peek()  出来。","solutions":[{"date":"2020-04-17","time":75,"memory":35,"script":"javascript","desc":"缓存值","code":"class PeekingIterator {\n  constructor(iterator) {\n    this.iterator = iterator;\n    this.cacheNext = iterator.next();\n    this.cacheHasNext = iterator.hasNext();\n  }\n  /**\n   * @return {number}\n   */\n  peek() {\n    return this.cacheNext;\n  }\n\n  /**\n   * @return {number}\n   */\n  next() {\n    const cache = this.cacheNext;\n    this.cacheHasNext = this.iterator.hasNext();\n    this.cacheNext = this.iterator.next();\n    return cache;\n  }\n\n  /**\n   * @return {boolean}\n   */\n  hasNext() {\n    return this.cacheHasNext;\n  }\n}"},{"date":"2021-10-05","time":80,"memory":39.4,"script":"typescript","desc":"储存下一个值。","code":"class PeekingIterator {\n  private nextVal: number;\n  private nextState: boolean;\n  constructor(private iterator: Iterator) {\n    this.next();\n  }\n  peek(): number {\n    return this.nextVal;\n  }\n  next(): number {\n    const ans = this.nextVal;\n    this.nextState = this.iterator.hasNext();\n    this.nextVal = this.iterator.next();\n    return ans;\n  }\n  hasNext(): boolean {\n    return this.nextState;\n  }\n}"}],"tagList":["设计","数组","迭代器"],"level":"Medium"}},{"problemName":"287.寻找重复数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/287.寻找重复数.json","problemData":{"id":"287","name":"287.寻找重复数","url":"https://leetcode.cn/problems/find-the-duplicate-number","desc":"根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。","solutions":[{"date":"2020-05-26","time":452,"memory":35.3,"script":"typescript","desc":"使用 include 判断是否存在相同数即可","code":"var findDuplicate = function (nums: number[]): number {\n  for (let i = 0, len = nums.length; i < len; i++)\n    if (nums.includes(nums[i], i + 1)) return nums[i];\n  return 0;\n};"},{"date":"2020-05-26","time":72,"memory":36.8,"script":"typescript","desc":"二分查找，通过只有一个数重复且数大小在 1~len-1 之间时进行判断","code":"var findDuplicate = function (nums: number[]): number {\n  const len = nums.length;\n  let l = 1,\n    r = len - 1,\n    res = -1;\n  while (l <= r) {\n    let c = 0;\n    const mid = (l + r) >> 1;\n    for (const num of nums) if (num <= mid) cpp;\n    if (c <= mid) {\n      l = mid + 1;\n    } else {\n      r = mid - 1;\n      res = mid;\n    }\n  }\n  return res;\n};"},{"date":"2020-05-26","time":68,"memory":36.7,"script":"typescript","desc":"利用位运算节省空间，遍历一遍即可","code":"var findDuplicate = function (nums: number[]): number {\n  const maxRadix = 30;\n  let cache: number[] = new Array(2).fill(0);\n  for (const num of nums) {\n    const compNum = num - 1;\n    const cacheNum = Math.floor(compNum / 30);\n    const bit = 1 << compNum;\n    if ((cache[cacheNum] & bit) !== 0) return num;\n    cache[cacheNum] |= bit;\n  }\n  return 0;\n};"},{"date":"2021-12-04","time":100,"memory":47.1,"script":"typescript","desc":"快慢指针。","code":"function findDuplicate(nums: number[]): number {\n  let p = nums[0];\n  let q = nums[p];\n  while (p != q) {\n    p = nums[p];\n    q = nums[nums[q]];\n  }\n  p = 0;\n  while (p != q) {\n    p = nums[p];\n    q = nums[q];\n  }\n  return p;\n}"}],"tagList":["位运算","数组","双指针","二分查找"],"level":"Medium"}},{"problemName":"289.生命游戏.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/289.生命游戏.json","problemData":{"id":"289","name":"289.生命游戏","url":"https://leetcode.cn/problems/game-of-life","desc":"根据 百度百科 ，生命游戏，简称为生命，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。","solutions":[{"date":"2020-04-09","time":60,"memory":34,"script":"javascript","desc":"判断周围 8 个位置的活细胞个数进行新数组赋值","code":"/**\n * @param {number[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nvar gameOfLife = function (board) {\n  function lifeOrDead(arr, now) {\n    let result = 0;\n    for (let item of arr) if (item === 1) result++;\n    if (result === 2) return now;\n    else if (result === 3) return 1;\n    else return 0;\n  }\n  const res = [];\n  for (let i = 0, len1 = board.length; i < len1; i++) res[i] = [];\n  for (let i = 0, len1 = board.length; i < len1; i++) {\n    for (let j = 0, len2 = board[i].length; j < len2; j++) {\n      const arr = [];\n      if (i > 0 && j > 0) arr.push(board[i - 1][j - 1]);\n      if (i > 0) arr.push(board[i - 1][j]);\n      if (j > 0) arr.push(board[i][j - 1]);\n      if (i < len1 - 1 && j < len2 - 1) arr.push(board[i + 1][j + 1]);\n      if (i < len1 - 1) arr.push(board[i + 1][j]);\n      if (j < len2 - 1) arr.push(board[i][j + 1]);\n      if (i < len1 - 1 && j > 0) arr.push(board[i + 1][j - 1]);\n      if (j < len2 - 1 && i > 0) arr.push(board[i - 1][j + 1]);\n      res[i][j] = lifeOrDead(arr, board[i][j]);\n    }\n  }\n  for (let i = 0, len1 = board.length; i < len1; i++) board[i] = res[i];\n};"},{"date":"2021-12-12","time":68,"memory":39.4,"script":"typescript","desc":"生成周围有几个活细胞的数组进行赋值。","code":"function getCntArr(board: number[][]) {\n  const n = board.length;\n  const m = board[0].length;\n  const ans = new Array(n).fill(0).map(_ => new Array(m).fill(0));\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (board[i][j] === 0) continue;\n      if (i > 0) ans[i - 1][j]++;\n      if (i < n - 1) ans[i + 1][j]++;\n      if (j > 0) ans[i][j - 1]++;\n      if (j < m - 1) ans[i][j + 1]++;\n      if (i > 0 && j > 0) ans[i - 1][j - 1]++;\n      if (i > 0 && j < m - 1) ans[i - 1][j + 1]++;\n      if (i < n - 1 && j > 0) ans[i + 1][j - 1]++;\n      if (i < n - 1 && j < m - 1) ans[i + 1][j + 1]++;\n    }\n  }\n  return ans;\n}\nfunction gameOfLife(board: number[][]): void {\n  const n = board.length;\n  const m = board[0].length;\n  const cntArr = getCntArr(board);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      const cnt = cntArr[i][j];\n      const state = board[i][j];\n      if (state === 1 && (cnt < 2 || cnt > 3)) board[i][j] = 0;\n      else if (state === 0 && cnt === 3) board[i][j] = 1;\n    }\n  }\n}"},{"date":"2021-12-12","time":68,"memory":39.6,"script":"typescript","desc":"优化上一题解。","code":"const dirs = [\n  [0, 1],\n  [0, -1],\n  [1, 0],\n  [-1, 0],\n  [1, 1],\n  [-1, -1],\n  [1, -1],\n  [-1, 1],\n];\nfunction getCntArr(board: number[][]) {\n  const n = board.length;\n  const m = board[0].length;\n  const ans = new Array(n).fill(0).map(_ => new Array(m).fill(0));\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      for (let k = 0; k < 8; k++) {\n        const x = i + dirs[k][0];\n        const y = j + dirs[k][1];\n        if (x < 0 || x >= n || y < 0 || y >= m) continue;\n        ans[x][y] += board[i][j];\n      }\n    }\n  }\n  return ans;\n}\nfunction gameOfLife(board: number[][]): void {\n  const n = board.length;\n  const m = board[0].length;\n  const cntArr = getCntArr(board);\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      const cnt = cntArr[i][j];\n      const state = board[i][j];\n      if (state === 1 && (cnt < 2 || cnt > 3)) board[i][j] = 0;\n      else if (state === 0 && cnt === 3) board[i][j] = 1;\n    }\n  }\n}"}],"tagList":["数组","矩阵","模拟"],"level":"Medium"}},{"problemName":"290.单词规律.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/290.单词规律.json","problemData":{"id":"290","name":"290.单词规律","url":"https://leetcode.cn/problems/word-pattern","desc":"给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。","solutions":[{"date":"2020-12-16","time":104,"memory":40.2,"script":"typescript","desc":"利用哈希表和 set 储存已遍历过的值。","code":"function wordPattern(pattern: string, s: string): boolean {\n  const cache: Record<string, string> = {};\n  const set = new Set<string>();\n  const arr = s.split(' ');\n  const len = arr.length;\n  if (len !== pattern.length) return false;\n  for (let i = 0; i < len; i++) {\n    const p = pattern[i];\n    const str = arr[i];\n    if (!cache[p] && !set.has(str)) {\n      cache[p] = str;\n      set.add(str);\n    } else if (cache[p] !== str) return false;\n  }\n  return true;\n}"}],"tagList":["哈希表","字符串"],"level":"Easy"}},{"problemName":"292.Nim游戏.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/292.Nim游戏.json","problemData":{"id":"292","name":"292.Nim游戏","url":"https://leetcode.cn/problems/nim-game","desc":"你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。","solutions":[{"date":"2020-05-19","time":72,"memory":32.3,"script":"javascript","desc":"只要不是 4 的倍数即可。","code":"/**\n * @param {number} n\n * @return {boolean}\n */\nvar canWinNim = n => n % 4 !== 0;"},{"date":"2021-09-18","time":76,"memory":39.3,"script":"javascript","desc":"统计。","code":"function canWinNim(n: number): boolean {\n  return n % 4 !== 0;\n}"},{"script":"python","time":29,"memory":16.47,"desc":"看谁能抢4。","code":"class Solution:\n    def canWinNim(self, n: int) -> bool:\n        return not not n % 4","date":"2024-02-04"}],"tagList":["脑筋急转弯","数学","博弈"],"level":"Easy"}},{"problemName":"295.数据流的中位数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/295.数据流的中位数.json","problemData":{"id":"295","name":"295.数据流的中位数","url":"https://leetcode.cn/problems/find-median-from-data-stream","desc":"中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。","solutions":[{"date":"2021-04-10","time":272,"memory":58.5,"script":"typescript","desc":"构建左侧大顶堆和右侧小顶堆，中间值为左侧堆最大值和右侧堆最小值的比较。","code":"class Heap<T> {\n  private arr: T[] = [];\n  get isEmpty() {\n    return this.size === 0;\n  }\n  get size() {\n    return this.arr.length;\n  }\n  get top() {\n    return this.arr[0];\n  }\n  constructor(private compare: (t1: T, t2: T) => number) {}\n  add(num: T): void {\n    this.arr.push(num);\n    this.shiftUp(this.size - 1);\n  }\n  remove(): T {\n    const num = this.arr.shift()!;\n    if (this.size) {\n      this.arr.unshift(this.arr.pop()!);\n      this.shiftDown(0);\n    }\n    return num;\n  }\n  private shiftUp(index: number): void {\n    if (index === 0) return;\n    const parentIndex = (index - 1) >> 1;\n    if (this.compare(this.arr[index], this.arr[parentIndex]) > 0) {\n      [this.arr[index], this.arr[parentIndex]] = [this.arr[parentIndex], this.arr[index]];\n      this.shiftUp(parentIndex);\n    }\n  }\n  private shiftDown(index: number): void {\n    let childrenIndex = index * 2 + 1;\n    if (childrenIndex > this.size - 1) return;\n    if (\n      childrenIndex + 1 <= this.size - 1 &&\n      this.compare(this.arr[childrenIndex + 1], this.arr[childrenIndex]) > 0\n    ) {\n      childrenIndex++;\n    }\n    if (this.compare(this.arr[childrenIndex], this.arr[index]) > 0) {\n      [this.arr[childrenIndex], this.arr[index]] = [this.arr[index], this.arr[childrenIndex]];\n      this.shiftDown(childrenIndex);\n    }\n  }\n}\n\nclass MedianFinder {\n  private leftHeap = new Heap<number>((num1: number, num2: number) => num1 - num2);\n  private rightHeap = new Heap<number>((num1: number, num2: number) => num2 - num1);\n  get size() {\n    return this.leftHeap.size + this.rightHeap.size;\n  }\n  addNum(num: number): void {\n    if (!this.leftHeap.size || this.leftHeap.top >= num) {\n      this.leftHeap.add(num);\n    } else {\n      this.rightHeap.add(num);\n    }\n    if (this.leftHeap.size === this.rightHeap.size + 2) {\n      this.rightHeap.add(this.leftHeap.remove());\n    } else if (this.leftHeap.size === this.rightHeap.size - 1) {\n      this.leftHeap.add(this.rightHeap.remove());\n    }\n  }\n  findMedian(): number {\n    if (this.size % 2 === 0) {\n      return (this.leftHeap.top + this.rightHeap.top) / 2;\n    } else {\n      return this.leftHeap.top;\n    }\n  }\n}"},{"date":"2021-08-27","time":1648,"memory":68.1,"script":"typescript","desc":"构建左侧大顶堆，右侧小顶堆，快速取中值。","code":"class Heap<T> {\n  private arr: T[] = [];\n  get isEmpty() {\n    return this.size === 0;\n  }\n  get size() {\n    return this.arr.length;\n  }\n  get top() {\n    return this.arr[0];\n  }\n  constructor(private compare: (t1: T, t2: T) => number) {}\n  add(num: T): void {\n    this.arr.push(num);\n    this.shiftUp(this.size - 1);\n  }\n  remove(): T {\n    const num = this.arr.shift()!;\n    if (this.size) {\n      this.arr.unshift(this.arr.pop()!);\n      this.shiftDown(0);\n    }\n    return num;\n  }\n  private shiftUp(index: number): void {\n    if (index === 0) return;\n    const parentIndex = (index - 1) >> 1;\n    if (this.compare(this.arr[index], this.arr[parentIndex]) > 0) {\n      [this.arr[index], this.arr[parentIndex]] = [this.arr[parentIndex], this.arr[index]];\n      this.shiftUp(parentIndex);\n    }\n  }\n  private shiftDown(index: number): void {\n    let childrenIndex = index * 2 + 1;\n    if (childrenIndex > this.size - 1) return;\n    if (\n      childrenIndex + 1 <= this.size - 1 &&\n      this.compare(this.arr[childrenIndex + 1], this.arr[childrenIndex]) > 0\n    ) {\n      childrenIndex++;\n    }\n    if (this.compare(this.arr[childrenIndex], this.arr[index]) > 0) {\n      [this.arr[childrenIndex], this.arr[index]] = [this.arr[index], this.arr[childrenIndex]];\n      this.shiftDown(childrenIndex);\n    }\n  }\n}\nclass MedianFinder {\n  left = new Heap<number>((t1, t2) => t1 - t2);\n  right = new Heap<number>((t1, t2) => t2 - t1);\n  get cnt() {\n    return this.left.size + this.right.size;\n  }\n  addNum(num: number): void {\n    if (this.left.size === 0 && this.right.size === 0) {\n      this.left.add(num);\n    } else if (this.left.top < num) {\n      this.right.add(num);\n    } else {\n      this.left.add(num);\n    }\n    if (this.right.size + 1 > this.left.size) this.left.add(this.right.remove());\n    if (this.left.size - 1 > this.right.size) this.right.add(this.left.remove());\n  }\n  findMedian(): number {\n    return this.cnt % 2 === 0 ? (this.left.top + this.right.top) / 2 : this.left.top;\n  }\n}"},{"date":"2021-11-28","time":376,"memory":83,"script":"c","desc":"堆。","code":"#define swap(a, b)              \\\n    {                           \\\n        __typeof(a) __temp = a; \\\n        a = b;                  \\\n        b = __temp;             \\\n    }\n\ntypedef struct\n{\n    int size, len, *data;\n    int(*comp)(int, int);\n} Heap;\nHeap *heap_create(int len, int (*comp)(int, int))\n{\n    Heap *h = (Heap *)malloc(sizeof(Heap));\n    h->comp = comp;\n    h->len = len;\n    h->size = 0;\n    h->data = (int *)malloc(sizeof(int) * len);\n    return h;\n}\nvoid heap_free(Heap *h)\n{\n    if (!h)\n        return;\n    free(h->data);\n    free(h);\n}\nvoid heap_shift_up(Heap *h, int idx)\n{\n    while (idx)\n    {\n        int p = (idx - 1) / 2;\n        if (h->comp(h->data[idx], h->data[p]) > 0)\n        {\n            swap(h->data[p], h->data[idx]);\n            idx = p;\n        }\n        else\n            break;\n    }\n}\nvoid heap_shift_down(Heap *h, int idx)\n{\n    while (idx * 2 + 1 < h->size)\n    {\n        int child = idx;\n        if (h->comp(h->data[child], h->data[idx * 2 + 1]) < 0)\n        {\n            child = idx * 2 + 1;\n        }\n        if (\n            idx * 2 + 2 < h->len && h->comp(h->data[child], h->data[idx * 2 + 2]) < 0)\n        {\n            child = idx * 2 + 2;\n        }\n        if (child == idx)\n            break;\n        swap(h->data[idx], h->data[child]);\n        idx = child;\n    }\n}\nint heap_remove(Heap *h)\n{\n    if (!h || h->size == 0)\n        return -1;\n    int val = h->data[0];\n    h->data[0] = h->data[--h->size];\n    heap_shift_down(h, 0);\n    return val;\n}\nint heap_add(Heap *h, int val)\n{\n    if (!h || h->len == h->size)\n        return 0;\n    h->data[h->size] = val;\n    heap_shift_up(h, h->size++);\n    return val;\n}\nint heap_top(Heap *h)\n{\n    if (!h || h->size == 0)\n        return -1;\n    return h->data[0];\n}\nvoid heap_show(Heap *h)\n{\n#ifdef DEBUG\n    printf(\"Heap : [\");\n    for (int i = 0; i < h->len; i++)\n    {\n        if (!h->data[i])\n            continue;\n        i != 0 && printf(\",\");\n        printf(\"%d\", h->data[i]);\n    }\n    printf(\"]\\n\");\n#endif\n}\n\nint comp1(int a, int b)\n{\n    return a - b;\n}\nint comp2(int a, int b)\n{\n    return b- a;\n}\n\ntypedef struct {\n    Heap *h1, *h2;\n} MedianFinder;\n\n#define MAX 200000\nMedianFinder* medianFinderCreate() {\n    MedianFinder *o = (MedianFinder *)malloc(sizeof(MedianFinder));\n    o->h1 = heap_create(MAX, comp1);\n    o->h2 = heap_create(MAX, comp2);\n    return o;\n}\n\nvoid medianFinderAddNum(MedianFinder* obj, int num) {\n    if(obj->h1->size == 0 || num <= heap_top(obj->h1)) {\n        heap_add(obj->h1, num);\n        if (obj->h1->size > obj->h2->size + 1) heap_add(obj->h2, heap_remove(obj->h1));\n    }\n    else {\n        heap_add(obj->h2, num);\n        if (obj->h2->size > obj->h1->size) heap_add(obj->h1, heap_remove(obj->h2));\n    }\n}\n\ndouble medianFinderFindMedian(MedianFinder* obj) {\n    if((obj->h1->size + obj->h2->size) & 1) return heap_top(obj->h1);\n    else return (heap_top(obj->h1) + heap_top(obj->h2)) / 2.0;\n}\n\nvoid medianFinderFree(MedianFinder* obj) {\n    heap_free(obj->h1);\n    heap_free(obj->h2);\n    free(obj);\n}"}],"tagList":["设计","双指针","数据流","排序","堆（优先队列）"],"level":"Hard"}},{"problemName":"297.二叉树的序列化与反序列化.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/297.二叉树的序列化与反序列化.json","problemData":{"id":"297","name":"297.二叉树的序列化与反序列化","url":"https://leetcode.cn/problems/serialize-and-deserialize-binary-tree","desc":"请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。","solutions":[{"date":"2020-06-16","time":108,"memory":44,"script":"javascript","desc":"取巧，直接输出，虽然通过但并不符合题意。","code":"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n\n/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function (root) {\n  return root;\n};\n\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function (data) {\n  return data;\n};\n\n/**\n * Your functions will be called as such:\n * deserialize(serialize(root));\n */"},{"date":"2020-06-16","time":156,"memory":46.8,"script":"javascript","desc":"使用 LeetCode 格式进行序列化与反序列化。","code":"var serialize = function (root) {\n  const queue = [root];\n  let str = '';\n  while (!isNull()) {\n    const node = queue.shift();\n    if (node === null) {\n      str += 'null,';\n      continue;\n    } else {\n      str += node.val + ',';\n    }\n    if (node.left !== null) queue.push(node.left);\n    else queue.push(null);\n    if (node.right !== null) queue.push(node.right);\n    else queue.push(null);\n  }\n  return `[${str.substr(0, str.length - 1)}]`;\n  function isNull() {\n    for (const node of queue) {\n      if (node !== null) return false;\n    }\n    return true;\n  }\n};\nvar deserialize = function (data) {\n  if (data === '[]') return null;\n  const arr = data\n    .substring(1, data.length - 1)\n    .split(',')\n    .map(v => (v === 'null' ? null : Number(v)));\n  if (arr.length === 0) return null;\n  let root = new TreeNode(arr.shift());\n  const queue = [root];\n  while (queue.length !== 0) {\n    const node = queue.shift();\n    let temp = arr.shift();\n    if (temp !== null && temp !== undefined) {\n      node.left = new TreeNode(temp);\n      queue.push(node.left);\n    }\n    temp = arr.shift();\n    if (temp !== null && temp !== undefined) {\n      node.right = new TreeNode(temp);\n      queue.push(node.right);\n    }\n  }\n  return root;\n};"},{"date":"2021-06-30","time":152,"memory":48.1,"script":"typescript","desc":"利用 JSON 化。","code":"/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function (root) {\n  return JSON.stringify(root);\n};\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function (data) {\n  return JSON.parse(data);\n};"}],"tagList":["树","深度优先搜索","广度优先搜索","设计","字符串","二叉树"],"level":"Hard"}},{"problemName":"299.猜数字游戏.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/299.猜数字游戏.json","problemData":{"id":"299","name":"299.猜数字游戏","url":"https://leetcode.cn/problems/bulls-and-cows","desc":"给你一个秘密数字 secret 和朋友猜测的数字 guess ，请你返回对朋友这次猜测的提示。","solutions":[{"date":"2021-11-08","time":100,"memory":40.2,"script":"typescript","desc":"遍历。","code":"function getHint(secret: string, guess: string): string {\n  const n = secret.length;\n  let a = 0;\n  let b = 0;\n  const map: Record<string, number> = {};\n  const set = new Set<number>();\n  for (let i = 0; i < n; i++) {\n    const ch1 = secret[i];\n    const ch2 = guess[i];\n    if (ch1 === ch2) {\n      a++;\n      set.add(i);\n    } else map[ch1] = (map[ch1] ?? 0) + 1;\n  }\n  for (let i = 0; i < n; i++) {\n    if (set.has(i)) continue;\n    const ch2 = guess[i];\n    if (map[ch2]) {\n      b++;\n      map[ch2]--;\n    }\n  }\n  return `${a}A${b}B`;\n}"},{"script":"python","time":68,"memory":16.65,"desc":"遍历。","code":"class Solution:\n    def getHint(self, secret: str, guess: str) -> str:\n        s1 = []\n        s2 = []\n        n = len(secret)\n        x = y = 0\n        for i in range(n):\n            if secret[i] == guess[i]:\n                x += 1\n            else:\n                s1.append(secret[i])\n                s2.append(guess[i])\n        for num in s1:\n            if num in s2:\n                y += 1\n                s2.remove(num)\n        return f'{x}A{y}B'","date":"2024-03-10"}],"tagList":["哈希表","字符串","计数"],"level":"Medium"}},{"problemName":"300.最长递增子序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/201-300/300.最长递增子序列.json","problemData":{"id":"300","name":"300.最长递增子序列","url":"https://leetcode.cn/problems/longest-increasing-subsequence","desc":"给定一个无序的整数数组，找到其中最长上升子序列的长度。","solutions":[{"date":"2020-05-10","time":72,"memory":34.6,"script":"javascript","desc":"递推的基础上，判断前一项是否值小于当前项。","code":"/**\n * @param {number[]} nums\n * @return {number}\n */\nvar lengthOfLIS = function (nums) {\n  const len = nums.length;\n  if (len === 0) return 0;\n  const dp = [1];\n  let max,\n    res = 1;\n  for (let i = 1; i < len; i++) {\n    const num = nums[i];\n    max = 0;\n    for (let j = 0; j < i; j++) {\n      if (nums[j] >= num) continue;\n      max = max > dp[j] ? max : dp[j];\n    }\n    dp[i] = max + 1;\n    res = res > dp[i] ? res : dp[i];\n  }\n  return res;\n};"},{"date":"2021-09-04","time":192,"memory":39.9,"script":"typescript","desc":"动态规划。","code":"function lengthOfLIS(nums: number[]): number {\n  const n = nums.length;\n  const dp = new Array(n).fill(1);\n  let ans = 1;\n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < i; j++) {\n      if (nums[i] > nums[j]) {\n        dp[i] = Math.max(dp[i], dp[j] + 1);\n        ans = Math.max(ans, dp[i]);\n      }\n    }\n  }\n  return ans;\n}"},{"date":"2021-09-04","time":76,"memory":39.5,"script":"typescript","desc":"找尽可能长的序列。","code":"function lengthOfLIS(nums: number[]): number {\n  const list = [nums[0]];\n  for (const num of nums) list[find(num)] = num;\n  return list.length;\n  function find(num: number): number {\n    let l = 0;\n    let r = list.length - 1;\n    if (num > list[r]) return list.length;\n    while (l < r) {\n      const mid = (l + r) >> 1;\n      if (list[mid] >= num) r = mid;\n      else l = mid + 1;\n    }\n    return l;\n  }\n}"},{"date":"2021-09-04","time":192,"memory":39.9,"script":"typescript","desc":"动态规划。","code":"function lengthOfLIS(nums: number[]): number {\n  const n = nums.length;\n  const dp = new Array(n).fill(1);\n  let ans = 1;\n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < i; j++) {\n      if (nums[i] > nums[j]) {\n        dp[i] = Math.max(dp[i], dp[j] + 1);\n        ans = Math.max(ans, dp[i]);\n      }\n    }\n  }\n  return ans;\n}"},{"date":"2021-09-04","time":76,"memory":39.5,"script":"typescript","desc":"找尽可能长的序列。","code":"function lengthOfLIS(nums: number[]): number {\n  const list = [nums[0]];\n  for (const num of nums) list[find(num)] = num;\n  return list.length;\n  function find(num: number): number {\n    let l = 0;\n    let r = list.length - 1;\n    if (num > list[r]) return list.length;\n    while (l < r) {\n      const mid = (l + r) >> 1;\n      if (list[mid] >= num) r = mid;\n      else l = mid + 1;\n    }\n    return l;\n  }\n}"}],"tagList":["数组","二分查找","动态规划"],"level":"Medium"}}]},{"dirName":"2101-2200","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\2101-2200","problems":[{"problemName":"2101.引爆最多的炸弹.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2101-2200/2101.引爆最多的炸弹.json","problemData":{"id":"2206","name":"2101.引爆最多的炸弹","url":"https://leetcode.cn/problems/detonate-the-maximum-bombs","desc":"给你数组 bombs ，请你返回在引爆 一个 炸弹的前提下，最多 能引爆的炸弹数目。","solutions":[{"script":"python","time":510,"memory":17.08,"desc":"遍历存储所有爆炸链接后dfs。","code":"class Solution:\n    def maximumDetonation(self, bombs: List[List[int]]) -> int:\n        n = len(bombs)\n        nexts = [[] for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    if (bombs[i][0] - bombs[j][0]) ** 2 + (bombs[i][1] - bombs[j][1]) ** 2 <= bombs[i][2] ** 2:\n                        nexts[i].append(j)\n        def dfs(cur: int, used: List[bool]) -> int:\n            used[cur] = True\n            return sum(\n                dfs(next, used)\n                for next in nexts[cur]\n                if not used[next]\n            ) + 1\n        return max(dfs(i, [False] * n) for i in range(n))","date":"2024-07-22"}],"tagList":["深度优先搜索","广度优先搜索","图","几何","数组","数学"],"level":"Medium"}},{"problemName":"2103.环和杆.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2101-2200/2103.环和杆.json","problemData":{"id":"2226","name":"2103.环和杆","url":"https://leetcode.cn/problems/rings-and-rods","desc":"找出所有集齐 全部三种颜色 环的杆，并返回这种杆的数量。","solutions":[{"script":"python","time":40,"memory":15.66,"desc":"遍历。","code":"class Solution:\n    def countPoints(self, rings: str) -> int:\n        map = { 'R': 0, 'G': 1, 'B': 2}\n        arr = [0] * 10\n        for i in range(0, len(rings), 2):\n            arr[int(rings[i + 1])] |= 1 << map[rings[i]]\n        return sum(v == 0b111 for v in arr)","date":"2023-11-02"}],"tagList":["哈希表","字符串"],"level":"Easy"}},{"problemName":"2104.子数组范围和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2101-2200/2104.子数组范围和.json","problemData":{"id":"2227","name":"2104.子数组范围和","url":"https://leetcode.cn/problems/sum-of-subarray-ranges","desc":"给你一个整数数组 nums 。nums 中，子数组的 范围 是子数组中最大元素和最小元素的差值。返回 nums 中 所有 子数组范围的 和 。","solutions":[{"date":"2022-03-04","time":12,"memory":11.5,"script":"cpp","desc":"单调栈，把子数组求和变换为，所有子数组的最大值求和减去最小值求和。","code":"class Solution {\n   public:\n    struct node {\n        int minl, maxl, minr, maxr, idx, num;\n    };\n    long long subArrayRanges(vector<int>& nums) {\n        long long ans = 0;\n        int n = nums.size();\n        stack<int> mins, maxs;\n        vector<node> list(n);\n        for (int i = 0; i < n; i++) {\n            list[i].idx = i;\n            list[i].num = nums[i];\n            while (mins.size() && nums[mins.top()] > nums[i]) {\n                list[mins.top()].minr = i;\n                mins.pop();\n            }\n            list[i].minl = mins.size() ? mins.top() : -1;\n            while (maxs.size() && nums[maxs.top()] < nums[i]) {\n                list[maxs.top()].maxr = i;\n                maxs.pop();\n            }\n            list[i].maxl = maxs.size() ? maxs.top() : -1;\n            mins.push(i);\n            maxs.push(i);\n        }\n        while (mins.size()) {\n            list[mins.top()].minr = n;\n            mins.pop();\n        }\n        while (maxs.size()) {\n            list[maxs.top()].maxr = n;\n            maxs.pop();\n        }\n        for (int i = 0; i < n; i++) {\n            ans += (long long)(list[i].maxr - i) * (i - list[i].maxl) *\n                   list[i].num;\n            ans -= (long long)(list[i].minr - i) * (i - list[i].minl) *\n                   list[i].num;\n        }\n        return ans;\n    }\n};"}],"tagList":["栈","数组","单调栈"],"level":"Medium"}},{"problemName":"2105.给植物浇水II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2101-2200/2105.给植物浇水II.json","problemData":{"id":"2228","name":"2105.给植物浇水II","url":"https://leetcode.cn/problems/watering-plants-ii","desc":"给你一个下标从 0 开始的整数数组 plants ，数组由 n 个整数组成。其中，plants[i] 为第 i 株植物需要的水量。另有两个整数 capacityA 和 capacityB 分别表示 Alice 和 Bob 水罐的容量。返回两人浇灌所有植物过程中重新灌满水罐的 次数 。","solutions":[{"script":"python","time":86,"memory":31.19,"desc":"模拟。","code":"class Solution:\n    def minimumRefill(self, plants: List[int], capacityA: int, capacityB: int) -> int:\n        res = 0\n        n = len(plants)\n        a = 0\n        wa = capacityA\n        b = n - 1\n        wb = capacityB\n        while a < b:\n            if wa < plants[a]:\n                wa = capacityA\n                res += 1\n            wa -= plants[a]\n            if wb < plants[b]:\n                wb = capacityB\n                res += 1\n            wb -= plants[b]\n            a += 1\n            b -= 1\n        if a == b and max(wa, wb) < plants[a]:\n            res += 1\n        return res","date":"2024-05-09"}],"tagList":["数组","双指针","模拟"],"level":"Medium"}},{"problemName":"2106.摘水果.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2101-2200/2106.摘水果.json","problemData":{"id":"2229","name":"2106.摘水果","url":"https://leetcode.cn/problems/maximum-fruits-harvested-after-at-most-k-steps","desc":"返回你可以摘到水果的 最大总数 。","solutions":[{"script":"cpp","time":388,"memory":163.4,"desc":"每向左走到一个水果点，对右侧进行二分查找最大能走到的水果点。","code":"class Solution {\npublic:\n    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {\n        int res = 0;\n        vector<vector<int>> l, r;\n        r.push_back(vector<int>{ -1, 0});\n        for (auto &item : fruits) {\n            item[0] -= startPos;\n            if (item[0] < 0) item[0] = -item[0], l.push_back(item);\n            else if (item[0] > 0) r.push_back(item);\n            else res += item[1];\n        }\n        l.push_back(vector<int>{ -1, 0});\n        reverse(l.begin(), l.end());\n        l.push_back(vector<int>{ INT_MAX, 0});\n        r.push_back(vector<int>{ INT_MAX, 0});\n        vector<int> sumL(1, 0), sumR(1, 0);\n        for (auto &item : l) sumL.push_back(sumL.back() + item[1]);\n        for (auto &item : r) sumR.push_back(sumR.back() + item[1]);\n        return res + max(f(l, sumL, r, sumR, k), f(r, sumR, l, sumL, k));\n    }\n    int f(vector<vector<int>> &left, vector<int> &sumL, vector<vector<int>> &right, vector<int> &sumR, int k) {\n        int res = sumR[bs(right, k)];\n        for (int i = 1; i < left.size() && left[i][0] <= k; i++)\n            res = max(res, sumL[i + 1] + sumR[bs(right, k - left[i][0] * 2)]);\n        return res;\n    }\n    int bs(vector<vector<int>> &list, int target) {\n        if (target <= 0) return 0;\n        int l = 0, r = list.size();\n        while (l < r) {\n            int m = (l + r) / 2;\n            if (list[m][0] > target) r = m;\n            else l = m + 1;\n        }\n        return l;\n    }\n};","date":"2023-05-04"},{"script":"python","time":476,"memory":50.9,"desc":"同上。","code":"class Solution:\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\n        res = 0\n        l, r = [], []\n        r.append([-1, 0])\n        for item in fruits:\n            item[0] -= startPos\n            if item[0] < 0:\n                item[0] = -item[0]\n                l.append(item)\n            elif item[0] > 0:\n                r.append(item)\n            else:\n                res += item[1]\n        l.append([-1, 0])\n        l.reverse()\n        l.append([inf, 0])\n        r.append([inf, 0])\n\n        sumL, sumR = [0], [0]\n        for item in l:\n            sumL.append(sumL[-1] + item[1])\n        for item in r:\n            sumR.append(sumR[-1] + item[1])\n\n        def f(left: List[List[int]], sumL: List[int], right: List[List[int]], sumR: List[int], k: int):\n            res = sumR[bs(right, k)]\n            for i in range(1, len(left)):\n                if left[i][0] > k:\n                    break\n                res = max(res, sumL[i + 1] +\n                        sumR[bs(right, k - left[i][0] * 2)])\n            return res\n\n        def bs(list: List[List[int]], target: int):\n            if target <= 0:\n                return 0\n            l = 0\n            r = len(list)\n            while l < r:\n                m = (l + r) // 2\n                if list[m][0] > target:\n                    r = m\n                else:\n                    l = m + 1\n            return l\n\n        return res + max(f(l, sumL, r, sumR, k), f(r, sumR, l, sumL, k))","date":"2023-05-04"},{"script":"rust","time":44,"memory":11.5,"desc":"同上。","code":"impl Solution {\npub fn max_total_fruits(fruits: Vec<Vec<i32>>, start_pos: i32, k: i32) -> i32 {\n    let mut res = 0;\n    let mut l: Vec<Vec<i32>> = vec![];\n    let mut r: Vec<Vec<i32>> = vec![];\n    r.push(vec![-1, 0]);\n    for mut item in fruits {\n        item[0] -= start_pos;\n        if item[0] < 0 {\n            item[0] = -item[0];\n            l.push(item);\n        } else if item[0] > 0 {\n            r.push(item);\n        } else {\n            res += item[1]\n        }\n    }\n    l.push(vec![-1, 0]);\n    l.reverse();\n    l.push(vec![i32::MAX, 0]);\n    r.push(vec![i32::MAX, 0]);\n    let mut suml = vec![0];\n    let mut sumr = vec![0];\n    for item in &l {\n        suml.push(*suml.last().unwrap() + item[1]);\n    }\n    for item in &r {\n        sumr.push(*sumr.last().unwrap() + item[1]);\n    }\n    res + std::cmp::max(f(&l, &suml, &r, &sumr, k), f(&r, &sumr, &l, &suml, k))\n}\n}\n\nfn f(left: &Vec<Vec<i32>>, suml: &Vec<i32>, right: &Vec<Vec<i32>>, sumr: &Vec<i32>, k: i32) -> i32 {\nlet mut res = sumr[bs(right, k)];\nfor i in 1..left.len() {\n    if left[i][0] > k {\n        break;\n    }\n    res = res.max(suml[i + 1] + sumr[bs(right, k - left[i][0] * 2)]);\n}\nres\n}\nfn bs(list: &Vec<Vec<i32>>, target: i32) -> usize {\nif target <= 0 {\n    0\n} else {\n    let mut l = 0;\n    let mut r = list.len();\n    while l < r {\n        let m = (l + r) / 2;\n        if list[m][0] > target {\n            r = m;\n        } else {\n            l = m + 1;\n        }\n    }\n    l\n}\n}","date":"2023-05-04"}],"tagList":["数组","二分查找","前缀和","滑动窗口"],"level":"Hard"}},{"problemName":"2115.从给定原材料中找到所有可以做出的菜.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2101-2200/2115.从给定原材料中找到所有可以做出的菜.json","problemData":{"id":"2220","name":"2115.从给定原材料中找到所有可以做出的菜","url":"https://leetcode.cn/problems/find-all-possible-recipes-from-given-supplies","desc":"你有 n 道不同菜的信息。请你返回你可以做出的所有菜。","solutions":[{"date":"2021-12-31","time":1380,"memory":91.1,"script":"cpp","desc":"循环遍历，然后判断每个菜能否被做出。","code":"class Solution {\n   public:\n    vector<string> findAllRecipes(vector<string>& recipes,\n                                  vector<vector<string>>& ingredients,\n                                  vector<string>& supplies) {\n        unordered_set<string> supply_set, recipe_set;\n        for (auto& supply : supplies) supply_set.insert(supply);\n        for (int i = 0; i < recipes.size(); i++) {\n            for (int i = 0; i < recipes.size(); i++) {\n                if (recipe_set.count(recipes[i])) continue;\n                int tag = 1;\n                for (auto& ingredient : ingredients[i]) {\n                    if (supply_set.count(ingredient) ||\n                        recipe_set.count(ingredient))\n                        continue;\n                    tag = 0;\n                    break;\n                }\n                if (tag) recipe_set.insert(recipes[i]);\n            }\n        }\n        vector<string> ans;\n        for (auto it = recipe_set.begin(); it != recipe_set.end(); it++)\n            ans.push_back(*it);\n        return ans;\n    }\n};"}],"tagList":["图","拓扑排序","数组","哈希表","字符串"],"level":"Medium"}},{"problemName":"2120.执行所有后缀指令.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2101-2200/2120.执行所有后缀指令.json","problemData":{"id":"2239","name":"2120.执行所有后缀指令","url":"https://leetcode.cn/problems/execution-of-all-suffix-instructions-staying-in-a-grid","desc":"返回一个长度为 m 的数组 answer ，其中 answer[i] 是机器人从第 i 条指令 开始 ，可以执行的 指令数目 。","solutions":[{"date":"2021-12-31","time":36,"memory":10.2,"script":"cpp","desc":"模拟。","code":"class Solution {\n   public:\n    int dirs[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    int getDirIdx(char ch) {\n        if (ch == 'D') return 0;\n        if (ch == 'U') return 1;\n        if (ch == 'R') return 2;\n        if (ch == 'L') return 3;\n        return -1;\n    }\n    vector<int> executeInstructions(int n, vector<int>& startPos, string s) {\n        vector<int> ans;\n        int n_str = s.size();\n        for (int i = 0; i < n_str; i++) {\n            int cnt = 0, row = startPos[0], col = startPos[1];\n            for (int j = i; j < n_str; j++, cnt++) {\n                int diridx = getDirIdx(s[j]);\n                row += dirs[diridx][0];\n                col += dirs[diridx][1];\n                if (row < 0 || row >= n || col < 0 || col >= n) break;\n            }\n            ans.push_back(cnt);\n        }\n        return ans;\n    }\n};"}],"tagList":["字符串","模拟"],"level":"Medium"}},{"problemName":"2122.还原原数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2101-2200/2122.还原原数组.json","problemData":{"id":"2241","name":"2122.还原原数组","url":"https://leetcode.cn/problems/recover-the-original-array","desc":"给你一个由 2n 个整数组成的整数数组 nums ，其中 恰好 n 个整数出现在 lower ，剩下的出现在 higher ，还原并返回 原数组 arr 。如果出现答案不唯一的情况，返回 任一 有效数组。","solutions":[{"date":"2021-12-31","time":880,"memory":285.8,"script":"cpp","desc":"存入 map 分别统计。","code":"class Solution {\n   public:\n    int get_k(unordered_map<int, int> m, vector<int>& nums, int k,\n              vector<int>& ans) {\n        for (int i = 0; i < nums.size(); i++) {\n            int low = nums[i];\n            if (m.count(low) == 0 || m[low] <= 0) continue;\n            int high = low + 2 * k;\n            if (m.count(high) == 0 || m[high] <= 0) return 0;\n            m[low]--;\n            m[high]--;\n            ans.push_back(low + k);\n        }\n        return k;\n    }\n    vector<int> recoverArray(vector<int>& nums) {\n        unordered_map<int, int> m;\n        for (auto& num : nums) m[num]++;\n        sort(nums.begin(), nums.end());\n        vector<int> ans;\n        int v1 = nums[0], v2, k = 0;\n        for (int i = 1; i < nums.size() && k == 0; i++) {\n            ans.clear();\n            v2 = nums[i];\n            if ((v2 - v1) & 1 || (v2 - v1) <= 1) continue;\n            k = get_k(m, nums, (v2 - v1) / 2, ans);\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","枚举","排序"],"level":"Hard"}},{"problemName":"2125.银行中的激光束数量.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2101-2200/2125.银行中的激光束数量.json","problemData":{"id":"2244","name":"2125.银行中的激光束数量","url":"https://leetcode.cn/problems/number-of-laser-beams-in-a-bank","desc":"返回银行中激光束的总数量。","solutions":[{"date":"2022-01-04","time":80,"memory":22.5,"script":"cpp","desc":"遍历并记录上一次有多少个守卫 。","code":"class Solution {\n   public:\n    int numberOfBeams(vector<string>& bank) {\n        int pre = 0, ans = 0, cnt = 0;\n        for (string& str : bank) {\n            cnt = 0;\n            for (char& ch : str) if (ch == '1') cnt++;\n            if (!cnt) continue;\n            ans += pre * cnt;\n            pre = cnt;\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","数学","字符串","矩阵"],"level":"Medium"}},{"problemName":"2127.参加会议的最多员工数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2101-2200/2127.参加会议的最多员工数.json","problemData":{"id":"2246","name":"2127.参加会议的最多员工数","url":"https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting","desc":"给你一个下标从 0 开始的整数数组 favorite ，其中 favorite[i] 表示第 i 位员工喜欢的员工。请你返回参加会议的 最多员工数目 。","solutions":[{"script":"python","time":552,"memory":137.49,"desc":"判断环的数量，如果环内超过2个，找最大数量的环，如果只有2个，找两个点的最大延伸链。","code":"class Solution:\n    def maximumInvitations(self, favorite: List[int]) -> int:\n        n = len(favorite)\n        deg = [0 for _ in range(n)]\n        for i in range(n): deg[favorite[i]] += 1\n        q = deque(i for i in range(n) if deg[i] == 0)\n        nexts = [[] for _ in range(n)]\n        while q:\n            i = q.popleft()\n            nexts[favorite[i]].append(i)\n            deg[favorite[i]] -= 1\n            if deg[favorite[i]] == 0: q.append(favorite[i])\n        def dfs(idx: int) -> int:\n            res = 1\n            for next_i in nexts[idx]:\n                res = max(res, dfs(next_i) + 1)\n            return res\n\n        max_ring = sum_chain = 0\n        for i in range(n):\n            if deg[i] == 0: continue\n            deg[i] = 0\n            ring = 1\n            next_i = favorite[i]\n            while next_i != i:\n                deg[next_i] = 0\n                ring += 1\n                next_i = favorite[next_i]\n            if ring == 2: sum_chain += dfs(i) + dfs(favorite[i])\n            else: max_ring = max(max_ring, ring)\n        return max(sum_chain, max_ring)","date":"2023-11-01"}],"tagList":["深度优先搜索","图","拓扑排序"],"level":"Hard"}},{"problemName":"2129.将标题首字母大写.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2101-2200/2129.将标题首字母大写.json","problemData":{"id":"2235","name":"2129.将标题首字母大写","url":"https://leetcode.cn/problems/capitalize-the-title","desc":"请你返回 大写后 的 title 。","solutions":[{"script":"python","time":40,"memory":16.35,"desc":"遍历。","code":"class Solution:\n    def capitalizeTitle(self, title: str) -> str:\n        return ' '.join(\n            map(\n                lambda s: s[0].upper() + s[1:].lower() if len(s) > 2 else s.lower(),\n                title.split(' ')\n            )\n        )","date":"2024-03-11"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"2132.用邮票贴满网格图.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2101-2200/2132.用邮票贴满网格图.json","problemData":{"id":"2200","name":"2132.用邮票贴满网格图","url":"https://leetcode.cn/problems/stamping-the-grid","desc":"如果在满足上述要求的前提下，可以放入邮票，请返回 true ，否则返回 false 。","solutions":[{"script":"python","time":1440,"memory":57.3,"desc":"前缀和统计区间内有无禁区，差分统计空白区是否都存在邮票。","code":"class Solution:\n    def possibleToStamp(self, grid: List[List[int]], stampHeight: int, stampWidth: int) -> bool:\n        n, m = len(grid), len(grid[0])\n        sums = [[0] * (m + 2) for _ in range(n + 2)]\n        arr  = [[0] * (m + 2) for _ in range(n + 2)]\n        for i in range(n):\n            for j in range(m):\n                sums[i + 1][j + 1] = sums[i][j + 1] + sums[i + 1][j] - sums[i][j] + grid[i][j]\n\n        for i in range(n):\n            for j in range(m):\n                endi = i + stampHeight - 1\n                endj = j + stampWidth  - 1\n                if grid[i][j] == 0 and endi < n and endj < m and sums[endi + 1][endj + 1] - sums[endi + 1][j] - sums[i][endj + 1] + sums[i][j] == 0:\n                    arr[i + 1][j + 1]        += 1\n                    arr[i + 1][endj + 2]     -= 1\n                    arr[endi + 2][j + 1]     -= 1\n                    arr[endi + 2][endj + 2]  += 1\n        \n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                arr[i][j] += arr[i][j - 1] + arr[i - 1][j] - arr[i - 1][j - 1]\n                if grid[i - 1][j - 1] == 0 and arr[i][j] == 0:\n                    return False\n\n        return True","date":"2023-12-14"}],"tagList":["贪心","数组","矩阵","前缀和"],"level":"Hard"}},{"problemName":"2136.全部开花的最早一天.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2101-2200/2136.全部开花的最早一天.json","problemData":{"id":"2257","name":"2136.全部开花的最早一天","url":"https://leetcode.cn/problems/earliest-possible-day-of-full-bloom","desc":"从第 0 开始，你可以按 任意 顺序播种种子。返回所有种子都开花的 最早 一天是第几天。","solutions":[{"script":"python","time":256,"memory":32,"desc":"同上。","code":"class Solution:\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\n        l = [i for i in range(len(plantTime))]\n        l.sort(key=lambda i: growTime[i], reverse=True)\n        cur = 0\n        res = 0\n        for i in l:\n            res = max(res, cur + growTime[i] + plantTime[i])\n            cur += plantTime[i]\n        return res\n","date":"2023-09-30"}],"tagList":["贪心","数组","排序"],"level":"Hard"}},{"problemName":"2171.拿出最少数目的魔法豆.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2101-2200/2171.拿出最少数目的魔法豆.json","problemData":{"id":"2290","name":"2171.拿出最少数目的魔法豆","url":"https://leetcode.cn/problems/removing-minimum-number-of-magic-beans","desc":"给定一个 正整数 数组 beans ，其中每个整数表示一个袋子里装的魔法豆的数目。请你从每个袋子中 拿出 一些豆子（也可以 不拿出），使得剩下的 非空 袋子中（即 至少还有一颗 魔法豆的袋子）魔法豆的数目 相等。一旦把魔法豆从袋子中取出，你不能再将它放到任何袋子中。请返回你需要拿出魔法豆的 最少数目。","solutions":[{"script":"python","time":372,"memory":39.59,"desc":"遍历。","code":"class Solution:\n    def minimumRemoval(self, beans: List[int]) -> int:\n        counter = list(Counter(beans).items())\n        counter.sort(reverse = True)\n        ans = nsum = sum(beans)\n        ncnt = 0\n        prev_num = -1\n        for num, cnt in counter:\n            if prev_num != -1: nsum += ncnt * (prev_num - num)\n            nsum -= num * cnt\n            prev_num = num\n            ncnt += cnt\n            ans = min(ans, nsum)\n        return ans","date":"2024-01-18"}],"tagList":["贪心","数组","枚举","前缀和","排序"],"level":"Medium"}},{"problemName":"2178.拆分成最多数目的正偶数之和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2101-2200/2178.拆分成最多数目的正偶数之和.json","problemData":{"id":"2279","name":"2178.拆分成最多数目的正偶数之和","url":"https://leetcode.cn/problems/maximum-split-of-positive-even-integers","desc":"给你一个整数 finalSum 。请你将它拆分成若干个 互不相同 的正偶数之和，且拆分出来的正偶数数目 最多 。","solutions":[{"script":"cpp","time":200,"memory":39.5,"desc":"贪心。","code":"class Solution {\npublic:\n    vector<long long> maximumEvenSplit(long long finalSum) {\n        vector<long long> res;\n        if (finalSum % 2 != 0) return res;\n        for (int num = 2; finalSum >= num; num += 2) {\n            res.push_back(num);\n            finalSum -= num;\n        }\n        res[res.size() - 1] += finalSum;\n        return res;\n    }\n};","date":"2023-07-06"},{"script":"python","time":624,"memory":25.6,"desc":"同上。","code":"class Solution:\n    def maximumEvenSplit(self, finalSum: int) -> List[int]:\n        res = []\n        if finalSum % 2 != 0: return res\n        num = 2\n        while num <= finalSum:\n            res.append(num)\n            finalSum -= num\n            num += 2\n        res[-1] += finalSum\n        return res","date":"2023-07-06"},{"script":"rust","time":40,"memory":3.2,"desc":"同上。","code":"impl Solution {\n    pub fn maximum_even_split(mut final_sum: i64) -> Vec<i64> {\n        let mut res = vec![];\n        if final_sum % 2 == 0 {\n            let mut num = 2;\n            while num <= final_sum {\n                res.push(num);\n                final_sum -= num;\n                num += 2;\n            }\n            *res.last_mut().unwrap() += final_sum;\n        }\n        res\n    }\n}","date":"2023-07-06"}],"tagList":["贪心","数学","回溯"],"level":"Medium"}},{"problemName":"2180.统计各位数字之和为偶数的整数个数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2101-2200/2180.统计各位数字之和为偶数的整数个数.json","problemData":{"id":"2298","name":"2180.统计各位数字之和为偶数的整数个数","url":"https://leetcode.cn/problems/count-integers-with-even-digit-sum","desc":"给你一个正整数 num ，请你统计并返回 小于或等于 num 且各位数字之和为 偶数 的正整数的数目。","solutions":[{"date":"2023-01-06","time":4,"memory":5.8,"script":"cpp","desc":"dfs。","code":"class Solution {\npublic:\n    int countEven(int num) {\n        function<int(int, int)> dfs = [&](int cur, int sum) -> int {\n            if (cur > num) return 0;\n            int ans = !(sum & 1);\n            for (int i = 0; i <= 9; i++) {\n                if (cur * 10 + i == cur) continue;\n                ans += dfs(cur * 10 + i, sum + i);\n            }\n            return ans;\n        };\n        return dfs(0, 0) - 1;\n    }\n};"},{"date":"2023-01-06","time":0,"memory":1.9,"script":"rust","desc":"同上。","code":"impl Solution {\n    pub fn count_even(num: i32) -> i32 {\n        return Solution::dfs(num, 0, 0) - 1;\n    }\n    fn dfs(num: i32, cur: i32, sum: i32) -> i32 {\n        if cur > num {\n            0\n        } else {\n            let mut ans = if sum % 2 == 0 { 1 } else { 0 };\n            for i in 0..=9 {\n                if cur * 10 + i == cur {\n                    continue;\n                }\n                ans += Solution::dfs(num, cur * 10 + i, sum + i);\n            }\n            ans\n        }\n    }\n}"},{"date":"2023-01-06","time":92,"memory":48.3,"script":"typescript","desc":"遍历。","code":"function countEven(num: number): number {\n  return new Array(num)\n    .fill(0)\n    .map((_, i) =>\n      (i + 1)\n        .toString()\n        .split('')\n        .map(v => +v)\n        .reduce((sum, cur) => sum + cur, 0)\n    )\n    .reduce((sum, cur) => sum + Number(cur % 2 == 0), 0);\n}"}],"tagList":["数学","模拟"],"level":"Easy"}},{"problemName":"2182.构造限制重复的字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2101-2200/2182.构造限制重复的字符串.json","problemData":{"id":"2300","name":"2182.构造限制重复的字符串","url":"https://leetcode.cn/problems/construct-string-with-repeat-limit","desc":"给你一个字符串 s 和一个整数 repeatLimit ，用 s 中的字符构造一个新字符串 repeatLimitedString ，使任何字母 连续 出现的次数都不超过 repeatLimit 次。你不必使用 s 中的全部字符。返回 字典序最大的 repeatLimitedString 。","solutions":[{"script":"python","time":212,"memory":18.19,"desc":"计数，贪心。","code":"class Solution:\n    def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\n        counter = Counter(s)\n        arr = list(counter.items())\n        arr.sort()\n        ans = ''\n        while arr:\n            ch, cnt = arr.pop()\n            while cnt:\n                cur_cnt = min(cnt, repeatLimit)\n                cnt -= cur_cnt\n                ans += ch * cur_cnt\n                if cnt:\n                    if arr:\n                        ans += arr[-1][0]\n                        arr[-1] = (arr[-1][0], arr[-1][1] - 1)\n                        if arr[-1][1] == 0:\n                            arr.pop()\n                    else:\n                        break\n        return ans","date":"2024-01-13"}],"tagList":["贪心","哈希表","字符串","计数","堆（优先队列）"],"level":"Medium"}},{"problemName":"2185.统计包含给定前缀的字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2101-2200/2185.统计包含给定前缀的字符串.json","problemData":{"id":"2292","name":"2185.统计包含给定前缀的字符串","url":"https://leetcode.cn/problems/counting-words-with-a-given-prefix","desc":"给你一个字符串数组 words 和一个字符串 pref 。返回 words 中以 pref 作为 前缀 的字符串的数目。","solutions":[{"date":"2023-01-08","time":56,"memory":44.1,"script":"typescript","desc":"遍历。","code":"function prefixCount(words: string[], pref: string): number {\n  return words.filter(v => v.startsWith(pref)).length;\n}"},{"date":"2023-01-08","time":0,"memory":2.1,"script":"rust","desc":"同上。","code":"impl Solution {\n    pub fn prefix_count(words: Vec<String>, pref: String) -> i32 {\n        words.into_iter().filter(|w| w.starts_with(&pref)).count() as i32\n    }\n}"}],"tagList":["数组","字符串","字符串匹配"],"level":"Easy"}},{"problemName":"2192.有向无环图中一个节点的所有祖先.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2101-2200/2192.有向无环图中一个节点的所有祖先.json","problemData":{"id":"1431","name":"2192.有向无环图中一个节点的所有祖先","url":"https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph","desc":"请你返回一个数组 answer，其中 answer[i]是第 i 个节点的所有 祖先 ，这些祖先节点 升序 排序。","solutions":[{"script":"python","time":112,"memory":35.63,"desc":"dfs。","code":"class Solution:\n    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:\n        nodes=[[] for _ in range(n)]\n        for f, t in edges:\n            nodes[t].append(f)\n        @cache\n        def dfs(node):\n            ans = []\n            for f in nodes[node]:\n                ans += [f] + dfs(f)\n            return sorted(set(ans))\n        return [dfs(i) for i in range(n)]","date":"2024-04-04"}],"tagList":["深度优先搜索","广度优先搜索","图","拓扑排序"],"level":"Medium"}}]},{"dirName":"2201-2300","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\2201-2300","problems":[{"problemName":"2208.将数组和减半的最少操作次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2201-2300/2208.将数组和减半的最少操作次数.json","problemData":{"id":"2310","name":"2208.将数组和减半的最少操作次数","url":"https://leetcode.cn/problems/minimum-operations-to-halve-array-sum","desc":"给你一个正整数数组 nums 。每一次操作中，你可以从 nums 中选择 任意 一个数并将它减小到 恰好 一半。（注意，在后续操作中你可以对减半过的数继续执行操作）请你返回将 nums 数组和 至少 减少一半的 最少 操作数。","solutions":[{"script":"cpp","time":8,"memory":9.3,"desc":"排序后遍历。","code":"class Solution {\npublic:\n    int deleteGreatestValue(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size(), res = 0;\n        for (auto &row : grid) sort(row.begin(), row.end());\n        for (int j = m - 1; j >= 0; j--) {\n            int cur = INT_MIN;\n            for (int i = 0; i < n; i++) {\n                cur = max(cur, grid[i][j]);\n            }\n            res += cur;\n        }\n        return res;\n    }\n};","date":"2023-07-27"},{"script":"python","time":112,"memory":16.2,"desc":"同上。","code":"class Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n        for row in grid:\n            row.sort()\n        n = len(grid)\n        m = len(grid[0])\n        res = 0\n        for j in range(m):\n            num = -inf\n            for i in range(n):\n                num = max(num, grid[i][j])\n            res += num\n        return res\n            ","date":"2023-07-27"},{"script":"rust","time":0,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn delete_greatest_value(mut grid: Vec<Vec<i32>>) -> i32 {\n        for row in &mut grid {\n            row.sort();\n        }\n        let mut res = 0;\n        for j in 0..grid[0].len() {\n            let mut num = i32::MIN;\n            for i in 0..grid.len() {\n                num = num.max(grid[i][j]);\n            }\n            res += num;\n        }\n        res\n    }\n}","date":"2023-07-27"}],"tagList":["贪心","数组","堆（优先队列）"],"level":"Medium"}},{"problemName":"2216.美化数组的最少删除数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2201-2300/2216.美化数组的最少删除数.json","problemData":{"id":"1355","name":"2216.美化数组的最少删除数","url":"https://leetcode.cn/problems/minimum-deletions-to-make-array-beautiful","desc":"返回使 nums 变为美丽数组所需删除的 最少 元素数目。","solutions":[{"script":"python","time":216,"memory":26.28,"desc":"一次遍历。","code":"class Solution:\n    def minDeletion(self, nums: List[int]) -> int:\n        ans = 0\n        for i in range(0, len(nums) - 1):\n            if (i - ans) % 2 == 0 and nums[i] == nums[i + 1]: ans += 1\n        return ans + (len(nums) - ans) % 2","date":"2023-11-21"}],"tagList":["栈","贪心","数组"],"level":"Medium"}},{"problemName":"2225.找出输掉零场或一场比赛的玩家.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2201-2300/2225.找出输掉零场或一场比赛的玩家.json","problemData":{"id":"1354","name":"2225.找出输掉零场或一场比赛的玩家","url":"https://leetcode.cn/problems/find-players-with-zero-or-one-losses","desc":"给你一个整数数组 matches 其中 matches[i] = [winneri, loseri] 表示在一场比赛中 winneri 击败了 loseri 。返回一个长度为 2 的列表 answer。","solutions":[{"script":"python","time":378,"memory":59.18,"desc":"遍历。","code":"class Solution:\n    def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n        counter = Counter()\n        for w, l in matches:\n            if not counter[w]: counter[w] = 0\n            counter[l] += 1\n        res = [[], []] \n        for k, v in sorted(counter.items()):\n            if v < 2:\n                res[v].append(k)\n        return res","date":"2024-05-22"},{"script":"python","time":209,"memory":56.78,"desc":"遍历。","code":"class Solution:\n            def findWinners(self, matches: List[List[int]]) -> List[List[int]]:\n                sets = [set() for _ in range(3)]\n                for w, l in matches:\n                    if w not in sets[0] and w not in sets[1] and w not in sets[2]:\n                        sets[0].add(w)\n                    if l not in sets[0] and l not in sets[1] and l not in sets[2]:\n                        sets[1].add(l)\n                    else:\n                        idx = 0\n                        while idx < 2:\n                            if l in sets[idx]:\n                                sets[idx].remove(l)\n                                sets[idx + 1].add(l)\n                                break\n                            idx += 1\n                return [sorted(v) for v in sets[:2]]","date":"2024-05-22"}],"tagList":["数组","哈希表","计数","排序"],"level":"Medium"}},{"problemName":"2235.两整数相加.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2201-2300/2235.两整数相加.json","problemData":{"id":"2383","name":"2235.两整数相加","url":"https://leetcode.cn/problems/add-two-integers","desc":"给你两个整数 num1 和 num2，返回这两个整数的和。","solutions":[{"script":"rust","time":0,"memory":1.85,"desc":"加法。","code":"impl Solution {\n    pub fn sum(num1: i32, num2: i32) -> i32 {\n        num1 + num2\n    }\n}","date":"2023-08-19"}],"tagList":["数学"],"level":"Easy"}},{"problemName":"2236.判断根结点是否等于子结点之和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2201-2300/2236.判断根结点是否等于子结点之和.json","problemData":{"id":"2384","name":"2236.判断根结点是否等于子结点之和","url":"https://leetcode.cn/problems/root-equals-sum-of-children","desc":"给你两个整数 num1 和 num2，返回这两个整数的和。","solutions":[{"date":"2023-08-21","script":"cpp","time":4,"memory":12.4,"desc":"直接计算。","code":"class Solution {\npublic:\n    bool checkTree(TreeNode* root) {\n        return root->val == root->left->val + root->right->val;\n    }\n};"},{"script":"rust","time":0,"memory":1.86,"desc":"同上。","code":"use std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        let root = root.unwrap();\n        let root_ref = root.as_ref().borrow();\n        return root_ref.val\n            == root_ref.left.as_ref().unwrap().as_ref().borrow().val\n                + root_ref.right.as_ref().unwrap().as_ref().borrow().val;\n    }\n}","date":"2023-08-21"}],"tagList":["树","二叉树"],"level":"Easy"}},{"problemName":"2240.买钢笔和铅笔的方案数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2201-2300/2240.买钢笔和铅笔的方案数.json","problemData":{"id":"2351","name":"2240.买钢笔和铅笔的方案数","url":"https://leetcode.cn/problems/number-of-ways-to-buy-pens-and-pencils","desc":"给你一个整数 total ，表示你拥有的总钱数。同时给你两个整数 cost1 和 cost2 ，分别表示一支钢笔和一支铅笔的价格。你可以花费你部分或者全部的钱，去买任意数目的两种笔。请你返回购买钢笔和铅笔的 不同方案数目 。","solutions":[{"script":"cpp","time":16,"memory":5.9,"desc":"枚举。","code":"class Solution {\npublic:\n    long long waysToBuyPensPencils(int total, int cost1, int cost2) {\n        long long idx1 = 0, res = 0;\n        while (idx1 * cost1 <= total) {\n            res += 1 + (total - idx1 * cost1) / cost2;\n            idx1 += 1;\n        }\n        return res;\n    }\n};","date":"2023-09-01"},{"script":"python","time":664,"memory":16,"desc":"同上。","code":"class Solution:\n    def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\n        idx1 = res = 0\n        while idx1 * cost1 <= total:\n            res += 1 + (total - idx1 * cost1) // cost2\n            idx1 += 1\n        return res","date":"2023-09-01"},{"script":"rust","time":12,"memory":2.04,"desc":"同上。","code":"impl Solution {\n    pub fn ways_to_buy_pens_pencils(total: i32, cost1: i32, cost2: i32) -> i64 {\n        let (total, cost1, cost2, mut idx1, mut res) = (\n            total as i64, cost1 as i64, cost2 as i64,\n            0i64, 0i64\n        );\n        while idx1 * cost1 <= total {\n            res += 1 + (total - cost1 * idx1) / cost2;\n            idx1 += 1;\n        }\n        res\n    }\n}","date":"2023-09-01"}],"tagList":["数学","枚举"],"level":"Medium"}},{"problemName":"2244.完成所有任务需要的最少轮数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2201-2300/2244.完成所有任务需要的最少轮数.json","problemData":{"id":"2362","name":"2244.完成所有任务需要的最少轮数","url":"https://leetcode.cn/problems/minimum-rounds-to-complete-all-tasks","desc":"返回完成所有任务需要的 最少 轮数，如果无法完成所有任务，返回 -1 。","solutions":[{"script":"python","time":147,"memory":70.3,"desc":"遍历。","code":"@cache\n    def check(num: int) -> int:\n        if num == 0: return 0\n        if num == 1: return inf\n        if num == 2 or num == 3: return 1\n        res = min(check(num - 2), check(num - 3))\n        if res == inf: return inf\n        return res + 1\n    class Solution:\n        def minimumRounds(self, tasks: List[int]) -> int:\n            counter = Counter(tasks)\n            res = 0\n            for cnt in counter.values():\n                check_res = check(cnt)\n                if check_res == inf: return -1\n                res += check_res \n            return res","date":"2024-05-14"},{"script":"python","time":99,"memory":31.63,"desc":"贪心。","code":"class Solution:\n    def minimumRounds(self, tasks: List[int]) -> int:\n        counter = Counter(tasks)\n        res = 0\n        for cnt in counter.values():\n            if cnt == 1: return -1\n            res += cnt // 3\n            if cnt % 3 != 0: res += 1 \n        return res","date":"2024-05-14"}],"tagList":["贪心","数组","哈希表","计数"],"level":"Medium"}},{"problemName":"2251.花期内花的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2201-2300/2251.花期内花的数目.json","problemData":{"id":"2334","name":"2251.花期内花的数目","url":"https://leetcode.cn/problems/number-of-flowers-in-full-bloom","desc":"请你返回一个大小为 n 的整数数组 answer ，其中 answer[i]是第 i 个人到达时在花期内花的 数目 。","solutions":[{"script":"cpp","time":240,"memory":82.55,"desc":"排序后遍历，差分数组记录当前值。","code":"class Solution {\npublic:\n    vector<int> fullBloomFlowers(vector<vector<int>>& flowers, vector<int>& people) {\n        vector<pair<int, int>> flist;\n        for (auto &item : flowers) {\n            flist.push_back(make_pair(item[0], 1));\n            flist.push_back(make_pair(item[1] + 1, -1));\n        }\n        sort(flist.begin(), flist.end(), [&](auto &a, auto &b) {\n            return a.first < b.first;\n        });\n        vector<int> plist;\n        for (int i = 0; i < people.size(); i++) plist.push_back(i);\n        sort(plist.begin(), plist.end(), [&](auto &a, auto &b) {\n            return people[a] < people[b];\n        });\n        int pidx = 0, cur = 0;\n        vector<int> res(people.size(), 0);\n        for (auto &item : flist) {\n            while (pidx < plist.size() && people[plist[pidx]] < item.first) {\n                res[plist[pidx]] = cur;\n                pidx += 1;\n            }\n            cur += item.second;\n        }\n        return res;\n    }\n};","date":"2023-09-28"},{"script":"python","time":228,"memory":40.3,"desc":"同上。","code":"class Solution:\n    def fullBloomFlowers(self, flowers: List[List[int]], people: List[int]) -> List[int]:\n        flist = []\n        for [start, end] in flowers:\n            flist.append((start, 1))\n            flist.append((end + 1, -1))\n        flist.sort()\n        plist = [i for i in range(len(people))]\n        plist.sort(key = lambda i: people[i])\n        pidx = 0\n        res = [0 for _ in range(len(people))]\n        cur = 0\n        for (idx, d) in flist:\n            while pidx < len(plist) and people[plist[pidx]] < idx:\n                res[plist[pidx]] = cur\n                pidx += 1\n            cur += d\n        return res\n","date":"2023-09-28"},{"script":"rust","time":48,"memory":6.7,"desc":"同上。","code":"impl Solution {\n    pub fn full_bloom_flowers(flowers: Vec<Vec<i32>>, people: Vec<i32>) -> Vec<i32> {\n        let mut flist = vec![];\n        for item in flowers {\n            flist.push((item[0], 1));\n            flist.push((item[1] + 1, -1));\n        }\n        flist.sort_by_cached_key(|o| o.0);\n        let mut plist = (0..people.len()).collect::<Vec<usize>>();\n        plist.sort_by_cached_key(|i| people[*i]);\n        let mut res = vec![0; people.len()];\n        let mut pidx = 0;\n        let mut cur = 0;\n        for (idx, d) in flist {\n            while pidx < plist.len() && people[plist[pidx]] < idx {\n                res[plist[pidx]] = cur;\n                pidx += 1;\n            }\n            cur += d;\n        }\n        res\n    }\n}","date":"2023-09-28"}],"tagList":["数组","哈希表","二分查找","有序集合","前缀和","排序"],"level":"Hard"}},{"problemName":"2258.逃离火灾.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2201-2300/2258.逃离火灾.json","problemData":{"id":"2344","name":"2258.逃离火灾","url":"https://leetcode.cn/problems/escape-the-spreading-fire","desc":"请你返回你在初始位置可以停留的 最多 分钟数，且停留完这段时间后你还能安全到达安全屋。如果无法实现，请你返回 -1 。如果不管你在初始位置停留多久，你 总是 能到达安全屋，请你返回 109 。","solutions":[{"script":"python","time":840,"memory":17.25,"desc":"bfs记录火蔓延的时间点，通过二分获取最大可能值。","code":"dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\nclass Solution:\n    def maximumMinutes(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n        times = [[inf] * m for _ in range(n)]\n        checks = [[False] * m for _ in range(n)]\n        q = deque()\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    q.append((i, j))\n                    times[i][j] = 0\n        \n        size = len(q)\n        time = 1\n        while q:\n            i, j = q.popleft()\n            for dir in dirs:\n                nexti = i + dir[0]\n                nextj = j + dir[1]\n                if 0 <= nexti < n and 0 <= nextj < m and grid[nexti][nextj] != 2 and times[nexti][nextj] == inf:\n                    q.append((nexti, nextj))\n                    times[nexti][nextj] = time\n            size -= 1\n            if size == 0:\n                size = len(q)\n                time += 1\n\n        def check(time: int) -> bool:\n            for i in range(n):\n                for j in range(m):\n                    checks[i][j] = False\n            q.clear()\n            time += 1\n            q.append((0, 0))\n            size = 1\n            while q:\n                i, j = q.popleft()\n                for dir in dirs:\n                    nexti = i + dir[0]\n                    nextj = j + dir[1]\n                    if 0 <= nexti < n and 0 <= nextj < m and grid[nexti][nextj] == 0:\n                        if nexti == n - 1 and nextj == m - 1 and times[nexti][nextj] >= time:\n                            return True\n                        if times[nexti][nextj] > time and (not checks[nexti][nextj]):\n                            checks[nexti][nextj] = True\n                            q.append((nexti, nextj))\n                size -= 1\n                if size == 0:\n                    size = len(q)\n                    time += 1\n            return False\n\n        l = -1\n        r = 10 ** 9\n        while l < r:\n            mid = (l + r + 1) // 2\n            if check(mid): l = mid\n            else: r = mid - 1\n\n        return l","date":"2023-11-09"}],"tagList":["广度优先搜索","数组","二分查找","矩阵"],"level":"Hard"}},{"problemName":"2276.统计区间中的整数数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2201-2300/2276.统计区间中的整数数目.json","problemData":{"id":"2357","name":"2276.统计区间中的整数数目","url":"https://leetcode.cn/problems/count-integers-in-intervals","desc":"给你区间的 空 集，请你设计并实现满足要求的数据结构：新增：添加一个区间到这个区间集合中。统计：计算出现在 至少一个 区间中的整数个数。","solutions":[{"script":"cpp","time":432,"memory":181.94,"desc":"平衡二叉树。","code":"class CountIntervals {\npublic:\n    map<int, int> tree;\n    int sum;\n    CountIntervals(): sum(0) {\n        tree[0] = 0;\n        tree[INT_MAX] = INT_MAX;\n    }\n    int count() {\n        return sum;\n    }\n    void add(int left, int right) {\n        auto it = tree.lower_bound(left);\n        auto prev = it;\n        prev--;\n        if (prev->second >= left) {\n            left = min(left, prev->first);\n            right = max(right, prev->second);\n            sum -= prev->second - prev->first + 1;\n            it = tree.erase(prev);\n        }\n        while (right >= it->first) {\n            right = max(right, it->second);\n            sum -= it->second - it->first + 1;\n            it = tree.erase(it);\n        }\n        tree[left] = right;\n        sum += right - left + 1;\n    }\n};","date":"2023-12-16"}],"tagList":["设计","线段树","有序集合"],"level":"Hard"}},{"problemName":"2283.判断一个数的数字计数是否等于数位的值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2201-2300/2283.判断一个数的数字计数是否等于数位的值.json","problemData":{"id":"2377","name":"2283.判断一个数的数字计数是否等于数位的值","url":"https://leetcode.cn/problems/check-if-number-has-equal-digit-count-and-digit-value","desc":"如果对于 每个 0 <= i < n 的下标 i ，都满足数位 i 在 num 中出现了 num[i]次，那么请你返回 true ，否则返回 false 。","solutions":[{"date":"2023-01-11","time":4,"memory":5.7,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    bool digitCount(string num) {\n        int n = num.size(), l[10] = {0};\n        for (auto &c : num) l[c - '0']++;\n        for (int i = 0; i < n; i++) {\n            if (num[i] - '0' != l[i]) return false;\n        }\n        return true;\n    }\n};"},{"date":"2023-01-11","time":0,"memory":2.2,"script":"rust","desc":"同上。","code":"impl Solution {\n    pub fn digit_count(num: String) -> bool {\n        let mut l = [0; 10];\n        let n = num.len();\n        let num = num.chars().collect::<Vec<char>>();\n        for c in num.iter() {\n            l[*c as usize - '0' as usize] += 1;\n        }\n        for i in 0..n {\n            if num[i] as usize - '0' as usize != l[i] {\n                return false;\n            }\n        }\n        true\n    }\n}"}],"tagList":["哈希表","字符串","计数"],"level":"Easy"}},{"problemName":"2287.重排字符形成目标字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2201-2300/2287.重排字符形成目标字符串.json","problemData":{"id":"2372","name":"2287.重排字符形成目标字符串","url":"https://leetcode.cn/problems/rearrange-characters-to-make-target-string","desc":"从 s 中取出字符并重新排列，返回可以形成 target 的 最大 副本数。","solutions":[{"script":"cpp","time":0,"memory":6,"desc":"遍历。","code":"class Solution {\npublic:\n    int rearrangeCharacters(string s, string target) {\n        int l1[26] = {0}, l2[26] = {0}, ans = 0x7fffffff;\n        for (auto &c : s) l1[c - 'a']++;\n        for (auto &c : target) l2[c - 'a']++;\n        for (int i = 0; i < 26; i++) {\n            if (l2[i] == 0) continue;\n            ans = min(ans, l1[i] / l2[i]);\n        }\n        return ans;\n    }\n};","date":"2023-01-13"},{"script":"rust","time":0,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn rearrange_characters(s: String, target: String) -> i32 {\n        let mut ans = i32::MAX;\n        let (mut l1, mut l2) = ([0; 26], [0; 26]);\n        s.chars().for_each(|c| {\n            l1[c as usize - 'a' as usize] += 1;\n        });\n        target.chars().for_each(|c| {\n            l2[c as usize - 'a' as usize] += 1;\n        });\n        for i in 0..26 {\n            if l2[i] != 0 {\n                ans = ans.min(l1[i] / l2[i]);\n            }\n        }\n        ans\n    }\n}","date":"2023-01-13"}],"tagList":["哈希表","字符串","计数"],"level":"Easy"}},{"problemName":"2288.价格减免.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2201-2300/2288.价格减免.json","problemData":{"id":"2373","name":"2288.价格减免","url":"https://leetcode.cn/problems/apply-discount-to-prices","desc":"返回表示修改后句子的字符串。","solutions":[{"script":"python","time":98,"memory":18.2,"desc":"遍历。","code":"class Solution:\n    def discountPrices(self, sentence: str, discount: int) -> str:\n        arr = sentence.split(' ')\n        for i in range(len(arr)):\n            if arr[i][0] == '$' and arr[i][1:].isdigit():\n                arr[i] = '$' + str(format(int(arr[i][1:]) * ((100 - discount) / 100), '.2f'))\n        return ' '.join(arr)","date":"2024-06-18"}],"tagList":["字符串"],"level":"Medium"}},{"problemName":"2293.极大极小游戏.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2201-2300/2293.极大极小游戏.json","problemData":{"id":"2386","name":"2293.极大极小游戏","url":"https://leetcode.cn/problems/min-max-game","desc":"执行算法后，返回 nums 中剩下的那个数字。","solutions":[{"script":"cpp","time":4,"memory":9.8,"desc":"递归。","code":"class Solution {\npublic:\n    int minMaxGame(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 1) return nums[0];\n        vector<int> next(n / 2, 0);\n        for (int i = 0, f = 1; i < n; i += 2, f ^= 1) {\n            if (f) next[i / 2] = min(nums[i], nums[i + 1]);\n            else next[i / 2] = max(nums[i], nums[i + 1]);\n        }\n        return minMaxGame(next);\n    }\n};","date":"2023-01-15"},{"script":"rust","time":4,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn min_max_game(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        if n == 1 {\n            nums[0]\n        } else {\n            let mut next = vec![0; n / 2];\n            let mut i = 0;\n            let mut f = true;\n            while i < n {\n                next[i / 2] = if f {\n                    nums[i].min(nums[i + 1])\n                } else {\n                    nums[i].max(nums[i + 1])\n                };\n                i += 2;\n                f = !f;\n            }\n            Solution::min_max_game(next)\n        }\n    }\n}","date":"2023-01-15"}],"tagList":["数组","模拟"],"level":"Easy"}},{"problemName":"2299.强密码检验器II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2201-2300/2299.强密码检验器II.json","problemData":{"id":"2391","name":"2299.强密码检验器II","url":"https://leetcode.cn/problems/strong-password-checker-ii","desc":"给你一个字符串 password ，如果它是一个 强 密码，返回 true，否则返回 false 。","solutions":[{"script":"cpp","time":0,"memory":5.9,"desc":"遍历。","code":"class Solution {\npublic:\n    bool strongPasswordCheckerII(string password) {\n        bool f[4] = {false};\n        string spec = \"!@#$%^&*()-+\";\n        for (int i = 0; i < password.size(); i++) {\n            if (islower(password[i])) f[0] = true;\n            if (isupper(password[i])) f[1] = true;\n            if (isdigit(password[i])) f[2] = true;\n            if (spec.find(password[i]) != string::npos) f[3] = true;\n            if (i != 0 && password[i] == password[i - 1]) return false;\n        }\n        return f[0] && f[1] && f[2] && f[3] && password.size() >= 8;\n    }\n};","date":"2023-01-19"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"impl Solution {\npub fn strong_password_checker_ii(password: String) -> bool {\n    let spec = \"!@#$%^&*()-+\";\n    let s = password.chars().collect::<Vec<char>>();\n    let mut f = [false; 4];\n    for i in 0..s.len() {\n        if s[i].is_lowercase() {\n            f[0] = true;\n        }\n        if s[i].is_uppercase() {\n            f[1] = true;\n        }\n        if s[i].is_digit(10) {\n            f[2] = true;\n        }\n        if spec.contains(s[i]) {\n            f[3] = true;\n        }\n        if i > 0 && s[i] == s[i - 1] {\n            return false;\n        }\n    }\n    s.len() >= 8 && f[0] && f[1] && f[2] && f[3]\n}","date":"2023-01-19"},{"script":"python","time":40,"memory":14.9,"desc":"同上。","code":"class Solution:\ndef strongPasswordCheckerII(self, password: str) -> bool:\n    spec = \"!@#$%^&*()-+\"\n    f = [False for _ in range(4)]\n    for i, c in enumerate(password):\n        f[0] |= c.islower()\n        f[1] |= c.isupper()\n        f[2] |= c.isdigit()\n        f[3] |= spec.find(c) != -1\n        if i != 0 and password[i - 1] == c:\n            return False\n    return len(password) >= 8 and f[0] and f[1] and f[2] and f[3]","date":"2023-01-19"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"2300.咒语和药水的成功对数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2201-2300/2300.咒语和药水的成功对数.json","problemData":{"id":"2392","name":"2300.咒语和药水的成功对数","url":"https://leetcode.cn/problems/successful-pairs-of-spells-and-potions","desc":"请你返回一个长度为 n 的整数数组 pairs，其中 pairs[i] 是能跟第 i 个咒语成功组合的 药水 数目。","solutions":[{"script":"python","time":264,"memory":35.04,"desc":"bfs记录火蔓延的时间点，通过二分获取最大可能值。","code":"class Solution:\n    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:\n        potions.sort()\n        return [len(potions) - bisect_left(potions, success / spell) for spell in spells]","date":"2023-11-10"}],"tagList":["数组","双指针","二分查找","排序"],"level":"Medium"}}]},{"dirName":"2301-2400","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\2301-2400","problems":[{"problemName":"2303.计算应缴税款总额.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2303.计算应缴税款总额.json","problemData":{"id":"1382","name":"2303.计算应缴税款总额","url":"https://leetcode.cn/problems/calculate-amount-paid-in-taxes","desc":"给你一个整数 income 表示你的总收入。返回你需要缴纳的税款总额。","solutions":[{"script":"cpp","time":12,"memory":13,"desc":"遍历。","code":"class Solution {\npublic:\n    double calculateTax(vector<vector<int>>& brackets, int income) {\n        double ans = 0.0;\n        for (int i = 0, prev = 0; i < brackets.size() && prev <= income; prev = brackets[i++][0])\n            ans += 1.0 * (min(income, brackets[i][0]) - prev) * brackets[i][1] / 100;\n        return ans;\n    }\n};","date":"2023-01-23"},{"script":"python","time":48,"memory":15,"desc":"同上。","code":"class Solution:\n    def calculateTax(self, brackets: List[List[int]], income: int) -> float:\n        ans = 0.0\n        prev = 0\n        for [k, v] in brackets:\n            if prev > income:\n                break\n            ans += (min(income, k) - prev) * v / 100\n            prev = k\n        return ans","date":"2023-01-23"},{"script":"rust","time":0,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn calculate_tax(brackets: Vec<Vec<i32>>, income: i32) -> f64 {\n        let mut ans = 0f64;\n        let mut prev = 0;\n        for item in brackets {\n            if prev > income {\n                break;\n            } else {\n                ans += ((income.min(item[0]) - prev) * item[1]) as f64 / 100f64;\n            }\n            prev = item[0]\n        }\n        ans\n    }\n}","date":"2023-01-23"}],"tagList":["数组","模拟"],"level":"Easy"}},{"problemName":"2304.网格中的最小路径代价.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2304.网格中的最小路径代价.json","problemData":{"id":"1394","name":"2304.网格中的最小路径代价","url":"https://leetcode.cn/problems/minimum-path-cost-in-a-grid","desc":"从 第一行 任意单元格出发，返回到达 最后一行 任意单元格的最小路径代价。","solutions":[{"script":"python","time":296,"memory":21.95,"desc":"dp[i][j]表示到ij时的最小开销。","code":"class Solution:\n    def minPathCost(self, grid: List[List[int]], moveCost: List[List[int]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n        dp = [[inf] * m for _ in range(n)]\n        for j in range(m): dp[0][j] = grid[0][j]\n        for i in range(1, n):\n            for j in range(m):\n                dp[i][j] = grid[i][j] + min(moveCost[grid[i - 1][k]][j] + dp[i - 1][k] for k in range(m))\n        return min(dp[n - 1])","date":"2023-11-22"}],"tagList":["数组","动态规划","矩阵"],"level":"Medium"}},{"problemName":"2312.卖木头块.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2312.卖木头块.json","problemData":{"id":"1376","name":"2312.卖木头块","url":"https://leetcode.cn/problems/selling-pieces-of-wood","desc":"请你返回切割一块大小为 m x n 的木块后，能得到的 最多 钱数。","solutions":[{"script":"python","time":6046,"memory":38.27,"desc":"dfs。","code":"class Solution:\n    def sellingWood(self, m: int, n: int, prices: List[List[int]]) -> int:\n        price_map = {}\n        for k1, k2, price in prices:\n            if k1 not in price_map: price_map[k1] = {}\n            item_map = price_map[k1]\n            if k2 not in item_map: item_map[k2] = price\n        @cache\n        def dfs(m: int, n: int) -> int:\n            ans = 0\n            if m in price_map and n in price_map[m]:\n                ans += price_map[m][n]\n            for i in range(1, m):\n                ans = max(ans, dfs(i, n) + dfs(m - i, n))\n            for i in range(1, n):\n                ans = max(ans, dfs(m, i) + dfs(m, n - i))\n            return ans\n        return dfs(m, n)","date":"2024-03-15"}],"tagList":["记忆化搜索","数组","动态规划"],"level":"Hard"}},{"problemName":"2315.统计星号.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2315.统计星号.json","problemData":{"id":"2401","name":"2315.统计星号","url":"https://leetcode.cn/problems/count-asterisks","desc":"请你返回 不在 竖线对之间，s 中 '*' 的数目。","solutions":[{"script":"cpp","time":4,"memory":6.5,"desc":"遍历。","code":"class Solution {\npublic:\n    int countAsterisks(string s) {\n        istringstream iss(s);\n        string tmp;\n        int ans = 0;\n        for (int i = 0; getline(iss, tmp, '|'); i++) {\n            if (i % 2 == 0) \n                for (auto &c : tmp) if (c == '*') ans++;\n        }\n        return ans;\n    }\n};","date":"2023-01-29"},{"script":"python","time":48,"memory":15,"desc":"同上。","code":"class Solution:\n    def countAsterisks(self, s: str) -> int:\n        list = s.split('|')\n        ans = 0\n        for i in range(len(list)):\n            if i % 2 == 0:\n                for c in list[i]:\n                    if c == '*':\n                        ans += 1\n        return ans","date":"2023-01-29"},{"script":"rust","time":0,"memory":2.1,"desc":"同上。","code":"impl Solution {\n    pub fn count_asterisks(s: String) -> i32 {\n        let list = s.split('|').collect::<Vec<_>>();\n        let mut ans = 0;\n        for i in 0..list.len() {\n            if i % 2 == 0 {\n                for c in list[i].chars() {\n                    if c == '*' {\n                        ans += 1\n                    }\n                }\n            }\n        }\n        ans\n    }\n}","date":"2023-01-29"},{"script":"typescript","time":68,"memory":43.9,"desc":"同上。","code":"function countAsterisks(s: string): number {\n        return s.split('|').filter((_, i) => i % 2 === 0).reduce((sum, cur) => sum + cur.split('').filter(v => v === '*').length, 0)\n    };","date":"2023-01-29"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"2316.统计无向图中无法互相到达点对数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2316.统计无向图中无法互相到达点对数.json","problemData":{"id":"2403","name":"2316.统计无向图中无法互相到达点对数","url":"https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph","desc":"给你一个整数 n ，表示一张 无向图 中有 n 个节点，编号为 0 到 n - 1 。同时给你一个二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示节点 ai 和 bi 之间有一条 无向 边。请你返回 无法互相到达 的不同 点对数目 。","solutions":[{"script":"cpp","time":352,"memory":130.11,"desc":"并查集。","code":"class UnionFind {\npublic:\n    int n;\n    vector<int> data, cnt;\n    UnionFind(int n) : n(n), data(vector<int>(n, 0)), cnt(vector<int>(n, 1)) {\n        iota(data.begin(), data.end(), 0);\n    }\n    int size(int v) { return cnt[find(v)]; }\n    int find(int v) {\n        if (data[v] == v) return v;\n        return data[v] = find(data[v]);\n    }\n    void uni(int v1, int v2) {\n        int p1 = find(v1), p2 = find(v2);\n        if (p1 != p2) cnt[p1] += cnt[p2], data[p2] = p1;\n    }\n    bool same(int v1, int v2) { return find(v1) == find(v2); }\n};\nclass Solution {\npublic:\n    long long countPairs(int n, vector<vector<int>>& edges) {\n        UnionFind uf(n);\n        for (auto &edge : edges) uf.uni(edge[0], edge[1]);\n        long long res = 0;\n        for (int i = 0; i < n; i++) {\n            if (uf.data[i] != i) continue;\n            res += (long long)uf.cnt[i] * (n - uf.cnt[i]);\n        }\n        return res / 2;\n    }\n};","date":"2023-10-21"},{"script":"python","time":408,"memory":61.26,"desc":"同上。","code":"class UnionFind:\n    def __init__(self, n) -> None:\n        self.n = n\n        self.data = [i for i in range(0, n)]\n        self.cnt = [1] * n\n\n    def size(self, v: int) -> int:\n        return self.cnt[self.find(v)]\n\n    def find(self, v: int) -> int:\n        if self.data[v] != v:\n            self.data[v] = self.find(self.data[v])\n        return self.data[v]\n\n    def uni(self, v1: int, v2: int):\n        p1 = self.find(v1)\n        p2 = self.find(v2)\n        if p1 != p2:\n            self.cnt[p1] += self.cnt[p2]\n            self.data[p2] = p1\n\n    def same(self, v1: int, v2: int):\n        return self.find(v1) == self.find(v2)\n\nclass Solution:\n    def countPairs(self, n: int, edges: List[List[int]]) -> int:\n        uf = UnionFind(n)\n        for [n1, n2] in edges:\n            uf.uni(n1, n2)\n        return sum(uf.cnt[i] * (n - uf.cnt[i]) if uf.data[i] == i else 0 for i in range(n)) // 2\n","date":"2023-10-21"},{"script":"rust","time":36,"memory":14.85,"desc":"同上。","code":"pub struct UnionFind {\n    pub n: usize,\n    pub data: Vec<usize>,\n    pub cnt: Vec<usize>,\n}\nimpl UnionFind {\n    pub fn new(n: usize) -> Self {\n        let mut data = vec![0; n];\n        for i in 0..data.len() {\n            data[i] = i;\n        }\n        Self {\n            n,\n            data,\n            cnt: vec![1; n],\n        }\n    }\n    pub fn size(&mut self, v: usize) -> usize {\n        let idx = self.find(v);\n        self.cnt[idx]\n    }\n    pub fn find(&mut self, v: usize) -> usize {\n        if self.data[v] != v {\n            self.data[v] = self.find(self.data[v]);\n        }\n        self.data[v]\n    }\n    pub fn uni(&mut self, v1: usize, v2: usize) {\n        let p1 = self.find(v1);\n        let p2 = self.find(v2);\n        if p1 != p2 {\n            self.cnt[p1] += self.cnt[p2];\n            self.data[p2] = p1;\n        }\n    }\n    pub fn same(&mut self, v1: usize, v2: usize) -> bool {\n        self.find(v1) == self.find(v2)\n    }\n}\nimpl Solution {\n    pub fn count_pairs(n: i32, edges: Vec<Vec<i32>>) -> i64 {\n        let n = n as usize;\n        let mut uf = UnionFind::new(n);\n        for edge in edges {\n            uf.uni(edge[0] as usize, edge[1] as usize);\n        }\n        (0..n)\n            .map(|i| {\n                if uf.data[i] != i {\n                    0\n                } else {\n                    uf.cnt[i] * (n - uf.cnt[i])\n                }\n            })\n            .sum::<usize>() as i64\n            / 2\n    }\n}","date":"2023-10-21"}],"tagList":["深度优先搜索","广度优先搜索","并查集","图"],"level":"Medium"}},{"problemName":"2319.判断矩阵是否是一个X矩阵.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2319.判断矩阵是否是一个X矩阵.json","problemData":{"id":"2398","name":"2319.判断矩阵是否是一个X矩阵","url":"https://leetcode.cn/problems/check-if-matrix-is-x-matrix","desc":"给你一个大小为 n x n 的二维整数数组 grid ，表示一个正方形矩阵。如果 grid 是一个 X 矩阵 ，返回 true ；否则，返回 false 。","solutions":[{"script":"cpp","time":24,"memory":15.9,"desc":"遍历。","code":"class Solution {\npublic:\n    bool checkXMatrix(vector<vector<int>>& grid) {\n        int n = grid.size();\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i == j || i == n - 1 - j) {\n                    if (grid[i][j] == 0) return false;\n                } else if (grid[i][j] != 0) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n};","date":"2023-01-31"},{"script":"python","time":48,"memory":15.8,"desc":"同上。","code":"class Solution:\n    def checkXMatrix(self, grid: List[List[int]]) -> bool:\n        n = len(grid)\n        for i in range(n):\n            for j in range(n):\n                if i == j or i == n - 1 - j:\n                    if grid[i][j] == 0:\n                        return False\n                elif grid[i][j] != 0:\n                    return False\n        return True","date":"2023-01-31"},{"script":"rust","time":4,"memory":2.3,"desc":"同上。","code":"impl Solution {\n    pub fn check_x_matrix(grid: Vec<Vec<i32>>) -> bool {\n        let n = grid.len();\n        for i in 0..n {\n            for j in 0..n {\n                if i == j || i == n - 1 - j {\n                    if grid[i][j] == 0 {\n                        return false;\n                    }\n                } else if grid[i][j] != 0 {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}","date":"2023-01-31"}],"tagList":["数组","矩阵"],"level":"Easy"}},{"problemName":"2325.解密消息.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2325.解密消息.json","problemData":{"id":"2406","name":"2325.解密消息","url":"https://leetcode.cn/problems/decode-the-message","desc":"返回解密后的消息。","solutions":[{"script":"cpp","time":24,"memory":15.9,"desc":"遍历。","code":"class Solution {\npublic:\n    string decodeMessage(string key, string message) {\n        char list[26] = {0};\n        for (int i = 0, p = 'a'; i < key.size(); i++) {\n            if (key[i] != ' ' && list[key[i] - 'a'] == 0) list[key[i] - 'a'] = p++;\n        }\n        string ans = \"\";\n        for (auto &c : message) {\n            if (c == ' ') ans += \" \";\n            else ans += list[c - 'a'];\n        }\n        return ans;\n    }\n};","date":"2023-02-01"},{"script":"python","time":48,"memory":15.1,"desc":"同上。","code":"class Solution:\n    def decodeMessage(self, key: str, message: str) -> str:\n        list = [''] * 26\n        p = 'a'\n        for c in key:\n            i = ord(c) - ord('a')\n            if c != ' ' and list[i] == '':\n                list[i] = p\n                p = chr(ord(p) + 1)\n        ans = ''\n        for c in message:\n            if c == ' ':\n                ans += ' '\n            else:\n                ans += list[ord(c) - ord('a')]\n        return ans","date":"2023-02-01"},{"script":"rust","time":0,"memory":2.1,"desc":"同上。","code":"impl Solution {\n    pub fn decode_message(key: String, message: String) -> String {\n        let message = message.chars().collect::<Vec<char>>();\n        let key = key.chars().collect::<Vec<char>>();\n        let mut list = ['\\0'; 26];\n        let mut ans = String::new();\n        let mut p = 'a';\n        for c in key {\n            let i = c as usize - 'a' as usize;\n            if c != ' ' && list[i] == '\\0' {\n                list[i] = p;\n                p = (p as u8 + 1) as char;\n            }\n        }\n        for c in message {\n            if c == ' ' {\n                ans.push(' ');\n            } else {\n                ans.push(list[c as usize - 'a' as usize]);\n            }\n        }\n        ans\n    }\n}","date":"2023-02-01"}],"tagList":["哈希表","字符串"],"level":"Easy"}},{"problemName":"2331.计算布尔二叉树的值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2331.计算布尔二叉树的值.json","problemData":{"id":"2416","name":"2331.计算布尔二叉树的值","url":"https://leetcode.cn/problems/evaluate-boolean-binary-tree","desc":"返回根节点 root 的布尔运算值。","solutions":[{"script":"cpp","time":12,"memory":14.6,"desc":"dfs。","code":"class Solution {\npublic:\n    bool dfs(TreeNode *node) {\n        if (node->val == 0) return false;\n        if (node->val == 1) return true;\n        if (node->left && node->val == 2) return dfs(node->left) || dfs(node->right);\n        if (node->left && node->val == 3) return dfs(node->left) && dfs(node->right);\n        return false;\n    }\n    bool evaluateTree(TreeNode* root) {\n        return dfs(root); \n    }\n};","date":"2023-02-06"},{"script":"python","time":60,"memory":15.8,"desc":"同上。","code":"class Solution:\n    def dfs(self, node: Optional[TreeNode]) -> bool:\n        if node.val == 0: return False\n        if node.val == 1: return True\n        if node.left and node.val == 2: return self.dfs(node.left) or self.dfs(node.right)\n        if node.left and node.val == 3: return self.dfs(node.left) and self.dfs(node.right)\n        return False\n    def evaluateTree(self, root: Optional[TreeNode]) -> bool:\n        return self.dfs(root)","date":"2023-02-06"},{"script":"rust","time":4,"memory":2.4,"desc":"同上。","code":"use std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn evaluate_tree(node: Option<Rc<RefCell<TreeNode>>>) -> bool {\n        let node = node.unwrap();\n        let node = node.as_ref().borrow();\n        if node.val == 0 {\n            return false;\n        }\n        if node.val == 1 {\n            return true;\n        }\n        if node.left.is_some() && node.val == 2 {\n            return Solution::evaluate_tree(node.left.clone()) || Solution::evaluate_tree(node.right.clone());\n        }\n        if node.left.is_some() && node.val == 3 {\n            return Solution::evaluate_tree(node.left.clone()) && Solution::evaluate_tree(node.right.clone());\n        }\n        return false;\n    }\n}","date":"2023-02-06"}],"tagList":["树","深度优先搜索","二叉树"],"level":"Easy"}},{"problemName":"2335.装满杯子需要的最短总时长.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2335.装满杯子需要的最短总时长.json","problemData":{"id":"2412","name":"2335.装满杯子需要的最短总时长","url":"https://leetcode.cn/problems/minimum-amount-of-time-to-fill-cups","desc":"给你一个下标从 0 开始、长度为 3 的整数数组 amount ，其中 amount[0]、amount[1] 和 amount[2] 分别表示需要装满冷水、温水和热水的杯子数量。返回装满所有杯子所需的 最少 秒数。","solutions":[{"script":"cpp","time":0,"memory":11.5,"desc":"堆。","code":"class Solution {\npublic:\n    int fillCups(vector<int>& amount) {\n        priority_queue<int> q;\n        for (auto &num : amount) if (num) q.push(num);\n        int res = 0;\n        while (q.size() >= 2) {\n            int num1 = q.top(); q.pop();\n            int num2 = q.top(); q.pop();\n            if (num1 != 1) q.push(num1 - 1);\n            if (num2 != 1) q.push(num2 - 1);\n            res++;\n        }\n        if (q.size()) res += q.top();\n        return res;\n    }\n};","date":"2023-02-11"},{"script":"python","time":40,"memory":14.9,"desc":"同上。","code":"class Solution:\n    def fillCups(self, amount: List[int]) -> int:\n        amount = [-v for v in amount if v]\n        heapify(amount)\n        res = 0\n        while len(amount) >= 2:\n            num1, num2 = heappop(amount), heappop(amount)\n            if num1 < -1:\n                heappush(amount, num1+1)\n            if num2 < -1:\n                heappush(amount, num2+1)\n            res += 1\n        if len(amount):\n            res += -heappop(amount)\n        return res","date":"2023-02-11"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn fill_cups(amount: Vec<i32>) -> i32 {\n        use std::collections::BinaryHeap;\n        let mut heap = BinaryHeap::new();\n        for num in amount {\n            if num != 0 {\n                heap.push(num)\n            }\n        }\n        let mut res = 0;\n        while heap.len() >= 2 {\n            let (num1, num2) = (heap.pop().unwrap(), heap.pop().unwrap());\n            if num1 != 1 {\n                heap.push(num1 - 1);\n            }\n            if num2 != 1 {\n                heap.push(num2 - 1)\n            }\n            res += 1\n        }\n        if !heap.is_empty() {\n            res += heap.pop().unwrap();\n        }\n        res\n    }\n}","date":"2023-02-11"}],"tagList":["贪心","数组","排序","堆（优先队列）"],"level":"Easy"}},{"problemName":"2336.无限集中的最小数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2336.无限集中的最小数字.json","problemData":{"id":"2413","name":"2336.无限集中的最小数字","url":"https://leetcode.cn/problems/smallest-number-in-infinite-set","desc":"现有一个包含所有正整数的集合 [1, 2, 3, 4, 5, ...] 。实现 SmallestInfiniteSet 类。","solutions":[{"script":"python","time":92,"memory":16.58,"desc":"堆。","code":"class SmallestInfiniteSet:\n    def __init__(self):\n        self.nmin = 1\n        self.q = []\n        self.used = set()\n    def popSmallest(self) -> int:\n        if not self.q:\n            self.nmin += 1\n            return self.nmin - 1\n        num = heappop(self.q)\n        self.used.remove(num)\n        return num\n    def addBack(self, num: int) -> None:\n        if self.nmin > num and num not in self.used:\n            heappush(self.q, num)\n            self.used.add(num)","date":"2023-11-29"}],"tagList":["设计","哈希表","堆（优先队列）"],"level":"Medium"}},{"problemName":"2337.移动片段得到字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2337.移动片段得到字符串.json","problemData":{"id":"2414","name":"2337.移动片段得到字符串","url":"https://leetcode.cn/problems/move-pieces-to-obtain-a-string","desc":"如果在移动字符串 start 中的片段任意次之后可以得到字符串 target ，返回 true ；否则，返回 false 。","solutions":[{"script":"cpp","time":56,"memory":18.6,"desc":"判断start的L都在target右侧，R都在target左侧。","code":"class Solution {\npublic:\n    bool canChange(string start, string target) {\n        int n = start.size(), i1 = 0, i2 = 0;\n        while (i1 < n && start[i1] == '_') i1 += 1;\n        while (i2 < n && target[i2] == '_') i2 += 1;\n        while (i1 < n && i2 < n) {\n            if (start[i1] != target[i2]) return false;\n            if (start[i1] == 'L' && i1 < i2) return false;\n            if (start[i1] == 'R' && i1 > i2) return false;\n            i1 += 1;\n            i2 += 1;\n            while (i1 < n && start[i1] == '_') i1 += 1;\n            while (i2 < n && target[i2] == '_') i2 += 1;\n        }\n        return i1 == n && i2 == n;\n    }\n};","date":"2023-08-21"},{"script":"python","time":240,"memory":16.43,"desc":"同上。","code":"class Solution:\n    def canChange(self, start: str, target: str) -> bool:\n        n = len(start)\n        i1 = i2 = 0\n        while i1 < n and start[i1] == '_':\n            i1 += 1\n        while i2 < n and target[i2] == '_':\n            i2 += 1\n        while i1 < n and i2 < n:\n            if start[i1] != target[i2]:\n                return False\n            if start[i1] == 'L' and i1 < i2:\n                return False\n            if start[i1] == 'R' and i1 > i2:\n                return False\n            i1 += 1\n            i2 += 1\n            while i1 < n and start[i1] == '_':\n                i1 += 1\n            while i2 < n and target[i2] == '_':\n                i2 += 1\n        return i1 == n and i2 == n","date":"2023-08-21"},{"script":"rust","time":12,"memory":3.1,"desc":"同上。","code":"pub fn str_to_vec(s: &String) -> Vec<char> {\n    s.chars().collect()\n}\nimpl Solution {\n    pub fn can_change(start: String, target: String) -> bool {\n        let start = str_to_vec(&start);\n        let target = str_to_vec(&target);\n        let n = start.len();\n        let (mut i1, mut i2) = (0, 0);\n        while i1 < n && start[i1] == '_' {\n            i1 += 1;\n        }\n        while i2 < n && target[i2] == '_' {\n            i2 += 1;\n        }\n        while (i1 < n && i2 < n) {\n            if start[i1] != target[i2] {\n                return false;\n            }\n            if start[i1] == 'L' && i1 < i2 {\n                return false;\n            }\n            if start[i1] == 'R' && i1 > i2 {\n                return false;\n            }\n            i1 += 1;\n            i2 += 1;\n            while i1 < n && start[i1] == '_' {\n                i1 += 1;\n            }\n            while i2 < n && target[i2] == '_' {\n                i2 += 1;\n            }\n        }\n        i1 == n && i2 == n\n    }\n}","date":"2023-08-21"}],"tagList":["双指针","字符串"],"level":"Medium"}},{"problemName":"2341.数组能形成多少数对.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2341.数组能形成多少数对.json","problemData":{"id":"2421","name":"2341.数组能形成多少数对","url":"https://leetcode.cn/problems/maximum-number-of-pairs-in-array","desc":"返回一个下标从 0 开始、长度为 2 的整数数组 answer 作为答案，其中 answer[0] 是形成的数对数目，answer[1] 是对 nums 尽可能执行上述操作后剩下的整数数目。","solutions":[{"script":"cpp","time":4,"memory":8.9,"desc":"遍历。","code":"class Solution {\npublic:\n    vector<int> numberOfPairs(vector<int>& nums) {\n        int list[105] = {0};\n        vector<int> res(2, 0);\n        for (auto &num : nums) {\n            list[num] ^= 1;\n            if (list[num] == 0) res[0]++;\n        }\n        for (int i = 0; i < 105; i++) res[1] += list[i];\n        return res;\n    }\n};","date":"2023-02-16"},{"script":"python","time":36,"memory":14.9,"desc":"同上。","code":"class Solution:\n    def numberOfPairs(self, nums: List[int]) -> List[int]:\n        l = [0] * 105\n        res = [0] * 2\n        for num in nums:\n            l[num] ^= 1\n            if l[num] == 0:\n                res[0] += 1\n        for i in range(105):\n            res[1] += l[i]\n        return res","date":"2023-02-16"},{"script":"rust","time":0,"memory":2.1,"desc":"同上。","code":"impl Solution {\n        pub fn number_of_pairs(nums: Vec<i32>) -> Vec<i32> {\n            let mut list = [0; 105];\n            let mut ans = vec![0; 2];\n            for num in nums {\n                let num = num as usize;\n                list[num] ^= 1;\n                if list[num] == 0 {\n                    ans[0] += 1;\n                }\n            }\n            for i in 0..105 {\n                ans[1] += list[i];\n            }\n            ans\n        }\n    }","date":"2023-02-16"}],"tagList":["数组","哈希表","计数"],"level":"Easy"}},{"problemName":"2342.数位和相等数对的最大和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2342.数位和相等数对的最大和.json","problemData":{"id":"2473","name":"2342.数位和相等数对的最大和","url":"https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits","desc":"给你一个下标从 0 开始的数组 nums ，数组中的元素都是 正 整数。请你选出两个下标 i 和 j（i != j），且 nums[i] 的数位和 与  nums[j] 的数位和相等。请你找出所有满足条件的下标 i 和 j ，找出并返回 nums[i] + nums[j] 可以得到的 最大值 。","solutions":[{"script":"python","time":792,"memory":31.2,"desc":"遍历。","code":"class Solution:\n    def maximumSum(self, nums: List[int]) -> int:\n        m = defaultdict(int)\n        ans = -1\n        for num in nums:\n            v = sum(int(c) for c in str(num))\n            if v in m: ans = max(ans, m[v] + num)\n            m[v] = max(m[v], num)\n        return ans","date":"2023-11-18"}],"tagList":["数组","哈希表","排序","堆（优先队列）"],"level":"Medium"}},{"problemName":"2347.最好的扑克手牌.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2347.最好的扑克手牌.json","problemData":{"id":"2433","name":"2347.最好的扑克手牌","url":"https://leetcode.cn/problems/best-poker-hand","desc":"请你返回一个字符串，表示给定的 5 张牌中，你能组成的 最好手牌类型 。","solutions":[{"script":"cpp","time":0,"memory":10,"desc":"遍历。","code":"class Solution {\npublic:\n    string bestHand(vector<int>& ranks, vector<char>& suits) {\n        unordered_map<int, int> m;\n        for (auto &v : suits) {\n            m[v] += 1;\n            if (m[v] == 5) return \"Flush\";\n        }\n        m.clear();\n        for (auto &v : ranks) {\n            m[v] += 1;\n            if (m[v] >= 3) return \"Three of a Kind\";\n        }\n        for (auto &item : m) {\n            if (item.second >= 2) return \"Pair\";\n        }\n        return \"High Card\";\n    }\n};","date":"2023-02-20"},{"script":"python","time":44,"memory":15,"desc":"同上。","code":"class Solution:\n    def bestHand(self, ranks: List[int], suits: List[str]) -> str:\n        n = len(set(suits))\n        if n == 1:\n            return 'Flush'\n        c = Counter(ranks)\n        if len(c) == 5:\n            return 'High Card'\n        for _, v in c.items():\n            if v >= 3:\n                return 'Three of a Kind'\n        return 'Pair'","date":"2023-02-20"},{"script":"rust","time":0,"memory":2.1,"desc":"同上。","code":"impl Solution {\n    pub fn best_hand(ranks: Vec<i32>, suits: Vec<char>) -> String {\n        use std::collections::HashMap;\n        let mut m = HashMap::<i32, i32>::new();\n        for v in suits {\n            let v = v as i32;\n            let item = m.entry(v).or_insert(0);\n            *item += 1;\n            if *item == 5 {\n                return \"Flush\".to_string();\n            }\n        }\n        m.clear();\n        for v in ranks {\n            let item = m.entry(v).or_insert(0);\n            *item += 1;\n            if *item >= 3 {\n                return \"Three of a Kind\".to_string();\n            }\n        }\n        for (_, v) in m {\n            if v >= 2 {\n                return \"Pair\".to_string();\n            }\n        }\n        \"High Card\".to_string()\n    }\n}","date":"2023-02-20"}],"tagList":["数组","哈希表","计数"],"level":"Easy"}},{"problemName":"2351.第一个出现两次的字母.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2351.第一个出现两次的字母.json","problemData":{"id":"2427","name":"2351.第一个出现两次的字母","url":"https://leetcode.cn/problems/first-letter-to-appear-twice","desc":"给你一个由小写英文字母组成的字符串 s ，请你找出并返回第一个出现 两次 的字母。","solutions":[{"date":"2023-01-01","time":0,"memory":6,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    char repeatedCharacter(string s) {\n        int list[26] = {0};\n        for (auto &c : s) {\n            if (list[c - 'a']++ == 1) return c;\n        }\n        return ' ';\n    }\n};"},{"date":"2023-01-01","time":0,"memory":2.3,"script":"rust","desc":"遍历。","code":"impl Solution {\n    pub fn repeated_character(s: String) -> char {\n        let s = s.as_bytes();\n        let mut list = [0; 26];\n        for c in s {\n            let i = *c as usize - 'a' as usize;\n            if list[i] == 1 {\n                return *c as char;\n            }\n            list[i] += 1;\n        }\n        ' '\n    }\n}"}],"tagList":["位运算","哈希表","字符串","计数"],"level":"Easy"}},{"problemName":"2352.相等行列对.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2352.相等行列对.json","problemData":{"id":"2428","name":"2352.相等行列对","url":"https://leetcode.cn/problems/equal-row-and-column-pairs","desc":"给你一个下标从 0 开始、大小为 n x n 的整数矩阵 grid ，返回满足 Ri 行和 Cj 列相等的行列对 (Ri, Cj) 的数目。","solutions":[{"script":"cpp","time":224,"memory":43,"desc":"哈希存储。","code":"class Solution {\npublic:\n    int equalPairs(vector<vector<int>>& grid) {\n        unordered_map<string, int> rows;\n        int res = 0, n = grid.size();\n        for (int i = 0; i < n; i++) {\n            string key = \"\";\n            for (int j = 0; j < n; j++) key += to_string(grid[i][j]) + \",\";\n            rows[key]++;\n        }\n        for (int j = 0; j < n; j++) {\n            string key = \"\";\n            for (int i = 0; i < n; i++) key += to_string(grid[i][j]) + \",\";\n            res += rows[key];\n        }\n        return res;\n    }\n};","date":"2023-06-06"},{"script":"python","time":212,"memory":20.6,"desc":"同上。","code":"class Solution:\n    def equalPairs(self, grid: List[List[int]]) -> int:\n        rows = Counter()\n        res = 0\n        n = len(grid)\n        for i in range(n):\n            key = \"\"\n            for j in range(n):\n                key += str(grid[i][j]) + \",\"\n            rows[key] += 1\n        for j in range(n):\n            key = \"\"\n            for i in range(n):\n                key += str(grid[i][j]) + \",\"\n            res += rows[key]\n        return res","date":"2023-06-06"},{"script":"rust","time":44,"memory":3,"desc":"同上。","code":"impl Solution {\npub fn equal_pairs(grid: Vec<Vec<i32>>) -> i32 {\n    let mut rows = std::collections::HashMap::<String, i32>::new();\n    let mut res = 0;\n    let n = grid.len();\n    for i in 0..n {\n        let mut key = String::new();\n        for j in 0..n {\n            key.push_str(&format!(\"{}\", grid[i][j]));\n            key.push(',');\n        }\n        *rows.entry(key).or_insert(0) += 1;\n    }\n    for j in 0..n {\n        let mut key = String::new();\n        for i in 0..n {\n            key.push_str(&format!(\"{}\", grid[i][j]));\n            key.push(',');\n        }\n        res += *rows.entry(key).or_insert(0);\n    }\n    res\n}\n}","date":"2023-06-06"}],"tagList":["数组","哈希表","矩阵","模拟"],"level":"Medium"}},{"problemName":"2357.使数组中所有元素都等于零.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2357.使数组中所有元素都等于零.json","problemData":{"id":"2436","name":"2357.使数组中所有元素都等于零","url":"https://leetcode.cn/problems/make-array-zero-by-subtracting-equal-amounts","desc":"返回使 nums 中所有元素都等于 0 需要的 最少 操作数。","solutions":[{"script":"cpp","time":4,"memory":8.3,"desc":"哈希存储。","code":"class Solution {\npublic:\n    int minimumOperations(vector<int>& nums) {\n        unordered_set<int> s(nums.begin(), nums.end());\n        return s.size() - (s.count(0));\n    }\n};","date":"2023-02-24"},{"script":"python","time":32,"memory":14.9,"desc":"同上。","code":"class Solution:\n    def minimumOperations(self, nums: List[int]) -> int:\n        return len(set(nums) - {0})","date":"2023-02-24"},{"script":"rust","time":0,"memory":2.3,"desc":"同上。","code":"impl Solution {\n    pub fn minimum_operations(nums: Vec<i32>) -> i32 {\n        let mut s = std::collections::HashSet::<i32>::new();\n        for num in nums {\n            s.insert(num);\n        }\n        return s.len() as i32 - if s.contains(&0) { 1 } else { 0 };\n    }\n}","date":"2023-02-24"}],"tagList":["贪心","数组","哈希表","排序","模拟","堆（优先队列）"],"level":"Easy"}},{"problemName":"2363.合并相似的物品.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2363.合并相似的物品.json","problemData":{"id":"2447","name":"2363.合并相似的物品","url":"https://leetcode.cn/problems/merge-similar-items","desc":"请你返回一个二维数组 ret，其中 ret[i] = [valuei, weighti]， weighti 是所有价值为 valuei 物品的 重量之和 。","solutions":[{"script":"cpp","time":24,"memory":6.4,"desc":"遍历。","code":"class Solution {\npublic:\n    vector<vector<int>> mergeSimilarItems(vector<vector<int>>& items1, vector<vector<int>>& items2) {\n        map<int, int> m;\n        for (auto &item : items1) m[item[0]] += item[1];\n        for (auto &item : items2) m[item[0]] += item[1];\n        vector<vector<int>> res;\n        for (auto &item : m) res.push_back({ item.first, item.second });\n        return res;\n    }\n};","date":"2023-02-28"},{"script":"python","time":36,"memory":15.5,"desc":"同上。","code":"class Solution:\n    def mergeSimilarItems(self, items1: List[List[int]], items2: List[List[int]]) -> List[List[int]]:\n        l = [0] * 1005\n        for [k, v] in items1:\n            l[k] += v\n        for [k, v] in items2:\n            l[k] += v\n        res = []\n        for i in range(1005):\n            if l[i]:\n                res.append([i, l[i]])\n        return res","date":"2023-02-28"},{"script":"rust","time":4,"memory":2.3,"desc":"同上。","code":"impl Solution {\n    pub fn merge_similar_items(items1: Vec<Vec<i32>>, items2: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        let mut m = std::collections::HashMap::<i32, i32>::new();\n        for item in items1 {\n            let v = m.entry(item[0]).or_insert(0);\n            *v += item[1];\n        }\n        for item in items2 {\n            let v = m.entry(item[0]).or_insert(0);\n            *v += item[1];\n        }\n        let mut res = m\n            .into_iter()\n            .map(|(k, v)| vec![k, v])\n            .collect::<Vec<Vec<i32>>>();\n        res.sort_by_key(|item| item[0]);\n        res\n    }\n}","date":"2023-02-28"}],"tagList":["数组","哈希表","有序集合","排序"],"level":"Easy"}},{"problemName":"2367.算术三元组的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2367.算术三元组的数目.json","problemData":{"id":"2442","name":"2367.算术三元组的数目","url":"https://leetcode.cn/problems/number-of-arithmetic-triplets","desc":"给你一个下标从 0 开始、严格递增 的整数数组 nums 和一个正整数 diff 。返回不同 算术三元组 的数目。","solutions":[{"script":"cpp","time":4,"memory":9.3,"desc":"哈希表+遍历。","code":"class Solution {\npublic:\n    int arithmeticTriplets(vector<int>& nums, int diff) {\n        unordered_map<int, int> m1, m2;\n        int res = 0;\n        for (auto &num : nums) {\n            res += m2[num - diff];\n            m2[num] += m1[num - diff];\n            m1[num] += 1;\n        }\n        return res;\n    }\n};","date":"2023-03-31"},{"script":"python","time":44,"memory":14.9,"desc":"同上。","code":"class Solution:\n    def arithmeticTriplets(self, nums: List[int], diff: int) -> int:\n        m1, m2 = Counter(), Counter()\n        res = 0\n        for num in nums:\n            res += m2[num-diff]\n            m2[num] += m1[num-diff]\n            m1[num] += 1\n        return res","date":"2023-03-31"},{"script":"rust","time":0,"memory":2.1,"desc":"同上。","code":"impl Solution {\n    pub fn arithmetic_triplets(nums: Vec<i32>, diff: i32) -> i32 {\n        use std::collections::HashMap;\n        let (mut m1, mut m2) = (HashMap::<i32, i32>::new(), HashMap::<i32, i32>::new());\n        let mut res = 0;\n        for num in nums {\n            res += *m2.entry(num - diff).or_insert(0);\n            *m2.entry(num).or_insert(0) += *m1.entry(num - diff).or_insert(0);\n            *m1.entry(num).or_insert(0) += 1;\n        }\n        res\n    }\n}","date":"2023-03-31"}],"tagList":["数组","哈希表","双指针","枚举"],"level":"Easy"}},{"problemName":"2369.检查数组是否存在有效划分.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2369.检查数组是否存在有效划分.json","problemData":{"id":"2443","name":"2369.检查数组是否存在有效划分","url":"https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array","desc":"给你一个下标从 0 开始的整数数组 nums ，你必须将数组划分为一个或多个 连续 子数组。如果数组 至少 存在一种有效划分，返回 true ，否则，返回 false 。","solutions":[{"script":"python","time":125,"memory":30.87,"desc":"dp[i]表示以i为节点时是否能够满足要求。","code":"class Solution:\n    def validPartition(self, nums: List[int]) -> bool:\n        n = len(nums)\n        dp = [False] * n\n        dp[0] = False\n        dp[1] = nums[0] == nums[1]\n        if n == 2: return dp[1]\n        dp[2] = nums[0] == nums[1] - 1 == nums[2] - 2 or \\\n                nums[0] == nums[1] == nums[2]\n        for i in range(3, n):\n            dp[i] = dp[i - 2] and nums[i] == nums[i - 1] or \\\n                    dp[i - 3] and nums[i] == nums[i - 1] == nums[i - 2] or \\\n                    dp[i - 3] and nums[i] == nums[i - 1] + 1 == nums[i - 2] + 2\n        return dp[n - 1]","date":"2024-03-01"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"2373.矩阵中的局部最大值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2373.矩阵中的局部最大值.json","problemData":{"id":"2454","name":"2373.矩阵中的局部最大值","url":"https://leetcode.cn/problems/largest-local-values-in-a-matrix","desc":"找出 grid 中每个 3 x 3 矩阵中的最大值。","solutions":[{"script":"cpp","time":12,"memory":10.8,"desc":"遍历。","code":"class Solution {\npublic:\n    vector<vector<int>> largestLocal(vector<vector<int>>& grid) {\n        int n = grid.size();\n        vector<vector<int>> res(n - 2, vector<int>(n - 2, 0));\n        for (int i = 1; i < n - 1; i++) {\n            for (int j = 1; j < n - 1; j++) {\n                for (int row = i - 1; row <= i + 1; row++) {\n                    for (int col = j - 1; col <= j + 1; col++) {\n                        res[i - 1][j - 1] = max(res[i - 1][j - 1], grid[row][col]);\n                    }\n                }\n            }\n        }\n        return res;\n    }\n};","date":"2023-03-01"},{"script":"python","time":36,"memory":15.5,"desc":"同上。","code":"class Solution:\n    def largestLocal(self, grid: List[List[int]]) -> List[List[int]]:\n        n = len(grid)\n        res = [[0] * (n-2) for _ in range(n-2)]\n        for i in range(1, n-1):\n            for j in range(1, n-1):\n                res[i-1][j-1] = max(\n                    grid[row][col]\n                    for row in range(i-1, i+2)\n                    for col in range(j-1, j+2)\n                )\n        return res","date":"2023-03-01"},{"script":"rust","time":4,"memory":2.2,"desc":"同上。","code":"impl Solution {\n        pub fn largest_local(grid: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n            let n = grid.len();\n            let mut res = vec![vec![0; n - 2]; n - 2];\n            for i in 1..(n - 1) {\n                for j in 1..(n - 1) {\n                    for row in (i - 1)..=(i + 1) {\n                        for col in (j - 1)..=(j + 1) {\n                            res[i - 1][j - 1] = res[i - 1][j - 1].max(grid[row][col]);\n                        }\n                    }\n                }\n            }\n            res\n        }\n    }","date":"2023-03-01"}],"tagList":["数组","矩阵"],"level":"Easy"}},{"problemName":"2379.得到K个黑块的最少涂色次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2379.得到K个黑块的最少涂色次数.json","problemData":{"id":"2463","name":"2379.得到K个黑块的最少涂色次数","url":"https://leetcode.cn/problems/minimum-recolors-to-get-k-consecutive-black-blocks","desc":"给你一个整数 k ，表示想要 连续 黑色块的数目。每一次操作中，你可以选择一个白色块将它 涂成 黑色块。请你返回至少出现 一次 连续 k 个黑色块的 最少 操作次数。","solutions":[{"script":"cpp","time":8,"memory":6.2,"desc":"遍历。","code":"class Solution {\npublic:\n    int minimumRecolors(string blocks, int k) {\n        int n = blocks.size(), ans = 0x3f3f3f3f, cur = 0;\n        for (int i = 0; i < n; i++) {\n            cur += blocks[i] == 'W' ? 1 : 0;\n            if (i + 1 >= k) {\n                if (i + 1 > k) cur -= blocks[i - k] == 'W' ? 1 : 0;\n                ans = min(ans, cur);\n            }\n        }\n        return ans;\n    }\n};","date":"2023-03-09"},{"script":"python","time":36,"memory":14.9,"desc":"同上。","code":"class Solution:\n    def minimumRecolors(self, blocks: str, k: int) -> int:\n        n, ans, cur = len(blocks), 0x3f3f3f3f, 0\n        for i in range(n):\n            cur += 1 if blocks[i] == 'W' else 0\n            if i + 1 >= k:\n                if i + 1 > k:\n                    cur -= 1 if blocks[i - k] == 'W' else 0\n                ans = min(ans, cur)\n        return ans","date":"2023-03-09"},{"script":"rust","time":0,"memory":2.1,"desc":"同上。","code":"impl Solution {\n        pub fn minimum_recolors(blocks: String, k: i32) -> i32 {\n            let k = k as usize;\n            let blocks = blocks.chars().collect::<Vec<char>>();\n            let (n, mut ans, mut cur) = (blocks.len(), 0x3f3f3f3f, 0);\n            for i in 0..n {\n                cur += if blocks[i] == 'W' { 1 } else { 0 };\n                if i + 1 >= k {\n                    if i + 1 > k {\n                        cur -= if blocks[i - k] == 'W' { 1 } else { 0 };\n                    }\n                    ans = ans.min(cur);\n                }\n            }\n            ans\n        }\n    }","date":"2023-03-09"}],"tagList":["字符串","滑动窗口"],"level":"Easy"}},{"problemName":"2383.赢得比赛需要的最少训练时长.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2383.赢得比赛需要的最少训练时长.json","problemData":{"id":"2459","name":"2383.赢得比赛需要的最少训练时长","url":"https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition","desc":"返回击败全部 n 个对手需要训练的 最少 小时数目。","solutions":[{"script":"cpp","time":0,"memory":10.9,"desc":"遍历。","code":"class Solution {\npublic:\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\n        int res = 0, esum = initialExperience;\n        res += max(accumulate(energy.begin(), energy.end(), 0) - initialEnergy + 1, 0);\n        for (auto &e : experience) {\n            if (e >= esum) res += e - esum + 1, esum += e - esum + 1;\n            esum += e;\n        }\n        return res;\n    }\n};","date":"2023-03-13"},{"script":"cpp","time":4,"memory":10.8,"desc":"遍历。","code":"class Solution {\npublic:\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\n        int res = 0;\n        for (int i = 0; i < energy.size(); i++) {\n            if (initialEnergy <= energy[i]) \n                res += energy[i] - initialEnergy + 1, initialEnergy += energy[i] - initialEnergy + 1;\n            initialEnergy -= energy[i];\n            if (initialExperience <= experience[i]) \n                res += experience[i] - initialExperience + 1, initialExperience += experience[i] - initialExperience + 1;\n            initialExperience += experience[i];\n        }\n        return res;\n    }\n};","date":"2023-03-13"},{"script":"python","time":36,"memory":14.9,"desc":"同上。","code":"class Solution:\ndef minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\n    res = 0\n    for i in range(len(energy)):\n        if initialEnergy <= energy[i]:\n            res += energy[i] - initialEnergy + 1\n            initialEnergy += energy[i] - initialEnergy + 1\n        initialEnergy -= energy[i]\n        if initialExperience <= experience[i]:\n            res += experience[i] - initialExperience + 1\n            initialExperience += experience[i] - initialExperience + 1\n        initialExperience += experience[i]\n    return res","date":"2023-03-13"},{"script":"rust","time":0,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn min_number_of_hours(\n        mut initial_energy: i32,\n        mut initial_experience: i32,\n        energy: Vec<i32>,\n        experience: Vec<i32>,\n    ) -> i32 {\n        let mut res = 0;\n        for i in 0..energy.len() {\n            if initial_energy <= energy[i] {\n                res += energy[i] - initial_energy + 1;\n                initial_energy += energy[i] - initial_energy + 1;\n            }\n            initial_energy -= energy[i];\n            if initial_experience <= experience[i] {\n                res += experience[i] - initial_experience + 1;\n                initial_experience += experience[i] - initial_experience + 1;\n            }\n            initial_experience += experience[i];\n        }\n        res\n    }\n}","date":"2023-03-13"}],"tagList":["贪心","数组"],"level":"Easy"}},{"problemName":"2385.感染二叉树需要的总时间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2385.感染二叉树需要的总时间.json","problemData":{"id":"2461","name":"2385.感染二叉树需要的总时间","url":"https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected","desc":"返回感染整棵树需要的分钟数。","solutions":[{"script":"python","time":331,"memory":59.43,"desc":"dfs。","code":"class Solution:\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\n        parent = {root:None}\n        start_node = None\n        q = deque([root])\n        while q:\n            node = q.popleft()\n            if node.val == start: start_node = node\n            if node.left: parent[node.left] = node; q.append(node.left)\n            if node.right: parent[node.right] = node; q.append(node.right)\n        def dfs(node: Optional[TreeNode], pre_node: Optional[TreeNode]):\n            if not node: return 0\n            res = 0\n            if parent[node] and parent[node] != pre_node:\n                res = max(res, dfs(parent[node], node))\n            if node.left and node.left != pre_node:\n                res = max(res, dfs(node.left, node))\n            if node.right and node.right != pre_node:\n                res=  max(res, dfs(node.right, node))\n            return res + 1\n        return dfs(start_node, None) - 1","date":"2024-04-24"}],"tagList":["树","深度优先搜索","广度优先搜索","哈希表","二叉树"],"level":"Medium"}},{"problemName":"2389.和有限的最长子序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2389.和有限的最长子序列.json","problemData":{"id":"2469","name":"2389.和有限的最长子序列","url":"https://leetcode.cn/problems/longest-subsequence-with-limited-sum","desc":"返回一个长度为 m 的数组 answer ，其中 answer[i] 是 nums 中 元素之和小于等于 queries[i] 的 子序列 的 最大 长度  。","solutions":[{"script":"typescript","time":72,"memory":44.4,"desc":"排序后遍历。","code":"function answerQueries(nums: number[], queries: number[]): number[] {\n        nums.sort((a, b) => a - b);\n        return queries.map(num => {\n          let i = 0;\n          let cur = 0;\n          while (i < nums.length && cur + nums[i] <= num) cur += nums[i++];\n          return i;\n        });\n      }","date":"2022-08-28"},{"script":"cpp","time":20,"memory":13.3,"desc":"排序后遍历。","code":"class Solution {\npublic:\n    vector<int> answerQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        vector<int> idxs(m), res(m, 0);\n        for (int i = 0; i < m; i++) idxs[i] = i;\n        sort(idxs.begin(), idxs.end(), [&](auto &a, auto &b){\n            return queries[a] < queries[b];\n        });\n        sort(nums.begin(), nums.end());\n        int idx = 0, sum = 0;\n        for (int i = 0; i < m; i++) {\n            while (idx < n && sum + nums[idx] <= queries[idxs[i]]) sum += nums[idx++];\n            res[idxs[i]] = idx;\n        }\n        return res;\n    }\n};","date":"2023-03-17"},{"script":"python","time":48,"memory":15.1,"desc":"同上。","code":"class Solution:\n    def answerQueries(self, nums: List[int], queries: List[int]) -> List[int]:\n        n, m = len(nums), len(queries)\n        idxs = [i for i in range(m)]\n        idxs.sort(key=lambda v: queries[v])\n        res = [0 for i in range(m)]\n        nums.sort()\n        idx, sums = 0, 0\n        for i in range(m):\n            while idx < n and sums + nums[idx] <= queries[idxs[i]]:\n                sums += nums[idx]\n                idx += 1\n            res[idxs[i]] = idx\n        return res","date":"2023-03-17"},{"script":"rust","time":4,"memory":2.1,"desc":"同上。","code":"impl Solution {\n    pub fn answer_queries(mut nums: Vec<i32>, queries: Vec<i32>) -> Vec<i32> {\n        nums.sort();\n        let (n, m) = (nums.len(), queries.len());\n        let mut idxs = (0..m).collect::<Vec<usize>>();\n        idxs.sort_by(|v1, v2| queries[*v1].cmp(&queries[*v2]));\n        let mut res = (0..m).map(|v| v as i32).collect::<Vec<i32>>();\n        let (mut idx, mut sum) = (0, 0);\n        for i in 0..m {\n            while idx < n && sum + nums[idx] <= queries[idxs[i]] {\n                sum += nums[idx];\n                idx += 1;\n            }\n            res[idxs[i]] = idx as i32;\n        }\n        res\n    }\n}","date":"2023-03-17"}],"tagList":["贪心","数组","二分查找","前缀和","排序"],"level":"Easy"}},{"problemName":"2391.收集垃圾的最少总时间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2391.收集垃圾的最少总时间.json","problemData":{"id":"2471","name":"2391.收集垃圾的最少总时间","url":"https://leetcode.cn/problems/minimum-amount-of-time-to-collect-garbage","desc":"请你返回收拾完所有垃圾需要花费的 最少 总分钟数。","solutions":[{"script":"python","time":54,"memory":16.46,"desc":"模拟。","code":"class Solution:\n    def garbageCollection(self, garbage: List[str], travel: List[int]) -> int:\n        n = len(garbage)\n        def run(c: str) -> int:\n            res = 0\n            prev = 0\n            for i in range(n):\n                cnt = garbage[i].count(c)\n                if cnt:\n                    res += sum(travel[prev:i]) + cnt\n                    prev = i\n            return res\n        return sum(map(run, 'MPG'))","date":"2024-05-11"}],"tagList":["数组","字符串","前缀和"],"level":"Medium"}},{"problemName":"2395.和相等的子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2395.和相等的子数组.json","problemData":{"id":"2480","name":"2395.和相等的子数组","url":"https://leetcode.cn/problems/find-subarrays-with-equal-sum","desc":"给你一个下标从 0 开始的整数数组 nums ，判断是否存在 两个 长度为 2 的子数组且它们的 和 相等。注意，这两个子数组起始位置的下标必须 不相同 。如果这样的子数组存在，请返回 true，否则返回 false 。","solutions":[{"script":"cpp","time":4,"memory":7.6,"desc":"遍历。","code":"class Solution {\npublic:\n    bool findSubarrays(vector<int>& nums) {\n        unordered_set<int> s;\n        for (int i = 1; i < nums.size(); i++) {\n            int num = nums[i] + nums[i - 1];\n            if (s.count(num)) return true;\n            s.insert(num);\n        }\n        return false;\n    }\n};","date":"2023-03-26"},{"script":"python","time":72,"memory":29.8,"desc":"同上。","code":"class Solution:\n    def findSubarrays(self, nums: List[int]) -> bool:\n        s = set()\n        for i in range(1, len(nums)):\n            num = nums[i] + nums[i - 1]\n            if num in s:\n                return True\n            s.add(num)\n        return False","date":"2023-03-26"},{"script":"rust","time":0,"memory":2.1,"desc":"同上。","code":"impl Solution {\n    pub fn find_subarrays(nums: Vec<i32>) -> bool {\n        let mut s = std::collections::HashSet::<i32>::new();\n        for i in 1..nums.len() {\n            let num = nums[i] + nums[i - 1];\n            if s.contains(&num) {\n                return true;\n            }\n            s.insert(num);\n        }\n        false\n    }\n}","date":"2023-03-26"}],"tagList":["数组","哈希表"],"level":"Easy"}},{"problemName":"2397.被列覆盖的最多行数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2397.被列覆盖的最多行数.json","problemData":{"id":"2482","name":"2397.被列覆盖的最多行数","url":"https://leetcode.cn/problems/maximum-rows-covered-by-columns","desc":"返回一个整数，表示可以由 numSelect 列构成的集合 覆盖 的 最大行数 。","solutions":[{"script":"python","time":48,"memory":16.85,"desc":"遍历所有列覆盖的情况。","code":"class Solution:\n    def maximumRows(self, matrix: List[List[int]], numSelect: int) -> int:\n        n = len(matrix)\n        m = len(matrix[0])\n        rows = []\n        for i in range(n):\n            used = 0\n            for j in range(m):\n                if matrix[i][j] == 1: used |= 1 << j\n            rows.append(used)\n        ans = 0\n        for used in range(1 << m):\n            if bin(used).count('1') != numSelect: continue\n            count = sum((rows[i] & used) == rows[i] for i in range(n))\n            ans = max(ans, count)\n        return ans","date":"2024-01-04"}],"tagList":["位运算","数组","回溯","枚举","矩阵"],"level":"Medium"}},{"problemName":"2399.检查相同字母间的距离.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2301-2400/2399.检查相同字母间的距离.json","problemData":{"id":"2476","name":"2399.检查相同字母间的距离","url":"https://leetcode.cn/problems/check-distances-between-same-letters","desc":"如果 s 是一个 匀整 字符串，返回 true ；否则，返回 false 。","solutions":[{"script":"javascript","time":68,"memory":43.4,"desc":"遍历。","code":"var checkDistances = function (s, distance) {\n        const cache = {};\n        for (let i = 0; i < s.length; i++) {\n          const prev = cache[s[i]];\n          if (prev !== undefined) {\n            const d = distance[s.codePointAt(i) - 'a'.codePointAt(0)];\n            if (d !== i - prev - 1) return false;\n          } else {\n            cache[s[i]] = i;\n          }\n        }\n        return true;\n      };","date":"2022-09-04"},{"script":"cpp","time":0,"memory":12.8,"desc":"遍历。","code":"class Solution {\npublic:\n    bool checkDistances(string s, vector<int>& distance) {\n        vector<int> list(26, -1);\n        for (int i = 0; i < s.size(); i++) {\n            if (list[s[i] - 'a'] == -1) list[s[i] - 'a'] = i;\n            else if (i - list[s[i] - 'a'] - 1 != distance[s[i] - 'a']) return false;\n        }\n        return true;\n    }\n};","date":"2023-04-09"},{"script":"python","time":68,"memory":14.8,"desc":"同上。","code":"class Solution:\n    def checkDistances(self, s: str, distance: List[int]) -> bool:\n        l = [-1] * 26\n        for i in range(len(s)):\n            idx = ord(s[i]) - ord('a')\n            if list[idx] == -1:\n                list[idx] = i\n            elif i - list[idx] - 1 != distance[idx]:\n                return False\n        return True","date":"2023-04-09"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn check_distances(s: String, distance: Vec<i32>) -> bool {\n        let s: Vec<usize> = s.chars().map(|v| v as usize).collect();\n        let mut list = vec![-1i32; 26];\n        for i in 0..s.len() {\n            let idx = s[i] - 'a' as usize;\n            if list[idx] == -1 {\n                list[idx] = i as i32;\n            } else if i as i32 - list[idx] - 1 != distance[idx] {\n                return false;\n            }\n        }\n        true\n    }\n}","date":"2023-04-09"}],"tagList":["数组","哈希表","字符串"],"level":"Easy"}}]},{"dirName":"2401-2500","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\2401-2500","problems":[{"problemName":"2404.出现最频繁的偶数元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2404.出现最频繁的偶数元素.json","problemData":{"id":"2486","name":"2404.出现最频繁的偶数元素","url":"https://leetcode.cn/problems/most-frequent-even-element","desc":"给你一个整数数组 nums ，返回出现最频繁的偶数元素。如果存在多个满足条件的元素，只需要返回 最小 的一个。如果不存在这样的元素，返回 -1 。","solutions":[{"script":"cpp","time":56,"memory":37.1,"desc":"遍历。","code":"class Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        unordered_map<int, int> m;\n        int res = -1, nmax = -1;\n        for (auto &num : nums) {\n            if (num % 2 == 0) {\n                m[num]++;\n                if (m[num] > nmax || m[num] == nmax && num < res) res = num, nmax = m[num];\n            }\n        }\n        return res;\n    }\n};","date":"2023-04-13"},{"script":"python","time":84,"memory":15.2,"desc":"同上。","code":"class Solution:\n    def mostFrequentEven(self, nums: List[int]) -> int:\n        m = Counter()\n        res = nmax = -1\n        for num in nums:\n            if num % 2 == 0:\n                m[num] += 1\n                if m[num] > nmax or m[num] == nmax and num < res:\n                    res = num\n                    nmax = m[num]\n        return res","date":"2023-04-13"},{"script":"rust","time":8,"memory":2.1,"desc":"同上。","code":"impl Solution {\n    pub fn most_frequent_even(nums: Vec<i32>) -> i32 {\n        let mut m = std::collections::HashMap::<i32, i32>::new();\n        let mut res = -1;\n        let mut nmax = -1;\n        for num in nums {\n            if num % 2 == 0 {\n                let item = m.entry(num).or_insert(0);\n                *item += 1;\n                if *item > nmax || *item == nmax && num < res {\n                    res = num;\n                    nmax = *item;\n                }\n            }\n        }\n        res\n    }\n}","date":"2023-04-13"}],"tagList":["数组","哈希表","计数"],"level":"Easy"}},{"problemName":"2409.统计共同度过的日子数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2409.统计共同度过的日子数.json","problemData":{"id":"2496","name":"2409.统计共同度过的日子数","url":"https://leetcode.cn/problems/count-days-spent-together","desc":"请你返回 Alice和 Bob 同时在罗马的天数。","solutions":[{"script":"cpp","time":0,"memory":5.9,"desc":"统计区间。","code":"#define X first\n#define Y second\nclass Solution {\npublic:\n    typedef pair<int, int> pii;\n    int days[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    int countDaysTogether(string arriveAlice, string leaveAlice, string arriveBob, string leaveBob) {\n        pii as = comp(arriveAlice), al = comp(leaveAlice), bs = comp(arriveBob), bl = comp(leaveBob);\n        if (as.X > bs.X || as.X == bs.X && as.Y > bs.Y) swap(as, bs), swap(al, bl);\n        if (al.X < bs.X || al.X == bs.X && al.Y < bs.Y) return 0;\n        pii start = bs, end = bl.X < al.X || bl.X == al.X && bl.Y < al.Y ? bl : al;\n        if (start.X == end.X) return end.Y - start.Y + 1;\n        int res = days[start.X] - start.Y + 1 + end.Y;\n        for (int i = start.X + 1; i < end.X; i++) res += days[i];\n        return res;\n    }\n    pii comp(string &time) {\n        return make_pair((time[0] - '0') * 10 + (time[1] - '0'), (time[3] - '0') * 10 + (time[4] - '0'));\n    }\n};","date":"2023-04-17"},{"script":"python","time":48,"memory":15,"desc":"同上。","code":"days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    def comp(time: str) -> Tuple[int, int]:\n        return (\n            (ord(time[0]) - ord('0')) * 10 + (ord(time[1]) - ord('0')),\n            (ord(time[3]) - ord('0')) * 10 + (ord(time[4]) - ord('0')),\n        )\n    class Solution:\n        def countDaysTogether(self, arriveAlice: str, leaveAlice: str, arriveBob: str, leaveBob: str) -> int:\n            aS, aL, bS, bL = comp(arriveAlice), comp(\n                leaveAlice), comp(arriveBob), comp(leaveBob)\n            if aS[0] > bS[0] or aS[0] == bS[0] and aS[1] > bS[1]:\n                temp = aS\n                aS = bS\n                bS = temp\n                temp = aL\n                aL = bL\n                bL = temp\n            if aL[0] < bS[0] or aL[0] == bS[0] and aL[1] < bS[1]:\n                return 0\n            start = bS\n            end = bL if bL[0] < aL[0] or bL[0] == aL[0] and bL[1] < aL[1] else aL\n            if start[0] == end[0]:\n                return end[1] - start[1] + 1\n            res = days[start[0]] - start[1] + 1 + end[1]\n            for i in range(start[0] + 1, end[0]):\n                res += days[i]\n            return res","date":"2023-04-17"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"fn str_to_vec(s: &String) -> Vec<char> {\n    s.chars().collect()\n}\nimpl Solution {\n    pub fn count_days_together(\n        arrive_alice: String,\n        leave_alice: String,\n        arrive_bob: String,\n        leave_bob: String,\n    ) -> i32 {\n        use std::mem::swap;\n        let days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n        let comp = |time: Vec<char>| -> (i32, i32) {\n            (\n                (time[0] as i32 - '0' as i32) * 10 + time[1] as i32 - '0' as i32,\n                (time[3] as i32 - '0' as i32) * 10 + time[4] as i32 - '0' as i32,\n            )\n        };\n        let (mut a_s, mut a_l, mut b_s, mut b_l) = (\n            comp(str_to_vec(&arrive_alice)),\n            comp(str_to_vec(&leave_alice)),\n            comp(str_to_vec(&arrive_bob)),\n            comp(str_to_vec(&leave_bob)),\n        );\n        if a_s.0 > b_s.0 || a_s.0 == b_s.0 && a_s.1 > b_s.1 {\n            swap(&mut a_s, &mut b_s);\n            swap(&mut a_l, &mut b_l);\n        }\n        if a_l.0 < b_s.0 || a_l.0 == b_s.0 && a_l.1 < b_s.1 {\n            0\n        } else {\n            let start = b_s;\n            let end = if b_l.0 < a_l.0 || b_l.0 == a_l.0 && b_l.1 < a_l.1 {\n                b_l\n            } else {\n                a_l\n            };\n            if start.0 == end.0 {\n                end.1 - start.1 + 1\n            } else {\n                let mut res = days[start.0 as usize] - start.1 + 1 + end.1;\n                for i in start.0 + 1..end.0 {\n                    res += days[i as usize];\n                }\n                res\n            }\n        }\n    }\n}","date":"2023-04-17"}],"tagList":["数学","字符串"],"level":"Easy"}},{"problemName":"2413.最小偶倍数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2413.最小偶倍数.json","problemData":{"id":"2491","name":"2413.最小偶倍数","url":"https://leetcode.cn/problems/smallest-even-multiple","desc":"给你一个正整数 n ，返回 2 和 n 的最小公倍数（正整数）。","solutions":[{"script":"cpp","time":0,"memory":5.8,"desc":"gcd。","code":"int gcd(int a, int b) {\n    if (a < b) return gcd(b, a);\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\nclass Solution {\npublic:\n    int smallestEvenMultiple(int n) {\n        int res = gcd(2, n), num = 2 * n / res;\n        if (num % 2 != 0) num *= 2;\n        return num;\n    }\n};","date":"2023-04-21"},{"script":"python","time":52,"memory":14.7,"desc":"同上。","code":"def gcd(a: int, b: int):\n    if a < b:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n\nclass Solution:\n    def smallestEvenMultiple(self, n: int) -> int:\n        res = gcd(2, n)\n        num = 2*n/res\n        if num % 2 != 0:\n            num *= 2\n        return int(num) ","date":"2023-04-21"},{"script":"rust","time":0,"memory":2.1,"desc":"同上。","code":"fn gcd(a: i32, b: i32) -> i32 {\n    if a < b {\n        gcd(b, a)\n    } else if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}\n\nimpl Solution {\n    pub fn smallest_even_multiple(n: i32) -> i32 {\n        let res = gcd(2, n);\n        let mut num = 2 * n / res;\n        if num % 2 != 0 {\n            num *= 2;\n        }\n        num\n    }\n}","date":"2023-04-21"}],"tagList":["数学","数论"],"level":"Easy"}},{"problemName":"2415.反转二叉树的奇数层.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2415.反转二叉树的奇数层.json","problemData":{"id":"2493","name":"2415.反转二叉树的奇数层","url":"https://leetcode.cn/problems/reverse-odd-levels-of-binary-tree","desc":"给你一棵 完美 二叉树的根节点 root ，请你反转这棵树中每个 奇数 层的节点值。","solutions":[{"script":"python","time":1776,"memory":22.2,"desc":"bfs。","code":"class Solution:\n    def reverseOddLevels(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root: return None\n        q = [root]\n        size = 1\n        level = 0\n        while q:\n            node = q.pop(0)\n            if node.left: q.append(node.left)\n            if node.right: q.append(node.right)\n            size -= 1\n            if size == 0:\n                size = len(q)\n                level += 1\n                if level % 2 != 0:\n                    for i in range(len(q) // 2):\n                        q[i].val, q[len(q) - 1 - i].val = q[len(q) - 1 - i].val, q[i].val\n        return root","date":"2023-12-15"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"2418.按身高排序.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2418.按身高排序.json","problemData":{"id":"2502","name":"2418.按身高排序","url":"https://leetcode.cn/problems/sort-the-people","desc":"给你一个字符串数组 names ，和一个由 互不相同 的正整数组成的数组 heights 。两个数组的长度均为 n 。","solutions":[{"script":"typescript","time":76,"memory":45.9,"desc":"遍历。","code":"function sortPeople(names: string[], heights: number[]): string[] {\n  return new Array(names.length)\n    .fill(0)\n    .map((_, i) => i)\n    .sort((a, b) => heights[b] - heights[a])\n    .map(i => names[i]);\n}","date":"2022-09-25"},{"script":"cpp","time":32,"memory":19.8,"desc":"遍历。","code":"class Solution {\npublic:\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\n        vector<int> idxs;\n        for (int i = 0; i < names.size(); i++) idxs.push_back(i);\n        sort(idxs.begin(), idxs.end(), [&](auto &i1, auto &i2) { return heights[i1] > heights[i2]; });\n        vector<string> res;\n        for (int i = 0; i < names.size(); i++) res.push_back(names[idxs[i]]);\n        return res;\n    }\n};","date":"2023-04-25"},{"script":"python","time":56,"memory":15.4,"desc":"同上。","code":"class Solution:\n    def sortPeople(self, names: List[str], heights: List[int]) -> List[str]:\n        l = [i for i in range(len(names))]\n        l.sort(key=lambda i: heights[i], reverse=True)\n        return [names[i] for i in l]","date":"2023-04-25"},{"script":"rust","time":8,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn sort_people(names: Vec<String>, heights: Vec<i32>) -> Vec<String> {\n        let mut l = (0..names.len()).collect::<Vec<usize>>();\n        l.sort_by_key(|i| heights[*i]);        \n        l.into_iter().rev().map(|i| names[i].clone()).collect()\n    }\n}","date":"2023-04-25"}],"tagList":["数组","哈希表","字符串","排序"],"level":"Easy"}},{"problemName":"2423.删除字符使频率相同.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2423.删除字符使频率相同.json","problemData":{"id":"2532","name":"2423.删除字符使频率相同","url":"https://leetcode.cn/problems/remove-letter-to-equalize-frequency","desc":"给你一个下标从 0 开始的字符串 word ，字符串只包含小写英文字母。你需要选择 一个 下标并 删除 下标处的字符，使得 word 中剩余每个字母出现 频率 相同。如果删除一个字母后，word 中剩余所有字母的出现频率都相同，那么返回 true ，否则返回 false 。","solutions":[{"script":"cpp","time":0,"memory":6,"desc":"模拟。","code":"class Solution {\npublic:\n    bool equalFrequency(string word) {\n        int cnt[26] = {0};\n        for (auto &c : word) cnt[c - 'a']++;\n        map<int, vector<int>> m;\n        for (int i = 0; i < 26; i++) \n            if (cnt[i]) m[cnt[i]].push_back(i);\n        // 如果都是一个频率，只有在频率都是1或者数量为1的时候才可以\n        if (m.size() == 1) return m.begin()->first == 1 || m.begin()->second.size() == 1;\n        // 超过两个频率就报错\n        if (m.size() != 2) return false;\n        int pi = -1;\n        vector<int> pl;\n        for (auto &item : m) {\n            int ci = item.first;\n            vector<int> cl = item.second;\n            if (pi == -1) pi = ci, pl = cl;\n            // 如果有一个频率是1且数量是1， 可以直接删\n            else if (pi == 1 && pl.size() == 1 || ci == 1 && cl.size() == 1) return true;\n            // 如果两个频率不差1， 就报错\n            else if (pi + 1 != ci) return false;\n            // 如果高频率不是只有1个，就报错\n            else if (cl.size() != 1) return false;\n        }\n        return true;\n    }\n};","date":"2023-04-29"}],"tagList":["哈希表","字符串","计数"],"level":"Easy"}},{"problemName":"2427.公因子的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2427.公因子的数目.json","problemData":{"id":"2507","name":"2427.公因子的数目","url":"https://leetcode.cn/problems/number-of-common-factors","desc":"给你两个正整数 a 和 b ，返回 a 和 b 的 公 因子的数目。如果 x 可以同时整除 a 和 b ，则认为 x 是 a 和 b 的一个 公因子 。","solutions":[{"script":"cpp","time":4,"memory":5.8,"desc":"遍历。","code":"class Solution {\npublic:\n    int commonFactors(int a, int b) {\n        int res = 0;\n        for (int i = 1; i <= min(a, b); i++) {\n            if (a % i == 0 && b % i == 0) res++;\n        }\n        return res;\n    }\n};","date":"2023-04-05"},{"script":"python","time":44,"memory":14.9,"desc":"同上。","code":"class Solution:\n    def commonFactors(self, a: int, b: int) -> int:\n        return len([i for i in range(1, min(a, b) + 1) if a % i == 0 and b % i == 0])\n  ","date":"2023-04-05"},{"script":"rust","time":0,"memory":1.9,"desc":"同上。","code":"impl Solution {\n    pub fn common_factors(a: i32, b: i32) -> i32 {\n        (1..=a.min(b))\n            .into_iter()\n            .filter(|v| a % v == 0 && b % v == 0)\n            .collect::<Vec<i32>>()\n            .len() as i32\n    }\n}","date":"2023-04-05"}],"tagList":["数学","枚举","数论"],"level":"Easy"}},{"problemName":"2432.处理用时最长的那个任务的员工.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2432.处理用时最长的那个任务的员工.json","problemData":{"id":"2518","name":"2432.处理用时最长的那个任务的员工","url":"https://leetcode.cn/problems/the-employee-that-worked-on-the-longest-task","desc":"返回处理用时最长的那个任务的员工的 id 。","solutions":[{"script":"cpp","time":56,"memory":34.8,"desc":"遍历。","code":"class Solution {\npublic:\n    int hardestWorker(int n, vector<vector<int>>& logs) {\n        int prev = 0, resVal = 0, res;\n        for (auto &log : logs) {\n            int val = log[1] - prev;\n            if (val > resVal || val == resVal && log[0] < res) resVal = val, res = log[0];\n            prev = log[1];\n        }\n        return res;\n    }\n};","date":"2023-05-05"},{"script":"python","time":368,"memory":16.2,"desc":"同上。","code":"class Solution:\n    def hardestWorker(self, n: int, logs: List[List[int]]) -> int:\n        prev = 0\n        resVal = 0\n        res = 0\n        for log in logs:\n            val = log[1] - prev\n            if val > resVal or val == resVal and log[0] < res:\n                resVal = val\n                res = log[0]\n            prev = log[1]\n        return res","date":"2023-05-05"},{"script":"rust","time":8,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn hardest_worker(n: i32, logs: Vec<Vec<i32>>) -> i32 {\n        let mut prev = 0;\n        let mut resVal = 0;\n        let mut res = 0;\n        for log in logs {\n            let val = log[1] - prev;\n            if val > resVal || val == resVal && log[0] < res {\n                resVal = val;\n                res = log[0];\n            }\n            prev = log[1];\n        }\n        res\n    }\n}","date":"2023-05-05"}],"tagList":["数组"],"level":"Easy"}},{"problemName":"2437.有效时间的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2437.有效时间的数目.json","problemData":{"id":"2528","name":"2437.有效时间的数目","url":"https://leetcode.cn/problems/number-of-valid-clock-times","desc":"请你返回一个整数 answer ，将每一个 ? 都用 0 到 9 中一个数字替换后，可以得到的有效时间的数目。","solutions":[{"script":"cpp","time":0,"memory":5.9,"desc":"枚举。","code":"class Solution {\npublic:\n    int countTime(string time) {\n        vector<int> idxs;\n        for (int i = 0; i < time.size(); i++) {\n            if (time[i] == '?') idxs.push_back(i);\n        }\n        int res = 0;\n        if (idxs.empty()) {\n            return check(time) ? 1 : 0;\n        }\n        function<void(int, string)> dfs = [&](int idx, string time) {\n            if (idx == idxs.size()) {\n                if (check(time)) res++;\n                return;\n            }\n            for (int i = 0; i <= 9; i++) {\n                time[idxs[idx]] = i + '0';\n                dfs(idx + 1, time);\n            }\n        };\n        dfs(0, time);\n        return res;\n    }\n    bool check(string &time) {\n        int h = (time[0] - '0') * 10 + (time[1] - '0'), \n            m = (time[3] - '0') * 10 + (time[4] - '0'); \n        if (h >= 24 || m >= 60) return false;\n        return true;\n    }\n};","date":"2023-05-09"},{"script":"python","time":48,"memory":15.9,"desc":"同上。","code":"class Solution:\n    def countTime(self, time: str) -> int:\n        time = list(time)\n        def check(time: str) -> bool:\n            h = (ord(time[0]) - ord('0')) * 10 + ord(time[1]) - ord('0')\n            m = (ord(time[3]) - ord('0')) * 10 + ord(time[4]) - ord('0')\n            return h < 24 and m < 60\n        idxs = []\n        for i in range(len(time)):\n            if time[i] == '?':\n                idxs.append(i)\n        if len(idxs) == 0:\n            return 1 if check(time) else 0\n        res = 0\n\n        def dfs(idx: int, time: List[str]):\n            nonlocal res\n            if idx == len(idxs):\n                if check(time):\n                    res += 1\n            else:\n                for i in range(0, 10):\n                    time[idxs[idx]] = chr(i + ord('0'))\n                    dfs(idx+1, time)\n        dfs(0, time)\n        return res","date":"2023-05-09"},{"script":"rust","time":0,"memory":1.9,"desc":"同上。","code":"fn str_to_vec(s: &String) -> Vec<char> {\n    s.chars().collect()\n}\nimpl Solution {\n    pub fn count_time(time: String) -> i32 {\n        let time = str_to_vec(&time);\n        let mut idxs = vec![];\n        for i in 0..time.len() {\n            if time[i] == '?' {\n                idxs.push(i);\n            }\n        }\n        if idxs.is_empty() {\n            if Solution::check(&time) {\n                1\n            } else {\n                0\n            }\n        } else {\n            let mut res = 0;\n            Solution::dfs(&mut res, &idxs, 0, time);\n            res\n        }\n    }\n    fn check(time: &Vec<char>) -> bool {\n        let h = (time[0] as u8 - b'0') * 10 + (time[1] as u8 - b'0');\n        let m = (time[3] as u8 - b'0') * 10 + (time[4] as u8 - b'0');\n        h < 24 && m < 60\n    }\n    fn dfs(res: &mut i32, idxs: &Vec<usize>, idx: usize, mut time: Vec<char>) {\n        if idx == idxs.len() {\n            if Solution::check(&time) {\n                *res += 1;\n            }\n        } else {\n            for i in 0..10 {\n                time[idxs[idx]] = (i + b'0') as char;\n                Solution::dfs(res, idxs, idx + 1, time.clone());\n            }\n        }\n    }\n}","date":"2023-05-09"}],"tagList":["字符串","枚举"],"level":"Easy"}},{"problemName":"2441.与对应负数同时存在的最大正整数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2441.与对应负数同时存在的最大正整数.json","problemData":{"id":"2524","name":"2441.与对应负数同时存在的最大正整数","url":"https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative","desc":"给你一个 不包含 任何零的整数数组 nums ，找出自身与对应的负数都在数组中存在的最大正整数 k 。返回正整数 k ，如果不存在这样的整数，返回 -1 。","solutions":[{"script":"typescript","time":76,"memory":45.9,"desc":"哈希存储。","code":"function findMaxK(nums: number[]): number {\n    const set1 = new Set<number>();\n    const set2 = new Set<number>();\n    for (const num of nums) {\n        if (set1.has(-num)) set2.add(Math.abs(num));\n        set1.add(num);\n    }\n    return [...set2].sort((a, b) => b - a)[0] ?? -1;\n}","date":"2022-10-16"},{"script":"cpp","time":16,"memory":19.2,"desc":"数组存储。","code":"class Solution {\npublic:\n    int findMaxK(vector<int>& nums) {\n        int list[2005] = {0}, res = -1;\n        for (auto &num : nums) {\n            list[num + 1000] += 1;\n            if (list[-num + 1000]) res = max(res, abs(num));\n        }\n        return res;\n    }\n};","date":"2023-05-13"},{"script":"python","time":76,"memory":16.2,"desc":"同上。","code":"class Solution:\n    def findMaxK(self, nums: List[int]) -> int:\n        list = [0] * 2005\n        res = -1\n        for num in nums:\n            list[num + 1000] += 1\n            if list[-num + 1000]:\n                res = max(res, abs(num))\n        return res","date":"2023-05-13"},{"script":"rust","time":4,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn find_max_k(nums: Vec<i32>) -> i32 {\n        let mut list = [0; 2005];\n        let mut res = -1;\n        for num in nums {\n            list[(num + 1000) as usize] += 1;\n            if list[(-num + 1000) as usize] != 0 {\n                res = res.max(num.abs());\n            }\n        }\n        res\n    }\n}","date":"2023-05-13"}],"tagList":["数组","哈希表","双指针","排序"],"level":"Easy"}},{"problemName":"2446.判断两个事件是否存在冲突.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2446.判断两个事件是否存在冲突.json","problemData":{"id":"2536","name":"2446.判断两个事件是否存在冲突","url":"https://leetcode.cn/problems/determine-if-two-events-have-conflict","desc":"如果两个事件之间存在冲突，返回 true ；否则，返回 false 。","solutions":[{"date":"2022-10-23","time":56,"memory":42.4,"script":"typescript","desc":"化成分钟表示后比较。","code":"function toTime(data: string) {\n  const time = data.split(':').map(v => +v);\n  return time[0] * 60 + time[1];\n}\nfunction haveConflict(event1: string[], event2: string[]): boolean {\n  let [l1, r1] = [toTime(event1[0]), toTime(event1[1])];\n  let [l2, r2] = [toTime(event2[0]), toTime(event2[1])];\n  if (l1 > l2) {\n    [l1, r1, l2, r2] = [l2, r2, l1, r1];\n  }\n  return r1 >= l2;\n}"},{"script":"cpp","time":0,"memory":11.1,"desc":"转换成数字后比大小。","code":"class Solution {\npublic:\n    bool haveConflict(vector<string>& event1, vector<string>& event2) {\n        auto to_time = [&](string t) -> int {\n            return ((t[0] - '0') * 10 + t[1] - '0') * 60 + (t[3] - '0') * 10 + t[4] - '0';\n        };\n        int s1 = to_time(event1[0]), e1 = to_time(event1[1]),\n            s2 = to_time(event2[0]), e2 = to_time(event2[1]);\n        if (s1 > s2) swap(s1, s2), swap(e1, e2);\n        return e1 >= s2;\n    }\n};","date":"2023-05-17"},{"script":"python","time":36,"memory":16.1,"desc":"同上。","code":"class Solution:\n    def haveConflict(self, event1: List[str], event2: List[str]) -> bool:\n        def to_time(t: str):\n            return int(t[:2]) * 60 + int(t[3:])\n        s1, e1 = to_time(event1[0]), to_time(event1[1])\n        s2, e2 = to_time(event2[0]), to_time(event2[1])\n        if s1 > s2:\n            s1, e1, s2, e2 = s2, e2, s1, e1\n        return e1 >= s2","date":"2023-05-17"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn have_conflict(event1: Vec<String>, event2: Vec<String>) -> bool {\n        let to_time =\n            |s: &String| -> i32 { s[0..2].parse::<i32>().unwrap() * 60 + s[3..].parse::<i32>().unwrap() };\n        let (mut s1, mut e1, mut s2, mut e2) = (\n            to_time(&event1[0]),\n            to_time(&event1[1]),\n            to_time(&event2[0]),\n            to_time(&event2[1]),\n        );\n        if s1 > s2 {\n            unsafe {\n                std::ptr::swap(&mut s1, &mut s2);\n                std::ptr::swap(&mut e1, &mut e2);\n            }\n        }\n        e1 >= s2\n    }\n}","date":"2023-05-17"}],"tagList":["数组","字符串"],"level":"Easy"}},{"problemName":"2447.最大公因数等于K的子数组数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2447.最大公因数等于K的子数组数目.json","problemData":{"id":"2546","name":"2447.最大公因数等于K的子数组数目","url":"https://leetcode.cn/problems/number-of-subarrays-with-gcd-equal-to-k","desc":"数组的最大公因数 是能整除数组中所有元素的最大整数。","solutions":[{"date":"2022-10-23","time":88,"memory":42.4,"script":"typescript","desc":"gcd 后暴力。","code":"function gcd(a: number, b: number): number {\n  if (a < b) return gcd(b, a);\n  if (b) return gcd(b, a % b);\n  return a;\n}\nfunction subarrayGCD(nums: number[], k: number): number {\n  let ans = 0;\n  const n = nums.length;\n  for (let i = 0; i < n; i++) {\n    if (nums[i] === k) {\n      ans++;\n    }\n    let num = nums[i];\n    for (let j = i - 1; j >= 0; j--) {\n      num = gcd(nums[j], num);\n      if (num === k) ans++;\n    }\n  }\n  return ans;\n}"}],"tagList":["数组","数学","数论"],"level":"Medium"}},{"problemName":"2448.使数组相等的最小开销.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2448.使数组相等的最小开销.json","problemData":{"id":"2538","name":"2448.使数组相等的最小开销","url":"https://leetcode.cn/problems/minimum-cost-to-make-array-equal","desc":"请你返回使 nums 中所有元素 相等 的 最少 总开销。","solutions":[{"date":"2022-10-23","time":180,"memory":82.3,"script":"cpp","desc":"贪心，最后化为的值一定是 nums 中存在的值，通过按值的大小排序后，结果成凹型，找到最低点即结果。","code":"struct Node {\n    int num, cost;\n    Node(int num, int cost): num(num), cost(cost) {}\n    long long getCost(int num) {\n        return abs(static_cast<long long>(num) - this->num) * cost;\n    }\n};\nclass Solution {\npublic:\n    long long minCost(vector<int>& nums, vector<int>& cost) {\n        int n = nums.size();\n        vector<Node> list;\n        for (int i = 0; i < n; i++) list.push_back(Node(nums[i], cost[i]));\n        sort(list.begin(), list.end(), [](Node &a, Node &b){ return a.num < b.num; });\n        int l = 0, r = n - 1;\n        long long ans = 0;\n        while (l < r) {\n            int m1 = (l + r) / 2, m2 = m1 + 1;\n            long long m1cost = comp(list, list[m1].num), m2cost = comp(list, list[m2].num);\n            if (m1cost >= m2cost) l = m2, ans = m2cost;\n            else r = m1, ans = m1cost;\n        }\n        return ans;\n    }\n    long long comp(vector<Node> &list, int num) {\n        long long ans = 0;\n        for (int i = 0; i < list.size(); i++) {\n            ans += list[i].getCost(num);\n        }\n        return ans;\n    }\n};"}],"tagList":["贪心","数组","二分查找","前缀和","排序"],"level":"Hard"}},{"problemName":"2451.差值数组不同的字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2451.差值数组不同的字符串.json","problemData":{"id":"2547","name":"2451.差值数组不同的字符串","url":"https://leetcode.cn/problems/odd-string-difference","desc":"给你一个字符串数组 words ，每一个字符串长度都相同，令所有字符串的长度都为 n 。","solutions":[{"script":"cpp","time":4,"memory":7.4,"desc":"哈希存储。","code":"class Solution {\npublic:\n    string oddString(vector<string>& words) {\n        unordered_map<string, vector<string>> m;\n        for (auto &w : words) {\n            string key = \"\";            \n            for (int i = 0; i < w.size() - 1; i++) key += to_string(w[i + 1] - w[i] + '0');\n            m[key].push_back(w);\n        }\n        for (auto &item : m) {\n            if (item.second.size() == 1) return item.second[0];\n        }\n        return words[0];\n    }\n};","date":"2023-05-25"},{"script":"python","time":48,"memory":15.9,"desc":"同上。","code":"class Solution:\n    def oddString(self, words: List[str]) -> str:\n        m = dict()\n        for w in words:\n            key = \"\"\n            for i in range(len(w) - 1):\n                key += chr(ord(w[i + 1]) - ord(w[i]) + ord('0'))\n            if not key in m: m[key] = []\n            m[key].append(w)\n        for v in m.values():\n            if len(v) == 1:\n                return v[0]\n        return words[0]","date":"2023-05-25"},{"script":"rust","time":0,"memory":2.1,"desc":"同上。","code":"pub fn str_to_vec(s: &String) -> Vec<char> {\n    s.chars().collect()\n}\nimpl Solution {\n    pub fn odd_string(words: Vec<String>) -> String {\n        let mut m = std::collections::HashMap::<String, Vec<String>>::new();\n        for w in words {\n            let mut key = String::new();\n            {\n                let w: Vec<char> = str_to_vec(&w);\n                for i in 0..w.len() - 1 {\n                    key.push((w[i + 1] as u8 - w[i] as u8 + b'0') as char);\n                }\n            }\n            m.entry(key).or_insert(vec![]).push(w);\n        }\n        for (_, list) in m.into_iter() {\n            if list.len() == 1 {\n                return list[0].clone();\n            }\n        }\n        String::new()\n    }\n}","date":"2023-05-25"}],"tagList":["数组","哈希表","字符串"],"level":"Easy"}},{"problemName":"2455.可被三整除的偶数的平均值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2455.可被三整除的偶数的平均值.json","problemData":{"id":"2542","name":"2455.可被三整除的偶数的平均值","url":"https://leetcode.cn/problems/average-value-of-even-numbers-that-are-divisible-by-three","desc":"给你一个由正整数组成的整数数组 nums ，返回其中可被 3 整除的所有偶数的平均值。","solutions":[{"script":"cpp","time":8,"memory":13.3,"desc":"遍历。","code":"class Solution {\npublic:\n    int averageValue(vector<int>& nums) {\n        int sum = 0, cnt = 0;\n        for (auto &num : nums) {\n            if (num % 6 == 0) sum += num, cnt++;\n        }\n        return cnt ? sum / cnt : 0;\n    }\n};","date":"2023-05-29"},{"script":"python","time":84,"memory":15.9,"desc":"同上。","code":"class Solution:\n    def averageValue(self, nums: List[int]) -> int:\n        sum = cnt = 0\n        for num in nums:\n            if num % 6 == 0:\n                sum += num\n                cnt += 1\n        return 0 if not cnt else sum // cnt","date":"2023-05-29"},{"script":"rust","time":0,"memory":2.1,"desc":"同上。","code":"impl Solution {\n    pub fn average_value(nums: Vec<i32>) -> i32 {\n        let (mut sum, mut cnt) = (0, 0);\n        for num in nums {\n            if num % 6 == 0 {\n                sum += num;\n                cnt += 1;\n            }\n        }\n        if cnt == 0 {\n            0\n        } else {\n            sum / cnt\n        }\n    }\n}","date":"2023-05-29"}],"tagList":["数组","数学"],"level":"Easy"}},{"problemName":"2456.最流行的视频创作者.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2456.最流行的视频创作者.json","problemData":{"id":"2543","name":"2456.最流行的视频创作者","url":"https://leetcode.cn/problems/most-popular-video-creator","desc":"给你一个由正整数组成的整数数组 nums ，返回其中可被 3 整除的所有偶数的平均值。","solutions":[{"date":"2022-10-30","time":8,"memory":13.3,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    int averageValue(vector<int>& nums) {\n        int sum = 0, cnt = 0;\n        for (auto &num : nums) {\n            if (num % 3 == 0 && num % 2 == 0) {\n                sum += num;\n                cnt += 1;\n            }\n        }\n        return cnt == 0 ? 0 : sum / cnt;\n    }\n};"}],"tagList":["数组","哈希表","字符串","排序","堆（优先队列）"],"level":"Medium"}},{"problemName":"2457.美丽整数的最小增量.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2457.美丽整数的最小增量.json","problemData":{"id":"2544","name":"2457.美丽整数的最小增量","url":"https://leetcode.cn/problems/minimum-addition-to-make-integer-beautiful","desc":"返回一个二维字符串数组 answer ，其中 answer[i] = [creatori, idi] 表示 creatori 的流行度 最高 且其最流行的视频 id 是 idi ，可以按任何顺序返回该结果。","solutions":[{"date":"2022-10-30","time":724,"memory":240.8,"script":"cpp","desc":"暴力枚举，通过 map 排序。","code":"struct MyData {\n    long long sum;\n    int nmax;\n    string name, smax;\n    map<string, int> m;\n    MyData() {};\n    MyData(string name): name(name), sum(0), nmax(0), smax(\"\"){}\n    void setMap(string id, int view) {\n        if (nmax < view || nmax == view && (smax == \"\" || smax > id)) {\n            nmax = view;\n            smax = id;\n        }\n        sum += view;\n        m[id] = view;\n    }\n};\nclass Solution {\npublic:\n    vector<vector<string>> mostPopularCreator(vector<string>& creators, vector<string>& ids, vector<int>& views) {\n        int n = creators.size();\n        map<string, MyData> m;\n        vector<vector<string>> ans;\n        for (int i = 0; i < n; i++) {\n            if (!m.count(creators[i])) m[creators[i]] = MyData(creators[i]);\n            m[creators[i]].setMap(ids[i], views[i]);\n        }\n        int maxsum = m.begin()->second.sum;\n        for (auto &item : m) {\n            if (item.second.sum > maxsum) ans.clear(), maxsum = item.second.sum;\n            if (item.second.sum < maxsum) continue;\n            vector<string> data(2);\n            data[0] = item.first;\n            data[1] = item.second.smax;\n            ans.push_back(move(data));\n        }\n        return ans;\n    }\n};"}],"tagList":["贪心","数学"],"level":"Medium"}},{"problemName":"2458.移除子树后的二叉树高度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2458.移除子树后的二叉树高度.json","problemData":{"id":"2545","name":"2458.移除子树后的二叉树高度","url":"https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries","desc":"返回一个长度为 m 的数组 answer ，其中 answer[i] 是执行第 i 个查询后树的高度。","solutions":[{"date":"2022-10-30","time":368,"memory":222.5,"script":"cpp","desc":"两次 dfs，第一次统计出每颗子树的高度，第二次记录层高，统计当前子树被移除后的剩余高度，通过最大高度和 level+右子树高度的最大值获取。","code":"class Solution {\npublic:\n    typedef pair<int, int> node;\n    unordered_map<int, node> m;\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\n        m[-1] = make_pair(0, 0);\n        dfs1(root);\n        dfs2(root);\n        vector<int> ans;\n        for (auto &q : queries) ans.push_back(m[q].second);\n        return ans;\n    }\n    int dfs1(TreeNode *node) {\n        if (node == nullptr) return 0;\n        int l = dfs1(node->left), r = dfs1(node->right), h = max(l, r) + 1;\n        m[node->val] = make_pair(h, 0);\n        return h;\n    }\n    void dfs2(TreeNode *node, int level = 0, int curH = 0) {\n        if (node == nullptr) return;\n        m[node->val].second = curH;\n        int l = node->left == nullptr ? -1 : node->left->val,\n            r = node->right == nullptr ? -1 : node->right->val;\n        dfs2(node->left, level + 1, max(curH, level + m[r].first));\n        dfs2(node->right, level + 1, max(curH, level + m[l].first));\n    }\n};"}],"tagList":["树","深度优先搜索","广度优先搜索","数组","二叉树"],"level":"Hard"}},{"problemName":"2460.对数组执行操作.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2460.对数组执行操作.json","problemData":{"id":"2551","name":"2460.对数组执行操作","url":"https://leetcode.cn/problems/apply-operations-to-an-array","desc":"给你一个下标从 0 开始的数组 nums ，数组大小为 n ，且由 非负 整数组成。返回结果数组。","solutions":[{"date":"2022-11-06","time":4,"memory":8.5,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    vector<int> applyOperations(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> list(n, 0);\n        int idx = 0;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] == 0) continue;\n            if (i == n - 1) {\n                list[idx++] = nums[i];\n            } else {\n                if (nums[i] == nums[i + 1]) {\n                    list[idx++] = nums[i] * 2;\n                    nums[i + 1] = 0;\n                } else {\n                    list[idx++] = nums[i];\n                }\n            }\n        }\n        return list;\n    }\n};"},{"script":"cpp","time":0,"memory":8.6,"desc":"遍历。","code":"class Solution {\npublic:\n    vector<int> applyOperations(vector<int>& nums) {\n        int n = nums.size(), start = 0;\n        for (int i = 0; i < n - 1; i++) {\n            if (nums[i] == nums[i + 1]) {\n                nums[i] *= 2;\n                nums[i + 1] = 0;\n            }\n            if (nums[i] != 0) nums[start++] = nums[i];\n        }\n        if (nums[n - 1]) nums[start++] = nums[n - 1];\n        while (start < n) nums[start++] = 0;\n        return nums;\n    }\n};","date":"2023-06-05"}],"tagList":["数组","双指针","模拟"],"level":"Easy"}},{"problemName":"2461.长度为K子数组中的最大和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2461.长度为K子数组中的最大和.json","problemData":{"id":"2552","name":"2461.长度为K子数组中的最大和","url":"https://leetcode.cn/problems/maximum-sum-of-distinct-subarrays-with-length-k","desc":"返回满足题面要求的最大子数组和。如果不存在子数组满足这些条件，返回 0 。","solutions":[{"date":"2022-11-06","time":192,"memory":90.8,"script":"cpp","desc":"滑动窗口遍历。","code":"class Solution {\npublic:\n    long long maximumSubarraySum(vector<int>& nums, int k) {\n        long long sum = 0, ans = 0;\n        int l = 0, r = 0, n = nums.size();\n        int cnt = 0;\n        unordered_map<int, int> m;\n        while (r < k) {\n            m[nums[r]]++;\n            sum += nums[r];\n            if (m[nums[r]] == 2) cnt++;\n            r++;\n        }\n        if (cnt == 0) ans = sum;\n        // cout << \"l = \" << l << \", r = \" << r << endl;\n        // cout << \"sum = \" << sum << \", cnt = \" << cnt << endl;\n        while (r < n) {\n            sum -= nums[l];\n            m[nums[l]]--;\n            if (m[nums[l]] == 1) cnt--;\n            l++;\n\n            sum += nums[r];\n            m[nums[r]]++;\n            if (m[nums[r]] == 2) cnt++;\n            r++;\n\n            // cout << \"l = \" << l << \", r = \" << r << endl;\n            if (cnt == 0) ans = max(ans, sum);\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","滑动窗口"],"level":"Medium"}},{"problemName":"2462.雇佣K位工人的总代价.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2462.雇佣K位工人的总代价.json","problemData":{"id":"2553","name":"2462.雇佣K位工人的总代价","url":"https://leetcode.cn/problems/total-cost-to-hire-k-workers","desc":"返回雇佣恰好 k 位工人的总代价。","solutions":[{"date":"2022-11-06","time":136,"memory":75.2,"script":"cpp","desc":"优先队列。","code":"class Solution {\npublic:\n    long long totalCost(vector<int>& costs, int k, int candidates) {\n        int n = costs.size();\n        int lmax = candidates, rmax = n - 1 - candidates;\n        priority_queue<int, vector<int>, greater<int>> ql, qr, qa;\n        for (int i = 0; i < candidates; i++) {\n            ql.push(costs[i]);\n            qr.push(costs[n - 1 - i]);\n        }\n        if (lmax > rmax) {\n            for (int i = 0; i < n; i++) {\n                qa.push(costs[i]);\n            }\n        }\n        long long sum = 0;\n        for (int i = 0; i < k; i++) {\n            // cout << \"i = \" << i << endl;\n            if (lmax > rmax) {\n                sum += qa.top();\n                qa.pop();\n            } else {\n                // cout << \"lmax = \" << lmax << \", rmax = \" << rmax << endl;\n                if (ql.top() <= qr.top()) {\n                    sum += ql.top();\n                    ql.pop();\n                    ql.push(costs[lmax]);\n                    lmax++;\n                } else {\n                    sum += qr.top();\n                    qr.pop();\n                    qr.push(costs[rmax]);\n                    rmax--;\n                }\n                if (lmax > rmax) {\n                    while (ql.size()) {\n                        qa.push(ql.top());\n                        ql.pop();\n                    }\n                    while (qr.size()) {\n                        qa.push(qr.top());\n                        qr.pop();\n                    }\n                }\n                // cout << \"lmax = \" << lmax << \", rmax = \" << rmax << endl;\n            }\n        }\n\n        return sum;\n    }\n};"},{"script":"python","time":305,"memory":32.84,"desc":"优先队列。","code":"class Solution:\n    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:\n        n = len(costs)\n        q = []\n        for i in range(candidates): \n            heappush(q, (costs[i], i))\n            if n - 1 - i >= candidates:\n                heappush(q, (costs[n - 1 - i], n - 1 - i))\n        l = candidates\n        r = n - 1 - candidates\n        res = 0\n        while k:\n            picked, picked_index = heappop(q)\n            res += picked\n            if l <= r:\n                if picked_index < l:\n                    heappush(q, (costs[l], l))\n                    l += 1\n                else:\n                    heappush(q, (costs[r], r))\n                    r -= 1\n            k -= 1\n        return res","date":"2024-05-01"}],"tagList":["数组","双指针","模拟","堆（优先队列）"],"level":"Medium"}},{"problemName":"2463.最小移动总距离.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2463.最小移动总距离.json","problemData":{"id":"2554","name":"2463.最小移动总距离","url":"https://leetcode.cn/problems/minimum-total-distance-traveled","desc":"请你返回所有机器人移动的最小总距离。测试数据保证所有机器人都可以被维修。","solutions":[{"date":"2022-11-10","time":40,"memory":8.2,"script":"cpp","desc":"dp[i][j] = 当只有 i 个工厂，j 个机器人时的最小移动距离。","code":"class Solution {\npublic:\n    const int MAX = 105;\n    long long minimumTotalDistance(vector<int>& robot, vector<vector<int>>& factory) {\n        sort(robot.begin(), robot.end());\n        sort(factory.begin(), factory.end(), [](auto &a, auto &b){ return a[0] < b[0]; });\n        int n = factory.size(), m = robot.size();\n        // dp[i][j] = 当只有i个工厂，j个机器人时的最小移动距离\n        long long dp[MAX][MAX];\n        memset(dp, 0x3f, sizeof(long long) * MAX * MAX);\n        for (int i = 0; i <= n; i++) dp[i][0] = 0;\n        for (int i = 1; i <= n; i++) {\n            auto &f = factory[i - 1];\n            for (int j = 1; j <= m; j++) {\n                // 当前工厂不做操作的时候 等于 前一个工厂\n                dp[i][j] = dp[i - 1][j];\n                long long sum = 0;\n                for (int k = j; k >= max(1, j - f[1] + 1); k--) {\n                    sum += abs(robot[k - 1] - f[0]);\n                    dp[i][j] = min(dp[i][j], sum + dp[i - 1][k - 1]);\n                }\n                // for (int k = 1; k <= min(j, f[1]); k++) {\n                //     sum += abs(robot[j - k] - f[0]);\n                //     dp[i][j] = min(dp[i][j], sum + dp[i - 1][j - k]);\n                // }\n            }\n        }\n        return dp[n][m];\n    }\n};"}],"tagList":["数组","动态规划","排序"],"level":"Hard"}},{"problemName":"2465.不同的平均值数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2465.不同的平均值数目.json","problemData":{"id":"2561","name":"2465.不同的平均值数目","url":"https://leetcode.cn/problems/number-of-distinct-averages","desc":"给你一个下标从 0 开始长度为 偶数 的整数数组 nums 。返回上述过程能得到的 不同 平均值的数目。","solutions":[{"script":"cpp","time":0,"memory":6.8,"desc":"排序后双指针遍历。","code":"class Solution {\npublic:\n    int distinctAverages(vector<int>& nums) {\n        unordered_set<double> s;\n        sort(nums.begin(), nums.end());\n        int l = 0, r = nums.size() - 1;\n        while (l < r) s.insert((nums[l++] + nums[r--]) * 1.0 / 2);\n        return s.size();\n    }\n};","date":"2023-06-05"}],"tagList":["数组","哈希表","双指针","排序"],"level":"Easy"}},{"problemName":"2469.温度转换.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2469.温度转换.json","problemData":{"id":"2556","name":"2469.温度转换","url":"https://leetcode.cn/problems/convert-the-temperature","desc":"返回数组 ans 。与实际答案误差不超过 10-5 的会视为正确答案。","solutions":[{"date":"2022-11-13","time":0,"memory":5.9,"script":"cpp","desc":"直接计算。","code":"class Solution {\npublic:\n    vector<double> convertTemperature(double celsius) {\n        vector<double> ans(2);\n        ans[0] = celsius + 273.15;\n        ans[1] = celsius * 1.80 + 32.00;\n        return ans;\n    }\n};"},{"script":"cpp","time":0,"memory":5.9,"desc":"直接计算。","code":"class Solution {\npublic:\n    vector<double> convertTemperature(double celsius) {\n        return vector<double>{ celsius + 273.15, celsius * 1.80 + 32.00 };\n    }\n};","date":"2023-03-21"},{"script":"python","time":32,"memory":14.8,"desc":"同上。","code":"class Solution:\n    def convertTemperature(self, celsius: float) -> List[float]:\n        return [celsius + 273.15, celsius * 1.80 + 32.00]","date":"2023-03-21"},{"script":"rust","time":0,"memory":1.9,"desc":"同上。","code":"impl Solution {\n    pub fn convert_temperature(celsius: f64) -> Vec<f64> {\n        vec![celsius + 273.15, celsius * 1.80 + 32.00]\n    }\n}","date":"2023-03-21"}],"tagList":["数学"],"level":"Easy"}},{"problemName":"2470.最小公倍数为K的子数组数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2470.最小公倍数为K的子数组数目.json","problemData":{"id":"2557","name":"2470.最小公倍数为K的子数组数目","url":"https://leetcode.cn/problems/number-of-subarrays-with-lcm-equal-to-k","desc":"给你一个整数数组 nums 和一个整数 k ，请你统计并返回 nums 的 子数组 中满足 元素最小公倍数为 k 的子数组数目。","solutions":[{"date":"2022-11-13","time":20,"memory":9,"script":"cpp","desc":"遍历，对每个子数组找最小公倍数。","code":"class Solution {\npublic:\n    int gcd(int a, int b) {\n        if (b == 0) return a;\n        return gcd(b, a % b);\n    }\n    int subarrayLCM(vector<int>& nums, int k) {\n        int n = nums.size(), ans = 0;\n        for (int i = 0; i < n; i++) {\n            int cur_gcd = nums[i], num = nums[i];\n            for (int j = i; j < n; j++) {\n                num = num * nums[j] / gcd(num, nums[j]);\n                if (num == k) ans++;\n                if (num > k) break;\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","数学","数论"],"level":"Medium"}},{"problemName":"2471.逐层排序二叉树所需的最少操作数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2471.逐层排序二叉树所需的最少操作数目.json","problemData":{"id":"2558","name":"2471.逐层排序二叉树所需的最少操作数目","url":"https://leetcode.cn/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level","desc":"返回每一层按 严格递增顺序 排序所需的最少操作数目。","solutions":[{"date":"2022-11-13","time":324,"memory":144.3,"script":"cpp","desc":"bfs 后遍历每行统计次数。","code":"int m[100005] = {0};\nclass Solution {\npublic:\n    set<int> s;\n    vector<int> list;\n    int minimumOperations(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int size = 1, ans = 0;\n        while (q.size()) {\n            TreeNode *node = q.front();\n            q.pop();\n            if (node->left) {\n                q.push(node->left);\n                int val = node->left->val;\n                m[val] = list.size();\n                list.push_back(val);\n                s.insert(val);\n            }\n            if (node->right) {\n                q.push(node->right);\n                int val = node->right->val;\n                m[val] = list.size();\n                list.push_back(val);\n                s.insert(val);\n            }\n            if (--size == 0) {\n                ans += check();\n                list.clear();\n                s.clear();\n                size = q.size();\n            }\n        }\n        return ans;\n    }\n    int check() {\n        if (list.empty()) return 0;\n        int cnt = 0, idx = 0;\n        for (auto &num : s) {\n            if (list[idx] != num) {\n                cnt++;\n                int next = m[num];\n                swap(list[idx], list[next]);\n                m[list[next]] = next;\n                m[num] = idx;\n            }\n            idx++;\n        }\n        return cnt;\n    }\n};"}],"tagList":["树","广度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"2472.不重叠回文子字符串的最大数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2472.不重叠回文子字符串的最大数目.json","problemData":{"id":"2559","name":"2472.不重叠回文子字符串的最大数目","url":"https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings","desc":"返回最优方案中能选择的子字符串的 最大 数目。","solutions":[{"date":"2022-11-13","time":44,"memory":6.6,"script":"cpp","desc":"dp[i]表示存在 i 个字符的时候最大回文个数。","code":"class Solution {\npublic:\n    string s;\n    int n;\n    int maxPalindromes(string s, int k) {\n        this->s = s;\n        n = s.size();\n        vector<int> dp(n + 1, 0);\n        for (int i = 0; i < n; i++) {\n            check(dp, k, i, i);\n            check(dp, k, i, i + 1);\n        }\n        return dp[n];\n    }\n    void check(vector<int> &dp, int k, int l, int r) {\n        dp[l + 1] = max(dp[l + 1], dp[l]);\n        for (; l >= 0 && r < n && s[l] == s[r]; l--, r++) {\n            if (r - l + 1 >= k) dp[r + 1] = max(dp[r + 1], dp[l] + 1);\n        }\n    }\n};"},{"date":"2022-11-13","time":40,"memory":6.5,"script":"cpp","desc":"方便获取 l 和 r。","code":"class Solution {\npublic:\n    int maxPalindromes(string s, int k) {\n        int n = s.size();\n        vector<int> dp(n + 1, 0);\n        for (int i = 0; i < 2 * n - 1; i++) {\n            int l = i / 2, r = l + i % 2;\n            dp[l + 1] = max(dp[l + 1], dp[l]);\n            for (; l >= 0 && r < n && s[l] == s[r]; l--, r++) {\n                if (r - l + 1 >= k) dp[r + 1] = max(dp[r + 1], dp[l] + 1);\n            }\n        }\n        return dp[n];\n    }\n};"}],"tagList":["字符串","动态规划"],"level":"Hard"}},{"problemName":"2475.数组中不等三元组的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2475.数组中不等三元组的数目.json","problemData":{"id":"2566","name":"2475.数组中不等三元组的数目","url":"https://leetcode.cn/problems/number-of-unequal-triplets-in-array","desc":"返回满足上述条件三元组的数目。","solutions":[{"date":"2022-11-20","time":344,"memory":8.4,"script":"cpp","desc":"暴力。","code":"class Solution {\npublic:\n    int unequalTriplets(vector<int>& nums) {\n        map<int, int> m;\n        for (auto &num : nums) m[num]++;\n        vector<int> list;\n        for (auto &item : m) list.push_back(item.first);\n        int ans = 0;\n        for (int i = 0; i < list.size(); i++) {\n            for (int j = i + 1; j < list.size(); j++) {\n                for (int k = j + 1; k < list.size(); k++) {\n                    ans += m[list[i]] * m[list[j]] * m[list[k]];\n                }\n            }\n        }\n        return ans;\n    }\n};"},{"date":"2022-11-20","time":4,"memory":8.3,"script":"cpp","desc":"对于每一组相同的数，判断比他小的有几个数，比他大的有几个数。","code":"class Solution {\npublic:\n    int unequalTriplets(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int ans = 0, prev = 0;\n        for (int i = 0; i < nums.size() - 1; i++) {\n            if (nums[i] == nums[i + 1]) continue;\n            ans += prev * (i - prev + 1) * (nums.size() - i - 1);\n            prev = i + 1;\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","排序"],"level":"Easy"}},{"problemName":"2476.二叉搜索树最近节点查询.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2476.二叉搜索树最近节点查询.json","problemData":{"id":"2567","name":"2476.二叉搜索树最近节点查询","url":"https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree","desc":"给你一个 二叉搜索树 的根节点 root ，和一个由正整数组成、长度为 n 的数组 queries 。","solutions":[{"date":"2022-11-20","time":308,"memory":150.5,"script":"cpp","desc":"bs。","code":"// bestlyg\n# define X first\n# define Y second\n# define lb(x) ((x) & (-x))\n# define mem(a,b) memset(a,b,sizeof(a))\n# define debug freopen(\"r.txt\",\"r\",stdin)\n# define pi pair<int,int>\n\n#ifdef DEBUG\n#define log(frm, args...) {    printf(frm, ##args);}\n#else\n#define log(frm, args...)\n#endif\n\ntypedef long long ll;\n\nusing namespace std;\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> list;\n    vector<vector<int>> ans;\n    vector<vector<int>> closestNodes(TreeNode* root, vector<int>& queries) {\n        dfs(root);\n        for (auto &q : queries) {\n            vector<int> item(2);\n            item[0] = find1(q);\n            item[1] = find2(q);\n            ans.push_back(item);\n        }\n        return ans;\n    }\n    void dfs(TreeNode *node) {\n        if (!node) return;\n        dfs(node->left);\n        list.push_back(node->val);\n        dfs(node->right);\n    }\n    int find1(int q) {\n        int l = -1, r = list.size() - 1, m;\n        while (l < r) {\n            m = (l + r + 1) / 2;\n            if (list[m] > q) r = m - 1;\n            else l = m;\n        }\n        if (l == -1) return l;\n        return list[l];\n    }\n\n    int find2(int q) {\n        int l = 0, r = list.size(), m;\n        while (l < r) {\n            m = (l + r) / 2;\n            if (list[m] >= q) r = m;\n            else l = m + 1;\n        }\n        if (l == list.size()) return -1;\n        return list[l];\n    }\n};"},{"script":"python","time":582,"memory":74.37,"desc":"dfs后排序处理queries。","code":"class Solution:\n    def closestNodes(self, root: Optional[TreeNode], queries: List[int]) -> List[List[int]]:\n        arr = []\n        def inorder(node: Optional[TreeNode]):\n            if not node: return\n            inorder(node.left)\n            arr.append(node.val)\n            inorder(node.right)\n        inorder(root)\n        idx = 0\n        ans = [[] for _ in range(len(queries))]\n        queries = sorted((q, i) for i, q in enumerate(queries))\n        for q, i in queries:\n            while idx < len(arr) and arr[idx] < q:\n                idx += 1\n            ans[i] = [-1, -1]\n            if idx < len(arr) and arr[idx] == q:\n                ans[i] = [q, q]\n            else:\n                if idx > 0: ans[i][0] = arr[idx - 1]\n                if idx < len(arr): ans[i][1] = arr[idx]\n        return ans","date":"2024-02-24"}],"tagList":["树","深度优先搜索","二叉搜索树","数组","二分查找","二叉树"],"level":"Medium"}},{"problemName":"2477.到达首都的最少油耗.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2477.到达首都的最少油耗.json","problemData":{"id":"2568","name":"2477.到达首都的最少油耗","url":"https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital","desc":"请你返回到达首都最少需要多少升汽油。","solutions":[{"date":"2022-11-20","time":796,"memory":256.5,"script":"cpp","desc":"递归，从外向里遍历。","code":"// bestlyg\n# define X first\n# define Y second\n# define lb(x) ((x) & (-x))\n# define mem(a,b) memset(a,b,sizeof(a))\n# define debug freopen(\"r.txt\",\"r\",stdin)\n# define pi pair<int,int>\n\n#ifdef DEBUG\n#define log(frm, args...) {    printf(frm, ##args);}\n#else\n#define log(frm, args...)\n#endif\n\ntypedef long long ll;\n\nusing namespace std;\n\nstruct City {\n    int len, idx, size;\n    unordered_set<int> next;\n    City(): len(0), idx(0), size(1) {}\n};\nclass Solution {\npublic:\n    vector<City> list;\n    vector<int> idxlist;\n    long long minimumFuelCost(vector<vector<int>>& roads, int seats) {\n        int n = roads.size() + 1;\n        if (n == 1) return 0;\n        list = vector<City>(n);\n        idxlist = vector<int>(n);\n        for (int i = 0; i < n; i++) {\n            list[i].idx = i;\n            idxlist[i] = i;\n        }\n        for (auto &road : roads) {\n            list[road[0]].next.insert(road[1]);\n            list[road[1]].next.insert(road[0]);\n        }\n        initLen();\n        // for (int i = 0; i < n; i++) {\n        //     cout << \"i = \" << i\n        //          << \", len = \" << list[i].len\n        //          << \", idx = \" << list[i].idx\n        //          << \", next = \";\n        //     for (auto &next : list[i].next) {\n        //         cout << next << \", \";\n        //     }\n        //     cout << endl;\n        // }\n        sort(idxlist.begin(), idxlist.end(), [&](auto &a, auto &b){\n            return list[a].len < list[b].len;\n        });\n        // cout << \"-====\" << endl;\n        long long ans = 0;\n        for (int idx = n - 1; idx > 0; idx--) {\n            int i = idxlist[idx];\n            ans += 1 + (list[i].size - 1) / seats;\n            int next = *list[i].next.begin();\n            list[next].size += list[i].size;\n            list[next].next.erase(i);\n            // cout << \"i = \" << i\n            //      << \", idx = \" << list[i].idx\n            //      << \", next = \" << list[next].idx\n            //      << \", cursize = \" << list[i].size\n            //      << \", nextsize = \" << list[next].size\n            //      << endl;\n        }\n        return ans;\n    }\n    void initLen() {\n        queue<int> q;\n        q.push(0);\n        int size = 1, cur = 1;\n        while (q.size()) {\n            int node = q.front();\n            q.pop();\n            for (auto &next : list[node].next) {\n                if (next == 0 || list[next].len != 0) continue;\n                list[next].len = cur;\n                q.push(next);\n            }\n            if (--size == 0) {\n                size = q.size();\n                cur++;\n            }\n        }\n    }\n};"},{"script":"python","time":352,"memory":52.7,"desc":"贪心，每次批量运送。","code":"class Solution:\n    def minimumFuelCost(self, roads: List[List[int]], seats: int) -> int:\n        n = len(roads) + 1\n        counts = [1] * n\n        nodes = [[] for _ in range(n)]\n        for n1, n2 in roads:\n            nodes[n1].append(n2)\n            nodes[n2].append(n1)\n        q = deque()\n        for i in range(1, n):\n            if len(nodes[i]) == 1:\n                q.append(i)\n        ans = 0\n        while q:\n            idx = q.popleft()\n            if len(nodes[idx]) == 1:\n                ans += ceil(counts[idx] / seats)\n                next_idx = nodes[idx][0]\n                nodes[next_idx].remove(idx)\n                counts[next_idx] += counts[idx]\n                if next_idx != 0 and len(nodes[next_idx]) == 1:\n                    q.append(next_idx)\n        return ans","date":"2023-12-05"}],"tagList":["树","深度优先搜索","广度优先搜索","图"],"level":"Medium"}},{"problemName":"2478.完美分割的方案数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2478.完美分割的方案数.json","problemData":{"id":"2569","name":"2478.完美分割的方案数","url":"https://leetcode.cn/problems/number-of-beautiful-partitions","desc":"给你一个字符串 s ，每个字符是数字 '1' 到 '9' ，再给你两个整数 k 和 minLength 。请你返回 s 的 完美 分割数目。由于答案可能很大，请返回答案对 109 + 7 取余 后的结果。","solutions":[{"date":"2022-11-20","time":32,"memory":30.4,"script":"cpp","desc":"dp[i][j]表示总共分成 i 组总共字符有 j 个的合理方案数。","code":"class Solution {\npublic:\n    string s;\n    int n;\n    const int mod = 1e9 + 7;\n    bool isPrime(int i) {\n        return s[i] == '2' || s[i] == '3' || s[i] == '5' || s[i] == '7';\n    }\n    bool canPart(int i) {\n        return i == 0 || i == n || !isPrime(i - 1) && isPrime(i);\n    }\n    int beautifulPartitions(string s, int k, int minLength) {\n        this->s = s;\n        n = s.size();\n        if (!isPrime(0) || isPrime(n - 1) || k * minLength > n) return false;\n        vector<vector<int>> dp(k + 1, vector<int>(n + 1, 0));\n        dp[0][0] = 1;\n        for (int i = 1; i <= k; i++) {\n            int sum = 0;\n            for (int j = i * minLength; j + (k - i) * minLength <= n; j++) {\n                if (canPart(j - minLength)) sum = (sum + dp[i - 1][j - minLength]) % mod;\n                if (canPart(j)) dp[i][j] = sum;\n            }\n        }\n        return dp[k][n];\n    }\n};"}],"tagList":["字符串","动态规划"],"level":"Hard"}},{"problemName":"2481.分割圆的最少切割次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2481.分割圆的最少切割次数.json","problemData":{"id":"2575","name":"2481.分割圆的最少切割次数","url":"https://leetcode.cn/problems/minimum-cuts-to-divide-a-circle","desc":"给你一个整数 n ，请你返回将圆切割成相等的 n 等分的 最少 切割次数。","solutions":[{"script":"cpp","time":4,"memory":5.9,"desc":"奇数的只能按照中心点分，偶数能按照两端分。","code":"class Solution {\npublic:\n    int numberOfCuts(int n) {\n        if (n == 1) return 0;\n        if (n % 2 == 0) return n / 2;\n        return n;\n    }\n};","date":"2023-06-17"}],"tagList":["几何","数学"],"level":"Easy"}},{"problemName":"2485.找出中枢整数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2485.找出中枢整数.json","problemData":{"id":"2571","name":"2485.找出中枢整数","url":"https://leetcode.cn/problems/find-the-pivot-integer","desc":"返回中枢整数 x 。","solutions":[{"script":"cpp","time":0,"memory":5.8,"desc":"遍历。","code":"class Solution {\n                public:\n                    int pivotInteger(int n) {\n                        int sum = (1 + n) * n / 2;\n                        int prev_sum = 0;\n                        for (int i = 1; i <=n ; i++) {\n                            int next_sum = sum - prev_sum;\n                            prev_sum += i;\n                            if (prev_sum == next_sum) return i;\n                        }\n                        return -1;\n                    }\n                };\n                ","date":"2022-11-27"},{"script":"cpp","time":0,"memory":5.9,"desc":"遍历。","code":"class Solution {\npublic:\n    int pivotInteger(int n) {\n        int r = (1 + n) * n / 2, l = 0;\n        for (int i = 1; i <= n; i++) {\n            l += i;\n            if (l == r) return i;\n            r -= i;\n        }\n        return -1;\n    }\n};","date":"2022-11-27"},{"script":"cpp","time":0,"memory":5.7,"desc":"对于圆在矩形的四边和在四个远郊区都进行检测。","code":"class Solution {\npublic:\n    int pivotInteger(int n) {\n        int r = (1 + n) * n / 2, l = 0;\n        for (int i = 1; i <= n; i++) {\n            l += i;\n            if (l == r) return i;\n            r -= i;\n        }\n        return -1;\n    }\n};","date":"2023-06-26"},{"script":"python","time":72,"memory":15.8,"desc":"同上。","code":"class Solution:\n    def pivotInteger(self, n: int) -> int:\n        l = 0\n        r = sum(range(1, n + 1))\n        for i in range(1, n + 1):\n            l += i\n            if l == r: return i\n            r -= i\n        return -1","date":"2023-06-26"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn pivot_integer(n: i32) -> i32 {\n        let mut l = 0;\n        let mut r: i32 = (1..=n).sum();\n        for i in 1..=n {\n            l += i;\n            if l == r {\n                return i\n            }\n            r -= i;\n        }\n        -1\n    }\n}","date":"2023-06-26"}],"tagList":["数学","前缀和"],"level":"Easy"}},{"problemName":"2486.追加字符以获得子序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2486.追加字符以获得子序列.json","problemData":{"id":"2572","name":"2486.追加字符以获得子序列","url":"https://leetcode.cn/problems/append-characters-to-string-to-make-subsequence","desc":"给你两个仅由小写英文字母组成的字符串 s 和 t 。现在需要通过向 s 末尾追加字符的方式使 t 变成 s 的一个 子序列 ，返回需要追加的最少字符数。","solutions":[{"date":"2022-11-27","time":12,"memory":10.5,"script":"cpp","desc":"遍历, 判断 s 还剩下几个没法匹配。","code":"# define X first\n# define Y second\n# define lb(x) ((x) & (-x))\n# define mem(a,b) memset(a,b,sizeof(a))\n# define debug freopen(\"r.txt\",\"r\",stdin)\n# define pi pair<int,int>\nusing namespace std;\ntypedef long long ll;\n\nclass Solution {\npublic:\n    int appendCharacters(string s, string t) {\n        int cur = 0;\n        for (int i = 0; i < s.size(); i++) {\n          if (s[i] == t[cur]) {\n            cur++;\n          }\n        }\n        return t.size() - cur;\n    }\n};"}],"tagList":["贪心","双指针","字符串"],"level":"Medium"}},{"problemName":"2487.从链表中移除节点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2487.从链表中移除节点.json","problemData":{"id":"2573","name":"2487.从链表中移除节点","url":"https://leetcode.cn/problems/remove-nodes-from-linked-list","desc":"给你一个链表的头节点 head 。对于列表中的每个节点 node ，如果其右侧存在一个具有 严格更大 值的节点，则移除 node 。返回修改后链表的头节点 head 。","solutions":[{"date":"2022-11-27","time":356,"memory":157.1,"script":"cpp","desc":"递归，记录后面的最大值。","code":"# define X first\n# define Y second\n# define lb(x) ((x) & (-x))\n# define mem(a,b) memset(a,b,sizeof(a))\n# define debug freopen(\"r.txt\",\"r\",stdin)\n# define pi pair<int,int>\nusing namespace std;\ntypedef long long ll;\n\nclass Solution {\npublic:\n    ListNode* removeNodes(ListNode* head) {\n      int maxnum = 0;\n      return _removeNodes(head, maxnum);\n    }\n    ListNode* _removeNodes(ListNode *head, int &maxnum) {\n      if (head == nullptr) return nullptr;\n      ListNode *next = _removeNodes(head->next, maxnum);\n      if (head->val >= maxnum) {\n        head->next = next;\n        next = head;\n      }\n      maxnum = max(maxnum, head->val);\n      return next;\n    }\n};"},{"script":"python","time":644,"memory":55.98,"desc":"单调栈记录最大序列，遍历时记录父节点。","code":"class Solution:\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        p = tempHead = ListNode(0, head)\n        s = []\n        map = {}\n        while p.next:\n            map[p.next] = p \n            while s and s[-1].val < p.next.val:\n                node = s.pop()\n                parent = map[node]\n                parent.next = node.next\n                map[node.next] = parent\n            s.append(p.next)\n            p = p.next\n        return tempHead.next","date":"2024-01-03"},{"script":"python","time":360,"memory":59.6,"desc":"dfs。","code":"class Solution:\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        self.max = 0\n        def dfs(node: Optional[ListNode]) -> Optional[ListNode]:\n            if not node: return node\n            node.next = dfs(node.next)\n            if self.max > node.val: return node.next\n            self.max = node.val\n            return node\n        return dfs(head)","date":"2024-01-03"},{"script":"rust","time":72,"memory":11.33,"desc":"同上。","code":"impl Solution {\n    pub fn remove_nodes(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        let mut max = 0;\n        fn dfs(node: Option<Box<ListNode>>, max: &mut i32) -> Option<Box<ListNode>> {\n            match node {\n                None => None,\n                Some(mut node) => {\n                    node.next = dfs(node.next.take(), max);\n                    if *max > node.val {\n                        node.next.take()\n                    } else {\n                        *max = node.val;\n                        Some(node)\n                    }\n                }\n            }\n        }\n        dfs(head, &mut max)\n    }\n}","date":"2024-01-03"}],"tagList":["栈","递归","链表","单调栈"],"level":"Medium"}},{"problemName":"2488.统计中位数为K的子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2488.统计中位数为K的子数组.json","problemData":{"id":"2574","name":"2488.统计中位数为K的子数组","url":"https://leetcode.cn/problems/count-subarrays-with-median-k","desc":"给你一个长度为 n 的数组 nums ，该数组由从 1 到 n 的 不同 整数组成。另给你一个正整数 k 。统计并返回 num 中的 中位数 等于 k 的非空子数组的数目。","solutions":[{"date":"2022-11-27","time":76,"memory":51.4,"script":"cpp","desc":"因为是中位数且只有一个，找到唯一的 k，向左遍历记录情况存储，再向右遍历统计。","code":"#define X first\n#define Y second\n#define lb(x) ((x) & (-x))\n#define mem(a,b) memset(a,b,sizeof(a))\n#define debug freopen(\"r.txt\",\"r\",stdin)\n#define pi pair<int,int>\nusing namespace std;\ntypedef long long ll;\n\nclass Solution {\npublic:\n    int countSubarrays(vector<int>& nums, int k) {\n        int ans = 1, idx = findK(nums, k), n = nums.size();\n        unordered_map<int, int> m;\n        pi item = make_pair(0, 0);\n        for (int i = idx - 1; i >= 0; i--) {\n            if (nums[i] > k) item.Y += 1;\n            else item.X += 1;\n            if (item.Y - item.X == 0 || item.Y - item.X == 1) ans++;\n            m[item.Y - item.X]++;\n        }\n        item = make_pair(0, 0);\n        for (int j = idx + 1; j < n; j++) {\n          if (nums[j] > k) item.Y += 1;\n          else item.X += 1;\n          if (item.Y - item.X == 0) ans += 1 + m[0] + m[1];\n          else if (item.Y - item.X == 1) ans += 1 + m[0] + m[-1];\n          else ans += m[item.X - item.Y] + m[item.X - item.Y + 1];\n        }\n        return ans;\n    }\n    int findK(vector<int>& nums, int k) {\n      for (int i = 0; i < nums.size(); i++) if (nums[i] == k) return i;\n      return -1;\n    }\n};"},{"script":"cpp","time":76,"memory":51.4,"desc":"遍历，对于每个值判断前面可取值，并存入map。","code":"class Solution {\npublic:\n    int countSubarrays(vector<int>& nums, int k) {\n        unordered_map<int, int> m;\n        int res = 0, cur = 0;\n        bool findK = false;\n        for (auto &num : nums) {\n            if (num > k) cur += 1;\n            else if (num < k) cur -= 1;\n            if (num == k) findK = true;\n            if (findK) res += m[cur] + m[cur - 1] + (cur == 0 || cur == 1);\n            else m[cur]++;\n        }\n        return res;\n    }\n};","date":"2023-03-16"},{"script":"python","time":120,"memory":16.7,"desc":"同上。","code":"class Solution:\n    def maximalNetworkRank(self, n: int, roads: List[List[int]]) -> int:\n        l = [set() for _ in range(n)]\n        for [n1, n2] in roads:\n            l[n1].add(n2)\n            l[n2].add(n1)\n        res = 0\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    res = max(res, len(l[i]) + len(l[j]) + (-1 if j in l[i] else 0))\n        return res","date":"2023-03-16"},{"script":"rust","time":16,"memory":3.2,"desc":"同上。","code":"impl Solution {\n    pub fn count_subarrays(nums: Vec<i32>, k: i32) -> i32 {\n        let mut m = std::collections::HashMap::<i32, i32>::new();\n        let (mut res, mut cur, mut find_k) = (0, 0, false);\n        for num in nums {\n            if num > k {\n                cur += 1;\n            } else if num < k {\n                cur -= 1;\n            } else {\n                find_k = true;\n            }\n            if find_k {\n                res += *m.get(&cur).unwrap_or(&0)\n                    + *m.get(&(cur - 1)).unwrap_or(&0)\n                    + ((cur == 0 || cur == 1) as i32);\n            } else {\n                *m.entry(cur).or_insert(0) += 1;\n            }\n        }\n        res\n    }\n}","date":"2023-03-16"}],"tagList":["数组","哈希表","前缀和"],"level":"Hard"}},{"problemName":"2490.回环句.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2490.回环句.json","problemData":{"id":"2580","name":"2490.回环句","url":"https://leetcode.cn/problems/circular-sentence","desc":"给你一个字符串 sentence ，请你判断它是不是一个回环句。如果是，返回 true ；否则，返回 false 。","solutions":[{"date":"2022-12-04","time":0,"memory":6.7,"script":"cpp","desc":"分割后判断。","code":"#include <iostream>\n#include <vector>\n// bestlyg\n# define X first\n# define Y second\n# define lb(x) ((x) & (-x))\n# define mem(a,b) memset(a,b,sizeof(a))\n# define debug freopen(\"r.txt\",\"r\",stdin)\n# define pi pair<int,int>\n\n#ifdef DEBUG\n#define log(frm, args...) {    printf(frm, ##args); }\n#else\n#define log(frm, args...)\n#endif\ntypedef long long ll;\n\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isCircularSentence(string sentence) {\n        int n = sentence.size();\n        istringstream iss(sentence);\n        string temp, prev = \"\", first = \"\";\n        while (getline(iss, temp, ' ')) {\n            if (prev == \"\") {\n                first = temp;\n            } else {\n                if (prev.back() != temp.front()) return false;\n            }\n            prev = temp;\n        }\n        if (temp.back() != first.front()) return false;\n        return true;\n    }\n};"},{"script":"cpp","time":56,"memory":60.9,"desc":"贪心，先填充2的列，再依次填充1的列。","code":"class Solution {\npublic:\n    bool isCircularSentence(string sentence) {\n        int n = sentence.size();\n        for (int i = 0; i < n; i++) {\n            while (sentence[i] != ' ' && i < n) i++;\n            if (i < n - 1 && sentence[i - 1] != sentence[i + 1]) return false;\n        }\n        return sentence[n - 1] == sentence[0];\n    }\n};","date":"2023-06-30"},{"script":"python","time":40,"memory":16.1,"desc":"字符串分割。","code":"class Solution:\n    def isCircularSentence(self, sentence: str) -> bool:\n        l = sentence.split(' ')\n        for i in range(len(l)):\n            if l[i][-1] != l[(i + 1) % len(l)][0]:\n                return False\n        return True","date":"2023-06-30"},{"script":"rust","time":4,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn is_circular_sentence(sentence: String) -> bool {\n        let l = sentence\n            .split(' ')\n            .into_iter()\n            .map(|v| v.as_bytes())\n            .collect::<Vec<&[u8]>>();\n        for i in 0..l.len() {\n            if *l[i].last().unwrap() != l[(i + 1) % l.len()][0] {\n                return false;\n            }\n        }\n        true\n    }\n}","date":"2023-06-30"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"2491.划分技能点相等的团队.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2491.划分技能点相等的团队.json","problemData":{"id":"2581","name":"2491.划分技能点相等的团队","url":"https://leetcode.cn/problems/divide-players-into-teams-of-equal-skill","desc":"给你一个正整数数组 skill ，数组长度为 偶数 n ，其中 skill[i] 表示第 i 个玩家的技能点。将所有玩家分成 n / 2 个 2 人团队，使每一个团队的技能点之和 相等 。","solutions":[{"date":"2022-12-04","time":72,"memory":51.3,"script":"cpp","desc":"排序后贪心判断。","code":"#include <iostream>\n#include <vector>\n// bestlyg\n# define X first\n# define Y second\n# define lb(x) ((x) & (-x))\n# define mem(a,b) memset(a,b,sizeof(a))\n# define debug freopen(\"r.txt\",\"r\",stdin)\n# define pi pair<int,int>\n\n#ifdef DEBUG\n#define log(frm, args...) {    printf(frm, ##args); }\n#else\n#define log(frm, args...)\n#endif\ntypedef long long ll;\n\nusing namespace std;\n\nclass Solution {\npublic:\n    long long dividePlayers(vector<int>& skill) {\n        int n = skill.size();\n        sort(skill.begin(), skill.end());\n        int sum = skill[0] + skill[n - 1];\n        long long ans = 0;\n        for (int i = 0; i < n / 2; i++) {\n            if (skill[i] + skill[n - 1 - i] != sum) return -1;\n            ans += skill[i] * skill[n - 1 - i];\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","双指针","排序"],"level":"Medium"}},{"problemName":"2492.两个城市间路径的最小分数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2492.两个城市间路径的最小分数.json","problemData":{"id":"2582","name":"2492.两个城市间路径的最小分数","url":"https://leetcode.cn/problems/minimum-score-of-a-path-between-two-cities","desc":"城市 1 和城市 n 之间的所有路径的 最小 分数。","solutions":[{"date":"2022-12-04","time":412,"memory":130.8,"script":"cpp","desc":"因为同一条路可以走多次，且 1 和 n 一定存在路，遍历 1 出发的所有路，找到最小值即可。","code":"#include <iostream>\n#include <vector>\n// bestlyg\n# define X first\n# define Y second\n# define lb(x) ((x) & (-x))\n# define mem(a,b) memset(a,b,sizeof(a))\n# define debug freopen(\"r.txt\",\"r\",stdin)\n# define pi pair<int,int>\n\n#ifdef DEBUG\n#define log(frm, args...) {    printf(frm, ##args); }\n#else\n#define log(frm, args...)\n#endif\ntypedef long long ll;\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int minScore(int n, vector<vector<int>>& roads) {\n        vector<vector<pi>> list(n);\n        for (auto &road : roads) {\n            int v1 = road[0] - 1, v2 = road[1] - 1;\n            list[v1].push_back(make_pair(v2, road[2]));\n            list[v2].push_back(make_pair(v1, road[2]));\n        }\n        int ans = 0x7fffffff;\n        unordered_set<int> s;\n        queue<int> q;\n        q.push(0);\n        s.insert(0);\n        while (q.size()) {\n            int cur = q.front();\n            q.pop();\n            for (auto &next : list[cur]) {\n                ans = min(ans, next.Y);\n                if (s.count(next.X)) continue;\n                q.push(next.X);\n                s.insert(next.X);\n            }\n\n        }\n        return ans;\n    }\n};"}],"tagList":["深度优先搜索","广度优先搜索","并查集","图"],"level":"Medium"}},{"problemName":"2493.将节点分成尽可能多的组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2493.将节点分成尽可能多的组.json","problemData":{"id":"2583","name":"2493.将节点分成尽可能多的组","url":"https://leetcode.cn/problems/divide-nodes-into-the-maximum-number-of-groups","desc":"请你返回最多可以将节点分为多少个组（也就是最大的 m ）。如果没办法在给定条件下分组，请你返回 -1 。","solutions":[{"date":"2022-12-04","time":1960,"memory":141.3,"script":"cpp","desc":"先通过并查集区分不同的连通图，对每个连通图的每个点进行枚举 bfs 判断对长组。","code":"#include <iostream>\n#include <vector>\n// bestlyg\n# define X first\n# define Y second\n# define lb(x) ((x) & (-x))\n# define mem(a,b) memset(a,b,sizeof(a))\n# define debug freopen(\"r.txt\",\"r\",stdin)\n# define pi pair<int,int>\n\n#ifdef DEBUG\n#define log(frm, args...) {    printf(frm, ##args); }\n#else\n#define log(frm, args...)\n#endif\ntypedef long long ll;\n\nusing namespace std;\n\nclass UnionFind {\npublic:\n    int n;\n    vector<int> list;\n    UnionFind(int n): n(n) {\n        list = vector<int>(n);\n        for (int i = 0; i < n; i++) list[i] = i;\n    }\n    int find(int v) {\n        if (list[v] == v) return v;\n        return list[v] = find(list[v]);\n    }\n    void uni(int v1, int v2) {\n        int p1 = find(v1), p2 = find(v2);\n        if (p1 != p2) list[p1] = p2;\n    }\n\n};\nclass Node {\npublic:\n    int v;\n    unordered_set<int> next;\n};\nclass Solution {\npublic:\n    int magnificentSets(int n, vector<vector<int>>& edges) {\n        vector<Node> list(n);\n        UnionFind uf(n);\n        for (int i = 0; i < n; i++) list[i].v = i;\n        for (auto &edge : edges) {\n            int v1 = edge[0] - 1, v2 = edge[1] - 1;\n            list[v1].next.insert(v2);\n            list[v2].next.insert(v1);\n            uf.uni(v1, v2);\n        }\n        auto comp = [&](int start){\n            // cout << \"====\" << start << endl;\n            queue<int> q;\n            q.push(start);\n            unordered_set<int> used;\n            unordered_map<int, unordered_set<int>> m;\n            int level = 0, size = 1;\n            used.insert(start);\n            m[0].insert(start);\n            while (q.size()) {\n                int cur = q.front();\n                // cout << \"cur = \" << cur << \", level = \" << level << endl;\n                q.pop();\n                for (auto &next : list[cur].next) {\n                    // cout << \"next = \" << next << \", \" << used.count(next) << endl;\n                    if (used.count(next)) {\n                        if (m[level - 1].count(next) || m[level + 1].count(next)) continue;\n                        else return -1;\n                    }\n                    used.insert(next);\n                    m[level + 1].insert(next);\n                    q.push(next);\n                }\n                if (--size == 0) {\n                    size = q.size();\n                    level++;\n                }\n            }\n            return level;\n        };\n        unordered_map<int, int> m;\n        for (int i = 0; i < n; i++) {\n            int p = uf.find(i), v = comp(i);\n            if (v == -1) return -1;\n            m[p] = max(m[p], v);\n        }\n        int ans = 0;\n        for (auto &item : m) ans += item.Y;\n        return ans;\n    }\n};"}],"tagList":["广度优先搜索","并查集","图"],"level":"Hard"}},{"problemName":"2496.数组中字符串的最大值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2401-2500/2496.数组中字符串的最大值.json","problemData":{"id":"2589","name":"2496.数组中字符串的最大值","url":"https://leetcode.cn/problems/maximum-value-of-a-string-in-an-array","desc":"给你一个字符串数组 strs ，每个字符串都只由字母和数字组成，请你返回 strs 中字符串的 最大值 。","solutions":[{"script":"cpp","time":0,"memory":7.7,"desc":"遍历。","code":"class Solution {\npublic:\n    int maximumValue(vector<string>& strs) {\n        int res = 0;\n        for (auto &s : strs) {\n            int cur = 0;\n            for (auto &c : s) {\n                if (!isdigit(c)) {\n                    cur = s.size();\n                    break;\n                } else {\n                    cur = cur * 10 + c - '0';\n                }\n            }\n            res = max(res, cur);\n        }\n        return res;\n    }\n};","date":"2023-06-23"},{"script":"python","time":32,"memory":16.1,"desc":"同上。","code":"class Solution:\n    def maximumValue(self, strs: List[str]) -> int:\n        return max(\n            len(s) if not s.isdigit() else int(s)\n            for s in strs\n        )","date":"2023-06-23"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn maximum_value(strs: Vec<String>) -> i32 {\n        strs.into_iter()\n            .map(|s| s.parse().unwrap_or(s.len() as i32))\n            .max()\n            .unwrap()\n    }\n}","date":"2023-06-23"}],"tagList":["数组","字符串"],"level":"Easy"}}]},{"dirName":"2501-2600","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\2501-2600","problems":[{"problemName":"2501.数组中最长的方波.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2501.数组中最长的方波.json","problemData":{"id":"2586","name":"2501.数组中最长的方波","url":"https://leetcode.cn/problems/longest-square-streak-in-an-array","desc":"返回 nums 中 最长方波 的长度，如果不存在 方波 则返回 -1 。","solutions":[{"date":"2022-12-11","time":244,"memory":105.7,"script":"cpp","desc":"哈希后遍历。","code":"class Solution {\npublic:\n    int longestSquareStreak(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size(), ans = -1;\n        unordered_map<int, int> m;\n        for (int i = 0; i < n; i++) {\n            if (!m.count(nums[i])) m[nums[i]] = i;\n        }\n        vector<int> dp(n, 1);\n        for (int i = 0; i < n; i++) {\n            int num = nums[i], prev = sqrt(num);\n            //cout << \"num = \" << num << \", p = \" << prev << endl;\n            if (prev * prev != num) continue;\n            if (!m.count(prev)) continue;\n            dp[i] = max(dp[i], dp[m[prev]] + 1);\n            //cout << \"i = \" << i << \", dp = \" << dp[i] << endl;\n            if (dp[i] > 1) ans = max(ans, dp[i]);\n        }\n        return ans;\n\n    }\n};"}],"tagList":["数组","哈希表","二分查找","动态规划","排序"],"level":"Medium"}},{"problemName":"2502.设计内存分配器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2502.设计内存分配器.json","problemData":{"id":"2587","name":"2502.设计内存分配器","url":"https://leetcode.cn/problems/design-memory-allocator","desc":"给你一个整数 n ，表示下标从 0 开始的内存数组的大小。所有内存单元开始都是空闲的。请你设计一个具备以下功能的内存分配器。","solutions":[{"date":"2022-12-11","time":40,"memory":29.7,"script":"cpp","desc":"链表。","code":"#include <vector>\n#include <set>\n#include <iostream>\n#include <unordered_map>\n#define X first\n#define Y second\n#define lb(x) ((x) & (-x))\n#define mem(a,b) memset(a,b,sizeof(a))\n#define debug freopen(\"input\",\"r\",stdin)\nusing namespace std;\ntypedef long long ll;\n\nclass Node {\npublic:\n    int l, r, mID;\n    Node *next, *prev;\n    Node() {}\n    Node(int l, int r, int mID): l(l), r(r), mID(mID), next(nullptr), prev(nullptr) {}\n    void insert(Node *node) {\n      node->next = next;\n      node->prev = prev;\n      if (next) next = node;\n      if (prev) prev->prev = node;\n    }\n    void remove() {\n      Node *nextNode = next;\n      next = nextNode->next;\n      nextNode->prev = this;\n    }\n};\nclass Allocator {\npublic:\n    int n;\n    Node *head, *tail;\n    Allocator(int n): n(n), head(new Node(-1, -1, 0)), tail(new Node(n, n, 0)){\n      head->next = tail;\n      tail->prev = head;\n    }\n    int allocate(int size, int mID) {\n        Node *p = head;\n        while (p != tail) {\n            int s = p->next->l - p->r - 1;\n            if (s >= size) {\n              Node *newNode = new Node(p->r + 1, p->r + size, mID);\n              p->insert(newNode);\n              return p->r + 1;\n            }\n            p = p->next;\n        }\n        return -1;\n    }\n\n    int free(int mID) {\n        Node *p = head;\n        int sum = 0;\n        while (p != tail) {\n          if (p->next->mID == mID) {\n            sum += p->next->r - p->next->l + 1;\n            p->remove();\n            continue;\n          }\n          p = p->next;\n        }\n        print();\n        return sum;\n    }\n    void print() {\n      Node *p = head;\n      while (true) {\n        if (p == tail) {\n          break;\n        }\n        p = p->next;\n      }\n    }\n};"}],"tagList":["设计","数组","哈希表","模拟"],"level":"Medium"}},{"problemName":"2503.矩阵查询可获得的最大分数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2503.矩阵查询可获得的最大分数.json","problemData":{"id":"2588","name":"2503.矩阵查询可获得的最大分数","url":"https://leetcode.cn/problems/maximum-number-of-points-from-grid-queries","desc":"给你一个大小为 m x n 的整数矩阵 grid 和一个大小为 k 的数组 queries 。在过程结束后，answer[i] 是你可以获得的最大分数。注意，对于每个查询，你可以访问同一个单元格 多次 。返回结果数组 answer 。","solutions":[{"date":"2022-12-11","time":264,"memory":30.5,"script":"cpp","desc":"对 query 排序后，从小往大找， 对于所有小于 q 的数字进行并查集合并。","code":"class UnionFind {\npublic:\n    int n;\n    vector<int> data, cnt;\n    UnionFind(int n): n(n), data(vector<int>(n, 0)), cnt(vector<int>(n, 1)) {\n        for (int i = 0; i < n; i++) data[i] = i;\n    }\n    int size(int v) {\n        return cnt[find(v)];\n    }\n    int find(int v) {\n        if (data[v] == v) return v;\n        return data[v] = find(data[v]);\n    }\n    void uni(int v1, int v2) {\n        int p1 = find(v1), p2 = find(v2);\n        if (p1 != p2) {\n            cnt[p1] += cnt[p2];\n            data[p2] = p1;\n        }\n    }\n};\nint pos2Idx(int x, int y, int size) {\n    return x * size + y;\n}\nvoid idx2Pos(int idx, int size, int &x, int &y) {\n    x = idx / size;\n    y = idx % size;\n}\nvector<vector<int>> dirs = {\n    {0, 1}, {0, -1},\n    {1, 0}, {-1, 0}\n};\nclass Solution {\npublic:\n    int n, m, qs;\n    vector<int> maxPoints(vector<vector<int>>& grid, vector<int>& queries) {\n        n = grid.size();\n        m = grid[0].size();\n        qs = queries.size();\n        vector<int> ans(qs, 0), list(qs), data;\n        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) data.push_back(pos2Idx(i, j, m));\n        sort(data.begin(), data.end(), [&](auto &i1, auto &i2){\n            int x1, y1, x2, y2;\n            idx2Pos(i1, m, x1, y1);\n            idx2Pos(i2, m, x2, y2);\n            return grid[x1][y1] < grid[x2][y2];\n        });\n        iota(list.begin(), list.end(), 0);\n        sort(list.begin(), list.end(), [&](auto &i1, auto &i2){ return queries[i1] < queries[i2]; });\n        /*\n        cout << \"data : \";\n        for (auto &idx : data) {\n            int x, y;\n            idx2Pos(idx, m, x, y);\n            cout << \"(\" << x << \", \" << y << \", \" << grid[x][y] << \"), \";\n        }\n        cout << \"none\" << endl;\n        cout << \"list : \";\n        for (auto &idx : list) {\n            cout << \"(\" << idx << \", \" << queries[idx] << \"), \";\n        }\n        cout << \"none\" << endl;\n        */\n        UnionFind uf(n * m);\n        int j = 0;\n        for (auto &idx : list) {\n            int q = queries[idx];\n            if (grid[0][0] >= q) continue;\n            // cout << \"q = \" << q << endl;\n            for (; j < data.size(); j++) {\n                int x, y;\n                idx2Pos(data[j], m, x, y);\n                // cout << \"j = \" << j << \", x = \" << x << \", y = \" << y << endl;\n                if (grid[x][y] >= q) break;\n                for (auto &dir : dirs) {\n                    int nx = x + dir[0], ny = y + dir[1];\n                    if (nx == -1 || nx == n || ny == -1 || ny == m) continue;\n                    if (grid[nx][ny] >= q) continue;\n                    uf.uni(data[j], pos2Idx(nx, ny, m));\n                }\n            }\n            ans[idx] = uf.size(0);\n        }\n        return ans;\n    }\n};"}],"tagList":["广度优先搜索","并查集","数组","双指针","矩阵","排序","堆（优先队列）"],"level":"Hard"}},{"problemName":"2506.统计相似字符串对的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2506.统计相似字符串对的数目.json","problemData":{"id":"2594","name":"2506.统计相似字符串对的数目","url":"https://leetcode.cn/problems/count-pairs-of-similar-strings","desc":"如果两个字符串由相同的字符组成，则认为这两个字符串 相似 。请你找出满足字符串  words[i] 和 words[j] 相似的下标对 (i, j) ，并返回下标对的数目，其中 0 <= i < j <= word.length - 1 。","solutions":[{"date":"2022-12-18","time":12,"memory":12.4,"script":"cpp","desc":"哈希统计前面的数量。","code":"class Solution {\npublic:\n    int similarPairs(vector<string>& words) {\n        unordered_map<int, int> m;\n        int ans = 0;\n        for (auto &word : words) {\n            int num = toNum(word);\n            ans += m[num];\n            m[num]++;\n        }\n        return ans;\n    }\n    int toNum(string &word) {\n        int ans = 0;\n        for (auto &ch : word) {\n            ans |= (1 << (ch - 'a'));\n        }\n        return ans;\n    }\n};"}],"tagList":["位运算","数组","哈希表","字符串"],"level":"Easy"}},{"problemName":"2507.使用质因数之和替换后可以取到的最小值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2507.使用质因数之和替换后可以取到的最小值.json","problemData":{"id":"2595","name":"2507.使用质因数之和替换后可以取到的最小值","url":"https://leetcode.cn/problems/smallest-value-after-replacing-with-sum-of-prime-factors","desc":"给你一个正整数 n 。返回 n 可以取到的最小值。","solutions":[{"date":"2022-12-18","time":4,"memory":5.9,"script":"cpp","desc":"dfs。","code":"class Solution {\npublic:\n    unordered_map<int, int> m;\n    int smallestValue(int n) {\n        int ans = n;\n        if (isPrime(n)) return n;\n        if (m.count(n)) return m[n];\n        int num = 0;\n        for (int i = 2; i <= n; i++) {\n            if (n % i != 0) continue;\n            while (n % i == 0) n /= i, num += i;\n        }\n        m[ans] = num;\n        return min(ans, smallestValue(num));\n    }\n    bool isPrime(int n) {\n        for (int i = 2; i * i <= n; i++) {\n            if (n % i == 0) return false;\n        }\n        return true;\n    }\n};"}],"tagList":["数学","数论","模拟"],"level":"Medium"}},{"problemName":"2508.添加边使所有节点度数都为偶数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2508.添加边使所有节点度数都为偶数.json","problemData":{"id":"2596","name":"2508.添加边使所有节点度数都为偶数","url":"https://leetcode.cn/problems/add-edges-to-make-degrees-of-all-nodes-even","desc":"给你一个有 n  个节点的 无向   图，节点编号为  1  到  n 。再给你整数  n  和一个二维整数数组  edges ，其中  edges[i] = [ai, bi]  表示节点  ai 和  bi  之间有一条边。图不一定连通。如果添加额外的边后，可以使得图中所有点的度数都是偶数，返回 true ，否则返回 false 。","solutions":[{"date":"2022-12-18","time":512,"memory":186.9,"script":"cpp","desc":"统计所有的可能。","code":"struct Node{\n  int val;\n unordered_set<int> next;\n};\nclass Solution {\npublic:\n    bool isPossible(int n, vector<vector<int>>& edges) {\n        vector<Node> list(n);\n        for (int i = 1; i <= n; i++) list[i - 1].val = i;\n        for (auto &edge : edges) {\n            int v1 = edge[0] - 1, v2 = edge[1] - 1;\n            list[v1].next.insert(v2);\n            list[v2].next.insert(v1);\n        }\n        vector<int> nodes, nodes0;\n        for (auto &node : list) {\n            if (node.next.size() & 1) {\n                // cout << \"node.val = \" << node.val << \", size = \" << node.next.size() << endl;\n                if (node.next.size() == n - 1) return false;\n                if (node.next.size() == 0) {\n                    nodes0.push_back(node.val - 1);\n                } else {\n                    nodes.push_back(node.val - 1);\n                }\n            }\n        }\n        cout << \"NODE : \" << endl;\n        for (auto &node : nodes) {\n            cout << list[node].val - 1 << \": \";\n            for (auto &next : list[node].next) cout << next << \", \";\n            cout << endl;\n        }\n        if (nodes.size() == 2) return true;\n        if (nodes.size() == 0) return true;\n        if (nodes.size() > 4) return false;\n        if (nodes0.size() > 1) return false;\n        if (nodes0.size() == 1) {\n            if (nodes.size() == 0) return true;\n            if (nodes.size() == 2) return true;\n            return false;\n        }\n        // cout << \"===\" << endl;\n        int ans = false;\n        unordered_set<int> used;\n        function<void(int,int)> dfs = [&](int i, int line) {\n            cout << \"i = \" << i << \", line = \" << line << \", nodes[i] = \" << (i == nodes.size() ? -1 : nodes[i]) << endl;\n            if (i == nodes.size()) {\n                ans = true;\n                return;\n            }\n            if (used.count(nodes[i])) {\n                // cout << \"1\" << endl;\n                dfs(i + 1, line);\n                return;\n            }\n            if (line == 0 && i != nodes.size()) return;\n                // cout << \"2\" << endl;\n                // cout << \"3\" << endl;\n            Node &node = list[nodes[i]];\n            for (int j = i + 1; j < nodes.size(); j++) {\n                if (used.count(nodes[j]) || node.next.count(nodes[j])) continue;\n                node.next.insert(nodes[j]);\n                list[nodes[j]].next.insert(nodes[i]);\n                used.insert(nodes[i]);\n                used.insert(nodes[j]);\n                // cout << \"link : \" << nodes[i] << \", \" << nodes[j] << endl;\n                dfs(i + 1, line - 1);\n                node.next.erase(nodes[j]);\n                list[nodes[j]].next.erase(nodes[i]);\n                used.erase(nodes[i]);\n                used.erase(nodes[j]);\n            }\n        };\n        dfs(0, 2);\n        return ans;\n    }\n};"}],"tagList":["图","哈希表"],"level":"Hard"}},{"problemName":"2509.查询树中环的长度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2509.查询树中环的长度.json","problemData":{"id":"2597","name":"2509.查询树中环的长度","url":"https://leetcode.cn/problems/cycle-length-queries-in-a-tree","desc":"请你返回一个长度为 m 的数组 answer ，其中 answer[i] 是第 i 个查询的结果。","solutions":[{"date":"2022-12-18","time":324,"memory":95.9,"script":"cpp","desc":"最近公共祖先。","code":"struct Node{\n    int v, p;\n    unordered_set<int> l, r;\n};\nclass Solution {\npublic:\n    vector<int> cycleLengthQueries(int n, vector<vector<int>>& queries) {\n        vector<int> ans(queries.size());\n        for (int i = 0; i < queries.size(); i++) {\n            ans[i] = query(n, queries[i]);\n        }\n        return ans;\n    }\n    int query(int n, vector<int> &q) {\n        int n1 = q[0], n2 = q[1],\n            l1 = getLevel(n1), l2 = getLevel(n2);\n        if (l1 < l2) {\n            swap(n1, n2);\n            swap(l1, l2);\n        }\n        // cout << \"n1 = \" << n1 << \", l1 = \" << l1 << \", n2 = \" << n2 << \", l2 = \" << l2 << endl;\n        int ans = 0;\n        while (l1 > l2) {\n            n1 = getParent(n1);\n            l1 = getLevel(n1);\n            ans++;\n        }\n        while (n1 != n2) {\n            ans += 2;\n            n1 = getParent(n1);\n            n2 = getParent(n2);\n        }\n        // cout << \"n1 = \" << n1 << \", l1 = \" << l1 << \", n2 = \" << n2 << \", l2 = \" << l2 << endl;\n        return ans + 1;\n    }\n    int comp(int n1, int n2) {\n        return 0;\n    }\n    unordered_map<int, int> m;\n    int getLevel(int val) {\n        if (m.count(val)) return m[val];\n        int i = 1, level = 0;\n        while (i <= val) i *= 2, level++;\n        return m[val] = level;\n    }\n    int getParent(int v) {\n        if (v == 1) return v;\n        return v / 2;\n    }\n};"}],"tagList":["树","数组","二叉树"],"level":"Hard"}},{"problemName":"2511.最多可以摧毁的敌人城堡数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2511.最多可以摧毁的敌人城堡数目.json","problemData":{"id":"2602","name":"2511.最多可以摧毁的敌人城堡数目","url":"https://leetcode.cn/problems/maximum-enemy-forts-that-can-be-captured","desc":"请你返回 最多 可以摧毁的敌人城堡数目。","solutions":[{"script":"cpp","time":4,"memory":7.41,"desc":"遍历。","code":"class Solution {\npublic:\n    int captureForts(vector<int>& forts) {\n        int res = 0, p0 = -1, p1 = -1;\n        for (int i = 0; i < forts.size(); i++) {\n            int fort = forts[i];\n            if (fort == 1) {\n                if (p0 != -1 && p0 > p1) res = max(res, i - 1 - p0);\n                p1 = i;\n            } else if (fort == -1) {\n                if (p1 != -1 && p1 > p0) res = max(res, i - 1 - p1);\n                p0 = i;\n            }\n        }\n        return res;\n    }\n};","date":"2023-09-02"},{"script":"python","time":60,"memory":15.82,"desc":"同上。","code":"class Solution:\n    def captureForts(self, forts: List[int]) -> int:\n        res = 0\n        p0 = p1 = -1\n        for i in range(len(forts)):\n            fort = forts[i]\n            if fort == 1:\n                if p0 != -1 and p0 > p1:\n                    res = max(res, i - p0 - 1)\n                p1 = i\n            elif fort == -1:\n                if p1 != -1 and p1 > p0:\n                    res = max(res, i - p1 - 1)\n                p0 = i\n        return res","date":"2023-09-02"},{"script":"rust","time":0,"memory":1.93,"desc":"同上。","code":"impl Solution {\n    pub fn capture_forts(forts: Vec<i32>) -> i32 {\n        let mut res = 0i32;\n        let (mut p0, mut p1) = (-1i32, -1i32);\n        for i in 0..forts.len() {\n            let fort = forts[i];\n            if fort == 1 {\n                if p0 != -1 && p0 > p1 {\n                    res = res.max((i as i32) - 1 - p0);\n                }\n                p1 = i as i32;\n            } else if fort == -1 {\n                if p1 != -1 && p1 > p0 {\n                    res = res.max((i as i32) - 1 - p1);\n                }\n                p0 = i as i32;\n            }\n        }\n        res as i32\n    }\n}","date":"2023-09-02"}],"tagList":["数组","双指针"],"level":"Easy"}},{"problemName":"2512.奖励最顶尖的K名学生.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2512.奖励最顶尖的K名学生.json","problemData":{"id":"2603","name":"2512.奖励最顶尖的K名学生","url":"https://leetcode.cn/problems/reward-top-k-students","desc":"给你一个整数 k ，请你返回按照得分 从高到低 最顶尖的 k 名学生。","solutions":[{"script":"cpp","time":4,"memory":9.2,"desc":"双指针。","code":"class Solution {\npublic:\n    long long findTheArrayConcVal(vector<int>& nums) {\n        long long i1 = 0, i2 = nums.size() - 1, res = 0;\n        while (i1 < i2) {\n            res += nums[i1] * pow(10, to_string(nums[i2]).size()) + nums[i2];\n            i1 += 1;\n            i2 -= 1;\n        }\n        if (i1 == i2) res += nums[i1];\n        return res;\n    }\n};","date":"2023-10-12"},{"script":"python","time":56,"memory":15.47,"desc":"同上。","code":"class Solution:\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\n        i1 = 0\n        i2 = len(nums) - 1\n        res = 0\n        while i1 < i2:\n            res += nums[i1] * 10 ** len(str(nums[i2])) + nums[i2]\n            i1 += 1\n            i2 -= 1\n        if i1 == i2: res += nums[i1]\n        return res","date":"2023-10-12"},{"script":"rust","time":0,"memory":2.12,"desc":"同上。","code":"impl Solution {\n    pub fn find_the_array_conc_val(nums: Vec<i32>) -> i64 {\n        let mut i1 = 0;\n        let mut i2 = nums.len() - 1;\n        let mut res = 0i64;\n        while i1 < i2 {\n            res += (nums[i1] as i64) * 10i64.pow(nums[i2].to_string().len() as u32)\n                + (nums[i2] as i64);\n            i1 += 1;\n            i2 -= 1;\n        }\n        if i1 == i2 {\n            res += nums[i1] as i64;\n        }\n        res\n    }\n}","date":"2023-10-12"}],"tagList":["数组","哈希表","字符串","排序","堆（优先队列）"],"level":"Medium"}},{"problemName":"2515.到目标字符串的最短距离.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2515.到目标字符串的最短距离.json","problemData":{"id":"2598","name":"2515.到目标字符串的最短距离","url":"https://leetcode.cn/problems/shortest-distance-to-target-string-in-a-circular-array","desc":"返回到达目标字符串 target 所需的最短距离。如果 words 中不存在字符串 target ，返回 -1 。","solutions":[{"date":"2022-12-25","time":24,"memory":14.1,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    int closetTarget(vector<string>& words, string target, int startIndex) {\n        if (words[startIndex] == target) return 0;\n        int i1 = startIndex, cnt1 = 0;\n        do {\n            i1 = (i1 + 1) % words.size(); cnt1++;\n        } while (words[i1] != target && i1 != startIndex);\n        if (i1 == startIndex) return -1;\n        int i2 = startIndex, cnt2 = 0;\n        do {\n            i2 = (i2 - 1 + words.size()) % words.size(); cnt2++;\n        } while (words[i2] != target && i2 != startIndex);\n        return min(cnt1, cnt2);\n    }\n};"}],"tagList":["数组","字符串"],"level":"Easy"}},{"problemName":"2516.每种字符至少取K个.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2516.每种字符至少取K个.json","problemData":{"id":"2599","name":"2516.每种字符至少取K个","url":"https://leetcode.cn/problems/take-k-of-each-character-from-left-and-right","desc":"你必须取走每种字符 至少 k 个，返回需要的 最少 分钟数；如果无法取到，则返回 -1 。","solutions":[{"date":"2022-12-25","time":24,"memory":14.1,"script":"cpp","desc":"二分答案。","code":"class Solution {\npublic:\n    int takeCharacters(string s, int k) {\n        if (k == 0) return 0;\n        int l = 0, r = s.size(), m, list[3] = {0};\n        for (auto &ch : s) list[ch - 'a']++;\n        if (list[0] < k || list[1] < k || list[2] < k) return -1;\n        while (l < r) {\n            m = (l + r) / 2;\n            if (check(s, k, m)) r = m;\n            else l = m + 1;\n        }\n        return l;\n    }\n    bool check(string &s, int &k, int &m) {\n        int list[3] = {0}, l = 0, r = s.size() - m;\n        for (int i = s.size() - 1; i >= r; i--) list[s[i] - 'a']++;\n        if (checklist(list, k)) return true;\n        while (l < m) {\n            list[s[l++] - 'a']++;\n            list[s[r++] - 'a']--;\n            if (checklist(list, k)) return true;\n        }\n        return false;\n    }\n    bool checklist(int list[3], int k) {\n        return list[0] >= k && list[1] >= k && list[2] >= k;\n    }\n};"}],"tagList":["哈希表","字符串","滑动窗口"],"level":"Medium"}},{"problemName":"2517.礼盒的最大甜蜜度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2517.礼盒的最大甜蜜度.json","problemData":{"id":"2600","name":"2517.礼盒的最大甜蜜度","url":"https://leetcode.cn/problems/maximum-tastiness-of-candy-basket","desc":"返回礼盒的 最大 甜蜜度。","solutions":[{"date":"2022-12-25","time":172,"memory":49.4,"script":"cpp","desc":"二分答案。","code":"class Solution {\npublic:\n    int n, k;\n    vector<int> price;\n    int maximumTastiness(vector<int>& price, int k) {\n        sort(price.begin(), price.end());\n        n = price.size();\n        this->k = k;\n        this->price = price;\n        int l = 0, r = price[n - 1] - price[0], m;\n        while (l < r) {\n            m = (l + r + 1) / 2;\n            if (check(m)) l = m;\n            else r = m - 1;\n        }\n        return l;\n    }\n    bool check(int num) {\n        int cnt = 1, cur = price[0];\n        for (int i = 1; i < n; i++) {\n            if (cur + num <= price[i]) {\n                cnt++;\n                cur = price[i];\n            }\n        }\n        return cnt >= k;\n    }\n};"},{"script":"cpp","time":212,"memory":47.3,"desc":"二分答案，尽可能找差超过target的数量。","code":"class Solution {\npublic:\n    int maximumTastiness(vector<int>& price, int k) {\n        sort(price.begin(), price.end());\n        int n = price.size(), l = 0, r = price[n - 1] - price[0];\n        while (l < r) {\n            int m = (l + r + 1) / 2, cnt = 1, prev = price[0];\n            for (int i = 1; i < n; i++) {\n                if (price[i] - prev >= m) cnt++, prev = price[i];\n            }\n            if (cnt < k) r = m - 1;\n            else l = m;\n        }\n        return l;\n    }\n};","date":"2023-06-01"},{"script":"python","time":996,"memory":27.5,"desc":"同上。","code":"class Solution:\n    def maximumTastiness(self, price: List[int], k: int) -> int:\n        price.sort()\n        n = len(price)\n        l = 0\n        r = price[n-1]-price[0]\n        while l < r:\n            m = (l+r+1)//2\n            cnt = 1\n            prev = price[0]\n            for i in range(1, n):\n                if price[i] - prev >= m:\n                    cnt += 1\n                    prev = price[i]\n            if cnt < k:\n                r = m-1\n            else:\n                l = m\n        return l","date":"2023-06-01"},{"script":"rust","time":44,"memory":3.9,"desc":"同上。","code":"impl Solution {\npub fn maximum_tastiness(mut price: Vec<i32>, k: i32) -> i32 {\n    price.sort();\n    let n = price.len();\n    let mut l = 0;\n    let mut r = price[n - 1] - price[0];\n    while l < r {\n        let m = (l + r + 1) / 2;\n        let mut cnt = 1;\n        let mut prev = price[0];\n        for i in 1..n {\n            if price[i] - prev >= m {\n                cnt += 1;\n                prev = price[i];\n            }\n        }\n        if cnt < k {\n            r = m - 1;\n        } else {\n            l = m\n        }\n    }\n    l\n}\n}","date":"2023-06-01"}],"tagList":["贪心","数组","二分查找","排序"],"level":"Medium"}},{"problemName":"2518.好分区的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2518.好分区的数目.json","problemData":{"id":"2601","name":"2518.好分区的数目","url":"https://leetcode.cn/problems/number-of-great-partitions","desc":"返回 不同 的好分区的数目。由于答案可能很大，请返回对 109 + 7 取余 后的结果。","solutions":[{"date":"2022-12-25","time":112,"memory":36.7,"script":"cpp","desc":"逆向统计，统计出有多少组是少于 k 的，res = sum - 2 \\* val。","code":"class Solution {\npublic:\n    int countPartitions(vector<int>& nums, int k) {\n        if (accumulate(nums.begin(), nums.end(), 0LL) < 2 * k) return 0;\n        sort(nums.begin(), nums.end());\n        int n = nums.size(), mod = 1e9 + 7, ans = 1;\n        vector<vector<int>> dp(n + 1, vector<int>(k, 0));\n        dp[0][0] = 1;\n        for (int i = 1; i <= n; i++) {\n            ans = (ans * 2) % mod;\n            dp[i][0] = 1;\n            for (int j = 1; j < k; j++) {\n                dp[i][j] = (dp[i][j] + dp[i - 1][j]) % mod;\n                if (j >= nums[i - 1]) dp[i][j] = (dp[i][j] + dp[i - 1][j - nums[i - 1]]) % mod;\n            }\n        }\n        for (auto &num : dp[n]) ans = (ans - 2 * num % mod + mod) % mod;\n        return ans;\n    }\n};"}],"tagList":["数组","动态规划"],"level":"Hard"}},{"problemName":"2520.统计能整除数字的位数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2520.统计能整除数字的位数.json","problemData":{"id":"2608","name":"2520.统计能整除数字的位数","url":"https://leetcode.cn/problems/count-the-digits-that-divide-a-number","desc":"给你一个整数 num ，返回 num 中能整除 num 的数位的数目。如果满足 nums % val == 0 ，则认为整数 val 可以整除 nums 。","solutions":[{"script":"cpp","time":0,"memory":5.94,"desc":"遍历。","code":"class Solution {\npublic:\n    int countDigits(int num) {\n        int res = 0;\n        for (int v = num; v; v /= 10) res += num % (v % 10) == 0;\n        return res;\n    }\n};","date":"2023-10-26"},{"script":"python","time":24,"memory":15.66,"desc":"同上。","code":"class Solution:\n    def countDigits(self, num: int) -> int:\n        return sum(num % int(c) == 0 for c in str(num))","date":"2023-10-26"},{"script":"rust","time":0,"memory":1.93,"desc":"同上。","code":"impl Solution {\n    pub fn count_digits(num: i32) -> i32 {\n        let mut res = 0;\n        let mut v = num;\n        while v > 0 {\n            res += if num % (v % 10) == 0 { 1 } else { 0 };\n            v /= 10;\n        }\n        res\n    }\n}","date":"2023-10-26"}],"tagList":["数学"],"level":"Easy"}},{"problemName":"2521.数组乘积中的不同质因数数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2521.数组乘积中的不同质因数数目.json","problemData":{"id":"2609","name":"2521.数组乘积中的不同质因数数目","url":"https://leetcode.cn/problems/distinct-prime-factors-of-product-of-array","desc":"给给你一个正整数数组 nums ，对 nums 所有元素求积之后，找出并返回乘积中 不同质因数 的数目。","solutions":[{"date":"2023-01-01","time":80,"memory":18.3,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    int distinctPrimeFactors(vector<int>& nums) {\n        unordered_set<int> s;\n        for (auto &num : nums) {\n            load(s, num);\n        }\n        return s.size();\n    }\n    void load(unordered_set<int> &s, int num) {\n        for (int i = 2; i <= num; i++) {\n            if (num % i == 0) {\n                s.insert(i);\n                while (num % i == 0) num /= i;\n            }\n        }\n    }\n};"},{"date":"2023-01-01","time":84,"memory":2.2,"script":"rust","desc":"遍历。","code":"use std::collections::HashSet;\nimpl Solution {\n    pub fn distinct_prime_factors(nums: Vec<i32>) -> i32 {\n        let mut set = HashSet::<i32>::new();\n        for num in nums {\n            Solution::load(&mut set, num);\n        }\n        set.len() as i32\n    }\n    fn load(set: &mut HashSet<i32>, num: i32) {\n        let mut num = num;\n        let mut i = 2;\n        while i <= num {\n            if i > num {\n                break;\n            }\n            if num % i == 0 {\n                set.insert(i);\n            }\n            while num % i == 0 {\n                num /= i;\n            }\n            i += 1;\n        }\n    }\n}"}],"tagList":["数组","哈希表","数学","数论"],"level":"Medium"}},{"problemName":"2522.将字符串分割成值不超过K的子字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2522.将字符串分割成值不超过K的子字符串.json","problemData":{"id":"2511","name":"2522.将字符串分割成值不超过K的子字符串","url":"https://leetcode.cn/problems/partition-string-into-substrings-with-values-at-most-k","desc":"请你返回 s 所有的 好 分割中，子字符串的 最少 数目。","solutions":[{"date":"2023-01-01","time":40,"memory":13.3,"script":"cpp","desc":"dp[i]存在 i 个字符的时候最小分割数为 dp[i]。","code":"class Solution {\npublic:\n    int minimumPartition(string s, int k) {\n        int n = s.size();\n        vector<long long> dp(n + 1, 0x3f3f3f3f);\n        dp[0] = 0;\n        for (int i = 1; i <= n; i++) {\n            long long num = 0;\n            for (long long j = i, mul = 1; j >= 1; j--, mul *= 10) {\n                num = (s[j - 1] - '0') * mul + num;\n                if (num > k) break;\n                dp[i] = min(dp[i], dp[j - 1] + 1);\n            }\n        }\n        return dp[n] >= 0x3f3f3f3f ? -1 : dp[n];\n    }\n};"},{"date":"2023-01-01","time":12,"memory":3.8,"script":"rust","desc":"同上。","code":"impl Solution {\n    pub fn minimum_partition(s: String, k: i32) -> i32 {\n        let k = k as i128;\n        let list = s.as_bytes();\n        let n = s.len();\n        let mut dp = vec![0x3f3f3f3f_i128; n + 1];\n        dp[0] = 0;\n        for i in 1..=n {\n            let mut num: i128 = 0;\n            let mut mul = 1;\n            for j in 0..i {\n                num = ((list[i - j - 1] as usize - '0' as usize) as i128) * mul + num;\n                if num > k {\n                    break;\n                }\n                dp[i] = dp[i].min(dp[i - j - 1] + 1);\n                mul *= 10;\n            }\n        }\n        if dp[n] == 0x3f3f3f3f {\n            -1\n        } else {\n            dp[n] as i32\n        }\n    }\n}"}],"tagList":["贪心","字符串","动态规划"],"level":"Medium"}},{"problemName":"2523.范围内最接近的两个质数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2523.范围内最接近的两个质数.json","problemData":{"id":"2610","name":"2523.范围内最接近的两个质数","url":"https://leetcode.cn/problems/closest-prime-numbers-in-range","desc":"请你返回正整数数组 ans = [nums1, nums2] 。","solutions":[{"date":"2023-01-01","time":248,"memory":10.2,"script":"cpp","desc":"计算质数表后统计。","code":"class Solution {\npublic:\n    int dp[1000005] = {0};\n    int left, right;\n    void load() {\n        for (int i = 2; i <= right; i++) {\n            if (dp[i] == 0) dp[++dp[0]] = i;\n            for (int j = 1; j <= dp[0] && i * dp[j] < 1000005; j++) {\n                dp[i * dp[j]] = 1;\n                if (i % dp[j] == 0) break;\n            }\n        }\n    }\n    vector<int> closestPrimes(int left, int right) {\n        this->left = left;\n        this->right = right;\n        load();\n        int start = 1;\n        while (start <= dp[0] && dp[start] < left) start++;\n        start++;\n        vector<int> ans(2, -1);\n        if (start > dp[0]) return ans;\n        ans[0] = dp[start - 1]; ans[1] = dp[start];\n        for (int i = start + 1; i <= dp[0] && dp[i] <= right; i++) {\n            if (dp[i] - dp[i - 1] < ans[1] - ans[0]) {\n                ans[0] = dp[i - 1];\n                ans[1] = dp[i];\n            }\n        }\n        return ans;\n    }\n};"},{"date":"2023-01-01","time":180,"memory":9.6,"script":"rust","desc":"同上。","code":"impl Solution {\n    pub fn closest_primes(left: i32, right: i32) -> Vec<i32> {\n        let primes = Solution::get_primes(right as usize);\n        let mut start = 1;\n        while start <= primes[0] && primes[start] < left as usize {\n            start += 1;\n        }\n        let mut ans: Vec<i32> = vec![-1; 2];\n        if start + 1 <= primes[0] {\n            start += 1;\n            ans[0] = primes[start - 1] as i32;\n            ans[1] = primes[start] as i32;\n            while start + 1 <= primes[0] {\n                start += 1;\n                if ((primes[start] - primes[start - 1]) as i32) < ans[1] - ans[0] {\n                    ans[0] = primes[start - 1] as i32;\n                    ans[1] = primes[start] as i32;\n                }\n            }\n        }\n        ans\n    }\n    fn get_primes(max: usize) -> Vec<usize> {\n        let mut ans = vec![0; 1000005];\n        for i in 2..=max {\n            if ans[i] == 0 {\n                ans[0] += 1;\n                let idx = ans[0];\n                ans[idx] = i;\n            }\n            for j in 1..=ans[0] {\n                if ans[j] * i >= 1000005 {\n                    break;\n                }\n                let idx = ans[j] * i;\n                ans[idx] = 1;\n                if i % ans[j] == 0 {\n                    break;\n                }\n            }\n        }\n        ans\n    }\n}"}],"tagList":["数学","数论"],"level":"Medium"}},{"problemName":"2525.根据规则将箱子分类.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2525.根据规则将箱子分类.json","problemData":{"id":"2619","name":"2525.根据规则将箱子分类","url":"https://leetcode.cn/problems/categorize-box-according-to-criteria","desc":"给你四个整数 length ，width ，height 和 mass ，分别表示一个箱子的三个维度和质量，请你返回一个表示箱子 类别 的字符串。","solutions":[{"script":"python","time":40,"memory":15.66,"desc":"逻辑判断。","code":"class Solution:\n    def categorizeBox(self, length: int, width: int, height: int, mass: int) -> str:\n        v = length * width * height\n        bulky = length >= 10 ** 4 or width >= 10 ** 4 or height >= 10 ** 4 or v >= 10 ** 9\n        heavy = mass >= 100\n        if bulky and heavy:\n            return \"Both\"\n        elif bulky:\n            return \"Bulky\"\n        elif heavy:\n            return \"Heavy\"\n        return \"Neither\"\n","date":"2023-10-20"}],"tagList":["数学"],"level":"Easy"}},{"problemName":"2529.正整数和负整数的最大计数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2529.正整数和负整数的最大计数.json","problemData":{"id":"2614","name":"2529.正整数和负整数的最大计数","url":"https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer","desc":"给你一个按 非递减顺序 排列的数组 nums ，返回正整数数目和负整数数目中的最大值。","solutions":[{"script":"python","time":51,"memory":16.64,"desc":"遍历。","code":"class Solution:\n    def maximumCount(self, nums: List[int]) -> int:\n        return max(\n            len(list(filter(lambda v: v > 0, nums))),\n            len(list(filter(lambda v: v < 0, nums)))\n        )","date":"2024-04-09"}],"tagList":["数组","二分查找","计数"],"level":"Easy"}},{"problemName":"2530.执行K次操作后的最大分数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2530.执行K次操作后的最大分数.json","problemData":{"id":"2616","name":"2530.执行K次操作后的最大分数","url":"https://leetcode.cn/problems/maximal-score-after-applying-k-operations","desc":"给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。你的 起始分数 为 0 。返回在 恰好 执行 k 次操作后，你可能获得的最大分数。","solutions":[{"date":"2023-01-08","time":160,"memory":70.8,"script":"cpp","desc":"堆。","code":"class Solution {\npublic:\n    long long maxKelements(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        priority_queue<int> q;\n        long long ans = 0;\n        int idx = nums.size() - 1;\n        while (k--) {\n            if (q.size() && (idx < 0 || q.top() >= nums[idx])) {\n                int num = q.top();\n                q.pop();\n                ans += num;\n                q.push(ceil(1.0 * num / 3));\n            } else {\n                int num = nums[idx--];\n                ans += num;\n                q.push(ceil(1.0 * num / 3));\n            }\n        }\n        return ans;\n    }\n};"},{"date":"2023-01-08","time":36,"memory":4.6,"script":"rust","desc":"同上。","code":"use std::collections::BinaryHeap;\nimpl Solution {\n    pub fn max_kelements(nums: Vec<i32>, k: i32) -> i64 {\n        let mut k = k;\n        let mut heap = BinaryHeap::new();\n        for num in nums {\n            heap.push(num);\n        }\n        let mut ans: i64 = 0;\n        while k != 0 {\n            let num = heap.pop().unwrap() as i64;\n            ans += num;\n            let num = (num as f64 / 3.0).ceil() as i32;\n            heap.push(num);\n            k -= 1;\n        }\n        ans\n    }\n}"},{"script":"python","time":1604,"memory":44.59,"desc":"堆存储。","code":"class Node:\n        def __init__(self, val):\n            self.val = val\n        def __lt__(self, o):\n            return o.val < self.val\n    \n    class Solution:\n        def maxKelements(self, nums: List[int], k: int) -> int:\n            q = [Node(num) for num in nums]\n            heapify(q)\n            res = 0\n            while k:\n                res += q[0].val\n                heappush(q, Node(ceil(heappop(q).val / 3)))\n                k -= 1\n            return res\n    ","date":"2023-10-18"},{"script":"python","time":344,"memory":29.59,"desc":"堆存储。","code":"class Solution:\n    def maxKelements(self, nums: List[int], k: int) -> int:\n        for i in range(len(nums)): nums[i] *= -1\n        heapify(nums)\n        res = 0\n        for _ in range(k):\n            res += -nums[0]\n            heappush(nums, -ceil(heappop(nums) / -3))\n        return res\n","date":"2023-10-18"}],"tagList":["贪心","数组","堆（优先队列）"],"level":"Medium"}},{"problemName":"2531.使字符串中不同字符的数目相等.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2531.使字符串中不同字符的数目相等.json","problemData":{"id":"2615","name":"2531.使字符串中不同字符的数目相等","url":"https://leetcode.cn/problems/make-number-of-distinct-characters-equal","desc":"给你两个下标从 0 开始的字符串 word1 和 word2 。如果可以通过 恰好一次 移动，使 word1 和 word2 中不同字符的数目相等，则返回 true ；否则，返回 false 。","solutions":[{"date":"2023-01-08","time":160,"memory":49,"script":"typescript","desc":"存储后遍历。","code":"const list = new Array(26).fill(0).map((_, i) => String.fromCodePoint(i + 97));\nfunction isItPossible(word1: string, word2: string): boolean {\n  const map1 = new Map<string, number>();\n  for (const c of word1) map1.set(c, (map1.get(c) ?? 0) + 1);\n  const map2 = new Map<string, number>();\n  for (const c of word2) map2.set(c, (map2.get(c) ?? 0) + 1);\n  const len1 = map1.size;\n  const len2 = map2.size;\n  for (const c1 of list) {\n    for (const c2 of list) {\n      if (check(c1, c2)) return true;\n    }\n  }\n  return false;\n  function check(c1: string, c2: string): boolean {\n    const cnt1 = map1.get(c1) ?? 0;\n    const t1 = map1.get(c2) ?? 0;\n\n    const cnt2 = map2.get(c2) ?? 0;\n    const t2 = map2.get(c1) ?? 0;\n    if (cnt1 === 0 || cnt2 === 0) return false;\n    if (c1 === c2) return len1 === len2;\n\n    if (cnt1 === 1 && cnt2 === 1) {\n      if (t1 === 0 && t2 === 0) return len1 === len2;\n      if (t1 === 0 && t2 !== 0) return len1 + 1 === len2;\n      if (t1 !== 0 && t2 === 0) return len1 === len2 + 1;\n      if (t1 !== 0 && t2 !== 0) return len1 === len2;\n    }\n    if (cnt1 === 1 && cnt2 > 1) {\n      if (t1 === 0 && t2 === 0) return len1 === len2 + 1;\n      if (t1 === 0 && t2 !== 0) return len1 === len2;\n      if (t1 !== 0 && t2 === 0) return len1 - 1 === len2 + 1;\n      if (t1 !== 0 && t2 !== 0) return len1 - 1 === len2;\n    }\n    if (cnt1 > 1 && cnt2 === 1) {\n      if (t1 === 0 && t2 === 0) return len2 === len1 + 1;\n      if (t1 !== 0 && t2 === 0) return len2 === len1;\n      if (t1 === 0 && t2 !== 0) return len2 - 1 === len1 + 1;\n      if (t1 !== 0 && t2 !== 0) return len2 - 1 === len1;\n    }\n    if (cnt1 > 1 && cnt2 > 1) {\n      if (t1 === 0 && t2 === 0) return len1 === len2;\n      if (t1 !== 0 && t2 === 0) return len1 === len2 + 1;\n      if (t1 === 0 && t2 !== 0) return len1 + 1 === len2;\n      if (t1 !== 0 && t2 !== 0) return len1 === len2;\n    }\n    return false;\n  }\n}"},{"date":"2023-01-08","time":4,"memory":2.3,"script":"rust","desc":"同上。","code":"impl Solution {\n    pub fn is_it_possible(word1: String, word2: String) -> bool {\n        let mut list = [0; 26];\n        for i in 0..26 {\n            list[i] = i;\n        }\n        let mut m1 = [0; 26];\n        let mut m2 = [0; 26];\n        let mut len1 = 0;\n        let mut len2 = 0;\n        for c in word1.chars() {\n            let idx = c as usize - 'a' as usize;\n            m1[idx] += 1;\n            if m1[idx] == 1 {\n                len1 += 1;\n            }\n        }\n        for c in word2.chars() {\n            let idx = c as usize - 'a' as usize;\n            m2[idx] += 1;\n            if m2[idx] == 1 {\n                len2 += 1;\n            }\n        }\n        let check = |i1: usize, i2: usize| -> bool {\n            let c1 = m1[i1];\n            let t1 = m1[i2];\n            let c2 = m2[i2];\n            let t2 = m2[i1];\n            if c1 == 0 || c2 == 0 {\n                return false;\n            }\n            if i1 == i2 {\n                return len1 == len2;\n            }\n            if c1 == 1 && c2 == 1 {\n                if t1 == 0 && t2 == 0 {\n                    return len1 == len2;\n                }\n                if t1 == 0 && t2 != 0 {\n                    return len1 + 1 == len2;\n                }\n                if t1 != 0 && t2 == 0 {\n                    return len1 == len2 + 1;\n                }\n                if t1 != 0 && t2 != 0 {\n                    return len1 == len2;\n                }\n            }\n            if c1 == 1 && c2 > 1 {\n                if t1 == 0 && t2 == 0 {\n                    return len1 == len2 + 1;\n                }\n                if t1 == 0 && t2 != 0 {\n                    return len1 == len2;\n                }\n                if t1 != 0 && t2 == 0 {\n                    return len1 - 1 == len2 + 1;\n                }\n                if t1 != 0 && t2 != 0 {\n                    return len1 - 1 == len2;\n                }\n            }\n            if c1 > 1 && c2 == 1 {\n                if t1 == 0 && t2 == 0 {\n                    return len2 == len1 + 1;\n                }\n                if t1 != 0 && t2 == 0 {\n                    return len2 == len1;\n                }\n                if t1 == 0 && t2 != 0 {\n                    return len2 - 1 == len1 + 1;\n                }\n                if t1 != 0 && t2 != 0 {\n                    return len2 - 1 == len1;\n                }\n            }\n            if c1 > 1 && c2 > 1 {\n                if t1 == 0 && t2 == 0 {\n                    return len1 == len2;\n                }\n                if t1 != 0 && t2 == 0 {\n                    return len1 == len2 + 1;\n                }\n                if t1 == 0 && t2 != 0 {\n                    return len1 + 1 == len2;\n                }\n                if t1 != 0 && t2 != 0 {\n                    return len1 == len2;\n                }\n            }\n            false\n        };\n        for c1 in list.iter() {\n            for c2 in list.iter() {\n                if check(*c1, *c2) {\n                    return true;\n                }\n            }\n        }\n        false\n    }\n}"},{"date":"2023-01-08","time":4,"memory":2.4,"script":"rust","desc":"同上, 优化。","code":"impl Solution {\n    pub fn is_it_possible(word1: String, word2: String) -> bool {\n        let mut list = [0; 26];\n        for i in 0..26 {\n            list[i] = i;\n        }\n        let (mut m1, mut len1) = ([0; 26], 0);\n        let (mut m2, mut len2) = ([0; 26], 0);\n        for c in word1.chars() {\n            let idx = c as usize - 'a' as usize;\n            m1[idx] += 1;\n            if m1[idx] == 1 {\n                len1 += 1;\n            }\n        }\n        for c in word2.chars() {\n            let idx = c as usize - 'a' as usize;\n            m2[idx] += 1;\n            if m2[idx] == 1 {\n                len2 += 1;\n            }\n        }\n        for i1 in list.iter() {\n            for i2 in list.iter() {\n                let (i1, i2) = (*i1, *i2);\n                let (c1, t1) = (m1[i1], m1[i2]);\n                let (c2, t2) = (m2[i2], m2[i1]);\n                if c1 == 0 || c2 == 0 {\n                    continue;\n                } else if i1 == i2 {\n                    if len1 == len2 {\n                        return true;\n                    }\n                } else {\n                    let mut len1 = len1;\n                    let mut len2 = len2;\n                    if c1 == 1 {\n                        len1 -= 1;\n                    }\n                    if t1 == 0 {\n                        len1 += 1;\n                    }\n                    if c2 == 1 {\n                        len2 -= 1;\n                    }\n                    if t2 == 0 {\n                        len2 += 1\n                    }\n                    if len1 == len2 {\n                        return true;\n                    }\n                }\n            }\n        }\n        false\n    }\n}"}],"tagList":["哈希表","字符串","计数"],"level":"Medium"}},{"problemName":"2532.过桥的时间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2532.过桥的时间.json","problemData":{"id":"2642","name":"2532.过桥的时间","url":"https://leetcode.cn/problems/time-to-cross-a-bridge","desc":"所有 n 个盒子都需要放入新仓库，请你返回最后一个搬运箱子的工人 到达河左岸 的时间。","solutions":[{"date":"2023-01-08","time":276,"memory":53,"script":"typescript","desc":"模拟。","code":"class Heap<T = number> {\n  public arr: T[] = [];\n  get isEmpty() {\n    return this.size === 0;\n  }\n  get size() {\n    return this.arr.length;\n  }\n  get top() {\n    return this.arr[0];\n  }\n  constructor(public compare: (t1: T, t2: T) => number) {}\n  add(num: T): void {\n    this.arr.push(num);\n    this.shiftUp(this.size - 1);\n  }\n  remove(): T {\n    const num = this.arr.shift()!;\n    if (this.size) {\n      this.arr.unshift(this.arr.pop()!);\n      this.shiftDown(0);\n    }\n    return num;\n  }\n  private shiftUp(index: number): void {\n    if (index === 0) return;\n    const parentIndex = (index - 1) >> 1;\n    if (this.compare(this.arr[index], this.arr[parentIndex]) > 0) {\n      [this.arr[index], this.arr[parentIndex]] = [this.arr[parentIndex], this.arr[index]];\n      this.shiftUp(parentIndex);\n    }\n  }\n  private shiftDown(index: number): void {\n    let childrenIndex = index * 2 + 1;\n    if (childrenIndex > this.size - 1) return;\n    if (\n      childrenIndex + 1 <= this.size - 1 &&\n      this.compare(this.arr[childrenIndex + 1], this.arr[childrenIndex]) > 0\n    ) {\n      childrenIndex++;\n    }\n    if (this.compare(this.arr[childrenIndex], this.arr[index]) > 0) {\n      [this.arr[childrenIndex], this.arr[index]] = [this.arr[index], this.arr[childrenIndex]];\n      this.shiftDown(childrenIndex);\n    }\n  }\n  *[Symbol.iterator](): IterableIterator<T> {\n    for (const t of this.arr) {\n      yield t;\n    }\n  }\n}\nclass TWorker {\n  constructor(\n    public i: number,\n    public l2r: number,\n    public pickOld: number,\n    public r2l: number,\n    public putNew: number,\n    public wait: number = 0\n  ) {}\n  cost() {\n    return this.l2r + this.r2l;\n  }\n  cmp(worker: TWorker) {\n    return this.cost() !== worker.cost() ? this.cost() - worker.cost() : this.i - worker.i;\n  }\n  cmpWait(worker: TWorker) {\n    return worker.wait - this.wait;\n  }\n  toString() {\n    return `Worker${this.i}: l2r=${this.l2r}, r2l=${this.r2l}, pickOld=${this.pickOld}, putNew=${\n      this.putNew\n    }, cost=${this.cost()}, wait = ${this.wait}`;\n  }\n}\nfunction findCrossingTime(n: number, k: number, time: number[][]): number {\n  const workers = new Array(k)\n    .fill(0)\n    .map((_, i) => new TWorker(i, ...(time[i] as [number, number, number, number])));\n  console.log('========');\n  console.log(workers.map(v => v.toString()).join('\n'));\n  console.log('========');\n  const lHeap = new Heap<TWorker>((w1, w2) => w1.cmp(w2));\n  const rHeap = new Heap<TWorker>((w1, w2) => w1.cmp(w2));\n  const pickHeap = new Heap<TWorker>((t1, t2) => t1.cmpWait(t2));\n  const putHeap = new Heap<TWorker>((t1, t2) => t1.cmpWait(t2));\n  const printHeap = (record: Record<string, Heap<TWorker>>) =>\n    Object.entries(record).forEach(([k, v]) =>\n      console.log(`=> ${k}(${v.size}):\n${v.arr.map(v => v.toString()).join('\n')}`)\n    );\n  for (const worker of workers) lHeap.add(worker);\n  let ans = 0;\n  while (n) {\n    console.log('=====loop====');\n    console.log(`ans = ${ans}, n = ${n}`);\n    printHeap({ lHeap, rHeap, pickHeap, putHeap });\n    while (pickHeap.size && pickHeap.top.wait <= ans) rHeap.add(pickHeap.remove());\n    while (putHeap.size && putHeap.top.wait <= ans) lHeap.add(putHeap.remove());\n    if (lHeap.isEmpty && rHeap.isEmpty) {\n      const pick = pickHeap.top?.wait ?? Infinity;\n      const put = putHeap.top?.wait ?? Infinity;\n      if (pick < put) ans = pickHeap.top.wait;\n      else ans = putHeap.top.wait;\n      while (pickHeap.size && pickHeap.top[0] <= ans) rHeap.add(pickHeap.remove()), n--;\n      while (putHeap.size && putHeap.top[0] <= ans) lHeap.add(putHeap.remove());\n    }\n    if (rHeap.size) {\n      ans += rHeap.top.r2l;\n      const worker = rHeap.remove();\n      worker.wait = ans + worker.putNew;\n      putHeap.add(worker);\n    } else if (lHeap.size && n) {\n      ans += lHeap.top.l2r;\n      const worker = lHeap.remove();\n      worker.wait = ans + worker.pickOld;\n      pickHeap.add(worker);\n      n--;\n    }\n  }\n  while (rHeap.size || pickHeap.size) {\n    console.log('=====after====');\n    console.log(`ans = ${ans}, n = ${n}`);\n    printHeap({ lHeap, rHeap, pickHeap, putHeap });\n    if (rHeap.size) ans += rHeap.remove().r2l;\n    while (pickHeap.size && pickHeap.top.wait <= ans) rHeap.add(pickHeap.remove());\n    if (rHeap.isEmpty && pickHeap.size) ans = pickHeap.top.wait;\n  }\n  return ans;\n}"},{"date":"2023-01-08","time":36,"memory":3.6,"script":"rust","desc":"同上。","code":"use std::{cmp::Ordering, collections::BinaryHeap};\n#[derive(Eq, Ord, PartialEq)]\nstruct Worker {\n    i: i32,\n    l2r: i32,\n    pick_old: i32,\n    r2l: i32,\n    put_new: i32,\n    wait: i32,\n    mode: bool,\n}\n\nimpl Worker {\n    fn new(i: i32, l2r: i32, pick_old: i32, r2l: i32, put_new: i32) -> Self {\n        Worker {\n            i,\n            l2r,\n            pick_old,\n            r2l,\n            put_new,\n            wait: 0,\n            mode: true,\n        }\n    }\n    fn cost(&self) -> i32 {\n        self.l2r + self.r2l\n    }\n    fn cmp(&self, worker: &Worker) -> Ordering {\n        if self.mode {\n            self.cmp_bridge(worker)\n        } else {\n            self.cmp_wait(worker)\n        }\n    }\n    fn cmp_bridge(&self, worker: &Worker) -> Ordering {\n        if self.cost() != worker.cost() {\n            self.cost().cmp(&worker.cost())\n        } else {\n            self.i.cmp(&worker.i)\n        }\n    }\n    fn cmp_wait(&self, worker: &Worker) -> Ordering {\n        worker.wait.cmp(&self.wait)\n    }\n    fn set_mode(&mut self, mode: bool) {\n        self.mode = mode;\n    }\n    fn set_bridge_mode(&mut self) {\n        self.set_mode(true)\n    }\n    fn set_wait_mode(&mut self) {\n        self.set_mode(false)\n    }\n}\n\nimpl ToString for Worker {\n    fn to_string(&self) -> String {\n        return format!(\n            \"Worker{}: l2r = {}, r2l = {}, pickOld = {}, putNew = {}, cost = {}, wait = {}\",\n            self.i,\n            self.l2r,\n            self.r2l,\n            self.pick_old,\n            self.put_new,\n            self.cost(),\n            self.wait\n        );\n    }\n}\n\nimpl PartialOrd for Worker {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nfn printHeap(name: &'static str, heap: &BinaryHeap<Worker>) {\n    println!(\"=> {name}({})\", heap.len());\n    for item in heap.iter() {\n        println!(\"{}\", item.to_string());\n    }\n}\nimpl Solution {\n    pub fn find_crossing_time(n: i32, k: i32, time: Vec<Vec<i32>>) -> i32 {\n        let mut n = n;\n        let mut workers = Vec::new();\n        for i in 0..time.len() {\n            workers.push(Worker::new(\n                i as i32, time[i][0], time[i][1], time[i][2], time[i][3],\n            ));\n        }\n        let mut left_heap = BinaryHeap::<Worker>::new();\n        let mut right_heap = BinaryHeap::<Worker>::new();\n        let mut pick_heap = BinaryHeap::<Worker>::new();\n        let mut put_heap = BinaryHeap::<Worker>::new();\n        for worker in workers {\n            left_heap.push(worker);\n        }\n        let mut ans = 0;\n        while n > 0 {\n            // println!(\"====loop====\");\n            // println!(\"ans = {ans}, n = {n}\");\n            // printHeap(\"left_heap\", &left_heap);\n            // printHeap(\"right_heap\", &right_heap);\n            // printHeap(\"pick_heap\", &pick_heap);\n            // printHeap(\"put_heap\", &put_heap);\n            while !pick_heap.is_empty() && pick_heap.peek().unwrap().wait <= ans {\n                let mut worker = pick_heap.pop().unwrap();\n                worker.set_bridge_mode();\n                right_heap.push(worker);\n            }\n            while !put_heap.is_empty() && put_heap.peek().unwrap().wait <= ans {\n                let mut worker = put_heap.pop().unwrap();\n                worker.set_bridge_mode();\n                left_heap.push(worker);\n            }\n            if left_heap.is_empty() && right_heap.is_empty() {\n                let pick = match pick_heap.peek() {\n                    Some(worker) => worker.wait,\n                    None => i32::MAX,\n                };\n                let put = match put_heap.peek() {\n                    Some(worker) => worker.wait,\n                    None => i32::MAX,\n                };\n                ans = pick.min(put);\n            }\n            if !right_heap.is_empty() {\n                let mut worker = right_heap.pop().unwrap();\n                ans += worker.r2l;\n                worker.wait = ans + worker.put_new;\n                worker.set_wait_mode();\n                put_heap.push(worker);\n            } else if !left_heap.is_empty() && n > 0 {\n                let mut worker = left_heap.pop().unwrap();\n                ans += worker.l2r;\n                worker.wait = ans + worker.pick_old;\n                worker.set_wait_mode();\n                pick_heap.push(worker);\n                n -= 1;\n            }\n        }\n        while !right_heap.is_empty() || !pick_heap.is_empty() {\n            // println!(\"====after====\");\n            // println!(\"ans = {ans}, n = {n}\");\n            // printHeap(\"left_heap\", &left_heap);\n            // printHeap(\"right_heap\", &right_heap);\n            // printHeap(\"pick_heap\", &pick_heap);\n            // printHeap(\"put_heap\", &put_heap);\n            if !right_heap.is_empty() {\n                ans += right_heap.pop().unwrap().r2l;\n            }\n            while !pick_heap.is_empty() && pick_heap.peek().unwrap().wait <= ans {\n                let mut worker = pick_heap.pop().unwrap();\n                worker.set_bridge_mode();\n                right_heap.push(worker);\n            }\n            if right_heap.is_empty() && !pick_heap.is_empty() {\n                ans = pick_heap.peek().unwrap().wait;\n            }\n        }\n        ans\n    }\n}"},{"script":"cpp","time":188,"memory":20.5,"desc":"模拟。","code":"#define X first\n#define Y second\nclass Solution {\npublic:\n    typedef pair<int, int> pii;\n    int findCrossingTime(int n, int k, vector<vector<int>>& time) {\n        auto cmp = [&](int i1, int i2) {\n            int v1 = time[i1][0] + time[i1][2], v2 = time[i2][0] + time[i2][2];\n            return v1 < v2 || v1 == v2 && i1 < i2;\n        };\n        priority_queue<int, vector<int>, decltype(cmp)> ql(cmp), qr(cmp);\n        for (int i = 0; i < k; i++) ql.push(i);\n\n        auto cmpp = [&](pii i1, pii i2) {\n            return i2.X < i1.X;\n        };\n        priority_queue<pii, vector<pii>, decltype(cmpp)> qpl(cmpp), qpr(cmpp);\n\n        int res = 0;\n        while (qr.size() || qpr.size() || n > 0) {\n            // cout << \"===> Loop: \" \n            //      << \"n = \" << n\n            //      << \", res = \" << res\n            //      << \", qpl = \" << (qpl.size() ? (long long)qpl.top().X * 100 + qpl.top().Y : -1)\n            //      << \", ql = \" << (ql.size() ? ql.top() : -1)\n            //      << \", qr = \" << (qr.size() ? qr.top() : -1)\n            //      << \", qpr = \" << (qpr.size() ? (long long)qpr.top().X * 100 + qpr.top().Y : -1)\n            //      << endl;\n\n            if ((ql.empty() && qr.empty()) || qr.empty() && qpr.size() && n == 0) {\n                res = max(\n                    res,\n                    min(\n                        qpl.size() ? qpl.top().X : INT_MAX,\n                        qpr.size() ? qpr.top().X : INT_MAX\n                    )\n                );\n            }\n\n            while (qpl.size() && qpl.top().X <= res) {\n                auto cur = qpl.top();\n                qpl.pop();\n                ql.push(cur.Y);\n            }\n            while (qpr.size() && qpr.top().X <= res) {\n                auto cur = qpr.top();\n                qpr.pop();\n                qr.push(cur.Y);\n            }\n\n            if (qr.size()) {\n                auto cur = qr.top();\n                qr.pop();\n                res += time[cur][2];\n                qpl.push(make_pair(res + time[cur][3], cur));\n            } else if (ql.size() && n > 0) {\n                n -= 1;\n                auto cur = ql.top();\n                ql.pop();\n                res += time[cur][0];\n                qpr.push(make_pair(res + time[cur][1], cur));\n            }\n        }\n\n        return res;\n    }\n};","date":"2023-07-07"}],"tagList":["数组","模拟","堆（优先队列）"],"level":"Hard"}},{"problemName":"2535.数组元素和与数字和的绝对差.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2535.数组元素和与数字和的绝对差.json","problemData":{"id":"2624","name":"2535.数组元素和与数字和的绝对差","url":"https://leetcode.cn/problems/difference-between-element-sum-and-digit-sum-of-an-array","desc":"返回 元素和 与 数字和 的绝对差。","solutions":[{"script":"cpp","time":12,"memory":15.2,"desc":"遍历。","code":"class Solution {\npublic:\n    int differenceOfSum(vector<int>& nums) {\n        int num1 = 0, num2 = 0;\n        for (int num : nums) num1 += num, num2 += comp(num);\n        return abs(num1 - num2);\n    }\n    int comp(int num) {\n        int ans = 0;\n        for (; num; num /= 10) ans += num % 10;\n        return ans;\n    }\n};","date":"2023-01-15"},{"script":"rust","time":0,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn difference_of_sum(nums: Vec<i32>) -> i32 {\n        let mut ans = 0;\n        for num in nums {\n            ans += num;\n            ans -= Solution::comp(num);\n        }\n        ans.abs()\n    }\n    fn comp(num: i32) -> i32 {\n        let mut num = num;\n        let mut ans = 0;\n        while num > 0 {\n            ans += num % 10;\n            num /= 10;\n        }\n        ans\n    }\n}","date":"2023-01-15"}],"tagList":["数组","数学"],"level":"Easy"}},{"problemName":"2536.子矩阵元素加1.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2536.子矩阵元素加1.json","problemData":{"id":"2625","name":"2536.子矩阵元素加1","url":"https://leetcode.cn/problems/increment-submatrices-by-one","desc":"返回执行完所有操作后得到的矩阵 mat 。","solutions":[{"script":"cpp","time":316,"memory":86.8,"desc":"差分。","code":"class Solution {\npublic:\n    vector<vector<int>> rangeAddQueries(int n, vector<vector<int>>& queries) {\n        vector<vector<int>> list(n + 1, vector<int>(n + 1, 0)), ans(n, vector<int>(n, 0));\n        for (auto &q : queries) \n            for (int i = q[0]; i <= q[2]; i++) \n                list[i][q[1]]++, list[i][q[3] + 1]--;\n        for (int i = 0; i < n; i++) {\n            int cur = 0;\n            for (int j = 0; j < n; j++) \n                cur += list[i][j], ans[i][j] = cur;\n        }\n        return ans;\n    }\n};","date":"2023-01-15"},{"script":"rust","time":92,"memory":5.5,"desc":"同上。","code":"impl Solution {\n    pub fn range_add_queries(n: i32, queries: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        let n = n as usize;\n        let (mut list, mut ans) = (vec![vec![0; n + 1]; n + 1], vec![vec![0; n]; n]);\n        for q in queries {\n            let mut i = q[0];\n            while i <= q[2] {\n                list[i as usize][q[1] as usize] += 1;\n                list[i as usize][(q[3] + 1) as usize] -= 1;\n                i += 1;\n            }\n        }\n        for i in 0..n {\n            let mut cur = 0;\n            for j in 0..n {\n                cur += list[i][j];\n                ans[i][j] = cur;\n            }\n        }\n        ans\n    }\n}","date":"2023-01-15"}],"tagList":["数组","矩阵","前缀和"],"level":"Medium"}},{"problemName":"2537.统计好子数组的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2537.统计好子数组的数目.json","problemData":{"id":"2626","name":"2537.统计好子数组的数目","url":"https://leetcode.cn/problems/count-the-number-of-good-subarrays","desc":"给你一个整数数组 nums 和一个整数 k ，请你返回 nums 中 好 子数组的数目。","solutions":[{"script":"cpp","time":168,"memory":73.3,"desc":"枚举最右侧节点，对每个最右侧节点统计最近的左侧节点，此时以该节点结尾大于K的有left+1个。","code":"class Solution {\npublic:\n    long long countGood(vector<int>& nums, int k) {\n        long long ans = 0, n = nums.size(), cnt = 0, l = 0;\n        unordered_map<int, int> m;\n        for (int i = 0; i < n; i++) {\n            cnt += m[nums[i]]++;\n            while (l < i && cnt - (m[nums[l]] - 1) >= k) cnt -= m[nums[l++]]-- - 1;\n            if (cnt >= k) ans += l + 1;\n        }\n        return ans;\n    }\n};","date":"2023-01-15"},{"script":"rust","time":44,"memory":4.9,"desc":"同上。","code":"use std::collections::HashMap;\nimpl Solution {\n    pub fn count_good(nums: Vec<i32>, k: i32) -> i64 {\n        let mut ans: i64 = 0;\n        let mut cnt = 0;\n        let mut l = 0;\n        let n = nums.len();\n        let mut m = HashMap::<i32, i32>::new();\n        let mut i = 0;\n        while i < n {\n            let num = nums[i];\n            cnt += m.get(&num).unwrap_or(&0);\n            if !m.contains_key(&num) {\n                m.insert(num, 1);\n            } else {\n                *m.get_mut(&num).unwrap() += 1;\n            }\n            while l < i && cnt - (m.get(&nums[l]).unwrap() - 1) >= k {\n                let v = m.get_mut(&nums[l]).unwrap();\n                *v -= 1;\n                cnt -= *v;\n                l += 1;\n            }\n            if cnt >= k {\n                ans += (l + 1) as i64;\n            }\n            i += 1;\n        }\n        ans\n    }\n}","date":"2023-01-15"}],"tagList":["数组","哈希表","滑动窗口"],"level":"Medium"}},{"problemName":"2538.最大价值和与最小价值和的差值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2538.最大价值和与最小价值和的差值.json","problemData":{"id":"2627","name":"2538.最大价值和与最小价值和的差值","url":"https://leetcode.cn/problems/difference-between-maximum-and-minimum-price-sum","desc":"请你返回所有节点作为根节点的选择中，最大 的 开销 为多少。","solutions":[{"script":"cpp","time":360,"memory":191.3,"desc":"[参考链接](https://leetcode.cn/problems/difference-between-maximum-and-minimum-price-sum/solution/by-endlesscheng-5l70/)。","code":"class Solution {\npublic:\n    typedef long long ll;\n    typedef pair<ll, ll> pll;\n    ll maxOutput(int n, vector<vector<int>>& edges, vector<int>& price) {\n        vector<vector<int>> nodes(n);\n        for (auto &e : edges) {\n            nodes[e[0]].push_back(e[1]);\n            nodes[e[1]].push_back(e[0]);\n        }\n        ll ans = 0;\n        function<pll(int, int)> dfs = [&](int cur, int parent) -> pll {\n            ll p = price[cur], max1 = p, max2 = 0;\n            for (auto &child : nodes[cur]) {\n                if (child == parent) continue;\n                auto res = dfs(child, cur);\n                ans = max(ans, max(max1 + res.second, max2 + res.first));\n                max1 = max(max1, res.first + p);\n                max2 = max(max2, res.second + p);\n            }\n            return make_pair(max1, max2);\n        };\n        dfs(0, -1);\n        return ans;\n    }\n};","date":"2023-01-15"},{"script":"rust","time":48,"memory":25.6,"desc":"同上。","code":"impl Solution {\n    pub fn max_output(n: i32, edges: Vec<Vec<i32>>, price: Vec<i32>) -> i64 {\n        let n = n as usize;\n        let mut nodes: Vec<Vec<i32>> = vec![vec![]; n];\n        for e in edges {\n            nodes[e[0] as usize].push(e[1]);\n            nodes[e[1] as usize].push(e[0]);\n        }\n        Solution::dfs(&nodes, &price, &mut 0, 0, -1).0\n    }\n    fn dfs(\n        nodes: &Vec<Vec<i32>>,\n        price: &Vec<i32>,\n        ans: &mut i64,\n        cur: i32,\n        parent: i32,\n    ) -> (i64, i64, i64) {\n        let p = price[cur as usize] as i64;\n        let mut max1 = p;\n        let mut max2 = 0;\n        for child in (*nodes)[cur as usize].iter() {\n            if *child != parent {\n                let (_, res_max1, res_max2) = Solution::dfs(nodes, price, ans, *child, cur);\n                *ans = *ans.max(&mut (res_max1 + max2)).max(&mut (res_max2 + max1));\n                max1 = max1.max(res_max1 + p);\n                max2 = max2.max(res_max2 + p);\n            }\n        }\n        (*ans, max1, max2)\n    }\n}","date":"2023-01-15"}],"tagList":["树","深度优先搜索","数组","动态规划"],"level":"Hard"}},{"problemName":"2544.交替数字和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2544.交替数字和.json","problemData":{"id":"2630","name":"2544.交替数字和","url":"https://leetcode.cn/problems/alternating-digit-sum","desc":"返回所有数字及其对应符号的和。","solutions":[{"script":"python","time":32,"memory":15,"desc":"遍历。","code":"class Solution:\ndef alternateDigitSum(self, n: int) -> int:\n    ans = 0\n    f = 1\n    if len(str(n)) % 2 == 0:\n        f = -1\n    while n:\n        ans += f * (n % 10)\n        f *= -1\n        n //= 10\n    return ans","date":"2023-01-22"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn alternate_digit_sum(n: i32) -> i32 {\n        let mut n = n;\n        let mut ans = 0;\n        let mut f = if n.to_string().len() % 2 == 0 { -1 } else { 1 };\n        while n > 0 {\n            ans += f * (n % 10);\n            f *= -1;\n            n /= 10;\n        }\n        return ans;\n    }\n}","date":"2023-01-22"},{"script":"cpp","time":4,"memory":5.7,"desc":"遍历。","code":"class Solution {\npublic:\n    int alternateDigitSum(int n) {\n        int len = to_string(n).size(), res = 0, cur = 1;\n        if (len % 2 == 0) cur *= -1; \n        while (n) {\n            res += (n % 10) * cur;\n            cur *= -1;\n            n /= 10;\n        }\n        return res;\n    }\n};","date":"2023-07-12"}],"tagList":["数学"],"level":"Easy"}},{"problemName":"2545.根据第K场考试的分数排序.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2545.根据第K场考试的分数排序.json","problemData":{"id":"2631","name":"2545.根据第K场考试的分数排序","url":"https://leetcode.cn/problems/sort-the-students-by-their-kth-score","desc":"返回排序后的矩阵。","solutions":[{"script":"typescript","time":108,"memory":51,"desc":"排序。","code":"function sortTheStudents(score: number[][], k: number): number[][] {\n    return score.sort((a, b) => b[k] - a[k]);\n}","date":"2023-01-22"},{"script":"python","time":52,"memory":19.4,"desc":"遍历。","code":"class Solution:\ndef sortTheStudents(self, score: List[List[int]], k: int) -> List[List[int]]:\n    score.sort(key=lambda e:e[k], reverse=True)\n    return score","date":"2023-01-22"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn sort_the_students(score: Vec<Vec<i32>>, k: i32) -> Vec<Vec<i32>> {\n        let mut score = score;\n        score.sort_by(move |a, b| b[k as usize].cmp(&a[k as usize]));\n        score\n    }\n}","date":"2023-01-22"}],"tagList":["数组","矩阵","排序"],"level":"Medium"}},{"problemName":"2546.执行逐位运算使字符串相等.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2546.执行逐位运算使字符串相等.json","problemData":{"id":"2632","name":"2546.执行逐位运算使字符串相等","url":"https://leetcode.cn/problems/apply-bitwise-operations-to-make-strings-equal","desc":"如果可以使 s 等于 target ，返回 true ，否则，返回 false 。","solutions":[{"script":"cpp","time":16,"memory":12.8,"desc":"判断是否存在11，10和01的情况。","code":"class Solution {\npublic:\n    bool makeStringsEqual(string s, string target) {\n        if (s == target) return true;\n        int n = s.size();\n        int s_has1 = 0, t_has1 = 0, has11 = 0, has01 = 0, has10 = 0;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '1' && target[i] == '1') return true;\n            if (s[i] == '0' && target[i] == '1') {\n                 has01++;\n                 if (has10) return true;\n            }\n            if (s[i] == '1' && target[i] == '0') {\n                has10++;\n                if (has01) return true;\n            }\n        }\n        return false;\n    }\n};","date":"2023-01-22"},{"script":"cpp","time":24,"memory":12.8,"desc":"判断两个字符串中是否都存在1。","code":"class Solution {\npublic:\n    bool makeStringsEqual(string s, string target) {\n        int n = s.size();\n        bool s1 = false, t1 = false;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == '1') s1 = true;\n            if (target[i] == '1') t1 = true;\n            if (s1 && t1) return true;\n        }\n        return s == target;\n    }\n};","date":"2023-01-22"},{"script":"python","time":36,"memory":15.7,"desc":"同上。","code":"class Solution:\n    def makeStringsEqual(self, s: str, target: str) -> bool:\n        return ('1' in s) and ('1' in target) or s == target","date":"2023-01-22"},{"script":"rust","time":4,"memory":2.6,"desc":"同上。","code":"impl Solution {\n    pub fn make_strings_equal(s: String, target: String) -> bool {\n        s.contains('1') && target.contains('1') || s == target\n    }\n}","date":"2023-01-22"}],"tagList":["位运算","字符串"],"level":"Medium"}},{"problemName":"2547.拆分数组的最小代价.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2547.拆分数组的最小代价.json","problemData":{"id":"2633","name":"2547.拆分数组的最小代价","url":"https://leetcode.cn/problems/minimum-cost-to-split-an-array","desc":"找出并返回拆分 nums 的所有可行方案中的最小代价。","solutions":[{"script":"cpp","time":1576,"memory":306,"desc":"dp判断每个数组作为结尾时的最小开销。","code":"class Solution {\n public:\n     int minCost(vector<int>& nums, int k) {\n         int n = nums.size();\n         vector<int> dp(n + 1, 0x3f3f3f3f);\n         dp[0] = 0;\n         for (int i = 1; i <= n; i++) {\n             unordered_map<int, int> m;\n             int sum = 0;\n             for (int j = i; j >= 1; j--) {\n                 m[nums[j - 1]]++;\n                 if (m[nums[j - 1]] == 2) sum += 2;\n                 else if (m[nums[j - 1]] > 2) sum += 1;\n                 dp[i] = min(dp[i], dp[j - 1] + k + sum);\n             }\n         }\n         return dp[n];\n     }\n };","date":"2023-01-22"},{"script":"python","time":5948,"memory":15.1,"desc":"同上。","code":"class Solution:\ndef minCost(self, nums: List[int], k: int) -> int:\n    n = len(nums)\n    dp = [0x3f3f3f3f for _ in range(n + 1)]\n    dp[0] = 0\n    for i in range(1, n + 1):\n        m = Counter()\n        sum = 0\n        for j in range(i, 0, -1):\n            num = nums[j-1]\n            m[num] += 1\n            if m[num] == 2:\n                sum += 2\n            elif m[num] > 2:\n                sum += 1\n            dp[i] = min(dp[i], dp[j - 1] + k + sum)\n    return dp[n]","date":"2023-01-22"},{"script":"rust","time":312,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn min_cost(nums: Vec<i32>, k: i32) -> i32 {\n        use std::collections::HashMap;\n        let n = nums.len();\n        let mut dp = vec![0x3f3f3f3f;n + 1];\n        dp[0] = 0;\n        for i in 1..=n {\n            let mut m = HashMap::<i32,i32>::new();\n            let mut sum = 0;\n            let mut j = i;\n            while j >= 1 {\n                let num = nums[j-1];\n                let val = m.entry(num).or_insert(0);\n                *val += 1;\n                if *val == 2 {\n                    sum += 2;\n                } else if *val > 2 {\n                    sum += 1;\n                }\n                dp[i] = dp[i].min(dp[j - 1] + k + sum);\n                j-=1;\n            }\n        }\n        dp[n]\n    }\n}","date":"2023-01-22"}],"tagList":["数组","哈希表","动态规划","计数"],"level":"Hard"}},{"problemName":"2549.统计桌面上的不同数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2549.统计桌面上的不同数字.json","problemData":{"id":"2679","name":"2549.统计桌面上的不同数字","url":"https://leetcode.cn/problems/count-distinct-numbers-on-board","desc":"返回在 109 天之后，出现在桌面上的 不同 整数的数目。","solutions":[{"script":"python","time":40,"memory":16.48,"desc":"最后会获取所有的数。","code":"class Solution:\n    def distinctIntegers(self, n: int) -> int:\n        return n - 1 if n > 1 else n","date":"2024-03-23"}],"tagList":["数组","哈希表","数学","模拟"],"level":"Easy"}},{"problemName":"2550.猴子碰撞的方法数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2550.猴子碰撞的方法数.json","problemData":{"id":"2680","name":"2550.猴子碰撞的方法数","url":"https://leetcode.cn/problems/count-collisions-of-monkeys-on-a-polygon","desc":"返回猴子至少发生 一次碰撞 的移动方法数。由于答案可能非常大，请返回对 109+7 取余后的结果。","solutions":[{"script":"cpp","time":4,"memory":6.3,"desc":"贪心， 只有在都顺和都逆才不相撞, 快速幂。","code":"typedef long long ll;\nint mod = 1e9 + 7;\nll quick_pow(ll a, ll b) {\n    ll ans = 1, tmp = a;\n    for (; b; b >>= 1) {\n        if (b & 1) ans = (ans * tmp) % mod;\n        tmp = (tmp * tmp) % mod;\n    }\n    return ans;\n}\n\nclass Solution {\npublic:\n    int monkeyMove(int n) {\n        return (quick_pow(2, n) + mod - 2) % mod;\n    }\n};","date":"2023-01-29"},{"script":"python","time":32,"memory":14.8,"desc":"同上。","code":"class Solution:\n    def monkeyMove(self, n: int) -> int:\n        mod = 10 ** 9 + 7\n        return (pow(2, n, mod) + mod - 2) % mod","date":"2023-01-29"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"fn pow(base: i64, exp: i64, mod_num: i64) -> i64 {\n    let mut exp = exp;\n    let mut tmp = base;\n    let mut ans = 1;\n    while exp != 0 {\n        if exp % 2 == 1 {\n            ans = (ans * tmp) % mod_num;\n        }\n        tmp = (tmp * tmp) % mod_num;\n        exp >>= 1\n    }\n    ans\n}\n\nimpl Solution {\n    pub fn monkey_move(n: i32) -> i32 {\n        let mod_num = 1000000007;\n        ((pow(2, n as i64, mod_num) + mod_num - 2) % mod_num) as i32\n    }\n}","date":"2023-01-29"}],"tagList":["递归","数学"],"level":"Medium"}},{"problemName":"2551.将珠子放入背包中.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2551.将珠子放入背包中.json","problemData":{"id":"2681","name":"2551.将珠子放入背包中","url":"https://leetcode.cn/problems/put-marbles-in-bags","desc":"一个珠子分配方案的 分数 是所有 k 个背包的价格之和。请你返回所有分配方案中，最大分数 与 最小分数 的 差值 为多少。","solutions":[{"script":"cpp","time":152,"memory":67.6,"desc":"贪心，只统计首位，当一个珠子当前组是末尾时，下一个珠子是下一组的首个。","code":"class Solution {\npublic:\n    long long putMarbles(vector<int>& weights, int k) {\n        vector<long long> list;\n        for (int i = 1; i < weights.size(); i++) list.push_back(weights[i - 1] + weights[i]);\n        sort(list.begin(), list.end());\n        long long ans = 0;\n        for (int i = 0; i < k - 1; i++) ans += list[list.size() - i - 1] - list[i];\n        return ans;\n    }\n};","date":"2023-01-29"},{"script":"python","time":224,"memory":25.4,"desc":"同上。","code":"class Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        list=[]\n        n = len(weights)\n        for i in range(1, n):\n            list.append(weights[i - 1] + weights[i])\n        list.sort()\n        return sum(list[len(list) - k + 1:]) - sum(list[:k - 1])","date":"2023-01-29"},{"script":"rust","time":40,"memory":3.5,"desc":"同上。","code":"impl Solution {\n    pub fn put_marbles(weights: Vec<i32>, k: i32) -> i64 {\n        let mut list = Vec::new();\n        for i in 1..weights.len() {\n            list.push(weights[i - 1] + weights[i]);\n        }\n        list.sort();\n        let mut ans = 0;\n        for i in 0..k - 1 {\n            let i = i as usize;\n            ans += (list[list.len() - i - 1] - list[i]) as i64;\n        }\n        ans\n    }\n}","date":"2023-01-29"},{"script":"rust","time":36,"memory":3.5,"desc":"同上。","code":"impl Solution {\n    pub fn put_marbles(weights: Vec<i32>, k: i32) -> i64 {\n        let mut list = Vec::new();\n        for i in 1..weights.len() {\n            list.push(weights[i - 1] + weights[i]);\n        }\n        list.sort();\n        let fold = |sum, cur: &i32| sum + (*cur) as i64;\n        list[list.len() - k as usize + 1..].iter().fold(0, fold)\n            - list[..k as usize - 1].iter().fold(0, fold)\n    }\n}","date":"2023-01-29"}],"tagList":["贪心","数组","排序","堆（优先队列）"],"level":"Hard"}},{"problemName":"2552.统计上升四元组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2552.统计上升四元组.json","problemData":{"id":"2682","name":"2552.统计上升四元组","url":"https://leetcode.cn/problems/count-increasing-quadruplets","desc":"给你一个长度为 n 下标从 0 开始的整数数组 nums ，它包含 1 到 n 的所有数字，请你返回上升四元组的数目。","solutions":[{"script":"cpp","time":272,"memory":10.6,"desc":"枚举l，对于每一个l，查找可能的j，记录j的132模式个数，即i<j<k&&v[i]<v[k]<v[j]。","code":"class Solution {\npublic:\n    typedef long long ll;\n    ll countQuadruplets(vector<int>& nums) {\n        int n = nums.size();\n        ll ans = 0;\n        vector<int> list(n, 0);\n        for (int l = 0; l < n; l++) {\n            for (int j = 0; j < l - 1; j++) {\n                if (nums[j] < nums[l]) ans += list[j];\n            }\n            for (int j = 0, cnt = 0; j < l; j++) {\n                if (nums[j] > nums[l]) list[j] += cnt;\n                if (nums[j] < nums[l]) cnt++;\n            }\n        }\n        return ans;\n    }\n};","date":"2023-02-01"},{"script":"python","time":2284,"memory":15.2,"desc":"同上。","code":"class Solution:\n    def countQuadruplets(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = 0\n        list = [0] * n\n        for l in range(n):\n            for j in range(l):\n                if nums[j] < nums[l]:\n                    ans += list[j]\n            cnt = 0\n            for j in range(l):\n                if nums[j] > nums[l]:\n                    list[j] += cnt\n                if nums[j] < nums[l]:\n                    cnt += 1\n        return ans","date":"2023-02-01"},{"script":"rust","time":72,"memory":2.1,"desc":"同上。","code":"impl Solution {\n    pub fn count_quadruplets(nums: Vec<i32>) -> i64 {\n        let n = nums.len();\n        let mut list = vec![0; n];\n        let mut ans = 0;\n        for l in 0..n {\n            for j in 0..l {\n                if nums[j] < nums[l] {\n                    ans += list[j];\n                }\n            }\n            let mut cnt = 0;\n            for j in 0..l {\n                if nums[j] > nums[l] {\n                    list[j] += cnt;\n                }\n                if nums[j] < nums[l] {\n                    cnt += 1;\n                }\n            }\n        }\n        ans\n    }\n}","date":"2023-02-01"}],"tagList":["树状数组","数组","动态规划","枚举","前缀和"],"level":"Hard"}},{"problemName":"2558.从数量最多的堆取走礼物.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2558.从数量最多的堆取走礼物.json","problemData":{"id":"2692","name":"2558.从数量最多的堆取走礼物","url":"https://leetcode.cn/problems/take-gifts-from-the-richest-pile","desc":"返回在 k 秒后剩下的礼物数量。","solutions":[{"script":"python","time":52,"memory":15.66,"desc":"堆。","code":"class Solution:\n    def pickGifts(self, gifts: List[int], k: int) -> int:\n        gifts = [-v for v in gifts]\n        heapify(gifts)\n        for _ in range(k):\n            heappush(gifts, -int((-heappop(gifts)) ** 0.5))\n        return -sum(gifts)","date":"2023-10-28"}],"tagList":["数组","模拟","堆（优先队列）"],"level":"Easy"}},{"problemName":"2559.统计范围内的元音字符串数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2559.统计范围内的元音字符串数.json","problemData":{"id":"2691","name":"2559.统计范围内的元音字符串数","url":"https://leetcode.cn/problems/count-vowel-strings-in-ranges","desc":"给你一个下标从 0 开始的字符串数组 words 以及一个二维整数数组 queries 。返回一个整数数组，其中数组的第 i 个元素对应第 i 个查询的答案。","solutions":[{"script":"cpp","time":128,"memory":63.1,"desc":"前缀和。","code":"class Solution {\npublic:\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\n        int n = words.size();\n        vector<int> sums(1, 0), ans;\n        unordered_set<char> s;\n        s.insert('a');\n        s.insert('e');\n        s.insert('i');\n        s.insert('o');\n        s.insert('u');\n        for (auto &w : words) {\n            bool f = s.count(w[0]) && s.count(w[w.size() - 1]);\n            sums.push_back(sums.back() + f);\n        }\n        for (auto &q : queries) {\n            ans.push_back(sums[q[1] + 1] - sums[q[0]]);\n        }\n        return ans;\n    }\n};","date":"2023-02-05"},{"script":"python","time":80,"memory":46.7,"desc":"同上。","code":"class Solution:\n  def vowelStrings(self, words: List[str], queries: List[List[int]]) -> List[int]:\n      s = {'a', 'e', 'i', 'o', 'u'}\n      sums = list(accumulate(\n          (w[0] in s and w[-1] in s for w in words), initial=0))\n      return [sums[r + 1] - sums[l] for l, r in queries]","date":"2023-02-05"},{"script":"rust","time":28,"memory":14.1,"desc":"同上。","code":"impl Solution {\n    pub fn vowel_strings(words: Vec<String>, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        use std::collections::HashSet;\n        let mut set = HashSet::<char>::new();\n        for c in \"aeiou\".to_string().chars().collect::<Vec<char>>() {\n            set.insert(c);\n        }\n        let mut sums = vec![0; 1];\n        for w in words {\n            let w = w.chars().collect::<Vec<char>>();\n            let f = if set.contains(w.first().unwrap()) && set.contains(w.last().unwrap()) {\n                1\n            } else {\n                0\n            };\n            sums.push(f + *sums.last().unwrap());\n        }\n        let mut ans = vec![];\n        for q in queries {\n            ans.push(sums[q[1] as usize + 1] - sums[q[0] as usize]);\n        }\n        ans\n    }\n}\n      ","date":"2023-02-05"},{"script":"cpp","time":148,"memory":63.1,"desc":"前缀和。","code":"class Solution {\npublic:\n    vector<int> vowelStrings(vector<string>& words, vector<vector<int>>& queries) {\n        unordered_set<char> s{ 'a', 'e', 'i', 'o', 'u'};\n        vector<int> sums(1, 0);\n        for (auto &w : words) sums.push_back(sums.back() + (s.count(w[0]) && s.count(w.back()) ? 1 : 0));\n        vector<int> res;\n        for (auto &q : queries) res.push_back(sums[q[1] + 1] - sums[q[0]]);\n        return res;\n    }\n};","date":"2023-06-02"}],"tagList":["数组","字符串","前缀和"],"level":"Medium"}},{"problemName":"2560.打家劫舍IV.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2560.打家劫舍IV.json","problemData":{"id":"2690","name":"2560.打家劫舍IV","url":"https://leetcode.cn/problems/house-robber-iv","desc":"给你一个下标从 0 开始的字符串数组 words 以及一个二维整数数组 queries 。返回一个整数数组，其中数组的第 i 个元素对应第 i 个查询的答案。","solutions":[{"script":"cpp","time":136,"memory":55.6,"desc":"结果二分+dp。","code":"class Solution {\npublic:\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\n        unordered_map<int, int> m;\n        for (auto &v : basket1) m[v]++;\n        for (auto &v : basket2) m[v]--;\n        vector<int> list;\n        int nmin = 0x3f3f3f3f;\n        for (auto &item : m) {\n            if (item.second % 2 != 0) return -1;\n            nmin = min(nmin, item.first);\n            for (int i = 0; i < abs(item.second) / 2; i++) list.push_back(item.first);\n        }\n        sort(list.begin(), list.end());\n        long long ans = 0;\n        for (int i = 0; i < list.size() / 2; i++) ans += min(list[i], nmin * 2);\n        return ans;\n    }\n};","date":"2023-02-05"},{"script":"python","time":740,"memory":22.9,"desc":"同上。","code":"class Solution:\n    def minCapability(self, nums: List[int], k: int) -> int:\n        def bs(target):\n            prev1, prev2 = 0, 0\n            for num in nums:\n                if num <= target:\n                    prev1, prev2 = prev2, max(prev1 + 1, prev2)\n                else:\n                    prev1 = prev2\n            return prev2\n        l, r = 1, max(nums)\n        while l < r:\n            m = (l + r) // 2\n            if bs(m) >= k: r = m\n            else: l = m + 1\n        return l","date":"2023-02-05"},{"script":"rust","time":16,"memory":4,"desc":"同上。","code":"impl Solution {\n    pub fn min_capability(nums: Vec<i32>, k: i32) -> i32 {\n        let (mut l, mut r) = (1, 1);\n        for num in nums.iter() {\n            r = r.max(*num);\n        }\n        let bs = move |target| {\n            let (mut prev1, mut prev2) = (0, 0);\n            for num in nums.iter() {\n                if *num <= target {\n                    let tmp = prev2;\n                    prev2 = prev2.max(prev1 + 1);\n                    prev1 = tmp;\n                } else {\n                    prev1 = prev2;\n                }\n            }\n            prev2\n        };\n        while l < r {\n            let m = (l + r) / 2;\n            if bs(m) >= k {\n                r = m;\n            } else {\n                l = m + 1\n            }\n        }\n        l\n    }\n}","date":"2023-02-05"},{"script":"python","time":520,"memory":27.9,"desc":"同上。","code":"class Solution:\n    def minCapability(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n\n        def check(target: int) -> bool:\n            cnt = 0\n            prev = -1\n            for i in range(n):\n                if nums[i] <= target and (prev == -1 or prev + 1 != i):\n                    prev = i\n                    cnt += 1\n            return cnt >= k\n\n        l, r = min(nums), max(nums)\n        while l < r:\n            m = (l + r) // 2\n            if check(m):\n                r = m\n            else:\n                l = m + 1\n        return l","date":"2023-09-19"}],"tagList":["数组","二分查找"],"level":"Medium"}},{"problemName":"2561.重排水果.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2561.重排水果.json","problemData":{"id":"2689","name":"2561.重排水果","url":"https://leetcode.cn/problems/rearranging-fruits","desc":"给你一个下标从 0 开始的字符串数组 words 以及一个二维整数数组 queries 。返回一个整数数组，其中数组的第 i 个元素对应第 i 个查询的答案。","solutions":[{"script":"cpp","time":140,"memory":83.8,"desc":"先抵消相同数字, 后最小和最大值进行匹配, 同时考虑两个值通过最小值进行一次交换。","code":"class Solution {\npublic:\n    long long minCost(vector<int>& basket1, vector<int>& basket2) {\n        unordered_map<int, int> m;\n        for (auto &v : basket1) m[v]++;\n        for (auto &v : basket2) m[v]--;\n        vector<int> list;\n        int nmin = 0x3f3f3f3f;\n        for (auto &item : m) {\n            if (item.second % 2  != 0) return -1;\n            nmin = min(nmin, item.first);\n            for (int i = 0; i < abs(item.second) / 2; i++) list.push_back(item.first);\n        }\n        sort(list.begin(), list.end());\n        long long ans = 0;\n        for (int i = 0; i < list.size() / 2; i++) ans += min(list[i], nmin * 2);\n        return ans;\n    }\n};","date":"2023-02-05"},{"script":"python","time":212,"memory":36.7,"desc":"同上。","code":"class Solution:\n  def minCost(self, basket1: List[int], basket2: List[int]) -> int:\n      m = Counter()\n      for num1, num2 in zip(basket1, basket2):\n          m[num1] += 1\n          m[num2] -= 1\n      nmin = min(m)\n      l = []\n      for k, v in m.items():\n          if v % 2 != 0:\n              return -1\n          for _ in range(abs(v) // 2):\n              l.append(k)\n      l.sort()\n      ans = 0\n      for i in range(len(l) // 2):\n          ans += min(l[i], nmin * 2)\n      return ans","date":"2023-02-05"},{"script":"rust","time":32,"memory":4.9,"desc":"同上。","code":"impl Solution {\n    pub fn min_cost(basket1: Vec<i32>, basket2: Vec<i32>) -> i64 {\n        use std::collections::HashMap;\n        let mut m = HashMap::<i32, i32>::new();\n        for num in basket1 {\n            let v = m.entry(num).or_insert(0);\n            *v += 1;\n        }\n        for num in basket2 {\n            let v = m.entry(num).or_insert(0);\n            *v -= 1;\n        }\n        let mut nmin = i32::MAX;\n        let mut list = vec![];\n        for (k, v) in m.iter() {\n            if *v % 2 != 0 {\n                return -1;\n            }\n            nmin = nmin.min(*k);\n            for _ in 0..(*v).abs() / 2 {\n                list.push(*k);\n            }\n        }\n        list.sort();\n        let mut ans = 0;\n        for i in 0..list.len() / 2 {\n            ans += list[i].min(nmin * 2) as i64;\n        }\n        ans\n    }\n}","date":"2023-02-05"}],"tagList":["贪心","数组","哈希表"],"level":"Hard"}},{"problemName":"2562.找出数组的串联值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2562.找出数组的串联值.json","problemData":{"id":"2698","name":"2562.找出数组的串联值","url":"https://leetcode.cn/problems/find-the-array-concatenation-value","desc":"返回执行完所有操作后 nums 的串联值。","solutions":[{"script":"cpp","time":8,"memory":9,"desc":"遍历。","code":"class Solution {\npublic:\n    long long findTheArrayConcVal(vector<int>& nums) {\n        long long res = 0;\n        while (nums.size() >= 2) {\n            long long num1 = nums[0], num2 = nums[nums.size() - 1];\n            res += merge(num1, num2);\n            nums.erase(nums.begin());\n            nums.pop_back();\n        }\n        if (nums.size() == 1) res += nums[0];\n        return res;\n    }\n    long long merge(long long num1, long long num2) {\n        return num1 * pow(10, cnt(num2)) + num2; \n    }\n    int cnt(long long num) {\n        int res = 0;\n        while (num) {\n            res += 1;\n            num /= 10;\n        }\n        return res;\n    }\n};","date":"2023-02-12"},{"script":"python","time":44,"memory":14.9,"desc":"同上。","code":"class Solution:\n    def findTheArrayConcVal(self, nums: List[int]) -> int:\n        res = 0\n        while len(nums) >= 2:\n            num1, num2 = nums[0], nums[-1]\n            res += int(str(num1) + str(num2))\n            nums = nums[1:-1]\n        if len(nums) == 1:\n            res += nums[0]\n        return res","date":"2023-02-12"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn find_the_array_conc_val(nums: Vec<i32>) -> i64 {\n        let mut nums = &nums[..];\n        let mut res = 0;\n        while nums.len() >= 2 {\n            let (num1, num2) = (nums.first().unwrap(), nums.last().unwrap());\n            res += [(*num1).to_string(), (*num2).to_string()]\n                .concat()\n                .parse::<i64>()\n                .unwrap();\n            nums = &nums[1..nums.len() - 1];\n        }\n        if nums.len() == 1 {\n            res += nums[0] as i64;\n        }\n        res\n    }\n}","date":"2023-02-12"}],"tagList":["数组","双指针","模拟"],"level":"Easy"}},{"problemName":"2563.统计公平数对的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2563.统计公平数对的数目.json","problemData":{"id":"2699","name":"2563.统计公平数对的数目","url":"https://leetcode.cn/problems/count-the-number-of-fair-pairs","desc":"给你一个下标从 0 开始、长度为 n 的整数数组 nums ，和两个整数 lower 和 upper ，返回 公平数对的数目 。","solutions":[{"script":"cpp","time":124,"memory":52.2,"desc":"双指针。","code":"\nclass Solution {\npublic:\n    long long countFairPairs(vector<int>& nums, int lower, int upper) {\n        sort(nums.begin(), nums.end());\n        long long res = 0;\n        int l = 0, r = 0, n = nums.size();\n        for (int i = 1; i < n; i++) {\n            while (r + 1 < i && nums[r + 1] + nums[i] <= upper) r++;\n            while (r - 1 >= 0 && nums[r] + nums[i] > upper) r--;            \n            while (l + 1 < i && nums[l] + nums[i] < lower) l++;\n            while (l - 1 >= 0 && nums[l - 1] + nums[i] >= lower) l--;\n            if (r > l) res += r - l + 1;\n            else if (r == l && nums[l] + nums[i] >= lower && nums[l] + nums[i] <= upper) res += 1;  \n        }\n        return res;\n    }\n};","date":"2023-02-12"},{"script":"python","time":312,"memory":26.7,"desc":"同上。","code":"class Solution:\n  def countFairPairs(self, nums: List[int], lower: int, upper: int) -> int:\n      nums.sort()\n      res = 0\n      l, r, n = 0, 0, len(nums)\n      for i in range(1, n):\n          while r + 1 < i and nums[r + 1] + nums[i] <= upper:\n              r += 1\n          while r - 1 >= 0 and nums[r] + nums[i] > upper:\n              r -= 1\n          while l + 1 < i and nums[l] + nums[i] < lower:\n              l += 1\n          while l - 1 >= 0 and nums[l - 1] + nums[i] >= lower:\n              l -= 1\n          if r > l:\n              res += r - l + 1\n          elif r == l and nums[l] + nums[i] >= lower and nums[l] + nums[i] <= upper:\n              res += 1\n      return res","date":"2023-02-12"},{"script":"rust","time":36,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn count_fair_pairs(nums: Vec<i32>, lower: i32, upper: i32) -> i64 {\n        let mut nums = nums;\n        nums.sort();\n        let mut res: i64 = 0;\n        let (mut l, mut r, n): (i64, i64, usize) = (0, 0, nums.len());\n        for i in 1..n {\n            while r + 1 < i as i64 && nums[r as usize + 1] + nums[i] <= upper {\n                r += 1\n            }\n            while r - 1 >= 0 && nums[r as usize] + nums[i] > upper {\n                r -= 1\n            }\n            while l + 1 < i as i64 && nums[l as usize] + nums[i] < lower {\n                l += 1\n            }\n            while l - 1 >= 0 && nums[l as usize - 1] + nums[i] >= lower {\n                l -= 1\n            }\n            if r > l {\n                res += (r - l + 1) as i64;\n            } else if r == l && nums[l as usize] + nums[i] >= lower && nums[l as usize] + nums[i] <= upper {\n                res += 1\n            }\n        }\n        res\n    }\n}","date":"2023-02-12"}],"tagList":["数组","双指针","二分查找","排序"],"level":"Medium"}},{"problemName":"2564.子字符串异或查询.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2564.子字符串异或查询.json","problemData":{"id":"2700","name":"2564.子字符串异或查询","url":"https://leetcode.cn/problems/substring-xor-queries","desc":"请你返回一个数组 ans ，其中 ans[i] = [lefti, righti] 是第 i 个查询的答案。","solutions":[{"script":"typescript","time":2752,"memory":87.9,"desc":"暴力。","code":"function substringXorQueries(s: string, queries: number[][]): number[][] {\n  return queries\n    .map(([v1, v2]) => (v1 ^ v2).toString(2))\n    .map(item => {\n      const i = s.indexOf(item);\n      if (i == -1) return [-1, -1];\n      return [i, i + item.length - 1];\n    });\n}","date":"2023-02-12"},{"script":"cpp","time":356,"memory":116.2,"desc":"预处理。","code":"class Solution {\npublic:\n    typedef pair<int, int> pii;\n    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {\n        unordered_map<int, pii> m;\n        for (int i = 0; i < s.size(); i++) {\n            int cur = 0;\n            for (int j = i; j < min((int)s.size(), i + 30); j++) {\n                cur = (cur << 1) | (s[j] - '0');\n                if (!m.count(cur) || m[cur].second - m[cur].first + 1 > j - i + 1) m[cur] = make_pair(i, j); \n            }\n        }\n        vector<vector<int>> ans;\n        for (auto &q : queries) {\n            int target = q[0] ^ q[1];\n            vector<int> item(2, -1);\n            if (m.count(target)) item[0] = m[target].first, item[1] = m[target].second;\n            ans.push_back(item);\n        }\n        return ans;\n    }\n};","date":"2023-02-12"},{"script":"python","time":532,"memory":56.9,"desc":"同上。","code":"class Solution:\n    def substringXorQueries(self, s: str, queries: List[List[int]]) -> List[List[int]]:\n        m = defaultdict()\n        for i in range(len(s)):\n            cur = 0\n            for j in range(i, min(len(s), i + 30)):\n                cur = (cur << 1) | (ord(s[j]) - ord('0'))\n                if cur in m:\n                    print(m[cur][1] - m[cur][0])\n                if cur not in m or m[cur][1] - m[cur][0] >= j - i + 1:\n                    m[cur] = (i, j)\n        return [\n            m.get(n1 ^ n2, (-1, -1))\n            for n1, n2 in queries\n        ]","date":"2023-02-12"},{"script":"rust","time":76,"memory":13.9,"desc":"同上。","code":"impl Solution {\n    pub fn substring_xor_queries(s: String, queries: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        use std::collections::HashMap;\n        let mut m = HashMap::<i32, (usize, usize)>::new();\n        let s = s.chars().collect::<Vec<char>>();\n        for i in 0..s.len() {\n            let mut cur = 0;\n            for j in i..s.len().min(i + 30) {\n                cur = ((cur << 1) | (s[j] as usize - '0' as usize) as i32);\n                if !m.contains_key(&cur) {\n                    m.insert(cur, (i, j));\n                } else {\n                    let item = m.get_mut(&cur).unwrap();\n                    if item.1 - item.0 + 1 > j - i + 1 {\n                        item.0 = i;\n                        item.1 = j\n                    };\n                }\n            }\n        }\n        let mut ans: Vec<Vec<i32>> = vec![];\n        for q in queries {\n            let target = q[0] ^ q[1];\n            let mut item = vec![-1i32; 2];\n            if let Some((l, r)) = m.get(&target) {\n                item[0] = *l as i32;\n                item[1] = *r as i32;\n            }\n            ans.push(item);\n        }\n        ans\n    }\n}","date":"2023-02-12"}],"tagList":["位运算","数组","哈希表","字符串"],"level":"Medium"}},{"problemName":"2565.最少得分子序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2565.最少得分子序列.json","problemData":{"id":"2701","name":"2565.最少得分子序列","url":"https://leetcode.cn/problems/subsequence-with-the-minimum-score","desc":"请你返回使 t 成为 s 子序列的最小得分。","solutions":[{"script":"cpp","time":16,"memory":11.2,"desc":"前后缀匹配，把s分成前后两部分进行枚举，对于每一部分尝试匹配t的前后缀的最大长度。","code":"class Solution {\npublic:\n    int minimumScore(string s, string t) {\n        int n = s.size(), m = t.size();\n        vector<int> pre(n), suf(n + 1, m);\n        for (int i = 0, p = 0; i < n && p < m; i++) {\n            if (s[i] == t[p]) p++;\n            pre[i] = p;\n        }\n        for (int i = n - 1, p = m - 1; i >= 0 && p >= 0; i--) {\n            if (s[i] == t[p]) p--;\n            suf[i] = p + 1;\n        }\n        int res = suf[0];\n        for (int i = 0; i < n; i++) {\n            if (suf[i + 1] < pre[i]) return 0;\n            res = min(res, suf[i + 1] - pre[i]);\n        }\n        return res;\n    }\n};","date":"2023-02-12"},{"script":"python","time":156,"memory":23.2,"desc":"同上。","code":"class Solution:\n    def minimumScore(self, s: str, t: str) -> int:\n        n, m = len(s), len(t)\n        pre, suf = [0] * n, [m] * (n + 1)\n        i, p = 0, 0\n        while i < n and p < m:\n            if s[i] == t[p]:\n                p += 1\n            pre[i] = p\n            i += 1\n        i, p = n-1, m-1\n        while i >= 0 and p >= 0:\n            if s[i] == t[p]:\n                p -= 1\n            suf[i] = p+1\n            i -= 1\n        res = suf[0]\n        for i in range(n):\n            if suf[i + 1] < pre[i]:\n                return 0\n            res = min(res, suf[i + 1] - pre[i])\n        return res","date":"2023-02-12"},{"script":"rust","time":0,"memory":4.8,"desc":"同上。","code":"impl Solution {\n    pub fn minimum_score(s: String, t: String) -> i32 {\n        let (s, t) = (\n            s.chars().collect::<Vec<char>>(),\n            t.chars().collect::<Vec<char>>(),\n        );\n        let (n, m) = (s.len(), t.len());\n        let (mut pre, mut suf) = (vec![0; n], vec![m; n + 1]);\n        let (mut i, mut p) = (0, 0);\n        while i < n && p < m {\n            if s[i] == t[p] {\n                p += 1;\n            }\n            pre[i] = p;\n            i += 1;\n        }\n        let (mut i, mut p) = ((n - 1) as i32, (m - 1) as i32);\n        while i >= 0 && p >= 0 {\n            if s[i as usize] == t[p as usize] {\n                p -= 1;\n            }\n            suf[i as usize] = p as usize + 1;\n            i -= 1;\n        }\n        let mut res = suf[0];\n        for i in 0..n {\n            if suf[i + 1] < pre[i] {\n                return 0;\n            }\n            res = res.min(suf[i + 1] - pre[i]);\n        }\n        res as i32\n    }\n}","date":"2023-02-12"}],"tagList":["双指针","字符串","二分查找"],"level":"Hard"}},{"problemName":"2570.合并两个二维数组-求和法.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2570.合并两个二维数组-求和法.json","problemData":{"id":"2707","name":"2570.合并两个二维数组-求和法","url":"https://leetcode.cn/problems/merge-two-2d-arrays-by-summing-values","desc":"合并两个二维数组。","solutions":[{"script":"cpp","time":8,"memory":10.4,"desc":"遍历。","code":"class Solution {\n    public:\n        vector<vector<int>> mergeArrays(vector<vector<int>>& nums1, vector<vector<int>>& nums2) {\n            vector<vector<int>> ans;\n            int i1 = 0, i2 = 0;\n            int n1 = nums1.size(), n2 = nums2.size();\n            while (i1 < n1 || i2 < n2) {\n                if (i1 == n1) ans.push_back(nums2[i2++]);\n                else if (i2 == n2) ans.push_back(nums1[i1++]);\n                else {\n                    if (nums1[i1][0] == nums2[i2][0]) {\n                        vector<int> item(2, nums1[i1][0]);\n                        item[1] = nums1[i1++][1] + nums2[i2++][1];\n                        ans.push_back(item);\n                    } else if (nums1[i1][0] < nums2[i2][0]) {\n                        ans.push_back(nums1[i1++]);\n                    } else {\n                        ans.push_back(nums2[i2++]);\n                    }\n                }\n            }\n            return ans;\n        }\n    };","date":"2023-02-19"},{"script":"python","time":40,"memory":15.1,"desc":"同上。","code":"class Solution:\n    def mergeArrays(self, nums1: List[List[int]], nums2: List[List[int]]) -> List[List[int]]:\n        ans = []\n        i1, i2, n1, n2 = 0, 0, len(nums1), len(nums2)\n        while i1 < n1 or i2 < n2:\n            if i1 == n1:\n                ans.append(nums2[i2])\n                i2 += 1\n            elif i2 == n2:\n                ans.append(nums1[i1])\n                i1 += 1\n            else:\n                if nums1[i1][0] == nums2[i2][0]:\n                    ans.append([\n                        nums1[i1][0],\n                        nums1[i1][1] + nums2[i2][1]\n                    ])\n                    i1 += 1\n                    i2 += 1\n                elif nums1[i1][0] < nums2[i2][0]:\n                    ans.append(nums1[i1])\n                    i1 += 1\n                else:\n                    ans.append(nums2[i2])\n                    i2 += 1\n        return ans","date":"2023-02-19"},{"script":"rust","time":0,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn merge_arrays(nums1: Vec<Vec<i32>>, nums2: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        let mut ans = vec![];\n        let (mut i1, mut i2, n1, n2) = (0, 0, nums1.len(), nums2.len());\n        while i1 < n1 || i2 < n2 {\n            if i1 == n1 {\n                ans.push(nums2[i2].clone());\n                i2 += 1\n            } else if i2 == n2 {\n                ans.push(nums1[i1].clone());\n                i1 += 1\n            } else {\n                if nums1[i1][0] == nums2[i2][0] {\n                    let mut item = vec![nums1[i1][0]; 2];\n                    item[1] = nums1[i1][1] + nums2[i2][1];\n                    ans.push(item);\n                    i1 += 1;\n                    i2 += 1;\n                } else if nums1[i1][0] < nums2[i2][0] {\n                    ans.push(nums1[i1].clone());\n                    i1 += 1;\n                } else {\n                    ans.push(nums2[i2].clone());\n                    i2 += 1;\n                }\n            }\n        }\n        ans\n    }\n}","date":"2023-02-19"}],"tagList":["数组","哈希表","双指针"],"level":"Easy"}},{"problemName":"2571.将整数减少到零需要的最少操作数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2571.将整数减少到零需要的最少操作数.json","problemData":{"id":"2710","name":"2571.将整数减少到零需要的最少操作数","url":"https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0","desc":"返回使 n 等于 0 需要执行的 最少 操作数。","solutions":[{"script":"cpp","time":676,"memory":66.2,"desc":"bfs，考虑所有可能加上减去的数字。","code":"# define lb(x) ((x) & (-x))\nclass Solution {\npublic:\n    int minOperations(int n) {\n        unordered_set<int> s;\n        queue<int> q;\n        q.push(n);\n        s.insert(n);\n        int size = 1, step = 1;\n        while (q.size()) {\n            int num = q.front();\n            // cout << \"num = \" << num << \", step = \" << step << \", size = \" << size << endl;\n            if (lb(num) == num) return step;\n            q.pop();\n            for (int i = 0; i <= 20; i++) {\n                int next1 = num + pow(2, i);\n                if (next1 <= pow(2, 17) && !s.count(next1)) {\n                    s.insert(next1);\n                    q.push(next1);\n                }\n                int next2 = num - pow(2, i);\n                if (next2 > 0 && !s.count(next2)) {\n                    s.insert(next2);\n                    q.push(next2);\n                }\n            }\n            if (--size == 0) {\n                size = q.size();\n                step++;\n            }\n        }\n        return 1;\n    }\n};","date":"2023-02-19"},{"script":"cpp","time":0,"memory":5.9,"desc":"bfs，考虑所有可能加上减去的lowbit。","code":"# define lb(x) ((x) & (-x))\nclass Solution {\npublic:\n    int minOperations(int n) {\n        unordered_set<int> s;\n        queue<int> q;\n        q.push(n);\n        s.insert(n);\n        int size = 1, step = 1;\n        while (q.size()) {\n            int num = q.front(), lbnum = lb(num);\n            if (lbnum == num) return step;\n            q.pop();\n            int next1 = num + lbnum;\n            if (!s.count(next1)) {\n                s.insert(next1);\n                q.push(next1);\n            }\n            int next2 = num - lbnum;\n            if (!s.count(next2)) {\n                s.insert(next2);\n                q.push(next2);\n            }\n            if (--size == 0) {\n                size = q.size();\n                step++;\n            }\n        }\n        return 1;\n    }\n};","date":"2023-02-19"},{"script":"cpp","time":0,"memory":6.3,"desc":"dfs，加上减去lowbit。","code":"# define lb(x) ((x) & (-x))\nclass Solution {\npublic:\n    unordered_map<int, int> m;\n    int dfs(int num) {\n        if (m.count(num)) return m[num];\n        int lbnum = lb(num);\n        if (lbnum == num) return m[num] = 1;\n        return m[num] = min(dfs(num + lbnum), dfs(num - lbnum)) + 1;\n    }\n    int minOperations(int n) {\n        return dfs(n);\n    }\n};","date":"2023-02-19"},{"script":"python","time":32,"memory":15.1,"desc":"同上。","code":"class Solution:\n    def minOperations(self, n: int) -> int:\n        def lb(num): return num & (-num)\n  \n        @cache\n        def dfs(num: int) -> int:\n            lbnum = lb(num)\n            if lbnum == num:\n                return 1\n            return min(dfs(num - lbnum), dfs(num + lbnum)) + 1\n        return dfs(n)","date":"2023-02-19"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"use std::collections::HashMap;\nimpl Solution {\n    pub fn min_operations(n: i32) -> i32 {\n        let mut map = HashMap::<i32, i32>::new();\n        Solution::dfs(n, &mut map)\n    }\n    pub fn dfs(num: i32, map: &mut HashMap<i32, i32>) -> i32 {\n        if (map.contains_key(&num)) {\n            *map.get(&num).unwrap()\n        } else {\n            let lb = num & -num;\n            if lb == num {\n                1\n            } else {\n                let res = Solution::dfs(num - lb, map).min(Solution::dfs(num + lb, map)) + 1;\n                map.insert(num, res);\n                res\n            }\n        }\n    }\n}","date":"2023-02-19"}],"tagList":["贪心","位运算","动态规划"],"level":"Medium"}},{"problemName":"2572.无平方子集计数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2572.无平方子集计数.json","problemData":{"id":"2709","name":"2572.无平方子集计数","url":"https://leetcode.cn/problems/count-the-number-of-square-free-subsets","desc":"返回数组 nums 中 无平方 且 非空 的子集数目。","solutions":[{"script":"cpp","time":156,"memory":90.5,"desc":"状态压缩+dp，对于每个数字找前面所有可能不重合的数字。","code":"class Solution {\n    typedef long long ll;\n    const int mod = 1e9 + 7;\n    const int MAXK = 10;\n    int prime[10] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};\n    bool check(int num) {\n        for (int i = 0; i < MAXK; i++) {\n            if (num % (int)pow(prime[i], 2) == 0) return true;\n        }\n        return false;\n    }\npublic:\n    int squareFreeSubsets(vector<int>& nums) {\n        nums = filter(nums);\n        int n = nums.size(), ans = 0;\n        vector<vector<ll>> dp(n + 1, vector<ll>(1 << MAXK, 0));\n        dp[0][0] = 1;\n        for (int i = 1; i <= n; i++) {\n            int num = nums[i - 1], mask = 0;\n            for (int j = 0; j < (1 << MAXK); j++) dp[i][j] = dp[i - 1][j];\n            for (int i = 0; i < MAXK; i++)\n                if (num % prime[i] == 0) mask |= (1 << i);\n            for (int j = 0; j < (1 << MAXK); j++)\n                if ((mask & j) == 0) dp[i][mask | j] = (dp[i][mask | j] + dp[i - 1][j]) % mod;\n        }\n        for (int j = 0; j < (1 << MAXK); j++) ans = (ans + dp[n][j]) % mod;\n        ans = (ans - 1 + mod) % mod;\n        return ans;\n    }\n    vector<int> filter(vector<int> &nums) {\n        vector<int> res;\n        for (auto &num : nums) {\n            if (!check(num)) res.push_back(num);\n        }\n        return res;\n    }\n};","date":"2023-02-19"},{"script":"python","time":1628,"memory":28.6,"desc":"同上。","code":"class Solution:\n    def squareFreeSubsets(self, nums: List[int]) -> int:\n        mod = 1e9 + 7\n        MAXK = 10\n        prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n\n        def check(num: int) -> bool:\n            for i in range(MAXK):\n                if num % pow(prime[i], 2) == 0:\n                    return True\n            return False\n\n        def filter(nums: List[int]) -> List[int]:\n            res = []\n            for num in nums:\n                if not check(num):\n                    res.append(num)\n            return res\n\n        nums = filter(nums)\n        n = len(nums)\n        ans = 0\n        dp = [[0] * (1 << MAXK) for _ in range(n+1)]\n        dp[0][0] = 1\n        for i in range(1, n+1):\n            num = nums[i-1]\n            mask = 0\n            for j in range(1 << MAXK):\n                dp[i][j] = dp[i-1][j]\n            for k in range(MAXK):\n                if num % prime[k] == 0:\n                    mask |= (1 << k)\n            for j in range(1 << MAXK):\n                if (mask & j) == 0:\n                    dp[i][mask | j] = (dp[i][mask | j] + dp[i-1][j]) % mod\n        for j in range(1 << MAXK):\n            ans = (ans + dp[n][j]) % mod\n        ans = (ans - 1 + mod) % mod\n        return int(ans)","date":"2023-02-19"},{"script":"rust","time":20,"memory":4.4,"desc":"同上。","code":"impl Solution {\n    pub fn square_free_subsets(nums: Vec<i32>) -> i32 {\n        let MOD = 1000000000 + 7;\n        let MAXK = 10;\n        let prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29];\n        let check = |num: i32| -> bool {\n            for v in prime.iter() {\n                if num % (*v as i32).pow(2) == 0 {\n                    return true;\n                }\n            }\n            false\n        };\n        let mut nums = nums\n            .into_iter()\n            .filter(|num| !check(*num))\n            .collect::<Vec<i32>>();\n        let n = nums.len();\n        let mut dp = vec![vec![0; 1 << MAXK]; n + 1];\n        dp[0][0] = 1;\n        for i in 1..=n {\n            let num = nums[i - 1];\n            let mut mask = 0;\n            for j in 0..(1 << MAXK) {\n                dp[i][j] = dp[i - 1][j];\n            }\n            for i in 0..MAXK {\n                if num % prime[i] == 0 {\n                    mask |= 1 << i;\n                }\n            }\n            for j in 0..(1 << MAXK) {\n                if (mask & j) == 0 {\n                    dp[i][mask | j] = (dp[i][mask | j] + dp[i - 1][j]) % MOD;\n                }\n            }\n        }\n        let mut ans = 0;\n        for j in 0..(1 << MAXK) {\n            ans = (ans + dp[n][j]) % MOD;\n        }\n        ans = (ans - 1 + MOD) % MOD;\n        ans\n    }\n}","date":"2023-02-19"}],"tagList":["位运算","数组","数学","动态规划","状态压缩"],"level":"Medium"}},{"problemName":"2573.找出对应LCP矩阵的字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2573.找出对应LCP矩阵的字符串.json","problemData":{"id":"2708","name":"2573.找出对应LCP矩阵的字符串","url":"https://leetcode.cn/problems/find-the-string-with-lcp","desc":"给你一个 n x n 的矩阵 lcp 。返回与 lcp 对应的、按字典序最小的字符串 word 。如果不存在这样的字符串，则返回空字符串。","solutions":[{"script":"cpp","time":168,"memory":67.1,"desc":"贪心的构造出字符串，再通过lcp验证字符串是否成立。","code":"class Solution {\npublic:\n    string findTheString(vector<vector<int>>& lcp) {\n        int n = lcp.size(), i = 0;\n        string s;\n        for (int j = 0; j < n; j++) s += \"#\";\n        for (char c = 'a'; c <= 'z'; cpp) {\n            while (i < n && s[i] != '#') i++;\n            if (i == n) break;\n            for (int j = i; j < n; j++)\n                if (lcp[i][j]) s[j] = c;\n        }\n        if (s.find('#') != string::npos) return \"\";\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                if (s[i] == s[j]) {\n                    if (i == n - 1 || j == n - 1) {\n                        if (lcp[i][j] != 1) return \"\";\n                    } else if (lcp[i][j] != lcp[i + 1][j + 1] + 1) return \"\";\n                } else if (lcp[i][j]) return \"\";\n            }\n        }\n        return s;\n    }\n};","date":"2023-02-19"},{"script":"python","time":320,"memory":45.2,"desc":"同上。","code":"class Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        n = len(lcp)\n        i = 0\n        s = [''] * n\n        for c in ascii_lowercase:\n            while i < n and s[i] != '':\n                i += 1\n            if i == n:\n                break\n            for j in range(i, n):\n                if lcp[i][j]:\n                    s[j] = c\n        if '' in s:\n            return ''\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if s[i] == s[j]:\n                    if i == n - 1 or j == n - 1:\n                        if lcp[i][j] != 1:\n                            return ''\n                    elif lcp[i][j] != lcp[i+1][j+1] + 1:\n                        return ''\n                elif lcp[i][j]:\n                    return ''\n        return ''.join(s)","date":"2023-02-19"},{"script":"rust","time":28,"memory":9.4,"desc":"同上。","code":"impl Solution {\n    pub fn find_the_string(lcp: Vec<Vec<i32>>) -> String {\n        let n = lcp.len();\n        let mut list = vec!['\\0'; n];\n        let mut c = 'a';\n        let mut i = 0;\n        while (c as u8) <= ('z' as u8) {\n            while i < n && list[i] != '\\0' {\n                i += 1;\n            }\n            if i == n {\n                break;\n            }\n            for j in i..n {\n                if lcp[i][j] != 0 {\n                    list[j] = c;\n                }\n            }\n            c = ((c as u8) + 1) as char;\n        }\n        if list.contains(&'\\0') {\n            String::new()\n        } else {\n            for i in (0..n).rev() {\n                for j in (0..n).rev() {\n                    if list[i] == list[j] {\n                        if i == n - 1 || j == n - 1 {\n                            if lcp[i][j] != 1 {\n                                return String::new();\n                            }\n                        } else if lcp[i][j] != lcp[i + 1][j + 1] + 1 {\n                            return String::new();\n                        }\n                    } else if lcp[i][j] != 0 {\n                        return String::new();\n                    }\n                }\n            }\n            String::from_utf8(list.into_iter().map(|c| c as u8).collect::<Vec<u8>>()).unwrap()\n        }\n    }\n}","date":"2023-02-19"}],"tagList":["贪心","并查集","数组","字符串","动态规划","矩阵"],"level":"Hard"}},{"problemName":"2574.左右元素和的差值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2574.左右元素和的差值.json","problemData":{"id":"2714","name":"2574.左右元素和的差值","url":"https://leetcode.cn/problems/left-and-right-sum-differences","desc":"给你一个下标从 0 开始的整数数组 nums ，请你找出一个下标从 0 开始的整数数组 answer。","solutions":[{"script":"cpp","time":4,"memory":10.8,"desc":"遍历。","code":"class Solution {\npublic:\n    vector<int> leftRigthDifference(vector<int>& nums) {\n        int sum = 0;\n        for (auto &num : nums) sum += num;\n        vector<int> ans;\n        int left = 0;\n        for (auto &num : nums) {\n            ans.push_back(abs(sum - num - left));\n            sum -= num;\n            left += num;\n        }\n        return ans;\n    }\n};","date":"2023-02-26"},{"script":"python","time":44,"memory":15.2,"desc":"同上。","code":"class Solution:\n    def leftRigthDifference(self, nums: List[int]) -> List[int]:\n        vsum = sum(nums)\n        ans = []\n        left = 0\n        for num in nums:\n            ans .append(abs(vsum - num - left))\n            vsum -= num\n            left += num\n        return ans","date":"2023-02-26"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn left_rigth_difference(nums: Vec<i32>) -> Vec<i32> {\n        let mut sum = nums.iter().fold(0, |sum, cur| sum + cur);\n        let mut ans = vec![];\n        let mut left = 0;\n        for num in nums {\n            ans.push((sum - num - left).abs());\n            sum -= num;\n            left += num;\n        }\n        ans\n    }\n}","date":"2023-02-26"}],"tagList":["数组","前缀和"],"level":"Easy"}},{"problemName":"2575.找出字符串的可整除数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2575.找出字符串的可整除数组.json","problemData":{"id":"2713","name":"2575.找出字符串的可整除数组","url":"https://leetcode.cn/problems/find-the-divisibility-array-of-a-string","desc":"返回 word 的可整除数组。","solutions":[{"script":"cpp","time":32,"memory":25.8,"desc":"遍历。","code":"class Solution {\npublic:\n    vector<int> divisibilityArray(string word, int m) {\n        vector<int> ans;\n        long long cur = 0;\n        for (auto &c : word) {\n            cur = (cur * 10 + c - '0') % m;\n            int num = cur == 0 ? 1 : 0;\n            ans.push_back(num);\n        }\n        return ans;\n    }\n};","date":"2023-02-26"},{"script":"python","time":164,"memory":18.1,"desc":"同上。","code":"class Solution:\n    def divisibilityArray(self, word: str, m: int) -> List[int]:\n        ans = []\n        cur = 0\n        for c in word:\n            cur = (cur * 10 + ord(c) - ord('0')) % m\n            ans.append(1 if cur == 0 else 0)\n        return ans","date":"2023-02-26"},{"script":"rust","time":36,"memory":3,"desc":"同上。","code":"impl Solution {\n        pub fn divisibility_array(word: String, m: i32) -> Vec<i32> {\n            let word = word.chars().collect::<Vec<char>>();\n            let m = m as i64;\n            let mut ans = vec![];\n            let mut cur = 0i64;\n            for c in word {\n                cur = (cur * 10 + c as i64 - '0' as i64) % m;\n                ans.push(if cur == 0 { 1 } else { 0 })\n            }\n            ans\n        }\n    }","date":"2023-02-26"},{"script":"python","time":159,"memory":19.35,"desc":"遍历时累加取模。","code":"class Solution:\n    def divisibilityArray(self, word: str, m: int) -> List[int]:\n        ans = []\n        cur = 1-1\n        for c in word:\n            cur = (cur * (11 - 1) + int(c)) % m\n            ans.append(int(cur == 1-1))\n        return ans","date":"2024-03-07"}],"tagList":["数组","数学","字符串"],"level":"Medium"}},{"problemName":"2576.求出最多标记下标.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2576.求出最多标记下标.json","problemData":{"id":"2712","name":"2576.求出最多标记下标","url":"https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices","desc":"返回 nums 中最多可以标记的下标数目。","solutions":[{"script":"cpp","time":120,"memory":58.6,"desc":"折半后用后半部分尽可能尝试匹配前半部分。","code":"class Solution {\npublic:\n    int maxNumOfMarkedIndices(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int ans = 0, n = nums.size(), i = 0;\n        for (int j = (n + 1) / 2; j < n; j++) {\n            if (nums[i] * 2 <= nums[j]) i += 1, ans += 2;\n        }\n        return ans;\n    }\n};","date":"2023-02-26"},{"script":"python","time":140,"memory":28.7,"desc":"同上。","code":"class Solution:\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\n        nums.sort()\n        ans = 0\n        n = len(nums)\n        i = 0\n        for j in range((n + 1) // 2, n):\n            if nums[i] * 2 <= nums[j]:\n                i += 1\n                ans += 2\n        return ans","date":"2023-02-26"},{"script":"rust","time":32,"memory":3.7,"desc":"同上。","code":"impl Solution {\n    pub fn max_num_of_marked_indices(nums: Vec<i32>) -> i32 {\n        let mut nums = nums;\n        nums.sort();\n        let mut ans = 0;\n        let n = nums.len();\n        let mut i = 0;\n        for j in ((n + 1) / 2)..n {\n            if nums[i] * 2 <= nums[j] {\n                i += 1;\n                ans += 2;\n            }\n        }\n        ans\n    }\n}","date":"2023-02-26"},{"script":"cpp","time":240,"memory":58.5,"desc":"二分答案，如果存在k个，则头部k个一定匹配尾部k个。","code":"class Solution {\npublic:\n    int maxNumOfMarkedIndices(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size();\n        auto check = [&](int k) -> bool {\n            for (int i = 0; i < k; i++) {\n                if (nums[i] * 2 > nums[n - k + i]) return false;\n            }\n            return true;\n        };\n        int l = 0, r = n / 2;\n        while (l < r) {\n            int m = (l + r + 1) / 2;\n            if (check(m)) l = m;\n            else r = m - 1;\n        }\n        return l * 2;\n    }\n};","date":"2023-02-26"},{"script":"python","time":600,"memory":29.5,"desc":"同上。","code":"class Solution:\n    def maxNumOfMarkedIndices(self, nums: List[int]) -> int:\n        nums.sort()\n        n = len(nums)\n        l, r = 0, n//2\n        while l < r:\n            m = (l + r + 1) // 2\n            if all(nums[i] * 2  <= nums[n - m + i] for i in range(m)) :\n                l = m\n            else : r = m - 1\n        return l *  2","date":"2023-02-26"},{"script":"rust","time":36,"memory":3.8,"desc":"同上。","code":"impl Solution {\n    pub fn max_num_of_marked_indices(nums: Vec<i32>) -> i32 {\n        let mut nums = nums;\n        nums.sort();\n        let n = nums.len();\n        let (mut l, mut r) = (0, n / 2);\n        while l < r {\n            let m = (l + r + 1) / 2;\n            if (0..m).all(|i| nums[i] * 2 <= nums[n - m + i]) {\n                l = m;\n            } else {\n                r = m - 1;\n            }\n        }\n        l as i32 * 2\n    }\n}","date":"2023-02-26"}],"tagList":["贪心","数组","双指针","二分查找","排序"],"level":"Medium"}},{"problemName":"2577.在网格图中访问一个格子的最少时间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2577.在网格图中访问一个格子的最少时间.json","problemData":{"id":"2711","name":"2577.在网格图中访问一个格子的最少时间","url":"https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid","desc":"你从 最左上角 出发，出发时刻为 0 ，你必须一直移动到上下左右相邻四个格子中的 任意 一个格子（即不能停留在格子上）。每次移动都需要花费 1 单位时间。请你返回 最早 到达右下角格子的时间，如果你无法到达右下角的格子，请你返回 -1 。","solutions":[{"script":"cpp","time":384,"memory":46.2,"desc":"优先队列，找最先可以触达的时间。","code":"struct Node {\n    int row, col, time;\n    Node(int row, int col, int time): row(row), col(col), time(time) {}\n};\nvector<vector<int>> dirs = { {0, 1}, {0, -1}, {1, 0}, {-1, 0} };\nclass Solution {\npublic:\n    int minimumTime(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        if (grid[0][1] > 1 && grid[1][0] > 1) return -1;\n        auto cmp = [&](Node &x, Node &y) -> bool { return x.time > y.time; };\n        priority_queue<Node, vector<Node>, decltype(cmp)> q(cmp);\n        q.push(Node(0, 0, 0));\n        bool cache[1005][1005] = {0};\n        cache[0][0] = true;\n        while (q.size()) {\n            Node cur = q.top();\n            if (cur.row == n - 1 && cur.col == m - 1) return cur.time;\n            q.pop();\n            for (auto &dir : dirs) {\n                int nrow = cur.row + dir[0], ncol = cur.col + dir[1];\n                if (nrow < 0 || nrow >= n || ncol < 0 || ncol >= m) continue;\n                int time = cur.time + 1;\n                if (grid[nrow][ncol] > time) {\n                    int minus = (grid[nrow][ncol] - time + 1) / 2;\n                    time = cur.time + minus * 2 + 1;\n                }\n                if (cache[nrow][ncol]) continue;\n                cache[nrow][ncol] = true;\n                q.push(Node(nrow, ncol, time));\n            }\n        }\n        return -1;\n    }\n};","date":"2023-02-26"},{"script":"python","time":2076,"memory":37.1,"desc":"同上。","code":"dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    \n    class Node:\n        def __init__(self, row: int, col: int, time: int):\n            self.row = row\n            self.col = col\n            self.time = time\n    \n        def __lt__(self, o: 'Node') -> bool:\n            return self.time < o.time\n    \n    class Solution:\n        def minimumTime(self, grid: List[List[int]]) -> int:\n            n, m = len(grid), len(grid[0])\n            if grid[0][1] > 1 and grid[1][0] > 1:\n                return -1\n            q = []\n            heappush(q, Node(0, 0, 0))\n            cache = [[0] * 1005 for _ in range(1005)]\n            cache[0][0] = 1\n            while True:\n                cur: Node = heappop(q)\n                if cur.row == n - 1 and cur.col == m - 1:\n                    return cur.time\n                for (i, j) in dirs:\n                    nrow = cur.row + i\n                    ncol = cur.col + j\n                    if 0 <= nrow < n and 0 <= ncol < m:\n                        time = cur.time + 1\n                        if grid[nrow][ncol] > time:\n                            minus = (grid[nrow][ncol] - time + 1) // 2\n                            time = cur.time + minus * 2 + 1\n                        if cache[nrow][ncol]:\n                            continue\n                        cache[nrow][ncol] = 1\n                        heappush(q, Node(nrow, ncol, time))","date":"2023-02-26"},{"script":"rust","time":72,"memory":5.1,"desc":"同上。","code":"const dirs: [[i32; 2]; 4] = [[0, 1], [0, -1], [1, 0], [-1, 0]];\nuse std::cell::RefCell;\nuse std::collections::HashMap;\nuse std::rc::Rc;\n#[derive(Clone, PartialEq, Eq, Ord)]\nstruct Node {\n    row: usize,\n    col: usize,\n    time: i32,\n}\nimpl Node {\n    fn new(row: usize, col: usize, time: i32) -> Self {\n        Node { row, col, time }\n    }\n}\nimpl PartialOrd for Node {\n    fn partial_cmp(&self, o: &Self) -> Option<std::cmp::Ordering> {\n        o.time.partial_cmp(&self.time)\n    }\n}\n\nimpl Solution {\n    pub fn minimum_time(grid: Vec<Vec<i32>>) -> i32 {\n        let n = grid.len();\n        let m = grid[0].len();\n        if grid[0][1] > 1 && grid[1][0] > 1 {\n            -1\n        } else {\n            let mut q = std::collections::BinaryHeap::<Node>::new();\n            q.push(Node::new(0, 0, 0));\n            let mut cache = [[false; 1005]; 1005];\n            cache[0][0] = true;\n            loop {\n                let cur = q.pop().unwrap();\n                if cur.row == n - 1 && cur.col == m - 1 {\n                    return cur.time;\n                }\n                for dir in dirs {\n                    let nrow = cur.row as i32 + dir[0];\n                    let ncol = cur.col as i32 + dir[1];\n                    if nrow < 0 || nrow >= n as i32 || ncol < 0 || ncol >= m as i32 {\n                        continue;\n                    }\n                    let mut time = cur.time + 1;\n                    let nrow = nrow as usize;\n                    let ncol = ncol as usize;\n                    if grid[nrow][ncol] > time {\n                        let minus = (grid[nrow][ncol] - time + 1) / 2;\n                        time = cur.time + minus * 2 + 1;\n                    }\n                    if cache[nrow][ncol] {\n                        continue;\n                    }\n                    cache[nrow][ncol] = true;\n                    q.push(Node::new(nrow, ncol, time));\n                }\n            }\n        }\n    }\n}","date":"2023-02-26"}],"tagList":["广度优先搜索","图","数组","矩阵","最短路","堆（优先队列）"],"level":"Hard"}},{"problemName":"2578.最小和分割.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2578.最小和分割.json","problemData":{"id":"2650","name":"2578.最小和分割","url":"https://leetcode.cn/problems/split-with-minimum-sum","desc":"请你返回 num1 和 num2 可以得到的和的 最小 值。","solutions":[{"script":"cpp","time":0,"memory":6.16,"desc":"贪心。","code":"class Solution {\npublic:\n    int splitNum(int num) {\n        vector<int> nums(10, 0);\n        vector<int> res(2, 0);\n        int cur = 0;\n        for (; num; num /= 10) nums[num % 10]++;\n        for (int i = 0; i < 10; i++) {\n            for (; nums[i]; nums[i]--, cur ^= 1) {\n                res[cur] = res[cur] * 10 + i;\n            }\n        }\n        return res[0] + res[1];\n    }\n};","date":"2023-10-09"},{"script":"python","time":24,"memory":15.56,"desc":"同上。","code":"class Solution:\n    def splitNum(self, num: int) -> int:\n        nums = [0] * 10\n        res = [0] * 2\n        cur = 0\n        while num:\n            nums[num % 10] += 1\n            num //= 10\n        for i in range(10):\n            while nums[i]:\n                res[cur] = res[cur] * 10 + i\n                nums[i] -= 1\n                cur ^= 1\n        return sum(res)","date":"2023-10-09"},{"script":"rust","time":0,"memory":2.03,"desc":"同上。","code":"impl Solution {\n    pub fn split_num(num: i32) -> i32 {\n        let mut num = num as usize;\n        let mut nums = vec![0; 10];\n        let mut res = vec![0; 2];\n        let mut cur = 0;\n        while num != 0 {\n            nums[num % 10] += 1;\n            num /= 10;\n        }\n        for i in 0..10 {\n            while nums[i] != 0 {\n                res[cur] = res[cur] * 10 + i;\n                cur ^= 1;\n                nums[i] -= 1;\n            }\n        }\n        res.into_iter().sum::<usize>() as i32\n    }\n}","date":"2023-10-09"}],"tagList":["贪心","数学","排序"],"level":"Easy"}},{"problemName":"2580.统计将重叠区间合并成组的方案数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2580.统计将重叠区间合并成组的方案数.json","problemData":{"id":"2651","name":"2580.统计将重叠区间合并成组的方案数","url":"https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges","desc":"请你返回将 ranges 划分成两个组的 总方案数 。","solutions":[{"script":"python","time":120,"memory":45.1,"desc":"并查集合并区间。","code":"class UnionFind:\n        def __init__(self, n) -> None:\n            self.n = n\n            self.data = [i for i in range(0, n)]\n            self.sizes = [1] * n\n            self.cnt = n\n        def size(self, v: int) -> int:\n            return self.sizes[self.find(v)]\n        def find(self, v: int) -> int:\n            if self.data[v] != v:\n                self.data[v] = self.find(self.data[v])\n            return self.data[v]\n        def uni(self, v1: int, v2: int):\n            p1 = self.find(v1)\n            p2 = self.find(v2)\n            if p1 != p2:\n                self.sizes[p1] += self.sizes[p2]\n                self.cnt -= self.sizes[p2]\n                self.data[p2] = p1\n        def same(self, v1: int, v2: int):\n            return self.find(v1) == self.find(v2)\n    class Solution:\n        def countWays(self, ranges: List[List[int]]) -> int:\n            n = len(ranges)\n            ranges.sort()\n            uf = UnionFind(n)\n            idx = 0\n            while idx < n:\n                start, end = ranges[idx]\n                while idx + 1 < n and ranges[idx + 1][0] <= end:\n                    end = max(end, ranges[idx + 1][1])\n                    uf.uni(idx, idx + 1)\n                    idx += 1\n                idx += 1\n            return (2 ** uf.cnt) % (10 ** 9 + 7)","date":"2024-03-27"},{"script":"python","time":94,"memory":45.06,"desc":"排序后合并区间。","code":"class Solution:\n    def countWays(self, ranges: List[List[int]]) -> int:\n        n = len(ranges)\n        ranges.sort()\n        idx = 0\n        cnt = 0\n        while idx < n:\n            start, end = ranges[idx]\n            cnt += 1\n            while idx + 1 < n and ranges[idx + 1][0] <= end:\n                end = max(end, ranges[idx + 1][1])\n                idx += 1\n            idx += 1\n        return pow(2, cnt, 10 ** 9 + 7)","date":"2024-03-27"}],"tagList":["数组","排序"],"level":"Medium"}},{"problemName":"2581.统计可能的树根数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2581.统计可能的树根数目.json","problemData":{"id":"2652","name":"2581.统计可能的树根数目","url":"https://leetcode.cn/problems/count-number-of-possible-root-nodes","desc":"给你二维整数数组 edges ，Bob 的所有猜测和整数 k ，请你返回可能成为树根的 节点数目 。如果没有这样的树，则返回 0。","solutions":[{"script":"python","time":425,"memory":97.89,"desc":"先统计以0为根的猜对个数， 再对每个节点为根进行dfs。","code":"class Solution:\n    def rootCount(self, edges: List[List[int]], guesses: List[List[int]], k: int) -> int:\n        nodes = [[] for _ in range(len(edges) + 1)]\n        for n1, n2 in edges:\n            nodes[n1].append(n2)\n            nodes[n2].append(n1)\n        s = {(n1, n2) for n1, n2 in guesses}\n        def dfs(node: int, parent: int) -> int:\n            ans = 0\n            for child in nodes[node]:\n                if child != parent:\n                    ans += (node, child) in s\n                    ans += dfs(child, node)\n            return ans\n        def reroot(node: int, parent: int, cnt: int) -> int:\n            ans = cnt >= k\n            for child in nodes[node]:\n                if child != parent:\n                    ans += reroot(child, node, cnt + ((child, node) in s) - ((node, child) in s))\n            return ans\n        return reroot(0, -1, dfs(0, -1))","date":"2024-02-29"}],"tagList":["树","深度优先搜索","数组","哈希表","动态规划"],"level":"Hard"}},{"problemName":"2582.递枕头.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2582.递枕头.json","problemData":{"id":"2645","name":"2582.递枕头","url":"https://leetcode.cn/problems/pass-the-pillow","desc":"过滤后返回餐馆的 id，按照 rating 从高到低排序。如果 rating 相同，那么按 id 从高到低排序。","solutions":[{"script":"cpp","time":88,"memory":26.94,"desc":"遍历。","code":"class Solution {\npublic:\n    vector<int> filterRestaurants(vector<vector<int>>& restaurants, int veganFriendly, int maxPrice, int maxDistance) {\n        vector<pair<int, int>> list;\n        for (auto &item : restaurants) {\n            if (item[3] <= maxPrice && item[4] <= maxDistance and (!veganFriendly || item[2])) {\n                list.push_back(make_pair(item[0], item[1]));\n            }\n        }\n        sort(list.begin(), list.end(), [&](auto &a, auto &b) {\n            return a.second != b.second ? a.second < b.second : a.first < b.first;\n        });\n        reverse(list.begin(), list.end());\n        vector<int> res;\n        for (auto &item : list) res.push_back(item.first);\n        return res;\n    }\n};","date":"2023-09-27"},{"script":"python","time":64,"memory":23.1,"desc":"同上。","code":"class Solution:\n    def filterRestaurants(self, restaurants: List[List[int]], veganFriendly: int, maxPrice: int, maxDistance: int) -> List[int]:\n        restaurants = [item for item in restaurants if item[3] <=\n                        maxPrice and item[4] <= maxDistance and (not veganFriendly or item[2])]\n        restaurants.sort(key=lambda item: (item[1], item[0]), reverse=True)\n        return [item[0] for item in restaurants]","date":"2023-09-27"},{"script":"rust","time":8,"memory":3.11,"desc":"同上。","code":"impl Solution {\n    pub fn filter_restaurants(\n        restaurants: Vec<Vec<i32>>,\n        vegan_friendly: i32,\n        max_price: i32,\n        max_distance: i32,\n    ) -> Vec<i32> {\n        let mut restaurants: Vec<Vec<i32>> = restaurants\n            .into_iter()\n            .filter(|item| {\n                item[3] <= max_price\n                    && item[4] <= max_distance\n                    && (vegan_friendly == 0 || item[2] == 1)\n            })\n            .collect();\n        restaurants.sort_by(|item1, item2| {\n            if item1[1] != item2[1] {\n                item2[1].cmp(&item1[1])\n            } else {\n                item2[0].cmp(&item1[0])\n            }\n        });\n        restaurants.into_iter().map(|item| item[0]).collect()\n    }\n}\n","date":"2023-09-27"}],"tagList":["数学","模拟"],"level":"Easy"}},{"problemName":"2583.二叉树中的第K大层和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2583.二叉树中的第K大层和.json","problemData":{"id":"2646","name":"2583.二叉树中的第K大层和","url":"https://leetcode.cn/problems/kth-largest-sum-in-a-binary-tree","desc":"给你一棵二叉树的根节点 root 和一个正整数 k 。树中的 层和 是指 同一层 上节点值的总和。返回树中第 k 大的层和（不一定不同）。如果树少于 k 层，则返回 -1 。。","solutions":[{"script":"python","time":267,"memory":51.8,"desc":"bfs。","code":"class Solution:\n    def kthLargestLevelSum(self, root: Optional[TreeNode], k: int) -> int:\n        if not root: return []\n        q = deque() \n        q.append(root)\n        size = 1\n        sums = [root.val]\n        while q:\n            node = q.popleft()\n            if node.left: q.append(node.left)\n            if node.right: q.append(node.right)\n            size -= 1\n            if size == 0:\n                size = len(q)\n                if q: sums.append(sum(node.val for node in q))\n        if len(sums) < k: return -1\n        return sorted(sums)[-k]","date":"2024-02-23"}],"tagList":["树","广度优先搜索","二叉树","排序"],"level":"Medium"}},{"problemName":"2586.统计范围内的元音字符串数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2586.统计范围内的元音字符串数.json","problemData":{"id":"2654","name":"2586.统计范围内的元音字符串数","url":"https://leetcode.cn/problems/count-the-number-of-vowel-strings-in-range","desc":"给你一个下标从 0 开始的字符串数组 words 和两个整数：left 和 right 。如果字符串以元音字母开头并以元音字母结尾，那么该字符串就是一个 元音字符串 ，其中元音字母是 'a'、'e'、'i'、'o'、'u' 。返回 words[i] 是元音字符串的数目，其中 i 在闭区间 [left, right] 内。","solutions":[{"script":"cpp","time":16,"memory":31.1,"desc":"遍历。","code":"class Solution {\npublic:\n    int vowelStrings(vector<string>& words, int left, int right) {\n        unordered_set<char> s{ 'a', 'e', 'i', 'o', 'u'};\n        int res = 0;\n        for (int i = left; i <= right; i++) {\n            if (s.count(words[i][0]) && s.count(words[i][words[i].size() - 1])) res++;\n        }\n        return res;\n    }\n};","date":"2023-03-12"},{"script":"python","time":32,"memory":15,"desc":"同上。","code":"class Solution:\n    def vowelStrings(self, words: List[str], left: int, right: int) -> int:\n        s = {'a', 'e', 'i', 'o', 'u'}\n        res = 0\n        return len(list(filter(\n            lambda w: w[0] in s and w[-1] in s,\n            words[left:right+1]\n        )))","date":"2023-03-12"},{"script":"rust","time":0,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn vowel_strings(words: Vec<String>, left: i32, right: i32) -> i32 {\n        let left = left as usize;\n        let right = right as usize;\n        let mut s = std::collections::HashSet::<char>::new();\n        ['a', 'e', 'i', 'o', 'u'].into_iter().for_each(|c| {\n            s.insert(*c);\n        });\n        let mut res = 0;\n        for word in words[left..=right].into_iter() {\n            let word = word.chars().collect::<Vec<char>>();\n            if s.contains(&word[0]) && s.contains(&word.last().unwrap()) {\n                res += 1;\n            }\n        }\n        res\n    }\n}","date":"2023-03-12"},{"script":"python","time":36,"memory":15.77,"desc":"合计。","code":"class Solution:\n    def vowelStrings(self, words: List[str], left: int, right: int) -> int:\n        return sum(word[0] in 'aeiou' and word[-1] in 'aeiou' for word in words[left:right + 1])","date":"2023-11-07"},{"script":"typescript","time":72,"memory":43.89,"desc":"合计。","code":"function vowelStrings(words: string[], left: number, right: number): number {\n    return words.slice(left, right + 1).filter(s => 'aeiou'.includes(s[0]) && 'aeiou'.includes(s[s.length - 1])).length\n};","date":"2023-11-07"}],"tagList":["数组","字符串"],"level":"Easy"}},{"problemName":"2587.重排数组以得到最大前缀分数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2587.重排数组以得到最大前缀分数.json","problemData":{"id":"2655","name":"2587.重排数组以得到最大前缀分数","url":"https://leetcode.cn/problems/rearrange-array-to-maximize-prefix-score","desc":"给你一个下标从 0 开始的整数数组 nums 。你可以将 nums 中的元素按 任意顺序 重排（包括给定顺序）。返回可以得到的最大分数。","solutions":[{"script":"cpp","time":132,"memory":81,"desc":"贪心从正到负依次取值。","code":"class Solution {\npublic:\n    int maxScore(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        long long n = nums.size(), sum = 0, res = 0;\n        if (nums[n - 1] <= 0) return 0;\n        for (int i = n - 1; i >= 0; i--) {\n            sum += nums[i];\n            if (sum <= 0) break;\n            res++;\n        }\n        return res;\n    }\n};","date":"2023-03-12"},{"script":"python","time":164,"memory":28.8,"desc":"同上。","code":"class Solution:\n    def maxScore(self, nums: List[int]) -> int:\n        nums.sort()\n        n, sums, res = len(nums), 0, 0\n        if nums[n-1] <= 0:\n            return 0\n        for i in range(n-1, -1, -1):\n            sums += nums[i]\n            if sums <= 0:\n                break\n            res += 1\n        return res","date":"2023-03-12"},{"script":"rust","time":32,"memory":3.4,"desc":"同上。","code":"impl Solution {\n    pub fn max_score(nums: Vec<i32>) -> i32 {\n        let mut nums = nums;\n        nums.sort();\n        let (n, mut sum, mut res) = (nums.len(), 0i64, 0);\n        if *nums.last().unwrap() <= 0 {\n            0\n        } else {\n            for i in (0..n).rev() {\n                sum += nums[i] as i64;\n                if sum <= 0 {\n                    break;\n                }\n                res += 1;\n            }\n            res\n        }\n    }\n}","date":"2023-03-12"}],"tagList":["贪心","数组","前缀和","排序"],"level":"Medium"}},{"problemName":"2588.统计美丽子数组数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2588.统计美丽子数组数目.json","problemData":{"id":"2656","name":"2588.统计美丽子数组数目","url":"https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays","desc":"请你返回数组 nums 中 美丽子数组 的数目。","solutions":[{"script":"cpp","time":268,"memory":117.5,"desc":"前缀和遍历，统计前面相同的掩码数。","code":"class Solution {\npublic:\n    long long beautifulSubarrays(vector<int>& nums) {\n        unordered_map<int, int> m;\n        m[0]++;\n        long long res = 0;\n        int mask = 0;\n        for (auto &num : nums) {\n            mask |= num;\n            res += m[mask];\n            m[mask]++;\n        }\n        return res;\n    }\n};","date":"2023-03-12"},{"script":"python","time":280,"memory":36.9,"desc":"同上。","code":"class Solution:\n    def beautifulSubarrays(self, nums: List[int]) -> int:\n        m = Counter()\n        m[0] += 1\n        res, mask = 0, 0\n        for num in nums:\n            mask ^= num\n            res += m[mask]\n            m[mask] += 1\n        return res","date":"2023-03-12"},{"script":"rust","time":36,"memory":4.6,"desc":"同上。","code":"impl Solution {\n    pub fn beautiful_subarrays(nums: Vec<i32>) -> i64 {\n        let mut m = std::collections::HashMap::<i32, i32>::new();\n        m.insert(0, 1);\n        let (mut res, mut mask) = (0i64, 0);\n        for num in nums {\n            mask ^= num;\n            let item = m.entry(mask).or_insert(0);\n            res += *item as i64;\n            *item += 1;\n        }\n        res\n    }\n}","date":"2023-03-12"}],"tagList":["位运算","数组","哈希表","前缀和"],"level":"Medium"}},{"problemName":"2589.完成所有任务的最少时间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2589.完成所有任务的最少时间.json","problemData":{"id":"2657","name":"2589.完成所有任务的最少时间","url":"https://leetcode.cn/problems/minimum-time-to-complete-all-tasks","desc":"你有一台电脑，它可以 同时 运行无数个任务。给你一个二维整数数组 tasks ，其中 tasks[i] = [starti, endi, durationi] 表示第 i 个任务需要在 闭区间 时间段 [starti, endi] 内运行 durationi 个整数时间点（但不需要连续）。当电脑需要运行任务时，你可以打开电脑，如果空闲时，你可以将电脑关闭。请你返回完成所有任务的情况下，电脑最少需要运行多少秒。","solutions":[{"script":"cpp","time":152,"memory":37.3,"desc":"按终止时间排序，对于每个任务先在时间段中找已经在运行的时间段，如果已经运行的时间段已经超过任务所需要的时间那不需要增加时间点，如果不满足，尽可能从后往前开启时间段。","code":"class Solution {\npublic:\n    int findMinimumTime(vector<vector<int>>& tasks) {\n        sort(tasks.begin(), tasks.end(), [&](auto &a, auto &b){\n            return a[1] < b[1];\n        });\n        int res = 0, time[2005] = {0};\n        for (auto &task : tasks) {\n            for (int i = task[0]; i <= task[1]; i++)\n                if (time[i]) task[2]--;\n            if (task[2] <= 0) continue;\n            for (int i = task[1]; i >= task[0] && task[2]; i--)\n                if (!time[i]) time[i] = 1, res++, task[2]--;\n        }\n        return res;\n    }\n};","date":"2023-03-12"},{"script":"python","time":1072,"memory":15.9,"desc":"同上。","code":"class Solution:\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\n        tasks.sort(key=lambda item: item[1])\n        res = 0\n        time = [False]*2005\n        for task in tasks:\n            for i in range(task[0], task[1]+1):\n                if time[i]:\n                    task[2] -= 1\n            if task[2] <= 0:\n                continue\n            for i in range(task[1], task[0]-1, -1):\n                if not time[i]:\n                    time[i] = True\n                    res += 1\n                    task[2] -= 1\n                if not task[2]:\n                    break\n        return res","date":"2023-03-12"},{"script":"rust","time":40,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn find_minimum_time(tasks: Vec<Vec<i32>>) -> i32 {\n        let mut tasks = tasks;\n        tasks.sort_by(|a, b| a[1].cmp(&b[1]));\n        let mut res = 0;\n        let mut time = [false; 2005];\n        for mut task in tasks {\n            for i in task[0]..=task[1] {\n                let i = i as usize;\n                if time[i] {\n                    task[2] -= 1;\n                }\n            }\n            if task[2] > 0 {\n                for i in (task[0]..=task[1]).rev() {\n                    let i = i as usize;\n                    if !time[i] {\n                        time[i] = true;\n                        res += 1;\n                        task[2] -= 1;\n                    }\n                    if task[2] == 0 {\n                        break;\n                    }\n                }\n            }\n        }\n        res\n    }\n}","date":"2023-03-12"},{"script":"python","time":529,"memory":17.4,"desc":"贪心，对于每个任务先查看当前已经占用的时间点，剩下的从后往前开始占用。","code":"class Solution:\n    def findMinimumTime(self, tasks: List[List[int]]) -> int:\n        tasks.sort(key = lambda v: v[1])\n        arr = [False] * 2001\n        res = 0\n        for s, e, d in tasks:\n            for t in range(s, e + 1):\n                if arr[t]:\n                    d -= 1\n            if d <= 0: continue\n            for t in range(e, s - 1, -1):\n                if d <= 0: break\n                if not arr[t]:\n                    arr[t] = True\n                    d -= 1\n                    res += 1\n        return res","date":"2024-05-15"}],"tagList":["栈","贪心","数组","二分查找","排序"],"level":"Hard"}},{"problemName":"2591.将钱分给最多的儿童.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2591.将钱分给最多的儿童.json","problemData":{"id":"2663","name":"2591.将钱分给最多的儿童","url":"https://leetcode.cn/problems/distribute-money-to-maximum-children","desc":"请你按照上述规则分配金钱，并返回 最多 有多少个儿童获得 恰好 8 美元。如果没有任何分配方案，返回 -1 。","solutions":[{"script":"cpp","time":4,"memory":6.05,"desc":"贪心计算。","code":"class Solution {\npublic:\n    int distMoney(int money, int children) {\n        if (money < children) return -1;\n        int cnt = money / 8, surplus_money = money % 8, surplus_children = children - cnt;\n        if (cnt == children) return surplus_money == 0 ? children : children - 1;\n        if (cnt > children) return children - 1;\n        if (surplus_money == surplus_children) return cnt;\n        if (surplus_money > surplus_children) return surplus_children == 1 and surplus_money == 4 ? cnt - 1 : cnt;\n        return cnt - ceil(1.0 * (surplus_children - surplus_money) / 7.0);\n    }\n};","date":"2023-09-22"},{"script":"python","time":52,"memory":15.61,"desc":"同上。","code":"class Solution:\n    def distMoney(self, money: int, children: int) -> int:\n        if money < children:\n            return -1\n        cnt = money // 8\n        surplus_money = money % 8\n        surplus_children = children - cnt\n        if cnt == children:\n            if surplus_money == 0:\n                return children\n            return children - 1\n        if cnt > children:\n            return children - 1\n        if surplus_money == surplus_children:\n            return cnt\n        if surplus_money > surplus_children:\n            if surplus_children == 1 and surplus_money == 4:\n                return cnt - 1\n            return cnt\n        return cnt - ceil((surplus_children - surplus_money) / 7)\n","date":"2023-09-22"},{"script":"rust","time":0,"memory":2.58,"desc":"同上。","code":"impl Solution {\n    pub fn dist_money(money: i32, children: i32) -> i32 {\n        if money < children {\n            -1\n        } else {\n            let (cnt, surplus_money) = (money / 8, money % 8);\n            let surplus_children = children - cnt;\n            if cnt == children {\n                if surplus_money == 0 {\n                    children\n                } else {\n                    children - 1\n                }\n            } else if cnt > children {\n                children - 1\n            } else if surplus_money == surplus_children {\n                cnt\n            } else if surplus_money > surplus_children {\n                if surplus_children == 1 && surplus_money == 4 {\n                    cnt - 1\n                } else {\n                    cnt\n                }\n            } else {\n                cnt - ((surplus_children - surplus_money) as f64 / 7.0).ceil() as i32\n            }\n        }\n    }\n}\n","date":"2023-09-22"}],"tagList":["贪心","数学"],"level":"Easy"}},{"problemName":"2594.修车的最少时间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2594.修车的最少时间.json","problemData":{"id":"2665","name":"2594.修车的最少时间","url":"https://leetcode.cn/problems/minimum-time-to-repair-cars","desc":"给你一个整数数组 ranks ，表示一些机械工的 能力值 。ranksi 是第 i 位机械工的能力值。能力值为 r 的机械工可以在 r * n2 分钟内修好 n 辆车。同时给你一个整数 cars ，表示总共需要修理的汽车数目。请你返回修理所有汽车 最少 需要多少时间。","solutions":[{"script":"cpp","time":112,"memory":51.34,"desc":"二分答案。","code":"class Solution {\npublic:\n    typedef long long ll;\n    ll repairCars(vector<int>& ranks, int cars) {\n        auto comp = [&](ll t) {\n            ll res = 0;\n            for (auto &rank : ranks) {\n                res += floor(sqrt(1.0 * t / rank));\n            }\n            return res;\n        };\n        ll l = 0, r = LLONG_MAX;\n        while (l < r) {\n            ll m = (r - l) / 2 + l;\n            if (comp(m) >= cars) r = m;\n            else l = m + 1;\n        }\n        return l;\n    }\n};","date":"2023-09-07"},{"script":"python","time":1292,"memory":20.16,"desc":"同上。","code":"class Solution:\n    def repairCars(self, ranks: List[int], cars: int) -> int:\n        l = 0\n        r = 2 ** 63 - 1\n        while l < r:\n            m = (r - l) // 2 + l\n            if sum(floor(sqrt(m / rank)) for rank in ranks) >= cars:\n                r = m\n            else:\n                l = m + 1\n        return l","date":"2023-09-07"},{"script":"rust","time":56,"memory":2.98,"desc":"同上。","code":"impl Solution {\n    pub fn repair_cars(ranks: Vec<i32>, cars: i32) -> i64 {\n        let cars = cars as i64;\n        let mut l = 0;\n        let mut r = i64::MAX;\n        while l < r {\n            let m = (r - l) / 2 + l;\n            if ranks\n                .iter()\n                .map(|rank| (m as f64 / *rank as f64).sqrt().floor() as i64)\n                .sum::<i64>()\n                >= cars\n            {\n                r = m;\n            } else {\n                l = m + 1;\n            }\n        }\n        l\n    }\n}","date":"2023-09-07"}],"tagList":["数组","二分查找"],"level":"Medium"}},{"problemName":"2595.奇偶位数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2595.奇偶位数.json","problemData":{"id":"2659","name":"2595.奇偶位数","url":"https://leetcode.cn/problems/number-of-even-and-odd-bits","desc":"给你一个 正 整数 n 。用 even 表示在 n 的二进制形式（下标从 0 开始）中值为 1 的偶数下标的个数。用 odd 表示在 n 的二进制形式（下标从 0 开始）中值为 1 的奇数下标的个数。返回整数数组 answer ，其中 answer = [even, odd] 。","solutions":[{"script":"cpp","time":0,"memory":7,"desc":"遍历。","code":"class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int even = 0, odd = 0;\n        for (int i = 0; i < 32; i++) {\n            if (n & (1 << i)) {\n                if (i & 1) odd++;\n                else even++;\n            }\n        }\n        return vector<int>{ even, odd };\n    }\n};","date":"2023-03-19"},{"script":"python","time":40,"memory":15,"desc":"同上。","code":"class Solution:\n    def evenOddBit(self, n: int) -> List[int]:\n        even, odd = 0, 0\n        for i in range(32):\n            if n & (1 << i):\n                if i & 1:\n                    odd += 1\n                else:\n                    even += 1\n        return [even, odd]","date":"2023-03-19"},{"script":"rust","time":0,"memory":1.9,"desc":"同上。","code":"impl Solution {\n    pub fn even_odd_bit(n: i32) -> Vec<i32> {\n        let mut res = vec![0, 0];\n        for i in 0..32 {\n            if (n & (1 << i)) != 0{\n                res[i % 2] += 1;\n            }\n        }\n        res\n    }\n}","date":"2023-03-19"}],"tagList":["位运算"],"level":"Easy"}},{"problemName":"2596.检查骑士巡视方案.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2596.检查骑士巡视方案.json","problemData":{"id":"2662","name":"2596.检查骑士巡视方案","url":"https://leetcode.cn/problems/check-knight-tour-configuration","desc":"如果 grid 表示了骑士的有效巡视方案，返回 true；否则返回 false。","solutions":[{"script":"cpp","time":8,"memory":27,"desc":"从0到末尾，用方向数组遍历所有数。","code":"int dirs[8][2] = {\n    {-2, -1}, {-1, -2},\n    {-2, 1}, {-1, 2},\n    {1, -2}, {2, -1},\n    {1, 2}, {2, 1},\n};\nclass Solution {\npublic:\n    typedef pair<int, int> pii;\n    bool checkValidGrid(vector<vector<int>>& grid) {\n        int n = grid.size();\n        pii cur = make_pair(0,0);\n        for (int i = 0; i < n * n; i++) {\n            if (grid[cur.first][cur.second] != i) return false;\n            for (int j = 0; j < 8; j++) {\n                int nrow = cur.first + dirs[j][0], ncol = cur.second + dirs[j][1];\n                if (nrow < 0 || nrow >= n || ncol < 0 || ncol >= n) continue;\n                if (grid[nrow][ncol] == i + 1) {\n                    cur = make_pair(nrow, ncol);\n                    break;\n                }\n            }\n        }\n        return true;\n    }\n};","date":"2023-03-19"},{"script":"python","time":32,"memory":15,"desc":"同上。","code":"class Solution:\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\n        dirs = [\n            [-2, -1], [-1, -2],\n            [-2, 1], [-1, 2],\n            [1, -2], [2, -1],\n            [1, 2], [2, 1],\n        ]\n        n = len(grid)\n        cur = (0, 0)\n        for i in range(n*n):\n            if grid[cur[0]][cur[1]] != i:\n                return False\n            for j in range(8):\n                nrow, ncol = cur[0] + dirs[j][0], cur[1]+dirs[j][1]\n                if 0 <= nrow < n and 0 <= ncol < n and grid[nrow][ncol] == i + 1:\n                    cur = (nrow, ncol)\n                    break\n        return True","date":"2023-03-19"},{"script":"rust","time":4,"memory":1.9,"desc":"同上。","code":"impl Solution {\n    pub fn check_valid_grid(grid: Vec<Vec<i32>>) -> bool {\n        const dirs: [[i32; 2]; 8] = [\n            [-2, -1],\n            [-1, -2],\n            [-2, 1],\n            [-1, 2],\n            [1, -2],\n            [2, -1],\n            [1, 2],\n            [2, 1],\n        ];\n        let n = grid.len();\n        let mut cur = (0, 0);\n        for i in 0..n * n {\n            if grid[cur.0][cur.1] != i as i32 {\n                return false;\n            }\n            for dir in dirs {\n                let (nrow, ncol) = (cur.0 as i32 + dir[0], cur.1 as i32 + dir[1]);\n                if nrow >= 0\n                    && (nrow as usize) < n\n                    && ncol >= 0\n                    && (ncol as usize) < n\n                    && grid[nrow as usize][ncol as usize] == i as i32 + 1\n                {\n                    cur = (nrow as usize, ncol as usize);\n                    break;\n                }\n            }\n        }\n        true\n    }\n}","date":"2023-03-19"},{"script":"python","time":40,"memory":16,"desc":"遍历。","code":"dirs = [(1, 2), (1, -2), (2, 1), (2, -1), (-1, 2), (-1, -2), (-2, 1), (-2, -1)]\n\nclass Solution:\n    def checkValidGrid(self, grid: List[List[int]]) -> bool:\n        n = len(grid)\n        cur = (0, 0)\n        if grid[0][0] != 0: return False\n        for i in range(n * n - 1):\n            f = False\n            for dir in dirs:\n                x = cur[0] + dir[0]\n                y = cur[1] + dir[1]\n                if 0 <= x < n and 0 <= y < n and grid[x][y] == i + 1:\n                    f = True\n                    cur = (x, y)\n            if not f:\n                return False\n        return True","date":"2023-09-13"}],"tagList":["深度优先搜索","广度优先搜索","数组","矩阵","模拟"],"level":"Medium"}},{"problemName":"2597.美丽子集的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2597.美丽子集的数目.json","problemData":{"id":"2696","name":"2597.美丽子集的数目","url":"https://leetcode.cn/problems/the-number-of-beautiful-subsets","desc":"给你一个由正整数组成的数组 nums 和一个 正 整数 k 。如果 nums 的子集中，任意两个整数的绝对差均不等于 k ，则认为该子数组是一个 美丽 子集。返回数组 nums 中 非空 且 美丽 的子集数目。","solutions":[{"script":"typescript","time":580,"memory":48,"desc":"dfs。","code":"function beautifulSubsets(nums: number[], k: number): number {\n        nums.sort((a, b) => a - b);\n        let res = 0;\n        const s = new Set();\n        dfs(0);\n        return res;\n        function dfs(cur: number) {\n          if (cur == nums.length) {\n            if (s.size) res++;\n            return;\n          }\n          dfs(cur + 1);\n          const num = nums[cur];\n          if (!s.has(num - k)) {\n            s.add(num);\n            dfs(cur + 1);\n            s.delete(num);\n          }\n        }\n      }","date":"2023-03-19"},{"script":"cpp","time":152,"memory":31.2,"desc":"dfs。","code":"class Solution {\npublic:\n    int beautifulSubsets(vector<int>& nums, int k) {\n        int res = 0, s[3005] = {0}, cnt = 0;\n        dfs(res, nums, k, s, cnt, 0);\n        return res;\n    }\n    void dfs(int &res, vector<int> &nums, int k, int *s, int &cnt, int cur = 0) {\n        if (cur == nums.size()) {\n            if (cnt) res++;\n            return;\n        }\n        dfs(res, nums, k, s, cnt, cur + 1);\n        int num = nums[cur];\n        if (!s[num + 1000 - k] && !s[num + 1000 + k]) {\n            cnt++;\n            s[num + 1000] = 1;\n            dfs(res, nums, k, s, cnt, cur + 1);\n            s[num + 1000] = 0;\n            cnt--;\n        }\n    }\n};","date":"2023-03-19"},{"script":"python","time":3856,"memory":16.2,"desc":"同上。","code":"class Solution:\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\n        s = [False] * 3005\n        cnt = 0\n        res = 0\n        def dfs(cur: int):\n            nonlocal cnt, res\n            if cur == len(nums):\n                if cnt:\n                    res += 1\n            else:\n                dfs(cur + 1)\n                num = nums[cur]\n                if not s[num + 1000-k] and not s[num + 1000+k]:\n                    cnt += 1\n                    s[num+1000] = True\n                    dfs(cur+1)\n                    s[num+1000] = False\n                    cnt -= 1\n        dfs(0)\n        return res","date":"2023-03-19"},{"script":"rust","time":60,"memory":2.1,"desc":"同上。","code":"impl Solution {\n    pub fn beautiful_subsets(nums: Vec<i32>, k: i32) -> i32 {\n        let mut s = [false; 3005];\n        let mut cnt = 0;\n        let mut res = 0;\n        fn dfs(\n            nums: &Vec<i32>,\n            k: usize,\n            s: &mut [bool; 3005],\n            cnt: &mut usize,\n            res: &mut i32,\n            cur: usize,\n        ) {\n            if cur == nums.len() {\n                if *cnt != 0 {\n                    *res += 1;\n                }\n            } else {\n                dfs(nums, k, s, cnt, res, cur + 1);\n                let num = nums[cur] as usize;\n                if !s[num + 1000 - k] && !s[num + 1000 + k] {\n                    *cnt += 1;\n                    s[num + 1000] = true;\n                    dfs(nums, k, s, cnt, res, cur + 1);\n                    s[num + 1000] = false;\n                    *cnt -= 1;\n                }\n            }\n        }\n        dfs(&nums, k as usize, &mut s, &mut cnt, &mut res, 0);\n        res\n    }\n}","date":"2023-03-19"}],"tagList":["数组","哈希表","数学","动态规划","回溯","组合数学","排序"],"level":"Medium"}},{"problemName":"2598.执行操作后的最大MEX.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2598.执行操作后的最大MEX.json","problemData":{"id":"2661","name":"2598.执行操作后的最大MEX","url":"https://leetcode.cn/problems/smallest-missing-non-negative-integer-after-operations","desc":"返回在执行上述操作 任意次 后，nums 的最大 MEX 。","solutions":[{"script":"cpp","time":224,"memory":117.9,"desc":"先对所有数字进行取模归并，再依次寻找。","code":"class Solution {\npublic:\n    int findSmallestInteger(vector<int>& nums, int value) {\n        unordered_map<int,int> m;\n        for (auto &num: nums) m[(num % value + value) % value]++;\n        for (int i = 0; ;i++) {\n            if (m[i%value]) m[i%value]--;\n            else return i;\n        }\n        return 0;\n\n    }\n};","date":"2023-03-19"},{"script":"python","time":356,"memory":35.3,"desc":"同上。","code":"class Solution:\n    def findSmallestInteger(self, nums: List[int], value: int) -> int:\n        m = Counter()\n        for num in nums:\n            m[(num % value + value) % value] += 1\n        i = 0\n        while True:\n            if m[i % value]:\n                m[i % value] -= 1\n            else:\n                return i\n            i += 1","date":"2023-03-19"},{"script":"rust","time":56,"memory":6.6,"desc":"同上。","code":"impl Solution {\n    pub fn find_smallest_integer(nums: Vec<i32>, value: i32) -> i32 {\n        let mut m = std::collections::HashMap::<i32, usize>::new();\n        for num in nums {\n            *m.entry((num % value + value) % value).or_insert(0) += 1;\n        }\n        let mut i = 0;\n        loop {\n            let item = m.get_mut(&(i % value));\n            if let Some(v) = item {\n                if *v == 0 {\n                    return i;\n                } else {\n                    *v -= 1;\n                }\n            } else {\n                return i as i32;\n            }\n            i += 1;\n        }\n    }\n}","date":"2023-03-19"}],"tagList":["贪心","数组","哈希表","数学"],"level":"Medium"}},{"problemName":"2600.K件物品的最大和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2501-2600/2600.K件物品的最大和.json","problemData":{"id":"2715","name":"2600.K件物品的最大和","url":"https://leetcode.cn/problems/k-items-with-the-maximum-sum","desc":"现计划从这些物品中恰好选出 k 件物品。","solutions":[{"script":"cpp","time":0,"memory":5.7,"desc":"分段计算。","code":"class Solution {\npublic:\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\n        if (numOnes >= k) return k;\n        if (numOnes + numZeros >= k) return numOnes;\n        return numOnes - (k - numOnes - numZeros);\n    }\n};","date":"2023-03-26"},{"script":"python","time":36,"memory":14.9,"desc":"同上。","code":"class Solution:\n    def kItemsWithMaximumSum(self, numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\n        if numOnes >= k:\n            return k\n        elif numOnes + numZeros >= k:\n            return numOnes\n        else:\n            return numOnes - (k - numOnes-numZeros)","date":"2023-03-26"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn k_items_with_maximum_sum(\n        num_ones: i32,\n        num_zeros: i32,\n        num_neg_ones: i32,\n        k: i32,\n    ) -> i32 {\n        if num_ones >= k {\n            k\n        } else if num_ones + num_zeros >= k {\n            num_ones\n        } else {\n            num_ones - (k - num_ones - num_zeros)\n        }\n    }\n}","date":"2023-03-26"},{"script":"cpp","time":8,"memory":5.9,"desc":"贪心。","code":"class Solution {\npublic:\n    int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {\n        int res = 0;\n        if (k && numOnes) {\n            res += min(k, numOnes);\n            k -= min(k, numOnes);\n        }\n        if (k && numZeros) {\n            k -= min(k, numZeros);\n        }\n        if (k && numNegOnes) {\n            res -= min(k, numNegOnes);\n            k -= min(k, numNegOnes);\n        }\n        return res;\n    }\n};","date":"2023-07-05"}],"tagList":["贪心","数学"],"level":"Easy"}}]},{"dirName":"2601-2700","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\2601-2700","problems":[{"problemName":"2601.质数减法运算.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2601.质数减法运算.json","problemData":{"id":"2716","name":"2601.质数减法运算","url":"https://leetcode.cn/problems/prime-subtraction-operation","desc":"给你一个下标从 0 开始的整数数组 nums ，数组长度为 n 。如果你能通过上述运算使得 nums 成为严格递增数组，则返回 true ；否则返回 false 。","solutions":[{"script":"cpp","time":16,"memory":23,"desc":"线性筛后对每个数尝试尽可能取最小。","code":"class Solution {\npublic:\n    int primes[1005] = {0};\n    bool primeSubOperation(vector<int>& nums) {\n        getPrimes();\n        nums[0] = formatNum(nums[0], 0);\n        for (int i = 1; i < nums.size(); i++) {\n            nums[i] = formatNum(nums[i], nums[i - 1]);\n            if (nums[i] <= nums[i - 1]) return false;\n        }\n        return true;\n    }\n\n    int formatNum(int num, int prev) {\n        int cur = num;\n        for (int i = 1; i < primes[0] + 1 && primes[i] < num && num - primes[i] > prev; i++) {\n            cur = min(cur, num - primes[i]);\n        }\n        return cur;\n    }\n    \n    void getPrimes() {\n        for (int i = 2; i < 1005; i++) {\n            if (primes[i] == 0) primes[++primes[0]] = i;\n            for (int j = 1; j <= primes[0] && i * primes[j] < 1005; j++) {\n                primes[i * primes[j]] = 1;\n                if (i % primes[j] == 0) break;\n            }\n        }\n    }\n};","date":"2023-03-26"},{"script":"python","time":364,"memory":15,"desc":"同上。","code":"def getPrimes(nmax: int):\n    primes = [0] * nmax\n    for i in range(2, nmax):\n        if primes[i] == 0:\n            primes[0] += 1\n            primes[primes[0]] = i\n        for j in range(1, nmax):\n            if i * primes[j] >= nmax:\n                break\n            primes[i * primes[j]] = 1\n            if i % primes[j] == 0:\n                break\n    return primes\n\nclass Solution:\n    def primeSubOperation(self, nums: List[int]) -> bool:\n        primes = getPrimes(1005)\n\n        def formatNum(num: int, prev: int):\n            cur = num\n            for i in range(1, primes[0] + 1):\n                if primes[i] >= num or num - primes[i] <= prev:\n                    break\n                cur = min(cur, num - primes[i])\n            return cur\n        nums[0] = formatNum(nums[0], 0)\n        for i in range(1, len(nums)):\n            nums[i] = formatNum(nums[i], nums[i-1])\n            if nums[i] <= nums[i-1]:\n                return False\n        return True","date":"2023-03-26"},{"script":"rust","time":8,"memory":2.1,"desc":"同上。","code":"fn get_primes(max: usize) -> Vec<usize> {\n    let mut primes = vec![0; max];\n    for i in 2..max {\n        if primes[i] == 0 {\n            primes[0] += 1;\n            let idx = primes[0];\n            primes[idx] = i;\n        }\n        for j in 1..=primes[0] {\n            let idx = i * primes[j];\n            if idx >= max {\n                break;\n            }\n            primes[idx] = 1;\n            if i % primes[j] == 0 {\n                break;\n            }\n        }\n    }\n    primes\n}\n\nimpl Solution {\n    pub fn prime_sub_operation(mut nums: Vec<i32>) -> bool {\n        let primes = get_primes(1005);\n        let format_num = |num: i32, prev: i32| {\n            let mut cur = num;\n            for i in 1..=primes[0] {\n                if primes[i] as i32 >= num || num - primes[i] as i32 <= prev {\n                    break;\n                }\n                cur = cur.min(num - primes[i] as i32);\n            }\n            cur\n        };\n        nums[0] = format_num(nums[0], 0);\n        for i in 1..nums.len() {\n            nums[i] = format_num(nums[i], nums[i - 1]);\n            if nums[i] <= nums[i - 1] {\n                return false;\n            }\n        }\n        return true;\n    }\n}","date":"2023-03-26"}],"tagList":["贪心","数组","数学","二分查找","数论"],"level":"Medium"}},{"problemName":"2602.使数组元素全部相等的最少操作次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2602.使数组元素全部相等的最少操作次数.json","problemData":{"id":"2718","name":"2602.使数组元素全部相等的最少操作次数","url":"https://leetcode.cn/problems/minimum-operations-to-make-all-array-elements-equal","desc":"给你一个正整数数组 nums 。请你返回一个长度为 m 的数组 answer ，其中 answer[i]是将 nums 中所有元素变成 queries[i] 的 最少 操作次数。","solutions":[{"script":"cpp","time":244,"memory":82.5,"desc":"排序后求前缀和，小值趋近大，大值趋近小。","code":"class Solution {\npublic:\n    vector<long long> minOperations(vector<int>& nums, vector<int>& queries) {\n        sort(nums.begin(), nums.end());\n        vector<long long> sums(1, 0);\n        for (auto &num: nums) sums.push_back(sums.back() + num);\n        vector<long long> res;\n        for (auto &qv : queries) {\n            long long q = qv; \n            int l = 0, r = nums.size();\n            while (l < r) {\n                int m = (l + r) / 2;\n                if (nums[m] >= q) r = m;\n                else l = m + 1;\n            }\n            if (l == 0 || r == nums.size()) \n                res.push_back(fabs(sums.back() - q * (long long)nums.size()));\n            else {\n                long long nl = sums[l] - sums[0], nr = sums[nums.size()] - sums[l],\n                          vl = l * q - nl, vr = nr - (nums.size() - l) * q;\n                res.push_back(vl + vr);\n            }\n        }\n        return res;\n    }\n};","date":"2023-03-26"},{"script":"python","time":792,"memory":44.5,"desc":"同上。","code":"class Solution:\n    def minOperations(self, nums: List[int], queries: List[int]) -> List[int]:\n        nums.sort()\n        sums = [0]\n        for num in nums:\n            sums.append(sums[-1] + num)\n        res = []\n        for q in queries:\n            l, r = 0, len(nums)\n            while l < r:\n                m = (l+r)//2\n                if nums[m] >= q:\n                    r = m\n                else:\n                    l = m+1\n            if l == 0 or r == len(nums):\n                res.append(abs(sums[-1] - q * len(nums)))\n            else:\n                nl, nr = sums[l] - sums[0], sums[nums.size()] - sums[l]\n                vl, vr = l * q - nl, nr - (nums.size() - l) * q\n                res.append(vl+vr)\n        return res","date":"2023-03-26"},{"script":"rust","time":60,"memory":5,"desc":"同上。","code":"impl Solution {\n    pub fn min_operations(mut nums: Vec<i32>, queries: Vec<i32>) -> Vec<i64> {\n        nums.sort();\n        let mut sums: Vec<i64> = vec![0; 1];\n        for num in &nums {\n            sums.push(*sums.last().unwrap() + *num as i64);\n        }\n        let mut res = vec![];\n        for q in queries {\n            let q = q as usize;\n            let (mut l, mut r) = (0, nums.len());\n            while l < r {\n                let m = (l + r) / 2;\n                if nums[m] >= q as i32 {\n                    r = m;\n                } else {\n                    l = m + 1;\n                }\n            }\n            if l == 0 || r == nums.len() {\n                res.push((*sums.last().unwrap() - (q * nums.len()) as i64).abs());\n            } else {\n                let (nl, nr) = (sums[l] - sums[0], sums[nums.len()] - sums[l]);\n                let (l, q) = (l as i64, q as i64);\n                let (vl, vr) = (l * q - nl, nr - (nums.len() as i64 - l) * q);\n                res.push(vl + vr);\n            }\n        }\n        res\n    }\n}","date":"2023-03-26"}],"tagList":["数组","二分查找","前缀和","排序"],"level":"Medium"}},{"problemName":"2603.收集树中金币.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2603.收集树中金币.json","problemData":{"id":"2717","name":"2603.收集树中金币","url":"https://leetcode.cn/problems/collect-coins-in-a-tree","desc":"你需要收集树中所有的金币，并且回到出发节点，请你返回最少经过的边数。","solutions":[{"script":"cpp","time":632,"memory":206.8,"desc":"先删除所有没有金币的叶子节点，再遍历两次，删除有金币的叶子节点，剩下的节点就是所有需要遍历的节点。","code":"class Solution {\npublic:\n    int collectTheCoins(vector<int>& coins, vector<vector<int>>& edges) {\n        int n = coins.size();\n        vector<vector<int>> list(n);\n        vector<int> cnts(n, 0);\n        for (auto &edge : edges) {\n            list[edge[0]].push_back(edge[1]);\n            list[edge[1]].push_back(edge[0]);\n            cnts[edge[0]] += 1;\n            cnts[edge[1]] += 1;\n        }\n        int cur_edges = n - 1;\n        queue<int> q;\n        // 第一次刪除所有的无金币叶子节点\n        for (int i = 0; i < n; i++) {\n            if (cnts[i] == 1 && coins[i] == 0) q.push(i); \n        }\n        while (q.size()) {\n            int idx = q.front();\n            q.pop();\n            cur_edges -= 1;\n            for (auto &next : list[idx]) {\n                cnts[next] -= 1;\n                if (cnts[next] == 1 && coins[next] == 0) q.push(next);\n            }\n        }\n        // 第二次寻找所有的叶子金币节点\n        for (int i = 0; i < n; i++) {\n            if (cnts[i] == 1 && coins[i] == 1) q.push(i);\n        }\n        cur_edges -= q.size();\n        while (q.size()) {\n            int idx = q.front();\n            q.pop();\n            for (auto &next : list[idx]) {\n                cnts[next] -= 1;\n                if (cnts[next] == 1) {\n                    cnts[next] -= 1;\n                    cur_edges -= 1;\n                }\n            }\n        }\n        return max(cur_edges * 2, 0);\n    }\n};","date":"2023-03-26"},{"script":"python","time":256,"memory":27.6,"desc":"同上。","code":"class Solution:\n    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n        n = len(coins)\n        l = [[] for _ in range(n)]\n        cnts = [0] * n\n        for edge in edges:\n            l[edge[0]].append(edge[1])\n            l[edge[1]].append(edge[0])\n            cnts[edge[0]] += 1\n            cnts[edge[1]] += 1\n        cur_edges = n - 1\n        q = deque()\n        for i in range(n):\n            if cnts[i] == 1 and coins[i] == 0:\n                q.append(i)\n        while len(q):\n            idx = q.popleft()\n            cur_edges -= 1\n            for ne in l[idx]:\n                cnts[ne] -= 1\n                if cnts[ne] == 1 and coins[ne] == 0:\n                    q.append(ne)\n        for i in range(n):\n            if cnts[i] == 1 and coins[i] == 1:\n                q.append(i)\n        cur_edges -= len(q)\n        while len(q):\n            idx = q.popleft()\n            for ne in l[idx]:\n                cnts[ne] -= 1\n                if cnts[ne] == 1:\n                    cnts[ne] -= 1\n                    cur_edges -= 1\n        return max(cur_edges * 2, 0)","date":"2023-03-26"},{"script":"rust","time":52,"memory":5.2,"desc":"同上。","code":"impl Solution {\n    pub fn collect_the_coins(coins: Vec<i32>, edges: Vec<Vec<i32>>) -> i32 {\n        let n = coins.len();\n        let mut list = vec![vec![]; n];\n        let mut cnts = vec![0; n];\n        for edge in edges {\n            list[edge[0] as usize].push(edge[1]);\n            list[edge[1] as usize].push(edge[0]);\n            cnts[edge[0] as usize] += 1;\n            cnts[edge[1] as usize] += 1;\n        }\n        let mut cur_edges = n - 1;\n        let mut q = std::collections::VecDeque::<usize>::new();\n        for i in 0..n {\n            if cnts[i] == 1 && coins[i] == 0 {\n                q.push_back(i);\n            }\n        }\n        while !q.is_empty() {\n            let idx = q.pop_front().unwrap();\n            cur_edges -= 1;\n            for next in list[idx].iter() {\n                let next = *next as usize;\n                cnts[next] -= 1;\n                if cnts[next] == 1 && coins[next] == 0 {\n                    q.push_back(next)\n                }\n            }\n        }\n        for i in 0..n {\n            if cnts[i] == 1 && coins[i] == 1 {\n                q.push_back(i);\n            }\n        }\n        cur_edges -= q.len();\n        while !q.is_empty() {\n            let idx = q.pop_front().unwrap();\n            for next in list[idx].iter() {\n                let next = *next as usize;\n                cnts[next] -= 1;\n                if cnts[next] == 1 {\n                    cnts[next] -= 1;\n                    cur_edges -= 1;\n                }\n            }\n        }\n        0.max(2 * cur_edges as i32)\n    }\n}","date":"2023-03-26"},{"script":"python","time":3812,"memory":28.9,"desc":"同上。","code":"class Solution:\n    def collectTheCoins(self, coins: List[int], edges: List[List[int]]) -> int:\n        n = len(edges) + 1\n        nodes: List[List[int]] = [[] for _ in range(n)]\n        for [n1, n2] in edges:\n            nodes[n1].append(n2)\n            nodes[n2].append(n1)\n        egde_sum = n - 1\n        # 把叶子没金币的删掉\n        q = deque(i for i in range(n) if len(nodes[i]) == 1 and coins[i] == 0)\n        while q:\n            cur = q.pop()\n            for idx in nodes[cur]:\n                egde_sum -= 1\n                nodes[idx].remove(cur)\n                if len(nodes[idx]) == 1 and coins[idx] == 0:\n                    q.append(idx)\n        # 遍历所有叶子有金币的\n        q = deque(i for i in range(n) if len(nodes[i]) == 1 and coins[i] == 1)\n        while q:\n            cur = q.pop()\n            egde_sum -= 1\n            for idx in nodes[cur]:\n                nodes[idx].remove(cur)\n                # 如果他只剩一条边，那就也可以不遍历他\n                if len(nodes[idx]) == 1:\n                    egde_sum -= 1\n        return max(egde_sum * 2, 0)","date":"2023-09-21"}],"tagList":["树","图","拓扑排序","数组"],"level":"Hard"}},{"problemName":"2605.从两个数字数组里生成最小数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2605.从两个数字数组里生成最小数字.json","problemData":{"id":"2668","name":"2605.从两个数字数组里生成最小数字","url":"https://leetcode.cn/problems/form-smallest-number-from-two-digit-arrays","desc":"给你两个只包含 1 到 9 之间数字的数组 nums1 和 nums2 ，每个数组中的元素 互不相同 ，请你返回 最小 的数字，两个数组都 至少 包含这个数字的某个数位。","solutions":[{"script":"python","time":40,"memory":15.7,"desc":"排序后遍历。","code":"class Solution:\n    def minNumber(self, nums1: List[int], nums2: List[int]) -> int:\n        nums1.sort()\n        nums2.sort()\n        for num in nums1:\n            if num in nums2:\n                return num\n        return min(nums1[0] * 10 + nums2[0], nums2[0] * 10 + nums1[0])","date":"2023-09-05"}],"tagList":["数组","哈希表","枚举"],"level":"Easy"}},{"problemName":"2609.最长平衡子字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2609.最长平衡子字符串.json","problemData":{"id":"2723","name":"2609.最长平衡子字符串","url":"https://leetcode.cn/problems/find-the-longest-balanced-substring-of-a-binary-string","desc":"给你一个仅由 0 和 1 组成的二进制字符串 s 。 如果子字符串中 所有的 0 都在 1 之前 且其中 0 的数量等于 1 的数量，则认为 s 的这个子字符串是平衡子字符串。请注意，空子字符串也视作平衡子字符串。 返回  s 中最长的平衡子字符串长度。","solutions":[{"script":"cpp","time":0,"memory":6,"desc":"遍历。","code":"class Solution {\n   public:\n    int findTheLongestBalancedSubstring(string s) {\n        int cnt0 = 0, cnt1 = 0, res = 0;\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == '0') {\n                cnt0++;\n            } else {\n                cnt1++;\n                if (cnt0 >= cnt1) {\n                    res = max(res, cnt1 * 2);\n                }\n                if (i + 1 == s.size() || s[i + 1] == '0') {\n                    cnt0 = cnt1 = 0;\n                }\n            }\n        }\n        return res;\n    }\n};","date":"2023-04-02"},{"script":"python","time":36,"memory":15,"desc":"同上。","code":"class Solution:\n    def findTheLongestBalancedSubstring(self, s: str) -> int:\n        cnt0 = cnt1 = res = 0\n        for i in range(len(s)):\n            c = s[i]\n            if c == '0':\n                cnt0 += 1\n            else:\n                cnt1 += 1\n                if cnt0 >= cnt1:\n                    res = max(res, cnt1*2)\n                if i + 1 == len(s) or s[i+1] == '0':\n                    cnt0 = cnt1 = 0\n        return res","date":"2023-04-02"},{"script":"rust","time":0,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn find_the_longest_balanced_substring(s: String) -> i32 {\n        let s = s.chars().collect::<Vec<char>>();\n        let (mut cnt0, mut cnt1, mut res) = (0, 0, 0);\n        for i in 0..s.len() {\n            if s[i] == '0' {\n                cnt0 += 1\n            } else {\n                cnt1 += 1;\n                if cnt0 >= cnt1 {\n                    res = res.max(cnt1 * 2)\n                }\n                if i + 1 == s.len() || s[i + 1] == '0' {\n                    cnt0 = 0;\n                    cnt1 = 0;\n                }\n            }\n        }\n        res\n    }\n}","date":"2023-04-02"},{"script":"python","time":44,"memory":15.48,"desc":"一次遍历。","code":"class Solution:\n    def findTheLongestBalancedSubstring(self, s: str) -> int:\n        n = len(s)\n        i = ans = 0\n        while i < n and s[i] == '1': i += 1\n        while i < n:\n            cur = i\n            while i < n and s[i] == '0': i += 1\n            cnt0 = i - cur\n            while i < n and s[i] == '1': i += 1\n            cnt1 = i - cur - cnt0\n            ans = max(ans, min(cnt0, cnt1) * 2)\n        return ans","date":"2023-11-08"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"2610.转换二维数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2610.转换二维数组.json","problemData":{"id":"2724","name":"2610.转换二维数组","url":"https://leetcode.cn/problems/convert-an-array-into-a-2d-array-with-conditions","desc":"给你一个整数数组 nums 。请你创建一个满足以下条件的二维数组。","solutions":[{"script":"cpp","time":12,"memory":29.2,"desc":"哈希存储。","code":"class Solution {\n   public:\n    vector<vector<int>> findMatrix(vector<int> &nums) {\n        unordered_map<int, int> m;\n        for (auto &num : nums) m[num]++;\n        vector<vector<int>> res;\n        while (1) {\n            bool f = false;\n            vector<int> items;\n            for (auto &item : m) {\n                if (item.second == 0) continue;                \n                item.second--;\n                items.push_back(item.first);\n                f = true;\n            }\n            if (!f) break;\n            res.push_back(items);\n        }\n        return res;\n    }\n};","date":"2023-04-02"},{"script":"python","time":48,"memory":15,"desc":"同上。","code":"class Solution:\n    def findMatrix(self, nums: List[int]) -> List[List[int]]:\n        m = Counter()\n        for num in nums:\n            m[num] += 1\n        res = []\n        while True:\n            f = False\n            items = []\n            for k, v in m.items():\n                if v == 0:\n                    continue\n                m[k] -= 1\n                items.append(k)\n                f = True\n            if not f:\n                break\n            res.append(items)\n        return res","date":"2023-04-02"},{"script":"rust","time":0,"memory":2.1,"desc":"同上。","code":"impl Solution {\n    pub fn find_matrix(nums: Vec<i32>) -> Vec<Vec<i32>> {\n        let mut m = std::collections::HashMap::<i32, i32>::new();\n        for num in nums {\n            *m.entry(num).or_insert(0) += 1;\n        }\n        let mut res = vec![];\n        loop {\n            let mut f = false;\n            let mut items = vec![];\n            for (k, v) in m.iter_mut() {\n                if *v == 0 {\n                    continue;\n                }\n                *v -= 1;\n                items.push(*k);\n                f = true;\n            }\n            if !f {\n                break;\n            }\n            res.push(items);\n        }\n        res\n    }\n}","date":"2023-04-02"}],"tagList":["数组","哈希表"],"level":"Medium"}},{"problemName":"2611.老鼠和奶酪.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2611.老鼠和奶酪.json","problemData":{"id":"2725","name":"2611.老鼠和奶酪","url":"https://leetcode.cn/problems/mice-and-cheese","desc":"给你一个整数数组 nums 。请你创建一个满足以下条件的二维数组。","solutions":[{"script":"cpp","time":132,"memory":107.6,"desc":"贪心找价值比最高的。","code":"class Solution {\n   public:\n    typedef pair<int, int> pii;\n    int miceAndCheese(vector<int> &reward1, vector<int> &reward2, int k) {\n        int n = reward1.size();\n        vector<pii> list;\n        for (int i = 0; i < n; i++) {\n            list.push_back(make_pair(reward1[i], reward2[i]));\n        }\n        sort(list.begin(), list.end(), [](auto &a, auto &b) {\n            int v1 = a.second - a.first, v2 = b.second - b.first;\n            return v1 < v2;\n        });\n        int res = 0, i = 0;\n        while (k--) res += list[i++].first;\n        while (i < n) res += list[i++].second;\n        return res;\n    }\n};","date":"2023-04-02"},{"script":"python","time":184,"memory":32.6,"desc":"同上。","code":"class Solution:\n    def miceAndCheese(self, reward1: List[int], reward2: List[int], k: int) -> int:\n        n = len(reward1)\n        l: List[(int, int)] = []\n        for i in range(n):\n            l.append((reward1[i], reward2[i]))\n        l.sort(key=lambda v: v[1] - v[0])\n        res = i = 0\n        while k:\n            res += l[i][0]\n            i += 1\n            k -= 1\n        while i < n:\n            res += l[i][1]\n            i += 1\n        return res","date":"2023-04-02"},{"script":"rust","time":28,"memory":4.3,"desc":"同上。","code":"impl Solution {\n    pub fn mice_and_cheese(reward1: Vec<i32>, reward2: Vec<i32>, mut k: i32) -> i32 {\n        let n = reward1.len();\n        let mut list: Vec<(i32, i32)> = vec![];\n        for i in 0..n {\n            list.push((reward1[i], reward2[i]));\n        }\n        list.sort_by_key(|v| (*v).1 - (*v).0);\n        let mut res = 0;\n        let mut i = 0;\n        while k != 0 {\n            res += list[i].0;\n            i += 1;\n            k -= 1;\n        }\n        while i < n {\n            res += list[i].1;\n            i += 1;\n        }\n        res\n    }\n}","date":"2023-04-02"},{"script":"cpp","time":312,"memory":103.5,"desc":"哈希存储。","code":"#define SORT(list, fn) sort(list.begin(), list.end(), [&](auto &v1, auto &v2){ fn });\nclass Solution {\npublic:\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\n        int n = reward1.size(), res = 0;\n        vector<int> idxs;\n        for (int i = 0; i < n; i++) idxs.push_back(i);\n        SORT(idxs, { return reward1[v1] - reward2[v1] < reward1[v2] - reward2[v2]; });\n        for (int i = 0; i < n - k; i++) res += reward2[idxs[i]];\n        for (int i = n - k; i < n; i++) res += reward1[idxs[i]];\n        return res;\n    }\n};","date":"2023-06-07"}],"tagList":["贪心","数组","排序","堆（优先队列）"],"level":"Medium"}},{"problemName":"2612.最少翻转操作数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2612.最少翻转操作数.json","problemData":{"id":"2726","name":"2612.最少翻转操作数","url":"https://leetcode.cn/problems/minimum-reverse-operations","desc":"请你返回一个数组 ans ，对于 [0, n - 1] 之间的任意下标 i ，ans[i] 是将 1 放到位置 i 处的 最少 翻转操作次数，如果无法放到位置 i 处，此数为 -1 。","solutions":[{"script":"cpp","time":716,"memory":163.36,"desc":"bfs+利用排序树快速删除和查找。","code":"class Solution {\n   public:\n    vector<int> minReverseOperations(int n, int p, vector<int> &banned, int k) {\n        vector<int> res(n, -1);\n        res[p] = 0;\n        if (k == 0 || k == 1) return res;\n        unordered_set<int> used(banned.begin(), banned.end());\n        set<int> ss[2];\n        ss[0].insert(n);\n        ss[1].insert(n);\n        for (int i = 0; i < n; i++) {\n            if (i != p && !used.count(i)) ss[i % 2].insert(i);\n        }\n        queue<int> q;\n        int size = 1, cnt = 1;\n        q.push(p);\n        while (q.size()) {\n            int p = q.front(), \n                nmin = max(p - k + 1, k - p - 1), \n                nmax = min(p + k - 1, 2 * n - k - p - 1);\n            q.pop();\n            auto it = ss[nmin % 2].lower_bound(nmin);\n            while (*it <= nmax) {\n                cout << \"it= \" << *it << endl;\n                res[*it] = cnt;\n                q.push(*it);\n                ss[nmin % 2].erase(*it++);\n            }\n            if (--size == 0) {\n                cnt++;\n                size = q.size();\n            }\n        }\n        return res;\n    }\n};","date":"2023-04-02"}],"tagList":["广度优先搜索","数组","有序集合"],"level":"Hard"}},{"problemName":"2614.对角线上的质数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2614.对角线上的质数.json","problemData":{"id":"2722","name":"2614.对角线上的质数","url":"https://leetcode.cn/problems/prime-in-diagonal","desc":"给你一个下标从 0 开始的二维整数数组 nums 。返回位于 nums 至少一条 对角线 上的最大 质数 。如果任一对角线上均不存在质数，返回 0 。","solutions":[{"script":"cpp","time":268,"memory":69.8,"desc":"线性筛。","code":"class Solution {\npublic:\n    int diagonalPrime(vector<vector<int>>& nums) {\n        int n = nums.size(), res = 0, MAX = 0;\n        unordered_set<int> s;\n        for (int i = 0; i < n; i++) {\n            s.insert(nums[i][i]);\n            s.insert(nums[i][n - 1 - i]);\n            MAX = max(MAX, nums[i][i]);\n            MAX = max(MAX, nums[i][n - 1 - i]);\n        }\n        MAX++;\n        vector<int> primes(MAX, 0);\n        for (int i = 2; i < MAX; i++) {\n            if (primes[i] == 0) {\n                primes[++primes[0]] = i;\n                if (s.count(i)) res = max(res, i);\n            }\n            for (int j = 1; j <= primes[0] && i * primes[j] < MAX; j++) {\n                primes[i * primes[j]] = 1;\n                if (i % primes[j] == 0) break;\n            }\n        }\n        return res;\n    }\n};","date":"2023-04-09"},{"script":"cpp","time":72,"memory":34.7,"desc":"枚举。","code":"class Solution {\npublic:\n    bool check(int num) {\n        if (num == 1) return false;\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n    int diagonalPrime(vector<vector<int>>& nums) {\n        int n = nums.size(), res = 0;\n        for (int i = 0; i < n; i++) {\n            if (check(nums[i][i])) res = max(res, nums[i][i]);\n            if (check(nums[i][n - 1 - i])) res = max(res, nums[i][n - 1 - i]);\n        }\n        return res;\n    }\n};","date":"2023-04-09"},{"script":"python","time":216,"memory":26.9,"desc":"同上。","code":"def check(num: int):\n    if num == 1:\n        return False\n    i = 2\n    while i * i <= num:\n        if num % i == 0:\n            return False\n        i += 1\n    return True\n\nclass Solution:\n    def diagonalPrime(self, nums: List[List[int]]) -> int:\n        n = len(nums)\n        res = 0\n        for i in range(n):\n            if check(nums[i][i]):\n                res = max(res, nums[i][i])\n            if check(nums[i][n - 1 - i]):\n                res = max(res, nums[i][n - 1 - i])\n        return res","date":"2023-04-09"},{"script":"rust","time":16,"memory":3.6,"desc":"同上。","code":"impl Solution {\n    pub fn diagonal_prime(nums: Vec<Vec<i32>>) -> i32 {\n        use std::cmp::max;\n        let check = |num: i32| {\n            if num == 1 {\n                false\n            } else {\n                let mut i = 2;\n                while i * i <= num {\n                    if num % i == 0 {\n                        return false;\n                    }\n                    i += 1;\n                }\n                true\n            }\n        };\n        let n = nums.len();\n        let mut res = 0;\n        for i in 0..n {\n            if check(nums[i][i]) {\n                res = max(res, nums[i][i]);\n            }\n            if check(nums[i][n - 1 - i]) {\n                res = max(res, nums[i][n - 1 - i]);\n            }\n        }\n        res\n    }\n}","date":"2023-04-09"}],"tagList":["数组","数学","矩阵","数论"],"level":"Easy"}},{"problemName":"2615.等值距离和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2615.等值距离和.json","problemData":{"id":"2721","name":"2615.等值距离和","url":"https://leetcode.cn/problems/sum-of-distances","desc":"给你一个下标从 0 开始的整数数组 nums 。现有一个长度等于 nums.length 的数组 arr 。对于满足 nums[j] == nums[i] 且 j != i 的所有 j ，arr[i] 等于所有 |i - j| 之和。如果不存在这样的 j ，则令 arr[i] 等于 0 。返回数组 arr 。","solutions":[{"script":"cpp","time":72,"memory":34.7,"desc":"收集所有相同数字的下标，做前缀和进行左右比较。","code":"class Solution {\npublic:\n    typedef long long ll;\n    vector<ll> distance(vector<int>& nums) {\n        int n = nums.size();\n        vector<ll> arr(n, 0);\n        unordered_map<int, vector<int>> m;\n        for (int i = 0; i < n; i++) {\n            m[nums[i]].push_back(i);\n        }\n        for (auto &item : m) {\n            auto &list = item.second;\n            ll sum = 0, left = 0;\n            for (auto &v : list) sum += v - list[0];\n            for (int i = 0; i < list.size(); i++) {\n                arr[list[i]] = sum + left;\n                if (i + 1 < list.size()) {\n                    left += (list[i + 1] - list[i]) * (i + 1);\n                    sum -= (list[i + 1] - list[i]) * (list.size() - 1 - i);\n                }\n            }\n        }\n        return arr;\n    }\n};","date":"2023-04-09"},{"script":"python","time":412,"memory":52.2,"desc":"同上。","code":"class Solution:\n    def distance(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        arr = [0] * n\n        m: dict[int, List[int]] = {}\n        for i in range(n):\n            if not nums[i] in m:\n                m[nums[i]] = []\n            m[nums[i]].append(i)\n        for _, list in m.items():\n            l, r = 0, 0\n            for v in list:\n                r += v - list[0]\n            for i in range(len(list)):\n                arr[list[i]] = r + l\n                if i + 1 < len(list):\n                    l += (list[i + 1] - list[i]) * (i + 1)\n                    r -= (list[i + 1] - list[i]) * (len(list) - 1 - i)\n        return arr","date":"2023-04-09"},{"script":"rust","time":68,"memory":12,"desc":"同上。","code":"impl Solution {\n    pub fn distance(nums: Vec<i32>) -> Vec<i64> {\n        use std::collections::HashMap;\n        let n = nums.len();\n        let mut arr: Vec<i64> = vec![0; n];\n        let mut m = HashMap::<i32, Vec<usize>>::new();\n        for i in 0..n {\n            let item = m.entry(nums[i]).or_insert(Vec::new());\n            item.push(i);\n        }\n        for (_, list) in m.into_iter() {\n            let (mut r, mut l) = (0, 0);\n            for v in &list {\n                r += *v - list[0];\n            }\n            for i in 0..list.len() {\n                arr[list[i]] = (r + l) as i64;\n                if i + 1 < list.len() {\n                    l += (list[i + 1] - list[i]) * (i + 1);\n                    r -= (list[i + 1] - list[i]) * (list.len() - 1 - i);\n                }\n            }\n        }\n        arr\n    }\n}","date":"2023-04-09"}],"tagList":["数组","哈希表","前缀和"],"level":"Medium"}},{"problemName":"2616.最小化数对的最大差值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2616.最小化数对的最大差值.json","problemData":{"id":"2720","name":"2616.最小化数对的最大差值","url":"https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs","desc":"给你一个下标从 0 开始的整数数组 nums 和一个整数 p 。请你从 nums 中找到 p 个下标对，每个下标对对应数值取差值，你需要使得这 p 个差值的 最大值 最小。同时，你需要确保每个下标在这 p 个下标对中最多出现一次。对于一个下标对 i 和 j ，这一对的差值为 |nums[i] - nums[j]| ，其中 |x| 表示 x 的 绝对值 。请你返回 p 个下标对对应数值 最大差值 的 最小值 。","solutions":[{"script":"cpp","time":160,"memory":79.3,"desc":"最大最小，二分查找。","code":"class Solution {\npublic:\n    int minimizeMax(vector<int>& nums, int p) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size();\n        auto check = [&](int target) -> bool {\n            int cnt = 0;\n            for(int i = 0; i < n && cnt < p; i++){\n                if (i + 1 < n && nums[i + 1] - nums[i] <= target) i++, cnt++;\n            }\n            return cnt >= p;\n        };\n        int l = 0, r = 1e9 + 7;\n        while(l < r){\n            int mid = (l + r) / 2;\n            if(check(mid)) r = mid;\n            else l = mid + 1;\n        }\n        return l;\n    }\n};","date":"2023-04-09"},{"script":"python","time":1140,"memory":29.6,"desc":"同上。","code":"class Solution:\n    def minimizeMax(self, nums: List[int], p: int) -> int:\n        nums.sort()\n        n = len(nums)\n  \n        def check(target: int) -> bool:\n            cnt = 0\n            i = 0\n            while i < n and cnt < p:\n                if i + 1 < n and nums[i + 1] - nums[i] <= target:\n                    i += 1\n                    cnt += 1\n                i += 1\n            return cnt >= p\n        l, r = 0, 1000000000+7\n        while l < r:\n            m = (l + r) // 2\n            if check(m):\n                r = m\n            else:\n                l = m+1\n        return l","date":"2023-04-09"},{"script":"rust","time":24,"memory":3.3,"desc":"同上。","code":"impl Solution {\n    pub fn minimize_max(mut nums: Vec<i32>, p: i32) -> i32 {\n        nums.sort();\n        let n = nums.len();\n        let (mut l, mut r) = (0, *nums.iter().max().unwrap());\n        let check = |target: i32| -> bool {\n            let mut cnt = 0;\n            let mut i = 0;\n            while i < n && cnt < p {\n                if i + 1 < n && nums[i + 1] - nums[i] <= target {\n                    i += 1;\n                    cnt += 1;\n                }\n                i += 1;\n            }\n            cnt >= p\n        };\n        while l < r {\n            let m = (l + r) / 2;\n            if check(m) {\n                r = m;\n            } else {\n                l = m + 1;\n            }\n        }\n        l\n    }\n}","date":"2023-04-09"}],"tagList":["贪心","数组","二分查找"],"level":"Medium"}},{"problemName":"2617.网格图中最少访问的格子数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2617.网格图中最少访问的格子数.json","problemData":{"id":"2697","name":"2617.网格图中最少访问的格子数","url":"https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid","desc":"请你返回到达 右下角 格子 (m - 1, n - 1) 需要经过的最少移动格子数，如果无法到达右下角格子，请你返回 -1 。","solutions":[{"script":"cpp","time":1312,"memory":340.1,"desc":"平衡树。","code":"#define X first\n#define Y second\nclass Solution {\npublic:\n    typedef pair<int, int> pii;\n    int minimumVisitedCells(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<set<int>> rows(n), cols(m);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                rows[i].insert(j);\n                cols[j].insert(i);\n            }\n        }\n        queue<pii> q;\n        q.push(make_pair(0, 0));\n        int size = 1, step = 1;\n        while (q.size()) {\n            auto cur = q.front();\n            q.pop();\n            if (cur.X == n - 1 && cur.Y == m - 1) return step;\n            int nmin = cur.Y + 1, nmax = grid[cur.X][cur.Y] + cur.Y;\n            auto it = rows[cur.X].lower_bound(nmin);\n            while (it != rows[cur.X].end() && *it <= nmax) {\n                q.push(make_pair(cur.X, *it));\n                it = rows[cur.X].erase(it);\n            }\n            nmin = cur.X + 1, nmax = grid[cur.X][cur.Y] + cur.X;\n            it = cols[cur.Y].lower_bound(nmin);\n            while (it != cols[cur.Y].end() && *it <= nmax) {\n                q.push(make_pair(*it, cur.Y));\n                it = cols[cur.Y].erase(it);\n            }\n            if (--size == 0) {\n                size = q.size();\n                step++;\n            }\n        }\n        return -1;\n    }\n};","date":"2023-04-09"}],"tagList":["栈","广度优先搜索","并查集","数组","动态规划","矩阵","单调栈","堆（优先队列）"],"level":"Hard"}},{"problemName":"2618.检查是否是类的对象实例.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2618.检查是否是类的对象实例.json","problemData":{"id":"2758","name":"2618.检查是否是类的对象实例","url":"https://leetcode.cn/problems/check-if-object-instance-of-class","desc":"请你编写一个函数，检查给定的对象是否是给定类或超类的实例。","solutions":[{"script":"typescript","time":112,"memory":53,"desc":"dp[i]表示以i为行末的最大高度。","code":"function checkIfInstanceOf(obj: any, classFunction: any): boolean {\n    if (obj === null || obj === undefined || classFunction == null || classFunction == undefined) return false;\n    while ((obj = obj.__proto__) && obj !== classFunction.prototype);\n    return obj === classFunction.prototype;\n}","date":"2023-04-23"}],"tagList":[],"level":"Medium"}},{"problemName":"2619.数组原型对象的最后一个元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2619.数组原型对象的最后一个元素.json","problemData":{"id":"2734","name":"2619.数组原型对象的最后一个元素","url":"https://leetcode.cn/problems/array-prototype-last","desc":"请你编写一段代码实现一个数组方法，使任何数组都可以调用 array.last() 方法，这个方法将返回数组最后一个元素。如果数组中没有元素，则返回 -1 。","solutions":[{"script":"typescript","time":64,"memory":42.3,"desc":"因为prototype上的会绑定this，直接获取即可。","code":"declare global {\n    interface Array<T> {\n        last(): T | -1;\n    }\n}\n\nArray.prototype.last = function() {\n    return this.length ? this[this.length - 1] : -1;\n};","date":"2023-04-23"}],"tagList":[],"level":"Easy"}},{"problemName":"2620.计数器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2620.计数器.json","problemData":{"id":"2732","name":"2620.计数器","url":"https://leetcode.cn/problems/counter","desc":"请你编写并返回一个 计数器 函数，它接收一个整型参数 n 。这个 计数器 函数最初返回 n，每次调用它时返回前一个值加 1 的值 ( n ,  n + 1 ,  n + 2 ，等等)。","solutions":[{"script":"typescript","time":64,"memory":42.4,"desc":"闭包。","code":"function createCounter(n: number): () => number {\n    return () => n++;\n}","date":"2023-04-23"}],"tagList":[],"level":"Easy"}},{"problemName":"2621.睡眠函数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2621.睡眠函数.json","problemData":{"id":"2733","name":"2621.睡眠函数","url":"https://leetcode.cn/problems/sleep","desc":"请你编写一个异步函数，它接收一个正整数参数 millis ，并休眠这么多毫秒。要求此函数可以解析任何值。","solutions":[{"script":"typescript","time":76,"memory":42.1,"desc":"利用promise可以延迟返回的原理，在内部设置timeout。","code":"async function sleep(millis: number): Promise<void> {\n    return new Promise(r => {\n        setTimeout(r, millis)\n    })\n}","date":"2023-04-23"}],"tagList":[],"level":"Easy"}},{"problemName":"2622.有时间限制的缓存.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2622.有时间限制的缓存.json","problemData":{"id":"2762","name":"2622.有时间限制的缓存","url":"https://leetcode.cn/problems/cache-with-time-limit","desc":"编写一个类，它允许获取和设置键-值对，并且每个键都有一个 过期时间 。","solutions":[{"script":"typescript","time":68,"memory":42.6,"desc":"哈希存储。","code":"class TimeLimitedCache {\n    cache = new Map<number, [number, number]>();\n\n    set(key: number, value: number, duration: number): boolean {\n        const now = Date.now();\n        const item = this.cache.get(key);\n        if (item) {\n            item[0] = now + duration;\n            item[1] = value;\n            return true;\n        } else {\n            this.cache.set(key, [now + duration, value]);\n            return false;\n        }\n    }\n\n    get(key: number): number {\n        const now = Date.now();\n        const item = this.cache.get(key);\n        if (!item || now > item[0]) return -1;\n        return item[1];\n    }\n\n    count(): number {\n        const now = Date.now();\n        let res = 0;\n        for (const [key, item] of this.cache.entries()) {\n            if (now > item[0]) {\n                this.cache.delete(key);\n            } else {\n                res++;\n            }\n        }\n        return res;\n    }\n}","date":"2023-04-23"}],"tagList":[],"level":"Medium"}},{"problemName":"2623.记忆函数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2623.记忆函数.json","problemData":{"id":"2731","name":"2623.记忆函数","url":"https://leetcode.cn/problems/memoize","desc":"请你编写一个函数，它接收另一个函数作为输入，并返回该函数的 记忆化 后的结果。","solutions":[{"script":"typescript","time":360,"memory":81.2,"desc":"哈希存储。","code":"type Fn = (...params: any) => any\n\nfunction memoize(fn: Fn): Fn {\n    const cache : Record<string, number> = {};\n    return function(...args) {\n        const key = args.join(\":\");\n        if (cache[key] !== undefined) return cache[key];\n        return cache[key] = fn(...args);\n    }\n}","date":"2023-04-23"}],"tagList":[],"level":"Medium"}},{"problemName":"2624.蜗牛排序.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2624.蜗牛排序.json","problemData":{"id":"2760","name":"2624.蜗牛排序","url":"https://leetcode.cn/problems/snail-traversal","desc":"请你编写一段代码为所有数组实现  snail(rowsCount，colsCount) 方法，该方法将 1D 数组转换为以蜗牛排序的模式的 2D 数组。","solutions":[{"script":"typescript","time":212,"memory":55.8,"desc":"模拟，利用方向数组控制方向。","code":"declare global {\n  interface Array<T> {\n    snail(rowsCount: number, colsCount: number): number[][];\n  }\n}\n\nArray.prototype.snail = function (rowsCount: number, colsCount: number): number[][] {\n  if (rowsCount * colsCount !== this.length) return [];\n  const res: number[][] = new Array(rowsCount).fill(0).map(_ => new Array(colsCount).fill(0));\n  const dirs = [\n    [0, rowsCount, 1],\n    [rowsCount - 1, -1, -1],\n  ];\n  let idx = 0;\n  for (let j = 0; j < colsCount; j++) {\n    const dir = dirs[j % 2];\n    for (let i = dir[0]; i != dir[1]; i += dir[2]) {\n      res[i][j] = this[idx++];\n    }\n  }\n  return res;\n};","date":"2023-04-23"}],"tagList":[],"level":"Medium"}},{"problemName":"2625.扁平化嵌套数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2625.扁平化嵌套数组.json","problemData":{"id":"2759","name":"2625.扁平化嵌套数组","url":"https://leetcode.cn/problems/flatten-deeply-nested-array","desc":"请你编写一个函数，它接收一个 多维数组 arr 和它的深度 n ，并返回该数组的 扁平化 后的结果。","solutions":[{"script":"typescript","time":196,"memory":73,"desc":"dfs。","code":"type MultiDimensionalArray = (number | MultiDimensionalArray)[];\n\nvar flat = function (arr: MultiDimensionalArray, n: number): MultiDimensionalArray {\n  if (n === 0) return arr;\n  const res: MultiDimensionalArray = [];\n  for (const num of arr) {\n    if (Array.isArray(num)) res.push(...flat(num, n - 1));\n    else res.push(num);\n  }\n  return res;\n};","date":"2023-04-23"}],"tagList":[],"level":"Medium"}},{"problemName":"2626.数组归约运算.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2626.数组归约运算.json","problemData":{"id":"2761","name":"2626.数组归约运算","url":"https://leetcode.cn/problems/array-reduce-transformation","desc":"请你编写一个函数，它的参数为一个整数数组 nums 、一个计算函数 fn 和初始值 init 。返回一个数组 归约后 的值。","solutions":[{"script":"typescript","time":72,"memory":43.9,"desc":"遍历。","code":"type Fn = (accum: number, curr: number) => number\n\nfunction reduce(nums: number[], fn: Fn, init: number): number {\n    if (nums.length === 0) return init;\n    for (const num of nums) init = fn(init, num); \n    return init;\n};","date":"2023-04-23"}],"tagList":[],"level":"Easy"}},{"problemName":"2627.函数防抖.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2627.函数防抖.json","problemData":{"id":"2743","name":"2627.函数防抖","url":"https://leetcode.cn/problems/debounce","desc":"请你编写一个函数，接收参数为另一个函数和一个以毫秒为单位的时间 t ，并返回该函数的 函数防抖 后的结果。","solutions":[{"script":"typescript","time":120,"memory":50.1,"desc":"闭包。","code":"function stringCompare(str1: string, str2: string) {\n  const [n1, n2] = [str1.length, str2.length];\n  let i = 0;\n  while (i < n1 && i < n2)\n    if (str1[i] == str2[i]) i++;\n    else return str1.codePointAt(i)! - str2.codePointAt(i)!;\n  if (i == n1 && i == n2) return 0;\n  if (i == n1) return -1;\n  else return 1;\n}\nconst sort = (o: object) => Object.entries(o).sort(([k1], [k2]) => stringCompare(k1, k2));\nfunction areDeeplyEqual(o1: any, o2: any): boolean {\n  const [t1, t2] = [typeof o1, typeof o2];\n  // 类型不等就错了\n  if (t1 !== t2) return false;\n  // 如果不是对象，直接判断\n  if (t1 !== 'object') return o1 === o2;\n  // 如果是null或undefined，直接判断\n  if (o1 === null || o1 === undefined || o2 === null || o2 === undefined) return o1 === o2;\n  // 如果是数组，先判断是否都是数组或者都不是数组\n  const [isArr1, isArr2] = [Array.isArray(o1), Array.isArray(o2)];\n  if ((!isArr1 && isArr2) || (isArr1 && !isArr2)) return false;\n  // 键值对排序\n  const [item1, item2] = [sort(o1), sort(o2)];\n  // 如果长度不想等，就错了\n  if (item1.length !== item2.length) return false;\n  // 如果键不等，或者值不等，就错了\n  for (let i = 0; i < item1.length; i++)\n    if (item1[i][0] !== item2[i][0] || !areDeeplyEqual(item1[i][1], item2[i][1])) return false;\n  return true;\n}","date":"2023-04-23"}],"tagList":[],"level":"Medium"}},{"problemName":"2628.完全相等的JSON字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2628.完全相等的JSON字符串.json","problemData":{"id":"2735","name":"2628.完全相等的JSON字符串","url":"https://leetcode.cn/problems/json-deep-equal","desc":"给定两个对象 o1 和 o2 ，请你检查它们是否 完全相等 。","solutions":[{"script":"typescript","time":120,"memory":50.1,"desc":"闭包。","code":"function stringCompare(str1: string, str2: string) {\n  const [n1, n2] = [str1.length, str2.length];\n  let i = 0;\n  while (i < n1 && i < n2)\n    if (str1[i] == str2[i]) i++;\n    else return str1.codePointAt(i)! - str2.codePointAt(i)!;\n  if (i == n1 && i == n2) return 0;\n  if (i == n1) return -1;\n  else return 1;\n}\nconst sort = (o: object) => Object.entries(o).sort(([k1], [k2]) => stringCompare(k1, k2));\nfunction areDeeplyEqual(o1: any, o2: any): boolean {\n  const [t1, t2] = [typeof o1, typeof o2];\n  // 类型不等就错了\n  if (t1 !== t2) return false;\n  // 如果不是对象，直接判断\n  if (t1 !== 'object') return o1 === o2;\n  // 如果是null或undefined，直接判断\n  if (o1 === null || o1 === undefined || o2 === null || o2 === undefined) return o1 === o2;\n  // 如果是数组，先判断是否都是数组或者都不是数组\n  const [isArr1, isArr2] = [Array.isArray(o1), Array.isArray(o2)];\n  if ((!isArr1 && isArr2) || (isArr1 && !isArr2)) return false;\n  // 键值对排序\n  const [item1, item2] = [sort(o1), sort(o2)];\n  // 如果长度不想等，就错了\n  if (item1.length !== item2.length) return false;\n  // 如果键不等，或者值不等，就错了\n  for (let i = 0; i < item1.length; i++)\n    if (item1[i][0] !== item2[i][0] || !areDeeplyEqual(item1[i][1], item2[i][1])) return false;\n  return true;\n}","date":"2023-04-23"}],"tagList":[],"level":"Medium"}},{"problemName":"2629.复合函数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2629.复合函数.json","problemData":{"id":"2741","name":"2629.复合函数","url":"https://leetcode.cn/problems/function-composition","desc":"请你编写一个函数，它接收一个函数数组 [f1, f2, f3，…]， fn] ，并返回一个新的函数 fn ，它是函数数组的 复合函数 。","solutions":[{"script":"typescript","time":72,"memory":45,"desc":"遍历。","code":"type F = (x: number) => number;\n\nfunction compose(functions: F[]): F {\n    functions = functions.reverse()\n    return function (x) {\n        for (const f of functions) x = f(x);\n        return x;\n    }\n};","date":"2023-04-23"}],"tagList":[],"level":"Easy"}},{"problemName":"2630.记忆函数II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2630.记忆函数II.json","problemData":{"id":"2744","name":"2630.记忆函数II","url":"https://leetcode.cn/problems/memoize-ii","desc":"请你编写一个函数，它接收一个函数参数 fn，并返回该函数的 记忆化 后的结果。","solutions":[{"script":"typescript","time":372,"memory":102,"desc":"trie。","code":"type Fn = (...params: any) => any;\n\nconst EmptyResult = Symbol('EmptyResult');\n\nclass Trie {\n  children = new Map<any, Trie>();\n  result: any = EmptyResult;\n  constructor(public val: any) {}\n}\n\nfunction memoize(fn: Fn): Fn {\n  const root = new Trie(null);\n  return function (...args: any[]) {\n    let node = root;\n    for (const arg of args) {\n      let next = node.children.get(arg);\n      if (!next) node.children.set(arg, (next = new Trie(arg)));\n      node = next;\n    }\n    if (node.result !== EmptyResult) return node.result;\n    return (node.result = fn(...args));\n  };\n}","date":"2023-04-23"}],"tagList":[],"level":"Hard"}},{"problemName":"2631.分组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2631.分组.json","problemData":{"id":"2742","name":"2631.分组","url":"https://leetcode.cn/problems/group-by","desc":"请你编写一段可应用于所有数组的代码，使任何数组调用 array. groupBy(fn) 方法时，它返回对该数组 分组后 的结果。","solutions":[{"script":"typescript","time":132,"memory":62.6,"desc":"遍历。","code":"declare global {\n  interface Array<T> {\n    groupBy(fn: (item: T) => string): Record<string, T[]>;\n  }\n}\n\nArray.prototype.groupBy = function (fn) {\n  const o: Record<string, any> = {};\n  this.forEach(item => {\n    let arr = o[fn(item)];\n    if (!arr) arr = o[fn(item)] = [];\n    arr.push(item);\n  });\n  return o;\n};","date":"2023-04-24"}],"tagList":[],"level":"Medium"}},{"problemName":"2632.柯里化.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2632.柯里化.json","problemData":{"id":"2740","name":"2632.柯里化","url":"https://leetcode.cn/problems/curry","desc":"请你编写一个函数，它接收一个其他的函数，并返回该函数的 柯里化 后的形式。","solutions":[{"script":"typescript","time":92,"memory":42.2,"desc":"闭包存储。","code":"function curry(fn: Function): Function {\n    const argSize = fn.length;\n    const preArgs: any[] = [];\n    return function curried(...args) {\n        if (argSize === args.length + preArgs.length) return fn(...preArgs, ...args);\n        preArgs.push(...args);\n        return curried;\n    };\n};","date":"2023-04-24"}],"tagList":[],"level":"Medium"}},{"problemName":"2633.将对象转换为JSON字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2633.将对象转换为JSON字符串.json","problemData":{"id":"2745","name":"2633.将对象转换为JSON字符串","url":"https://leetcode.cn/problems/convert-object-to-json-string","desc":"现给定一个对象，返回该对象的有效 JSON 字符串。你可以假设这个对象只包括字符串、整数、数组、对象、布尔值和 null。返回的字符串不能包含额外的空格。键的返回顺序应该与 Object.keys() 的顺序相同。","solutions":[{"script":"typescript","time":104,"memory":64.6,"desc":"对对象递归查找，并判断是否是数组，对字符串加双引号。","code":"function jsonStringify(object: any): string {\n  const t = typeof object;\n  if (t !== 'object' || object === null || object === undefined)\n    return t === 'string' ? `\"${object}\"` : `${object}`;\n  const isArr = Array.isArray(object);\n  let str = '';\n  str += isArr ? '[' : '{';\n  str += Object.entries(object)\n    .map(([k, v]) => {\n      const isStr = typeof v === 'string';\n      let str = '';\n      if (!isArr) str += `\"${k}\":`;\n      if (isStr) str += `\"`;\n      str += jsonStringify(v);\n      if (isStr) str += `\"`;\n      return str;\n    })\n    .join(',');\n  str += isArr ? ']' : '}';\n  return str;\n}","date":"2023-04-24"}],"tagList":[],"level":"Medium"}},{"problemName":"2634.过滤数组中的元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2634.过滤数组中的元素.json","problemData":{"id":"2746","name":"2634.过滤数组中的元素","url":"https://leetcode.cn/problems/filter-elements-from-array","desc":"请你编写一个函数，该函数接受一个整数数组参数 arr 和一个过滤函数 fn，并返回一个过滤后元素数量较少或元素数量相等的新数组。","solutions":[{"script":"typescript","time":72,"memory":42.3,"desc":"遍历。","code":"function filter(arr: number[], fn: (n: number, i: number) => any): number[] {\n  const res: number[] = [];\n  for (let i = 0; i < arr.length; i++) {\n    if (fn(arr[i], i)) res.push(arr[i]);\n  }\n  return res;\n}","date":"2023-04-24"}],"tagList":[],"level":"Easy"}},{"problemName":"2635.转换数组中的每个元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2635.转换数组中的每个元素.json","problemData":{"id":"2747","name":"2635.转换数组中的每个元素","url":"https://leetcode.cn/problems/apply-transform-over-each-element-in-array","desc":"编写一个函数，这个函数接收一个整数数组 arr 和一个映射函数  fn ，通过该映射函数返回一个新的数组。","solutions":[{"script":"typescript","time":80,"memory":42.5,"desc":"遍历。","code":"function map(arr: number[], fn: (n: number, i: number) => number): number[] {\n  const res: number[] = [];\n  for (let i = 0; i < arr.length; i++) {\n    res.push(fn(arr[i], i));\n  }\n  return res;\n}","date":"2023-04-24"}],"tagList":[],"level":"Easy"}},{"problemName":"2636.Promise对象池.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2636.Promise对象池.json","problemData":{"id":"2750","name":"2636.Promise对象池","url":"https://leetcode.cn/problems/promise-pool","desc":"请你编写一个异步函数 promisePool ，它接收一个异步函数数组 functions 和 池限制 n。它应该返回一个 promise 对象，当所有输入函数都执行完毕后，promise 对象就执行完毕。","solutions":[{"script":"typescript","time":76,"memory":42.5,"desc":"递归监听每个函数的then，收集调用过的个数和完成的个数。","code":"type F = () => Promise<any>;\n\nfunction promisePool(functions: F[], n: number): Promise<any> {\n  return new Promise<void>(r => {\n    const len = functions.length;\n    if (len === 0) r();\n    let cur = 0;\n    let end = 0;\n    const f: any = () => {\n      if (++end === len) r();\n      else if (cur < len) functions[cur++]().then(f);\n    };\n    while (n-- && cur < len) functions[cur++]().then(f);\n  });\n}","date":"2023-04-24"}],"tagList":[],"level":"Medium"}},{"problemName":"2637.有时间限制的Promise对象.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2637.有时间限制的Promise对象.json","problemData":{"id":"2749","name":"2637.有时间限制的Promise对象","url":"https://leetcode.cn/problems/promise-time-limit","desc":"请你编写一个函数，它接收一个异步函数 fn 和一个以毫秒为单位的时间 t。它应根据限时函数返回一个有 限时 效果的函数。","solutions":[{"script":"typescript","time":64,"memory":42.3,"desc":"每次调用时设置定时器定时reject。","code":"type Fn = (...params: any[]) => Promise<any>;\n\nfunction timeLimit(fn: Fn, t: number): Fn {\n  return async function (...args) {\n    return new Promise((resolve, reject) => {\n      fn(...args).then(resolve, reject);\n      setTimeout(() => reject('Time Limit Exceeded'), t);\n    });\n  };\n}","date":"2023-04-24"}],"tagList":[],"level":"Medium"}},{"problemName":"2639.查询网格图中每一列的宽度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2639.查询网格图中每一列的宽度.json","problemData":{"id":"2675","name":"2639.查询网格图中每一列的宽度","url":"https://leetcode.cn/problems/find-the-width-of-columns-of-a-grid","desc":"给你一个下标从 0 开始的 m x n 整数矩阵 grid 。矩阵中某一列的宽度是这一列数字的最大 字符串长度 。","solutions":[{"script":"python","time":44,"memory":17.66,"desc":"遍历。","code":"class Solution:\n    def findColumnWidth(self, grid: List[List[int]]) -> List[int]:\n        return [\n            max(len(str(grid[i][j])) for i in range(len(grid)))\n            for j in range(len(grid[0]))\n        ]","date":"2024-04-27"}],"tagList":["数组","矩阵"],"level":"Easy"}},{"problemName":"2641.二叉树的堂兄弟节点II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2641.二叉树的堂兄弟节点II.json","problemData":{"id":"2677","name":"2641.二叉树的堂兄弟节点II","url":"https://leetcode.cn/problems/cousins-in-binary-tree-ii","desc":"给你一棵二叉树的根 root ，请你将每个节点的值替换成该节点的所有 堂兄弟节点值的和 。如果两个节点在树中有相同的深度且它们的父节点不同，那么它们互为 堂兄弟 。请你返回修改值之后，树的根 root 。","solutions":[{"script":"python","date":"2024-02-07","time":41,"memory":16.5,"desc":"bfs时当记录完一层的节点后进行遍历处理。","code":"class Solution:\n    def replaceValueInTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        root.val = 0\n        map = {}\n        q = deque()\n        q.append(root)\n        size = 1\n        sum = 0\n        while q:\n            node = q.popleft()\n            if node.left:\n                map[node.left] = node\n                q.append(node.left)\n                sum += node.left.val\n            if node.right: \n                map[node.right] = node\n                q.append(node.right)\n                sum += node.right.val\n            size -= 1\n            if size == 0:\n                nums = []\n                for child in q:\n                    csum = 0\n                    if map[child].left: csum += map[child].left.val\n                    if map[child].right: csum += map[child].right.val\n                    nums.append(sum - csum)\n                for i in range(len(q)):\n                    q[i].val = nums[i]\n                sum = 0\n                size = len(q)\n        return root"}],"tagList":["树","深度优先搜索","广度优先搜索","哈希表","二叉树"],"level":"Medium"}},{"problemName":"2642.设计可以求最短路径的图类.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2642.设计可以求最短路径的图类.json","problemData":{"id":"2678","name":"2642.设计可以求最短路径的图类","url":"https://leetcode.cn/problems/design-graph-with-shortest-path-calculator","desc":"请你实现一个 Graph 类。","solutions":[{"script":"python","time":349,"memory":20.49,"desc":"图的最短路。","code":"class Node:\n    def __init__(self):\n        self.f = []\n        self.t = []\n\nclass Graph:\n    def __init__(self, n: int, edges: List[List[int]]):\n        self.n = n\n        self.nodes = [Node() for _ in range(n)]\n        for [f, t, cost] in edges:\n            self.nodes[f].t.append((t, cost))\n            self.nodes[t].f.append((f, cost))\n\n    def addEdge(self, edge: List[int]) -> None:\n        self.nodes[edge[0]].t.append((edge[1], edge[2]))\n\n    def shortestPath(self, node1: int, node2: int) -> int:\n        q = [(0, node1)]\n        used = {}\n        while q: \n            cost, node = heappop(q)\n            if node == node2: return cost\n            for next_node, next_cost in self.nodes[node].t:\n                cost2 = next_cost + cost\n                if next_node not in used or used[next_node] > cost2:\n                    heappush(q, (cost2, next_node))\n                    used[next_node] = cost2\n        return -1","date":"2024-03-26"}],"tagList":["图","设计","最短路","堆（优先队列）"],"level":"Hard"}},{"problemName":"2643.一最多的行.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2643.一最多的行.json","problemData":{"id":"2737","name":"2643.一最多的行","url":"https://leetcode.cn/problems/row-with-maximum-ones","desc":"给你一个大小为 m x n 的二进制矩阵 mat ，请你找出包含最多 1 的行的下标（从 0 开始）以及这一行中 1 的数目。如果有多行包含最多的 1 ，只需要选择 行下标最小 的那一行。返回一个由行下标和该行中 1 的数量组成的数组。","solutions":[{"script":"cpp","time":104,"memory":59.2,"desc":"遍历。","code":"class Solution {\n    public:\n        vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\n            vector<int> res(2, 0);\n            for (int i = 0; i < mat.size(); i++) {\n                int cnt = 0;\n                for (auto &v: mat[i]) {\n                    if (v == 1) cnt++;\n                }\n                if (res[1] < cnt) {\n                    res[0] = i;\n                    res[1] = cnt;\n                }\n            }\n            return res;\n        }\n    };","date":"2023-04-16"},{"script":"python","time":88,"memory":15.7,"desc":"同上。","code":"class Solution:\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\n        res = [0, 0]\n        for i in range(len(mat)):\n            cnt = 0\n            for v in mat[i]:\n                if v == 1:\n                    cnt += 1\n            if res[1] < cnt:\n                res[0] = i\n                res[1] = cnt\n        return res","date":"2023-04-16"},{"script":"rust","time":20,"memory":2.3,"desc":"同上。","code":"impl Solution {\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\n        let mut res = vec![0, 0];\n        for i in 0..mat.len() {\n            let mut cnt = 0;\n            for v in mat[i].iter() {\n                if *v == 1 {\n                    cnt += 1;\n                }\n            }\n            if res[1] < cnt {\n                res[0] = i;\n                res[1] = cnt;\n            }\n        }\n        res.into_iter().map(|v|v as i32).collect()\n    }\n}","date":"2023-04-16"}],"tagList":["数组","矩阵"],"level":"Easy"}},{"problemName":"2644.找出可整除性得分最大的整数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2644.找出可整除性得分最大的整数.json","problemData":{"id":"2694","name":"2644.找出可整除性得分最大的整数","url":"https://leetcode.cn/problems/find-the-maximum-divisibility-score","desc":"给你两个下标从 0 开始的整数数组 nums 和 divisors 。divisors[i] 的 可整除性得分 等于满足 nums[j] 能被 divisors[i] 整除的下标 j 的数量。返回 可整除性得分 最大的整数 divisors[i] 。如果有多个整数具有最大得分，则返回数值最小的一个。","solutions":[{"script":"cpp","time":240,"memory":28.6,"desc":"遍历。","code":"class Solution {\n    public:\n        int maxDivScore(vector<int>& nums, vector<int>& divisors) {\n            int res = 0x7fffffff, resCnt = 0;\n            for (auto &v : divisors) {\n                int cnt = 0;\n                for (auto &num : nums) {\n                    if (num % v == 0) cnt++;\n                }\n                if (resCnt < cnt || resCnt == cnt && res > v) {\n                    res = v;\n                    resCnt = cnt;\n                }\n            }\n            return res;\n        }\n    };","date":"2023-04-16"},{"script":"python","time":2868,"memory":15.2,"desc":"同上。","code":"class Solution:\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\n        res = 0x7fffffff\n        resCnt = 0\n        for v in divisors:\n            cnt = 0\n            for num in nums:\n                if num % v == 0:\n                    cnt += 1\n            if resCnt < cnt or resCnt == cnt and res > v:\n                res = v\n                resCnt = cnt\n        return res","date":"2023-04-16"},{"script":"rust","time":172,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn max_div_score(nums: Vec<i32>, divisors: Vec<i32>) -> i32 {\n        let mut res = i32::MAX;\n        let mut resCnt = 0;\n        for v in divisors {\n            let mut cnt = 0;\n            for num in nums.iter() {\n                if *num % v == 0 {\n                    cnt += 1;\n                }\n            }\n            if resCnt < cnt || resCnt == cnt && res > v {\n                res = v;\n                resCnt = cnt;\n            }\n        }\n        res\n    }\n}","date":"2023-04-16"},{"script":"python","time":4015,"memory":16.7,"desc":"遍历。","code":"class Solution:\n    def maxDivScore(self, nums: List[int], divisors: List[int]) -> int:\n        res = 0\n        res_num = divisors[0]\n        arr = [sum(num % divisor == 0 for num in nums) for divisor in divisors]\n        for i in range(len(divisors)):\n            if arr[i] >= res:\n                if arr[i] > res or arr[i] == res and divisors[i] < res_num:\n                    res_num = divisors[i]\n                res = arr[i]\n        return res_num","date":"2024-05-18"}],"tagList":["数组"],"level":"Easy"}},{"problemName":"2645.构造有效字符串的最少插入数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2645.构造有效字符串的最少插入数.json","problemData":{"id":"2736","name":"2645.构造有效字符串的最少插入数","url":"https://leetcode.cn/problems/minimum-additions-to-make-valid-string","desc":"给你一个字符串 word ，你可以向其中任何位置插入 \"a\"、\"b\" 或 \"c\" 任意次，返回使 word 有效 需要插入的最少字母数。","solutions":[{"script":"python","time":32,"memory":16.93,"desc":"遍历。","code":"class Solution:\n    def addMinimum(self, word: str) -> int:\n        s = 'abc'\n        ans = i = 0\n        for c in word:\n            while s[i] != c:\n                i = (i + 1) % 3\n                ans += 1\n            i = (i + 1) % 3\n        return ans + (3 - i) % 3","date":"2024-01-11"}],"tagList":["栈","贪心","字符串","动态规划"],"level":"Medium"}},{"problemName":"2646.最小化旅行的价格总和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2646.最小化旅行的价格总和.json","problemData":{"id":"2739","name":"2646.最小化旅行的价格总和","url":"https://leetcode.cn/problems/minimize-the-total-price-of-the-trips","desc":"现有一棵无向、无根的树，树中有 n 个节点，按从 0 到 n - 1 编号。给你一个整数 n 和一个长度为 n - 1 的二维整数数组 edges ，其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条边。每个节点都关联一个价格。给你一个整数数组 price ，其中 price[i] 是第 i 个节点的价格。给定路径的 价格总和 是该路径上所有节点的价格之和。另给你一个二维整数数组 trips ，其中 trips[i] = [starti, endi] 表示您从节点 starti 开始第 i 次旅行，并通过任何你喜欢的路径前往节点 endi 。在执行第一次旅行之前，你可以选择一些 非相邻节点 并将价格减半。返回执行所有旅行的最小价格总和。","solutions":[{"script":"cpp","time":760,"memory":241.1,"desc":"树dp，记录选当前点和不选时的打折价格。","code":"#define pii pair<int, int>\n    #define X first\n    #define Y second\n    struct Node {\n        int idx, price;\n        vector<int> next;\n    };\n    struct QNode {\n        int i, sum;\n        vector<int> list;\n    };\n    class Solution {\n    public:\n        int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\n            vector<Node> list(n);\n            for (int i = 0; i < n; i++) {\n                list[i].idx = i;\n                list[i].price = price[i];\n            }\n            for (auto &edge : edges) {\n                list[edge[0]].next.push_back(edge[1]);\n                list[edge[1]].next.push_back(edge[0]);\n            }\n            // 记录所有路径\n            vector<vector<QNode>> roads(n, vector<QNode>(n));\n            for (int i = 0; i < n; i++) {\n                roads[i][i] = QNode{ i, list[i].price, vector<int>(1, i)};\n                queue<QNode> q;\n                q.push(QNode{ i, list[i].price, vector<int>(1, i)});\n                unordered_set<int> used;\n                used.insert(i);\n                while (q.size()) {\n                    auto cur = q.front();\n                    q.pop();\n                    for (auto &next : list[cur.i].next) {\n                        if (used.count(next)) continue;\n                        used.insert(next);\n                        auto nextNode = cur;\n                        nextNode.i = next;\n                        nextNode.sum += list[next].price;\n                        nextNode.list.push_back(next);\n                        roads[i][next] = nextNode;\n                        q.push(nextNode);\n                    }\n                }\n            }\n            // 记录不打折时总价，和每个点会被遍历几次\n            int sums = 0, res = 0x7fffffff;\n            vector<int> weights(n, 0);\n            for (auto &trip : trips) {\n                sums += roads[trip[0]][trip[1]].sum;\n                for (auto &item : roads[trip[0]][trip[1]].list) {\n                    weights[item]++;\n                }\n            }\n            // X 记录这个点选的时候最多能打多少\n            // Y 记录这个点不选的时候最多能打多少\n            unordered_set<int> used;\n            function<pii(int)> discount = [&](int start) -> pii {\n                pii res = make_pair(list[start].price / 2 * weights[start], 0);\n                for (auto &next : list[start].next) {\n                    if (used.count(next)) continue;\n                    used.insert(next);\n                    auto nextRes = discount(next);\n                    res.X += nextRes.Y;                \n                    res.Y += max(nextRes.X, nextRes.Y);\n                    used.erase(next);\n                }\n                return res;\n            };\n            used.insert(0);\n            auto disres = discount(0);\n            res = min(res, sums - max(disres.X, disres.Y));\n            used.erase(0);\n            return res;\n        }\n    };","date":"2023-04-16"},{"script":"python","time":888,"memory":257.3,"desc":"提前统计每个点会被经过的次数，然后dp判断每个点打折和不打折的情况。","code":"class Solution:\n        def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\n            nodes = [[] for _ in range(n)]\n            for n1, n2 in edges:\n                nodes[n1].append(n2)\n                nodes[n2].append(n1)\n            cnts = [0] * n\n            def dfs(start: int, end: int, used: int) -> bool:\n                if start == end:\n                    cnts[end] += 1\n                    return True\n                check = False\n                for next in nodes[start]:\n                    if (used & (1 << next)) == 0 and dfs(next, end, used | (1 << next)):\n                        cnts[start] += 1\n                        check = True\n                return check\n            for start, end in trips: dfs(start, end, 1 << start)\n            sums = sum(c * price[i] for i, c in enumerate(cnts))\n            @cache\n            def try_trip(idx: int, used: int, can: bool) -> int:\n                res1 = 0\n                if can: \n                    res1 += int(cnts[idx] * price[idx] / 2)\n                    for next in nodes[idx]:\n                        if (used & (1 << next)) == 0:\n                            res1 += try_trip(next, used | (1 << next), not can)\n                res2 = 0\n                for next in nodes[idx]:\n                    if (used & (1 << next)) == 0:\n                        res2 += try_trip(next, used | (1 << next), True)\n                return max(res1, res2)\n            return min(sums - try_trip(i, 1 << i, True) for i in range(n))","date":"2023-12-06"}],"tagList":["树","深度优先搜索","图","数组","动态规划"],"level":"Hard"}},{"problemName":"2648.生成斐波那契数列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2648.生成斐波那契数列.json","problemData":{"id":"2775","name":"2648.生成斐波那契数列","url":"https://leetcode.cn/problems/generate-fibonacci-sequence","desc":"请你编写一个生成器函数，并返回一个可以生成 斐波那契数列 的生成器对象。","solutions":[{"script":"typescript","time":72,"memory":43.8,"desc":"每次产出第一个值。","code":"function* fibGenerator(): Generator<number, any, number> {\n    let first = 0;\n    let second = 1;\n    let cnt = 0\n    for (;; cnt++) {\n        yield first;\n        [first, second] = [second, first + second];\n    }\n};","date":"2023-04-24"}],"tagList":[],"level":"Easy"}},{"problemName":"2649.嵌套数组生成器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2649.嵌套数组生成器.json","problemData":{"id":"2783","name":"2649.嵌套数组生成器","url":"https://leetcode.cn/problems/nested-array-generator","desc":"现给定一个整数的 多维数组 ，请你返回一个生成器对象，按照 中序遍历 的顺序逐个生成整数。","solutions":[{"script":"typescript","time":144,"memory":60.8,"desc":"双状态循环，一直找当前栈顶是number才退出。","code":"type MultidimensionalArray = (MultidimensionalArray | number)[]\n\nfunction* inorderTraversal(arr: MultidimensionalArray): Generator<number, void, unknown> {\n    const stack: [MultidimensionalArray, number][] = [[arr, 0]];\n    const top = () => stack[stack.length - 1];\n    while (stack.length) {\n        // 栈顶不是number就一直循环\n        while (stack.length && typeof top()[0][top()[1]] !== 'number') {\n            // 栈顶是数组就一直入栈\n            while (stack.length && Array.isArray(top()[0][top()[1]])) stack.push([top()[0][top()[1]++] as MultidimensionalArray, 0]);\n            // 栈顶数组已经耗尽就出栈\n            while (stack.length && top()[1] >= top()[0].length) stack.pop();\n        }\n        if (stack.length) yield top()[0][top()[1]++] as number;\n    }\n};","date":"2023-04-24"}],"tagList":[],"level":"Medium"}},{"problemName":"2650.设计可取消函数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2650.设计可取消函数.json","problemData":{"id":"2788","name":"2650.设计可取消函数","url":"https://leetcode.cn/problems/design-cancellable-function","desc":"有时候你会有一个长时间运行的任务，并且你可能希望在它完成之前取消它。为了实现这个目标，请你编写一个名为 cancellable 的函数，它接收一个生成器对象，并返回一个包含两个值的数组：一个 取消函数 和一个 promise 对象。","solutions":[{"script":"typescript","time":64,"memory":42.5,"desc":"dfs。","code":"function cancellable<T>(generator: Generator<Promise<any>, T, unknown>): [() => void, Promise<T>] {\n  let cancel = false;\n  function dfs(node) {\n    if (node.done) return Promise.resolve(node.value);\n    if (node.value instanceof Promise)\n      return node.value.then(\n        res => (cancel ? dfs(generator.throw('Cancelled')) : dfs(generator.next(res))),\n        res => dfs(generator.throw(res))\n      );\n    else return dfs(generator.next(node.value));\n  }\n  return [\n    () => (cancel = true),\n    new Promise<T>((resolve, reject) => dfs(generator.next()).then(resolve, reject)),\n  ];\n}","date":"2023-04-24"}],"tagList":[],"level":"Hard"}},{"problemName":"2651.计算列车到站时间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2651.计算列车到站时间.json","problemData":{"id":"2748","name":"2651.计算列车到站时间","url":"https://leetcode.cn/problems/calculate-delayed-arrival-time","desc":"给你一个正整数 arrivalTime 表示列车正点到站的时间（单位：小时），另给你一个正整数 delayedTime 表示列车延误的小时数。返回列车实际到站的时间。","solutions":[{"script":"cpp","time":0,"memory":2.1,"desc":"相加后取模。","code":"class Solution {\npublic:\n    int findDelayedArrivalTime(int arrivalTime, int delayedTime) {\n        return (arrivalTime + delayedTime) % 24;\n    }\n};","date":"2023-09-08"},{"script":"python","time":48,"memory":16.1,"desc":"同上。","code":"class Solution:\n    def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\n        return (arrivalTime + delayedTime) % 24","date":"2023-09-08"},{"script":"rust","time":0,"memory":2.98,"desc":"同上。","code":"impl Solution {\n    pub fn find_delayed_arrival_time(arrival_time: i32, delayed_time: i32) -> i32 {\n        (arrival_time + delayed_time) % 24\n    }\n}","date":"2023-09-08"}],"tagList":["数学"],"level":"Easy"}},{"problemName":"2652.倍数求和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2652.倍数求和.json","problemData":{"id":"2752","name":"2652.倍数求和","url":"https://leetcode.cn/problems/sum-multiples","desc":"给你一个正整数 n ，请你计算在 [1，n] 范围内能被 3、5、7 整除的所有整数之和。返回一个整数，用于表示给定范围内所有满足约束条件的数字之和。","solutions":[{"script":"python","time":92,"memory":16,"desc":"遍历。","code":"class Solution:\n    def sumOfMultiples(self, n: int) -> int:\n        return sum(\n            list(\n                filter(\n                    lambda num: num % 3 == 0 or num % 5 == 0 or num % 7 == 0, \n                    [num for num in range(1, n + 1)]\n                )\n            )\n        )","date":"2023-10-17"}],"tagList":["数学"],"level":"Easy"}},{"problemName":"2656.K个元素的最大和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2656.K个元素的最大和.json","problemData":{"id":"2767","name":"2656.K个元素的最大和","url":"https://leetcode.cn/problems/maximum-sum-with-exactly-k-elements","desc":"给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。请你返回执行以上操作恰好 k 次后的最大得分。","solutions":[{"script":"python","time":52,"memory":15.9,"desc":"等差数列。","code":"class Solution:\n    def maximizeSum(self, nums: List[int], k: int) -> int:\n        return max(nums) * k + (k - 1) * k // 2","date":"2023-11-15"}],"tagList":["贪心","数组"],"level":"Easy"}},{"problemName":"2660.保龄球游戏的获胜者.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2660.保龄球游戏的获胜者.json","problemData":{"id":"2684","name":"2660.保龄球游戏的获胜者","url":"https://leetcode.cn/problems/determine-the-winner-of-a-bowling-game","desc":"返回如果玩家 1 的得分高于玩家 2 的得分，则为 1 ；如果玩家 2 的得分高于玩家 1 的得分，则为 2 ；如果平局，则为 0 。","solutions":[{"script":"python","time":72,"memory":16.9,"desc":"模拟。","code":"class Solution:\n    def isWinner(self, player1: List[int], player2: List[int]) -> int:\n        def getScore(player: List[int]) -> int:\n            cur = 0\n            sum = 0\n            for v in player:\n                sum += v + v * ((cur & 0b11) != 0)\n                cur = cur << 1 | (v == 10)\n            return sum\n        s1, s2 = getScore(player1), getScore(player2)\n        return 1 if s1 > s2 else 2 if s2 > s1 else 0","date":"2023-12-27"},{"script":"cpp","time":44,"memory":70.5,"desc":"同上。","code":"class Solution {\npublic:\n    int getScore(vector<int>& player) {\n        int cur = 0, sum = 0;\n        for (auto &v: player) {\n            sum += v + v * ((cur & 0b11) != 0);\n            cur = cur << 1 | (v == 10);\n        }\n        return sum;\n    }\n    int isWinner(vector<int>& player1, vector<int>& player2) {\n        int s1 = getScore(player1), s2 = getScore(player2);\n        return s1 > s2 ? 1 : s2 > s1 ? 2 : 0;\n    }\n};","date":"2023-12-27"},{"script":"rust","time":12,"memory":2.12,"desc":"同上。","code":"impl Solution {\n    pub fn is_winner(player1: Vec<i32>, player2: Vec<i32>) -> i32 {\n        fn getScore(player: &Vec<i32>) -> i32 {\n            let mut cur = 0;\n            let mut sum = 0;\n            for v in player {\n                sum += *v + *v * ((cur & 0b11) != 0) as i32;\n                cur = cur << 1 | (*v == 10) as i32;\n            }\n            sum\n        }\n        let (s1, s2) = (getScore(&player1), getScore(&player2));\n        if s1 > s2 {\n            1\n        } else if s2 > s1 {\n            2\n        } else {\n            0\n        }\n    }\n}","date":"2023-12-27"}],"tagList":["数组","模拟"],"level":"Easy"}},{"problemName":"2661.找出叠涂元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2661.找出叠涂元素.json","problemData":{"id":"2685","name":"2661.找出叠涂元素","url":"https://leetcode.cn/problems/first-completely-painted-row-or-column","desc":"请你找出 arr 中在 mat 的某一行或某一列上都被涂色且下标最小的元素，并返回其下标 i 。","solutions":[{"script":"python","time":192,"memory":49.78,"desc":"哈希计数。","code":"class Solution:\n    def firstCompleteIndex(self, arr: List[int], mat: List[List[int]]) -> int:\n        n = len(mat)\n        m = len(mat[0])\n        map = {mat[i][j]: (i, j) for i in range(n) for j in range(m)}\n        rows = [0] * n\n        cols = [0] * m\n        for idx, num in enumerate(arr):\n            i, j = map[num]\n            rows[i] += 1\n            cols[j] += 1\n            if rows[i] == m or cols[j] == n: return idx","date":"2023-12-01"},{"script":"rust","time":40,"memory":11.39,"desc":"同上。","code":"impl Solution {\n    pub fn first_complete_index(arr: Vec<i32>, mat: Vec<Vec<i32>>) -> i32 {\n        let n = mat.len();\n        let m = mat[0].len();\n        let mut map = std::collections::HashMap::<i32, (usize, usize)>::new();\n        for i in 0..n {\n            for j in 0..m {\n                map.insert(mat[i][j], (i, j));\n            }\n        }\n        let mut rows = vec![0; n];\n        let mut cols = vec![0; m];\n        for (idx, num) in arr.into_iter().enumerate() {\n            let (i, j) = map.get(&num).unwrap();\n            rows[*i] += 1;\n            cols[*j] += 1;\n            if rows[*i] == m || cols[*j] == n {\n                return idx as i32;\n            }\n        }\n        0\n    }\n}","date":"2023-12-01"}],"tagList":["数组","哈希表","矩阵"],"level":"Medium"}},{"problemName":"2663.字典序最小的美丽字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2663.字典序最小的美丽字符串.json","problemData":{"id":"2687","name":"2663.字典序最小的美丽字符串","url":"https://leetcode.cn/problems/lexicographically-smallest-beautiful-string","desc":"请你找出并返回一个长度为 n 的美丽字符串，该字符串还满足：在字典序大于 s 的所有美丽字符串中字典序最小。如果不存在这样的字符串，则返回一个空字符串。","solutions":[{"script":"python","time":205,"memory":18.18,"desc":"贪心遍历。","code":"class Solution:\n    def smallestBeautifulString(self, s: str, k: int) -> str:\n        arr = list(s)\n        ord0 = ord('a')\n        def get_next(c: str) -> str:\n            ordc = ord(c)\n            if ordc - ord0 + 1 == k:\n                return None\n            return chr(ordc + 1)\n        for i in range(len(arr) - 1, -1, -1):\n            next_ord = get_next(arr[i])\n            while next_ord and (i > 0 and next_ord == arr[i - 1] or i > 1 and next_ord == arr[i - 2]):\n                next_ord = get_next(next_ord)\n            if next_ord:\n                arr[i] = next_ord\n                starti = i + 1\n                if 0 < i < len(arr) - 1 and arr[i - 1] == 'a':\n                    arr[starti] = 'b'\n                    starti += 1\n                for j in range(starti, len(arr)):\n                    cur = 0\n                    ch = chr(cur + ord0)\n                    while ch and (j > 0 and ch == arr[j - 1] or j > 1 and ch == arr[j - 2]):\n                        cur = (cur + 1) % k\n                        ch = chr(cur + ord0)\n                    arr[j] = ch\n                break\n        res = ''.join(arr)\n        return res if res > s else ''","date":"2024-06-22"}],"tagList":["贪心","字符串"],"level":"Hard"}},{"problemName":"2665.计数器II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2665.计数器II.json","problemData":{"id":"2789","name":"2665.计数器II","url":"https://leetcode.cn/problems/counter-ii","desc":"请你写一个函数 createCounter. 这个函数接收一个初始的整数值 init  并返回一个包含三个函数的对象。","solutions":[{"script":"typescript","time":76,"memory":44.5,"desc":"闭包。","code":"type ReturnObj = {\n  increment: () => number;\n  decrement: () => number;\n  reset: () => number;\n};\n\nfunction createCounter(init: number): ReturnObj {\n  let v = init;\n  return {\n    increment: () => ++v,\n    decrement: () => --v,\n    reset: () => (v = init),\n  };\n}","date":"2023-05-10"}],"tagList":[],"level":"Easy"}},{"problemName":"2666.只允许一次函数调用.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2666.只允许一次函数调用.json","problemData":{"id":"2796","name":"2666.只允许一次函数调用","url":"https://leetcode.cn/problems/allow-one-function-call","desc":"给定一个函数 fn ，它返回一个新的函数，返回的函数与原始函数完全相同，只不过它确保 fn 最多被调用一次。","solutions":[{"script":"typescript","time":56,"memory":42.5,"desc":"闭包。","code":"function once<T extends (...args: any[]) => any>(\n  fn: T\n): (...args: Parameters<T>) => ReturnType<T> | undefined {\n  let used = false;\n  return (...args) => (used ? undefined : ((used = true), fn(...args)));\n}","date":"2023-05-10"}],"tagList":[],"level":"Easy"}},{"problemName":"2667.创建HelloWorld函数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2667.创建HelloWorld函数.json","problemData":{"id":"2809","name":"2667.创建HelloWorld函数","url":"https://leetcode.cn/problems/create-hello-world-function","desc":"请你编写一个名为 createHelloWorld 的函数。它应该返回一个新的函数，该函数总是返回 \"Hello World\" 。","solutions":[{"script":"typescript","time":60,"memory":42,"desc":"闭包。","code":"function createHelloWorld() {\nreturn () => 'Hello World';\n}","date":"2023-05-10"}],"tagList":[],"level":"Easy"}},{"problemName":"2670.找出不同元素数目差数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2670.找出不同元素数目差数组.json","problemData":{"id":"2777","name":"2670.找出不同元素数目差数组","url":"https://leetcode.cn/problems/find-the-distinct-difference-array","desc":"返回 nums 的 不同元素数目差 数组。","solutions":[{"script":"cpp","time":48,"memory":90.9,"desc":"从左往右统计，从右往左统计。","code":"class Solution {\npublic:\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\n        unordered_set<int> s;\n        int n = nums.size();\n        vector<int> list1(n, 0), list2(n, 0), res(n, 0);\n        for (int i = 0; i < n; i++) {\n            s.insert(nums[i]);\n            list1[i] = s.size();\n        }\n        s.clear();\n        for (int i = n - 1; i >= 0; i--) {\n            list2[i] = s.size();\n            s.insert(nums[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            res[i] = list1[i] - list2[i];\n        }\n        return res;\n    }\n};","date":"2023-05-07"},{"script":"python","time":72,"memory":16.1,"desc":"同上。","code":"class Solution:\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\n        s = set()\n        n = len(nums)\n        list1 = [0] * n\n        list2 = [0] * n\n        res = [0] * n\n        for i in range(0, n):\n            s.add(nums[i])\n            list1[i] = len(s)\n        s.clear()\n        for i in range(n - 1, -1, -1):\n            list2[i] = len(s)\n            s.add(nums[i])\n        for i in range(0, n):\n            res[i] = list1[i] - list2[i]\n        return res","date":"2023-05-07"},{"script":"rust","time":0,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn distinct_difference_array(nums: Vec<i32>) -> Vec<i32> {\n        let mut s = std::collections::HashSet::<i32>::new();\n        let n = nums.len();\n        let mut list1 = vec![0; n];\n        let mut list2 = vec![0; n];\n        let mut res = vec![0; n];\n        for i in 0..n {\n            s.insert(nums[i]);\n            list1[i] = s.len();\n        }\n        s.clear();\n        for i in (0..n).rev() {\n            list2[i] = s.len();\n            s.insert(nums[i]);\n        }\n        for i in 0..n {\n            res[i] = (list1[i] - list2[i]) as i32\n        }\n        res\n    }\n}\n","date":"2023-05-07"},{"script":"python","time":300,"memory":48.3,"desc":"记录下标，判断下标之间的最大距离。","code":"class Solution:\n    def distinctDifferenceArray(self, nums: List[int]) -> List[int]:\n        rdict = defaultdict(int)\n        for num in nums: rdict[num] += 1\n        cur = len(rdict)\n        res = []\n        ldict = defaultdict(int)\n        for num in nums:\n            rdict[num] -= 1\n            if rdict[num] == 0: cur -= 1\n            ldict[num] += 1\n            if ldict[num] == 1: cur -= 1\n            res.append(-cur)\n        return res","date":"2024-01-31"}],"tagList":["数组","哈希表"],"level":"Easy"}},{"problemName":"2671.频率跟踪器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2671.频率跟踪器.json","problemData":{"id":"2778","name":"2671.频率跟踪器","url":"https://leetcode.cn/problems/frequency-tracker","desc":"请你设计并实现一个能够对其中的值进行跟踪的数据结构，并支持对频率相关查询进行应答。","solutions":[{"script":"python","time":374,"memory":81.89,"desc":"利用两个dict记录数量和频率。","code":"class FrequencyTracker:\n    def __init__(self):\n        self.freq_map = {}\n        self.cnt_map = {}\n    \n    def del_freq(self, freq: int, number: int):\n        if freq in self.freq_map and number in self.freq_map[freq]:\n            self.freq_map[freq].remove(number)\n            if not len(self.freq_map[freq]): del self.freq_map[freq]\n\n    def add_freq(self, freq: int, number: int):\n        if freq not in self.freq_map: self.freq_map[freq] = set()\n        if number not in self.freq_map[freq]: self.freq_map[freq].add(number)\n\n    def add(self, number: int) -> None:\n        if number not in self.cnt_map: self.cnt_map[number] = 0\n        self.del_freq(self.cnt_map[number], number)\n        self.cnt_map[number] += 1\n        self.add_freq(self.cnt_map[number], number)\n\n    def deleteOne(self, number: int) -> None:\n        if number not in self.cnt_map: self.cnt_map[number] = 0\n        self.del_freq(self.cnt_map[number], number)\n        if self.cnt_map[number] > 0:\n            self.cnt_map[number] -= 1\n            self.add_freq(self.cnt_map[number], number)\n\n    def hasFrequency(self, frequency: int) -> bool:\n        return frequency in self.freq_map","date":"2024-03-21"}],"tagList":["设计","哈希表"],"level":"Medium"}},{"problemName":"2672.有相同颜色的相邻元素数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2672.有相同颜色的相邻元素数目.json","problemData":{"id":"2779","name":"2672.有相同颜色的相邻元素数目","url":"https://leetcode.cn/problems/number-of-adjacent-elements-with-the-same-color","desc":"给你一个下标从 0 开始、长度为 n 的数组 nums 。请你返回一个长度与 queries 相等的数组 answer ，其中 answer[i]是前 i 个操作 之后 ，相邻元素颜色相同的数目。","solutions":[{"script":"cpp","time":452,"memory":197.9,"desc":"每次着色时统计对前后两个值得影响。","code":"class Solution {\npublic:\n    vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\n        vector<int> res(queries.size(), 0), list(n, 0);\n        if (n == 1) return res;\n        int prev = 0;\n        for (int i = 0; i < queries.size(); i++) {\n            int idx = queries[i][0], col = queries[i][1];\n            if (list[idx] != col) {\n                if (idx != n - 1) {\n                    if (list[idx] == 0) {\n                        if (col == list[idx + 1]) prev++;\n                    } else {\n                        if (list[idx] == list[idx + 1]) prev--;\n                        else if (col == list[idx + 1]) prev++;\n                    }\n                }\n                if (idx != 0) {\n                    if (list[idx] == 0) {\n                        if (col == list[idx - 1]) prev++;\n                    } else {\n                        if (list[idx] == list[idx - 1]) prev--;\n                        else if (col == list[idx - 1]) prev++;\n                    }\n                }\n            }\n            list[idx] = col;\n            res[i] = prev;\n        }\n        return res;\n    }\n};","date":"2023-05-07"},{"script":"python","time":276,"memory":47.6,"desc":"同上。","code":"class Solution:\n    def colorTheArray(self, n: int, queries: List[List[int]]) -> List[int]:\n        res = [0] * len(queries)\n        list = [0] * n\n        if n == 1:\n            return res\n        prev = 0\n        for i in range(0, len(queries)):\n            idx = queries[i][0]\n            col = queries[i][1]\n            if list[idx] != col:\n                if idx != n - 1:\n                    if list[idx] == 0:\n                        if col == list[idx + 1]:\n                            prev += 1\n                    else:\n                        if list[idx] == list[idx + 1]:\n                            prev -= 1\n                        elif col == list[idx + 1]:\n                            prev += 1\n\n                if idx != 0:\n                    if list[idx] == 0:\n                        if col == list[idx - 1]:\n                            prev += 1\n                    else:\n                        if list[idx] == list[idx - 1]:\n                            prev -= 1\n                        elif col == list[idx - 1]:\n                            prev += 1\n            list[idx] = col\n            res[i] = prev\n        return res","date":"2023-05-07"},{"script":"rust","time":60,"memory":8.8,"desc":"同上。","code":"impl Solution {\n    pub fn color_the_array(n: i32, queries: Vec<Vec<i32>>) -> Vec<i32> {\n        let n = n as usize;\n        let mut res = vec![0; queries.len()];\n        let mut list = vec![0; n];\n        if n != 1 {\n            let mut prev = 0;\n            for i in 0..queries.len() {\n                let idx = queries[i][0] as usize;\n                let col = queries[i][1];\n                if list[idx] != col {\n                    if idx != n - 1 {\n                        if list[idx] == 0 {\n                            if col == list[idx + 1] {\n                                prev += 1;\n                            }\n                        } else {\n                            if list[idx] == list[idx + 1] {\n                                prev -= 1;\n                            } else if col == list[idx + 1] {\n                                prev += 1;\n                            }\n                        }\n                    }\n                    if idx != 0 {\n                        if list[idx] == 0 {\n                            if col == list[idx - 1] {\n                                prev += 1;\n                            }\n                        } else {\n                            if list[idx] == list[idx - 1] {\n                                prev -= 1;\n                            } else if col == list[idx - 1] {\n                                prev += 1;\n                            }\n                        }\n                    }\n                }\n                list[idx] = col;\n                res[i] = prev;\n            }\n        }\n        res\n    }\n}","date":"2023-05-07"}],"tagList":["数组"],"level":"Medium"}},{"problemName":"2673.使二叉树所有路径值相等的最小代价.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2673.使二叉树所有路径值相等的最小代价.json","problemData":{"id":"2780","name":"2673.使二叉树所有路径值相等的最小代价","url":"https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree","desc":"你的目标是让根到每一个 叶子结点 的路径值相等。请你返回 最少 需要执行增加操作多少次。","solutions":[{"script":"cpp","time":168,"memory":132,"desc":"dfs每次统计左右子树的差值。","code":"class Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int level = log2(n + 1), res = 0;\n        function<int(int, int)> dfs = [&](int root, int l) -> int {\n            if (l == level) return cost[root];\n            int left = dfs(root * 2 + 1, l + 1), right = dfs(root * 2 + 2, l + 1);\n            if (left == right) return left + cost[root];\n            res += abs(right - left);\n            return max(left, right) + cost[root];\n        };\n        dfs(0, 1);\n        return res;\n    }\n};","date":"2023-05-07"},{"script":"python","time":324,"memory":48.6,"desc":"同上。","code":"class Solution:\n    def minIncrements(self, n: int, cost: List[int]) -> int:\n        level = log2(n+1)\n        res = 0\n\n        def dfs(root: int, l: int) -> int:\n            nonlocal res\n            if l == level : return cost[root]\n            left = dfs(root * 2 + 1, l + 1)\n            right = dfs(root * 2 + 2, l + 1)\n            if left == right :return left + cost[root]\n            res += abs(left -right)\n            return max(left, right ) + cost[root]\n        dfs(0, 1)\n        return res","date":"2023-05-07"},{"script":"rust","time":24,"memory":3.4,"desc":"同上。","code":"impl Solution {\n    pub fn min_increments(n: i32, cost: Vec<i32>) -> i32 {        \n        let level = ((n + 1) as f64).log2() as u32;\n        let mut res = 0;\n        fn dfs(cost: &Vec<i32>, level: u32, res: &mut i32, root: usize, l: u32) -> i32 {\n            if l == level {\n                cost[root]\n            } else {\n                let left = dfs(cost, level, res, root * 2 + 1, l + 1);\n                let right = dfs(cost, level, res, root * 2 + 2, l + 1);\n                if left == right {\n                    left + cost[root]\n                } else {\n                    *res += (right - left).abs();\n                    left.max(right) + cost[root]\n                }\n            }\n        }\n        dfs(&cost, level, &mut res, 0, 1);\n        res\n    }\n}","date":"2023-05-07"},{"script":"python","time":233,"memory":45.47,"desc":"dfs时记录左右的节点的值，进行遍历和平衡。","code":"class Solution:\n    def minIncrements(self, n: int, cost: List[int]) -> int:\n        ans = 0\n        def dfs(node: int) -> int:\n            nonlocal ans\n            if node * 2 > n: return cost[node - 1]\n            l, r = dfs(node * 2), dfs(node * 2 + 1)\n            maxn = max(l, r)\n            ans += 2 * maxn - l - r\n            return maxn + cost[node - 1]\n        dfs(1)\n        return ans","date":"2024-02-28"}],"tagList":["贪心","树","数组","动态规划","二叉树"],"level":"Medium"}},{"problemName":"2675.将对象数组转换为矩阵.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2675.将对象数组转换为矩阵.json","problemData":{"id":"2769","name":"2675.将对象数组转换为矩阵","url":"https://leetcode.cn/problems/array-of-objects-to-matrix","desc":"编写一个函数，将对象数组 arr 转换为矩阵 m 。","solutions":[{"script":"typescript","time":360,"memory":67.9,"desc":"先深度遍历拿所有的Key，再对每个对象尝试读key。","code":"const isObject = (o: unknown): o is object => o instanceof Object;\nfunction jsonToMatrix(arr: any[]): (string | number | boolean | null)[][] {\n    const keySet = new Set<string>();\n    for (const item of arr) findKey(item);\n    keySet.delete('');\n    const keys = Array.from(keySet.keys()).sort();\n    return [keys, ...arr.map(item => keys.map(k => get(item, k)))];\n    function findKey(item: any[] | object, key = '') {\n        if (isObject(item))\n        for (const k of Object.keys(item)) findKey(item[k], key ? key + '.' + k : `${k}`);\n        else keySet.add(key);\n    }\n    function get(item: object, k: string): any {\n        for (const nextK of k.split('.'))\n        if (!isObject(item) || item[nextK] === undefined) return '';\n        else item = item[nextK];\n        return isObject(item) ? '' : item;\n    }\n}","date":"2023-05-16"}],"tagList":[],"level":"Hard"}},{"problemName":"2676.节流.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2676.节流.json","problemData":{"id":"2771","name":"2676.节流","url":"https://leetcode.cn/problems/throttle","desc":"现给定一个函数 fn 和一个以毫秒为单位的时间 t ，请你返回该函数的 节流 版本。","solutions":[{"script":"typescript","time":76,"memory":42.4,"desc":"闭包存储状态，利用setTimeout恢复状态。","code":"type F = (...args: any[]) => void;\nfunction throttle(fn: F, t: number): F {\n    // 如果有需要调用但未调用的情况，储存参数\n    let callArgs: any[] | null = null;\n    // 记录当前状态是否已经掉用过\n    let called = false;\n    return function call(...args) {\n        if (called) callArgs = args;\n        else {\n            fn(...args);\n            called = true;\n            setTimeout(() => {\n                // 恢复调用状态\n                called = false;\n                if (callArgs) call(...callArgs), (callArgs = null);\n            }, t);\n        }\n    };\n}","date":"2023-05-16"}],"tagList":[],"level":"Medium"}},{"problemName":"2677.分块数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2677.分块数组.json","problemData":{"id":"2798","name":"2677.分块数组","url":"https://leetcode.cn/problems/chunk-array","desc":"给定一个数组 arr 和一个块大小 size ，返回一个 分块 的数组。分块 的数组包含了 arr 中的原始元素，但是每个子数组的长度都是 size 。如果 arr.length 不能被 size 整除，那么最后一个子数组的长度可能小于 size 。","solutions":[{"script":"typescript","time":76,"memory":45.5,"desc":"利用余数为0判断是否产生分割。","code":"function chunk(arr: any[], size: number): any[][] {\n    const res: any[][] = [];\n    const item: any[] = [];\n    for (let i = 1; i <= arr.length; i++) {\n        item.push(arr[i - 1]);\n        if (i % size === 0) res.push([...item]), (item.length = 0);\n    }\n    if (item.length) res.push([...item]);\n    return res;\n}","date":"2023-05-16"}],"tagList":[],"level":"Easy"}},{"problemName":"2678.老人的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2678.老人的数目.json","problemData":{"id":"2727","name":"2678.老人的数目","url":"https://leetcode.cn/problems/number-of-senior-citizens","desc":"请你返回乘客中年龄 严格大于 60 岁 的人数。","solutions":[{"script":"python","time":36,"memory":15.65,"desc":"切片后统计。","code":"class Solution:\n    def countSeniors(self, details: List[str]) -> int:\n        return sum(int(v[11:13]) > 60 for v in details)","date":"2023-10-23"}],"tagList":["数组","字符串"],"level":"Easy"}},{"problemName":"2679.矩阵中的和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2679.矩阵中的和.json","problemData":{"id":"2728","name":"2679.矩阵中的和","url":"https://leetcode.cn/problems/sum-in-a-matrix","desc":"给你一个下标从 0 开始的二维整数数组 nums 。请你返回最后的 分数 。","solutions":[{"script":"cpp","time":176,"memory":67.4,"desc":"堆。","code":"class Solution {\npublic:\n    int matrixSum(vector<vector<int>>& nums) {\n        int n = nums.size(), m = nums[0].size();\n        vector<priority_queue<int>> qs(n);\n        for (int i = 0; i < n; i++) {\n            auto &q = qs[i];\n            for (auto &num : nums[i]) q.push(num);\n        }\n        int res = 0;\n        for (int j = 0; j < m; j++) {\n            priority_queue<int> q;\n            for (int i = 0; i < n; i++) {\n                q.push(qs[i].top());\n                qs[i].pop();\n            }\n            res += q.top();\n        }\n        return res;\n    }\n};","date":"2023-07-04"},{"script":"cpp","time":100,"memory":46.9,"desc":"排序。","code":"class Solution {\npublic:\n    int matrixSum(vector<vector<int>>& nums) {\n        int res = 0;\n        for (auto &row : nums) sort(row.begin(), row.end());\n        for (int j = nums[0].size() - 1; j >= 0; j--) {\n            int val = 0;\n            for (int i = 0; i < nums.size(); i++) val = max(val, nums[i][j]);\n            res += val;\n        }\n        return res;\n    }\n};","date":"2023-07-04"},{"script":"python","time":132,"memory":33.6,"desc":"同上。","code":"class Solution:\n    def matrixSum(self, nums: List[List[int]]) -> int:\n        for l in nums:\n            l.sort()\n        res = 0\n        for j in range(len(nums[0]) - 1, -1, -1):\n            val = 0\n            for i in range(len(nums)):\n                val = max(val, nums[i][j])\n            res += val\n        return res","date":"2023-07-04"},{"script":"rust","time":20,"memory":3.6,"desc":"同上。","code":"impl Solution {\n    pub fn matrix_sum(mut nums: Vec<Vec<i32>>) -> i32 {\n        let mut res = 0;\n        for row in &mut nums {\n            row.sort()\n        }\n        for j in (0..nums[0].len()).rev() {\n            let mut val = 0;\n            for i in 0..nums.len() {\n                val = val.max(nums[i][j]);\n            }\n            res += val;\n        }\n        res\n    }\n}","date":"2023-07-04"}],"tagList":["数组","矩阵","排序","模拟","堆（优先队列）"],"level":"Medium"}},{"problemName":"2681.英雄的力量.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2681.英雄的力量.json","problemData":{"id":"2784","name":"2681.英雄的力量","url":"https://leetcode.cn/problems/power-of-heroes","desc":"请你返回所有可能的 非空 英雄组的 力量 之和。","solutions":[{"script":"cpp","time":88,"memory":88.63,"desc":"排序后遍历统计。","code":"class Solution {\npublic:\n    typedef long long ll;\n    int sumOfPower(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        // min (...cnt) max， sum统计min为最小值的情况个数，pow(2, cnt)\n        ll res = 0, MOD = 1e9 + 7, sum = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            ll num = nums[i], num2 = num * num % MOD;\n            // 当子序列内只有num时的情况\n            res += num2 * num % MOD;\n            // 前面最小值的和 乘以 最大值的平方\n            res += sum * num2 % MOD;\n            // 重新累加最小值的和\n            sum = ((sum * 2 % MOD) + num) % MOD;\n        }\n        return res % MOD;\n    }\n};","date":"2023-08-01"},{"script":"python","time":168,"memory":25.5,"desc":"同上。","code":"class Solution:\n    def sumOfPower(self, nums: List[int]) -> int:\n        nums.sort()\n        res = sum = 0\n        MOD = 1000000000 + 7\n        for i in range(len(nums)):\n            num = nums[i]\n            num2 = num * num % MOD\n            res += num2 * num % MOD + sum * num2 % MOD\n            sum = (sum * 2 % MOD + num) % MOD\n        return int(res % MOD)","date":"2023-08-01"},{"script":"rust","time":24,"memory":3.37,"desc":"同上。","code":"impl Solution {\n    pub fn sum_of_power(nums: Vec<i32>) -> i32 {\n        let mut nums: Vec<i64> = nums.into_iter().map(|v| v as i64).collect();\n        nums.sort();\n        let mut res = 0i64;\n        let mut sum = 0i64;\n        const MOD: i64 = 1000000000 + 7;\n        for i in 0..nums.len() {\n            let num = nums[i];\n            let num2 = num * num % MOD;\n            res += num2 * num % MOD + sum * num2 % MOD;\n            sum = (sum * 2 % MOD + num) % MOD\n        }\n        (res % MOD) as i32\n    }\n}","date":"2023-08-01"}],"tagList":["数组","数学","动态规划","前缀和","排序"],"level":"Hard"}},{"problemName":"2682.找出转圈游戏输家.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2682.找出转圈游戏输家.json","problemData":{"id":"2791","name":"2682.找出转圈游戏输家","url":"https://leetcode.cn/problems/find-the-losers-of-the-circular-game","desc":"给你参与游戏的朋友数量 n 和一个整数 k ，请按升序排列返回包含所有输家编号的数组 answer 作为答案。","solutions":[{"script":"cpp","time":8,"memory":13.16,"desc":"模拟。","code":"class Solution {\npublic:\n    vector<int> circularGameLosers(int n, int k) {\n        int list[50] = {0}, cur = 0;\n        list[cur] += 1;\n        for (int i = 1; ; i++) {\n            cur = (cur + i * k) % n;\n            list[cur] += 1;\n            if (list[cur] > 1) break;\n        }\n        vector<int> res;\n        for (int i = 0; i < n; i++) {\n            if (list[i] == 0) res.push_back(i + 1);\n        }\n        return res;\n    }\n};","date":"2023-08-16"},{"script":"python","time":72,"memory":15.46,"desc":"同上。","code":"class Solution:\n    def circularGameLosers(self, n: int, k: int) -> List[int]:\n        list = [0 for _ in range(n)]\n        cur = 0\n        list[cur] += 1\n        i = 1\n        while True:\n            cur = (cur + i * k) % n\n            list[cur] += 1\n            i += 1\n            if list[cur] > 1:\n                break\n        res = []\n        for i in range(n):\n            if list[i] == 0:\n                res.append(i + 1)\n        return res","date":"2023-08-16"},{"script":"rust","time":4,"memory":1.88,"desc":"同上。","code":"impl Solution {\n    pub fn circular_game_losers(n: i32, k: i32) -> Vec<i32> {\n        let n = n as usize;\n        let k = k as usize;\n        let mut list = vec![0; n];\n        let mut cur = 0;\n        list[cur] += 1;\n        for i in 1.. {\n            cur = (cur + i * k) % n;\n            list[cur] += 1;\n            if list[cur] > 1 {\n                break;\n            }\n        }\n        (0..n)\n            .collect::<Vec<_>>()\n            .into_iter()\n            .filter(|i| list[*i] == 0)\n            .map(|v| (v + 1) as i32)\n            .collect()\n    }\n}","date":"2023-08-16"}],"tagList":["数组","哈希表","模拟"],"level":"Easy"}},{"problemName":"2684.矩阵中移动的最大次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2684.矩阵中移动的最大次数.json","problemData":{"id":"2794","name":"2684.矩阵中移动的最大次数","url":"https://leetcode.cn/problems/maximum-number-of-moves-in-a-grid","desc":"返回你在矩阵中能够 移动 的 最大 次数。","solutions":[{"script":"python","time":226,"memory":41.75,"desc":"dfs。","code":"dirs = [(1, 1), (0, 1), (-1, 1)]\n\n    class Solution:\n        def maxMoves(self, grid: List[List[int]]) -> int:\n            n, m = len(grid), len(grid[0])\n            @cache\n            def dfs(row: int, col: int) -> int:\n                ans = 0\n                for x, y in dirs:\n                    nrow, ncol = row + x, col + y\n                    if 0 <= nrow < n and 0 <= ncol < m and grid[row][col] < grid[nrow][ncol]:\n                        ans = max(ans, 1 + dfs(nrow, ncol))\n                return ans\n            return max(dfs(row, 0) for row in range(n))","date":"2024-03-16"}],"tagList":["数组","动态规划","矩阵"],"level":"Medium"}},{"problemName":"2693.使用自定义上下文调用函数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2693.使用自定义上下文调用函数.json","problemData":{"id":"2790","name":"2693.使用自定义上下文调用函数","url":"https://leetcode.cn/problems/call-function-with-custom-context","desc":"增强所有函数，使其具有 callPolyfill 方法。该方法接受一个对象 obj 作为第一个参数，以及任意数量的附加参数。obj 成为函数的 this 上下文。附加参数将传递给该函数（即 callPolyfill 方法所属的函数）。","solutions":[{"script":"typescript","time":64,"memory":43.9,"desc":"利用原型链挂载this。","code":"declare global {\n    interface Function {\n        callPolyfill(context: Record<any, any>, ...args: any[]): any;\n    }\n}\nFunction.prototype.callPolyfill = function (context: any, ...args): any {\n    const temp = Symbol();\n    context.__proto__[temp] = this;\n    const res =  context[temp](...args);\n    delete context.__proto__[temp];\n    return res;\n};","date":"2023-05-23"}],"tagList":[],"level":"Medium"}},{"problemName":"2694.事件发射器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2694.事件发射器.json","problemData":{"id":"2797","name":"2694.事件发射器","url":"https://leetcode.cn/problems/event-emitter","desc":"设计一个 EventEmitter 类。这个接口与 Node.js 或 DOM 的 Event Target 接口相似，但有一些差异。EventEmitter 应该允许订阅事件和触发事件。","solutions":[{"script":"typescript","time":68,"memory":44,"desc":"利用闭包map存储已经订阅的消息。","code":"type Callback = (...args: any[]) => any;\ntype Subscription = {\n    unsubscribe: () => void;\n};\n\nclass EventEmitter {\n    map: Record<string, Set<Callback>> = {}\n    subscribe(eventName: string, callback: Callback): Subscription {\n        if (!this.map[eventName]) this.map[eventName] = new Set();\n        this.map[eventName].add(callback);\n        return {\n            unsubscribe: () => {\n                this.map[eventName].delete(callback);\n            },\n        };\n    }\n\n    emit(eventName: string, args: any[] = []): any {\n        return Array.from(this.map[eventName] ?? []).map(fn => fn(...args));\n    }\n}","date":"2023-05-23"}],"tagList":[],"level":"Medium"}},{"problemName":"2695.包装数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2695.包装数组.json","problemData":{"id":"2805","name":"2695.包装数组","url":"https://leetcode.cn/problems/array-wrapper","desc":"创建一个名为 ArrayWrapper 的类，它在其构造函数中接受一个整数数组作为参数。","solutions":[{"script":"typescript","time":56,"memory":44.2,"desc":"存储nums后，valueOf中累加，toString中返回字符串。","code":"class ArrayWrapper {\n    constructor(public nums: number[]) {}\n    valueOf() {\n        return this.nums.reduce((sum, num) => sum + num, 0);\n    }\n    toString() {\n        return `[${this.nums.join(',')}]`;\n    }\n};","date":"2023-05-23"}],"tagList":[],"level":"Easy"}},{"problemName":"2696.删除子串后的字符串最小长度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2696.删除子串后的字符串最小长度.json","problemData":{"id":"2800","name":"2696.删除子串后的字符串最小长度","url":"https://leetcode.cn/problems/minimum-string-length-after-removing-substrings","desc":"返回可获得的最终字符串的 最小 可能长度。","solutions":[{"script":"python","time":48,"memory":17.09,"desc":"用栈储存遍历过的元素。","code":"class Solution:\n    def minLength(self, s: str) -> int:\n        stack = []\n        for c in s:\n            if stack and stack[-1] == 'A' and c == 'B' or stack and stack[-1] == 'C' and c == 'D': stack.pop()\n            else: stack.append(c)\n        return len(stack)","date":"2024-01-10"}],"tagList":["栈","字符串","模拟"],"level":"Easy"}},{"problemName":"2697.字典序最小回文串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2697.字典序最小回文串.json","problemData":{"id":"2816","name":"2697.字典序最小回文串","url":"https://leetcode.cn/problems/lexicographically-smallest-palindrome","desc":"返回最终的回文字符串。","solutions":[{"script":"python","time":148,"memory":16.23,"desc":"遍历。","code":"class Solution:\n    def makeSmallestPalindrome(self, s: str) -> str:\n        arr = list(s)\n        for i in range(len(arr) // 2):\n            arr[i] = arr[len(arr) - 1 - i]= min(arr[i], arr[len(arr) - 1 - i])\n        return ''.join(arr)","date":"2023-12-13"},{"script":"cpp","time":32,"memory":15.03,"desc":"同上。","code":"class Solution {\npublic:\n    string makeSmallestPalindrome(string s) {\n        for (int i = 0; i < s.size() / 2; i++) {\n            s[i] = s[s.size() - 1 - i] = min(s[i], s[s.size() - 1 - i]);\n        }\n        return s;\n    }\n};","date":"2023-12-13"},{"script":"rust","time":8,"memory":2.35,"desc":"同上。","code":"impl Solution {\n    pub fn make_smallest_palindrome(s: String) -> String {\n        let mut arr = s.chars().map(|c| c as u8).collect::<Vec<u8>>();\n        let n = arr.len();\n        for i in 0..n / 2 {\n            arr[i] = arr[i].min(arr[n - 1 - i]);\n            arr[n - 1 - i] = arr[i];\n        }\n        String::from_utf8(arr).unwrap()\n    }\n}","date":"2023-12-13"}],"tagList":["贪心","双指针","字符串"],"level":"Easy"}},{"problemName":"2698.求一个整数的惩罚数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2698.求一个整数的惩罚数.json","problemData":{"id":"2802","name":"2698.求一个整数的惩罚数","url":"https://leetcode.cn/problems/find-the-punishment-number-of-an-integer","desc":"给你一个正整数 n ，请你返回 n 的 惩罚数 。","solutions":[{"script":"cpp","time":316,"memory":5.92,"desc":"dfs计算当前值是否可行。","code":"class Solution {\npublic:\n    bool check(int num) {\n        string s = to_string(num * num);\n        function<bool(int, int)> dfs = [&](int idx, int target) -> bool {\n            if (idx == s.size()) return target == 0;\n            for (int cnt = 1; cnt <= s.size() - idx; cnt++) {\n                if (dfs(idx + cnt, target - stoi(s.substr(idx, cnt)))) return true;\n            }\n            return false;\n        };\n        return dfs(0, num);\n    }\n    int punishmentNumber(int n) {\n        int res = 0;\n        for (int i = 1; i <= n; i++) res += check(i) ? i * i : 0;\n        return res;\n    }\n};","date":"2023-10-25"},{"script":"python","time":1416,"memory":15.71,"desc":"同上。","code":"def check(num: int) -> bool:\n        s = str(num * num)\n        def dfs(idx: int, target: int) -> bool:\n            if idx == len(s): return target == 0\n            for cnt in range(1, len(s) - idx + 1):\n                if dfs(idx + cnt, target - int(s[idx: idx + cnt])): return True\n            return False\n\n        return dfs(0, num)\n\n    class Solution:\n        def punishmentNumber(self, n: int) -> int:\n            return sum(i * i if check(i) else 0 for i in range(1, n + 1))","date":"2023-10-25"},{"script":"rust","time":124,"memory":1.9,"desc":"同上。","code":"fn check(num: i32) -> bool {\n    let s = num.pow(2).to_string().chars().collect::<Vec<_>>();\n    fn dfs(s: &Vec<char>, idx: usize, target: i32) -> bool {\n        if idx == s.len() {\n            target == 0\n        } else {\n            for cnt in 1..=(s.len() - idx) {\n                if dfs(\n                    s,\n                    idx + cnt,\n                    target - &s[idx..idx + cnt].iter().collect::<String>().parse::<i32>().unwrap(),\n                ) {\n                    return true;\n                }\n            }\n            false\n        }\n    }\n    dfs(&s, 0, num)\n}\n\nimpl Solution {\n    pub fn punishment_number(n: i32) -> i32 {\n        (1..=n).map(|i| if check(i) { i * i } else { 0 }).sum()\n    }\n}","date":"2023-10-25"}],"tagList":["数学","回溯"],"level":"Medium"}},{"problemName":"2699.修改图中的边权.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2699.修改图中的边权.json","problemData":{"id":"2803","name":"2699.修改图中的边权","url":"https://leetcode.cn/problems/modify-graph-edge-weights","desc":"给你一个 n 个节点的 无向带权连通 图，节点编号为 0 到 n - 1 ，再给你一个整数数组 edges ，其中 edges[i] = [ai, bi, wi] 表示节点 ai 和 bi 之间有一条边权为 wi 的边。部分边的边权为 -1（wi = -1），其他边的边权都为 正 数（wi > 0）。你需要将所有边权为 -1 的边都修改为范围 [1, 2 * 109] 中的 正整数 ，使得从节点 source 到节点 destination 的 最短距离 为整数 target 。如果有 多种 修改方案可以使 source 和 destination 之间的最短距离等于 target ，你可以返回任意一种方案。如果存在使 source 到 destination 最短距离为 target 的方案，请你按任意顺序返回包含所有边的数组（包括未修改边权的边）。如果不存在这样的方案，请你返回一个 空数组 。","solutions":[{"script":"cpp","time":792,"memory":255.6,"desc":"dijkstra对于所有正数边求解，如果d小于target则无解，否则每次增加一条负数边判断是否有解。","code":"#define X first\n#define Y second\n#define pii pair<int, int>\nstruct QNode {\n    int cur, sum;\n    QNode(int cur, int sum = 0): cur(cur), sum(sum) {}\n};\nclass Solution {\npublic:\n    vector<vector<int>> modifiedGraphEdges(int n, vector<vector<int>>& edges, int source, int destination, int target) {\n        vector<vector<int>> nodes(n, vector<int>(n, 0));\n        for (auto &e : edges) {\n            nodes[e[0]][e[1]] = e[2];\n            nodes[e[1]][e[0]] = e[2];\n        }\n        int d = dijkstra(n, nodes, source, destination);\n        vector<vector<int>> res;\n        if (d < target) return res;\n        bool success = d == target;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (nodes[i][j] > 0) res.push_back(vector<int>{ i, j, nodes[i][j] });\n                else if (nodes[i][j] == 0) continue;\n                else if (success) res.push_back(vector<int>{ i, j, (int)2e9 });\n                else {\n                    nodes[i][j] = 1;\n                    nodes[j][i] = 1;\n                    int d = dijkstra(n, nodes, source, destination);\n                    if (d > target) {\n                        res.push_back(vector<int>{ i, j, 1 });\n                    } else {\n                        res.push_back(vector<int>{ i, j, target - d + 1 });\n                        success = true;\n                    }\n                }\n            }\n        }\n        return success ? res : vector<vector<int>>{};\n    }\n    int dijkstra(int n, vector<vector<int>>& nodes, int from, int to) {\n        int res = 0;\n        auto cmp = [&](QNode &v1, QNode &v2) { return v2.sum < v1.sum; };\n        priority_queue<QNode, vector<QNode>, decltype(cmp)> q(cmp);\n        q.push(QNode(from, 0));\n        vector<vector<bool>> used(n, vector<bool>(n, false));\n        while (q.size()) {\n            auto node = q.top();\n            if (node.cur == to) return node.sum;\n            q.pop();\n            for (int i = 0; i < n; i++) {\n                if (nodes[node.cur][i] > 0 && !used[node.cur][i]) {\n                    QNode next = node;\n                    next.cur = i;\n                    next.sum = node.sum + nodes[node.cur][i];\n                    used[node.cur][i] = true;\n                    q.push(move(next));\n                }\n            }\n        }\n        return INT_MAX;\n    }\n};","date":"2023-06-09"}],"tagList":["图","最短路","堆（优先队列）"],"level":"Hard"}},{"problemName":"2700.两个对象之间的差异.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2601-2700/2700.两个对象之间的差异.json","problemData":{"id":"2774","name":"2700.两个对象之间的差异","url":"https://leetcode.cn/problems/differences-between-two-objects","desc":"请你编写一个函数，它接收两个深度嵌套的对象或数组 obj1 和 obj2 ，并返回一个新对象表示它们之间差异。","solutions":[{"script":"typescript","time":76,"memory":45.3,"desc":"dfs。","code":"// 特殊标识符，在左右相等时返回\nconst same = Symbol('same');\n// 存储所有已经存在的key\nfunction mergeKey(key1: string[], key2: string[]) {\n    const set1 = new Set(key1);\n    const set2 = new Set(key2);\n    const res = new Set<string>();\n    for (const k of set1) {\n        if (set2.has(k)) res.add(k);\n    }\n    return res;\n}\n\nfunction objDiff(obj1: any, obj2: any, topLevel = true): any {\n    const t1 = typeof obj1;\n    const t2 = typeof obj2;\n    // 类型不等，肯定不等\n    if (t1 !== t2) return [obj1, obj2];\n    // 如果不是对象，直接判断是否相等\n    if (t1 !== 'object') return obj1 === obj2 ? same : [obj1, obj2];\n    // 如果是null或undefined，直接判断防止下面出错\n    if (obj1 === null || obj1 === undefined || obj2 === null || obj2 === undefined) return same;\n    // 如果一个是数组一个不是数组，那就不等\n    if (\n        (!Array.isArray(obj1) && Array.isArray(obj2)) ||\n        (Array.isArray(obj1) && !Array.isArray(obj2))\n    )\n        return [obj1, obj2];\n    // 此时肯定是对象或数组\n    // 拿所有共存的key\n    const keys = mergeKey(Object.keys(obj1), Object.keys(obj2));\n    const res = {};\n    // 遍历obj1中所有的kv\n    for (const [k, v] of Object.entries(obj1).filter(([k]) => keys.has(k))) {\n        // 递归比较，利用topLevel记录是不是顶层\n        const diff = objDiff(v, obj2[k], false);\n        // 如果不同就存储\n        if (diff != same) res[k] = diff;\n    }\n    // 如果是空的，但是是顶层的，那就返回相等\n    if (Object.keys(res).length === 0 && !topLevel) return same;\n    // 否则顶层要返回控对象\n    return res;\n}","date":"2023-05-25"}],"tagList":[],"level":"Medium"}}]},{"dirName":"2701-2800","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\2701-2800","problems":[{"problemName":"2704.相等还是不相等.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2704.相等还是不相等.json","problemData":{"id":"2813","name":"2704.相等还是不相等","url":"https://leetcode.cn/problems/to-be-or-not-to-be","desc":"请你编写一个名为 expect 的函数，用于帮助开发人员测试他们的代码。它应该接受任何值 val 并返回一个包含以下两个函数的对象。","solutions":[{"script":"typescript","time":68,"memory":42.5,"desc":"直接判断。","code":"type ToBeOrNotToBe = {\n    toBe: (val: any) => boolean;\n    notToBe: (val: any) => boolean;\n};\nfunction throwError(msg: string): never {\n    throw new Error(msg);\n}\nfunction expect(val1: any): ToBeOrNotToBe {\n    return {\n        toBe: val2 => (val1 === val2 ? true : throwError('Not Equal')),\n        notToBe: val2 => (val1 !== val2 ? true : throwError('Equal')),\n    };\n}","date":"2023-06-03"}],"tagList":[],"level":"Easy"}},{"problemName":"2705.精简对象.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2705.精简对象.json","problemData":{"id":"2804","name":"2705.精简对象","url":"https://leetcode.cn/problems/compact-object","desc":"现给定一个对象或数组 obj，返回一个 精简对象 。精简对象 与原始对象相同，只是将包含 假 值的键移除。该操作适用于对象及其嵌套对象。数组被视为索引作为键的对象。当 Boolean(value) 返回 false 时，值被视为 假 值。","solutions":[{"script":"typescript","time":156,"memory":69,"desc":"对于每个是对象的value，进行dfs。","code":"type Obj = Record<any, any>;\n\nfunction compactObject(obj: Obj): Obj {\n    const res: any = Array.isArray(obj) ? [] : {};\n    for (const [k, v] of Object.entries(obj)) {\n        if (Boolean(v)) {\n            const newv = typeof v === 'object' ? compactObject(v) : v;\n            if (Array.isArray(obj)) res.push(newv);\n            else res[k] = newv;\n        }\n    }\n    return res;\n};","date":"2023-06-05"}],"tagList":[],"level":"Medium"}},{"problemName":"2706.购买两块巧克力.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2706.购买两块巧克力.json","problemData":{"id":"2756","name":"2706.购买两块巧克力","url":"https://leetcode.cn/problems/buy-two-chocolates","desc":"请你返回在购买两块巧克力后，最多能剩下多少钱。","solutions":[{"script":"python","time":48,"memory":16.98,"desc":"排序后计算。","code":"class Solution:\n    def buyChoco(self, prices: List[int], money: int) -> int:\n        prices.sort()\n        res = money - prices[0] - prices[1]\n        return res if res >= 0 else money","date":"2023-12-29"}],"tagList":["数组","排序"],"level":"Easy"}},{"problemName":"2707.字符串中的额外字符.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2707.字符串中的额外字符.json","problemData":{"id":"2755","name":"2707.字符串中的额外字符","url":"https://leetcode.cn/problems/extra-characters-in-a-string","desc":"给你一个下标从 0 开始的字符串 s 和一个单词字典 dictionary 。你需要将 s 分割成若干个 互不重叠 的子字符串，每个子字符串都在 dictionary 中出现过。s 中可能会有一些 额外的字符 不在任何子字符串中。请你采取最优策略分割 s ，使剩下的字符 最少 。","solutions":[{"script":"python","time":156,"memory":16.97,"desc":"dp[i]表示以i为结尾的字符串省略的最多字符。","code":"class Solution:\n    def minExtraChar(self, s: str, dictionary: List[str]) -> int:\n        cache = set(dictionary)\n        n = len(s)\n        dp = [inf] * (n + 1)\n        dp[0] = 0\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1] + 1\n            for j in range(i):\n                if s[j: i] in cache:\n                    dp[i] = min(dp[i], dp[j])\n        return dp[n]","date":"2024-01-09"}],"tagList":["字典树","数组","哈希表","字符串","动态规划"],"level":"Medium"}},{"problemName":"2710.移除字符串中的尾随零.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2710.移除字符串中的尾随零.json","problemData":{"id":"2819","name":"2710.移除字符串中的尾随零","url":"https://leetcode.cn/problems/remove-trailing-zeros-from-a-string","desc":"给你一个用字符串表示的正整数 num ，请你以字符串形式返回不含尾随零的整数 num 。","solutions":[{"script":"python","time":47,"memory":16.7,"desc":"遍历。","code":"class Solution:\n    def removeTrailingZeros(self, num: str) -> str:\n        arr = list(num)\n        while arr[-1] == '0': arr.pop()\n        return ''.join(arr)","date":"2024-06-29"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"2711.对角线上不同值的数量差.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2711.对角线上不同值的数量差.json","problemData":{"id":"2801","name":"2711.对角线上不同值的数量差","url":"hthttps://leetcode.cn/problems/difference-of-number-of-distinct-values-on-diagonals","desc":"给你一个下标从 0 开始、大小为 m x n 的二维矩阵 grid ，请你求解大小同样为 m x n 的答案矩阵 answer 。","solutions":[{"script":"cpp","time":56,"memory":32.2,"desc":"以每个顶点开始向右下遍历。","code":"class Solution {\npublic:\n    vector<vector<int>> differenceOfDistinctValues(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<int>> res(n, vector<int>(m, 0));\n        auto comp = [&](int row, int col) {\n            unordered_map<int, int> l, r;\n            int nrow = row + 1, ncol = col + 1;\n            while (nrow < n && ncol < m) {\n                r[grid[nrow][ncol]]++;\n                nrow++;\n                ncol++;\n            }\n            res[row][col] = abs((int)l.size() - (int)r.size());\n            while (row + 1 < n && col + 1 < m) {\n                l[grid[row][col]]++;\n                row++;\n                col++;\n                r[grid[row][col]]--;\n                if (r[grid[row][col]] == 0) r.erase(grid[row][col]);\n                res[row][col] = abs((int)l.size() - (int)r.size());\n            }\n        };\n        for (int j = 0; j < m; j++)  comp(0, j);\n        for (int i = 1; i < n; i++)  comp(i, 0);\n        return res;\n    }\n};;","date":"2023-05-28"},{"script":"python","time":112,"memory":16.2,"desc":"同上。","code":"class Solution:\n    def differenceOfDistinctValues(self, grid: List[List[int]]) -> List[List[int]]:\n        n = len(grid)\n        m = len(grid[0])\n        res = [[0 for _ in range(m)] for _ in range(n)]\n\n        def comp(row: int, col: int):\n            l = Counter()\n            r = Counter()\n            nrow = row + 1\n            ncol = col + 1\n            while nrow < n and ncol < m:\n                r[grid[nrow][ncol]] += 1\n                nrow += 1\n                ncol += 1\n            res[row][col] = abs(len(l) - len(r))\n            while row + 1 < n and col + 1 < m:\n                l[grid[row][col]] += 1\n                row += 1\n                col += 1\n                r[grid[row][col]] -= 1\n                if r[grid[row][col]] == 0:\n                    r.pop(grid[row][col])\n                res[row][col] = abs(len(l) - len(r))\n        for j in range(m):\n            comp(0, j)\n        for i in range(1, n):\n            comp(i, 0)\n        return res\n","date":"2023-05-28"},{"script":"rust","time":12,"memory":2.1,"desc":"同上。","code":"impl Solution {\n    pub fn difference_of_distinct_values(grid: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\n        use std::collections::HashMap;\n        let n = grid.len();\n        let m = grid[0].len();\n        let mut res = vec![vec![0; m]; n];\n        let mut comp = |mut row: usize, mut col: usize| {\n            let mut l = HashMap::<i32, i32>::new();\n            let mut r = HashMap::<i32, i32>::new();\n            let mut nrow = row + 1;\n            let mut ncol = col + 1;\n            while nrow < n && ncol < m {\n                *r.entry(grid[nrow][ncol]).or_insert(0) += 1;\n                nrow += 1;\n                ncol += 1;\n            }\n            res[row][col] = (l.len() as i32 - r.len() as i32).abs();\n            while row + 1 < n && col + 1 < m {\n                *l.entry(grid[row][col]).or_insert(0) += 1;\n                row += 1;\n                col += 1;\n                let item = r.get_mut(&grid[row][col]).unwrap();\n                *item -= 1;\n                if *item == 0 {\n                    r.remove(&grid[row][col]);\n                }\n                res[row][col] = (l.len() as i32 - r.len() as i32).abs();\n            }\n        };\n        for j in 0..m {\n            comp(0, j);\n        }\n        for i in 1..n {\n            comp(i, 0);\n        }\n        res\n    }\n}","date":"2023-05-28"}],"tagList":["数组","哈希表","矩阵"],"level":"Medium"}},{"problemName":"2712.使所有字符相等的最小成本.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2712.使所有字符相等的最小成本.json","problemData":{"id":"2817","name":"2712.使所有字符相等的最小成本","url":"https://leetcode.cn/problems/minimum-cost-to-make-all-characters-equal","desc":"返回使字符串内所有字符 相等 需要的 最小成本 。","solutions":[{"script":"cpp","time":92,"memory":30.8,"desc":"从中间向两边遍历。","code":"class Solution {\npublic:\n    typedef long long ll;\n    ll minimumCost(string s) {\n        ll n = s.size(), m = n / 2;\n        function<ll(ll, ll, bool)> compL = [&](ll idx, ll target, bool rev) -> ll {\n            if (idx == -1) return 0;\n            ll val = s[idx] - '0';\n            if (rev) val ^= 1;\n            if (val == target) return compL(idx - 1, target, rev);\n            return compL(idx - 1, target, !rev) + (idx + 1);\n        };\n        function<ll(ll, ll, bool)> compR = [&](ll idx, ll target, bool rev) -> ll {\n            if (idx == n) return 0;\n            ll val = s[idx] - '0';\n            if (rev) val ^= 1;\n            if (val == target) return compR(idx + 1, target, rev);\n            return compR(idx + 1, target, !rev) + (n - idx);\n        };\n        return min(compL(m - 1, 0, false) + compR(m, 0, false), compL(m - 1, 1, false) + compR(m, 1, false));\n    }\n};","date":"2023-05-28"},{"script":"cpp","time":20,"memory":11.8,"desc":"一次遍历，遇到左右不等的，要不翻转左边，要不翻转右边。","code":"class Solution {\npublic:\n    typedef long long ll;\n    ll minimumCost(string s) {\n        ll res = 0;\n        for (int i = 1; i < s.size(); i++) {\n            if (s[i] != s[i - 1]) res += min(i, (int)s.size() - i);\n        }\n        return res;\n    }\n};","date":"2023-05-28"},{"script":"python","time":168,"memory":16.7,"desc":"同上。","code":"class Solution:\n    def minimumCost(self, s: str) -> int:\n        res = 0\n        for i in range(1, len(s)):\n            if s[i] != s[i - 1]: res += min(i, len(s) - i)\n        return res\n","date":"2023-05-28"},{"script":"rust","time":0,"memory":2.7,"desc":"同上。","code":"pub fn str_to_vec(s: &String) -> Vec<char> {\n    s.chars().collect()\n}\nimpl Solution {\n    pub fn minimum_cost(s: String) -> i64 {\n        let mut res = 0i64;\n        let s = str_to_vec(&s);\n        for i in 1..s.len() {\n            if s[i] != s[i - 1] {\n                res += i.min(s.len() - i) as i64;\n            }\n        }\n        res\n    }\n}","date":"2023-05-28"}],"tagList":["贪心","字符串","动态规划"],"level":"Medium"}},{"problemName":"2713.矩阵中严格递增的单元格数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2713.矩阵中严格递增的单元格数.json","problemData":{"id":"2818","name":"2713.矩阵中严格递增的单元格数","url":"https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix","desc":"请你找出从某个单元开始访问矩阵所能访问的 单元格的最大数量 。","solutions":[{"script":"python","time":1089,"memory":71.42,"desc":"根据数值进行统计后dp。","code":"class Solution:\n    def maxIncreasingCells(self, mat: List[List[int]]) -> int:\n        n = len(mat)\n        m = len(mat[0])\n        rows = [0] * n\n        cols = [0] * m\n        map = defaultdict(list)\n        for i in range(n):\n            for j in range(m):\n                map[mat[i][j]].append((i, j))\n        for _, arr in sorted(map.items(), key = lambda item: item[0]):\n            varr = [max(rows[i], cols[j]) + 1 for i, j in arr]\n            for (i, j), v in zip(arr, varr):\n                rows[i] = max(rows[i], v)\n                cols[j] = max(cols[j], v)\n        return max(rows)","date":"2024-06-19"}],"tagList":["记忆化搜索","数组","哈希表","二分查找","动态规划","矩阵","有序集合","排序"],"level":"Hard"}},{"problemName":"2719.统计整数数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2719.统计整数数目.json","problemData":{"name":"2719.统计整数数目","url":"https://leetcode.cn/problems/count-of-integers/description/","desc":"请你返回好整数的数目。","solutions":[{"script":"python","time":232,"memory":18.31,"desc":"数位dp。","code":"def digit_dp(n: int, min_num: str, max_num: str, min_sum: int, max_sum: int):\n    @cache\n    def dfs(i: int, val: int, limit_low: bool, limit_high: bool) -> int:\n        if val > max_sum: return 0\n        if i == n: return val >= min_sum\n        lo = int(min_num[i]) if limit_low else 0\n        hi = int(max_num[i]) if limit_high else 9\n        return sum(\n            dfs(i + 1, val + d, limit_low and lo == d, limit_high and hi == d)\n            for d in range(lo, hi + 1)\n        )\n    return  dfs\n    \nclass Solution:\n    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -> int:\n        dfs = digit_dp(len(num2), num1.zfill(len(num2)), num2, min_sum, max_sum)\n        return dfs(0, 0, True, True) % (10 ** 9 + 7)","date":"2024-01-16"}],"tagList":[],"level":"Easy"}},{"problemName":"2731.移动机器人.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2731.移动机器人.json","problemData":{"id":"2787","name":"2731.移动机器人","url":"https://leetcode.cn/problems/movement-of-robots","desc":"请你返回指令重复执行 d 秒后，所有机器人之间两两距离之和。","solutions":[{"script":"cpp","time":108,"memory":97.32,"desc":"贪心，忽略碰撞。","code":"class Solution {\npublic:\n    int sumDistance(vector<int>& nums, string s, int d) {\n        long long n = nums.size(), res = 0, MOD = 1e9 + 7;\n        vector<long long> arr;\n        for (int i = 0; i < n; i++) {\n            arr.push_back(s[i] == 'L' ? nums[i] - d : nums[i] + d);\n        }\n        sort(arr.begin(), arr.end());\n        for (int i = 1; i < n; i++) {\n            long long v = (arr[i] - arr[i - 1]) % MOD * (n - i) * i % MOD;\n            res = (res + v) % MOD;\n        }\n        return res;\n    }\n};","date":"2023-10-10"},{"script":"python","time":136,"memory":26.55,"desc":"同上。","code":"class Solution:\n    def sumDistance(self, nums: List[int], s: str, d: int) -> int:\n        n = len(nums)\n        arr = [nums[i] - d if s[i] == 'L' else nums[i] + d for i in range(n)]\n        arr.sort()\n        return sum((arr[i] - arr[i - 1]) * (n - i) * i for i in range(1, n)) % 1000000007","date":"2023-10-10"},{"script":"rust","time":24,"memory":4.51,"desc":"同上。","code":"impl Solution {\n    pub fn sum_distance(nums: Vec<i32>, s: String, d: i32) -> i32 {\n        let s = s.chars().into_iter().collect::<Vec<_>>();\n        let n = nums.len();\n        let mut res = 0;\n        const MOD: i64 = 1000000007;\n        let mut arr = vec![];\n        for i in 0..n {\n            arr.push(if s[i] == 'L' {\n                (nums[i] - d) as i64\n            } else {\n                (nums[i] + d) as i64\n            })\n        }\n        arr.sort();\n        for i in 1..n {\n            let v = (arr[i] - arr[i - 1]) % MOD * ((n as i64) - i as i64) * (i as i64);\n            res = (res + v) % MOD;\n        }\n        res as i32\n    }\n}","date":"2023-10-10"}],"tagList":["脑筋急转弯","数组","前缀和","排序"],"level":"Medium"}},{"problemName":"2734.执行子串操作后的字典序最小字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2734.执行子串操作后的字典序最小字符串.json","problemData":{"id":"2828","name":"2734.执行子串操作后的字典序最小字符串","url":"https://leetcode.cn/problems/lexicographically-smallest-string-after-substring-operation","desc":"返回执行上述操作 恰好一次 后可以获得的 字典序最小 的字符串。","solutions":[{"script":"python","time":162,"memory":22.7,"desc":"贪心，找第一个a前面的子串进行更新。","code":"class Solution:\n    def smallestString(self, s: str) -> str:\n        arr = list(s)\n        starti = 0\n        while starti < len(arr) and arr[starti] == 'a':\n            starti += 1\n        if starti == len(arr):\n            arr[-1] = 'z'\n        else:\n            endi = starti + 1\n            while endi < len(arr) and arr[endi] != 'a': endi += 1\n            for i in range(starti, endi):\n                arr[i] = chr(ord(arr[i]) - 1)\n        return ''.join(arr)","date":"2024-06-27"}],"tagList":["贪心","字符串"],"level":"Medium"}},{"problemName":"2735.收集巧克力.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2735.收集巧克力.json","problemData":{"id":"2810","name":"2735.收集巧克力","url":"https://leetcode.cn/problems/collecting-chocolates","desc":"假设你可以执行任意次操作，请返回收集所有类型巧克力所需的最小成本。","solutions":[{"script":"python","time":2948,"memory":24.91,"desc":"对每一个偏移求出最小值。","code":"class Solution:\n    def minCost(self, nums: List[int], x: int) -> int:\n        n = len(nums)\n        dp = [[inf] * n for _ in range(n + 1)]\n        for i in range(n): dp[0][i] = nums[i]\n        res = sum(nums)\n        for offset in range(1, n):\n            for i in range(n):\n                dp[offset][i] = min(dp[offset - 1][i], nums[(i + offset) % n])\n            res = min(res, sum(dp[offset]) + x * offset)\n        return res","date":"2023-12-28"}],"tagList":["数组","枚举"],"level":"Medium"}},{"problemName":"2736.最大和查询.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2736.最大和查询.json","problemData":{"id":"2839","name":"2736.最大和查询","url":"https://leetcode.cn/problems/maximum-sum-queries","desc":"给你两个长度为 n 、下标从 0 开始的整数数组 nums1 和 nums2 ，另给你一个下标从 1 开始的二维数组 queries ，其中 queries[i] = [xi, yi] 。对于第 i 个查询，在所有满足 nums1[j] >= xi 且 nums2[j] >= yi 的下标 j (0 <= j < n) 中，找出 nums1[j] + nums2[j] 的 最大值 ，如果不存在满足条件的 j 则返回 -1 。返回数组 answer ，其中 answer[i] 是第 i 个查询的答案。","solutions":[{"script":"python","time":340,"memory":56.66,"desc":"单调栈。","code":"class Solution:\n    def maximumSumQueries(self, nums1: List[int], nums2: List[int], queries: List[List[int]]) -> List[int]:\n        n = len(nums1)\n        nums = [(nums1[i], nums2[i]) for i in range(n)]\n        nums.sort()\n\n        qn = len(queries)\n        qlist = [i for i in range(qn)]\n        qlist.sort(key = lambda i: queries[i])\n        \n        stack = []\n        ans = [0] * qn\n\n        while qlist:\n            qidx = qlist.pop()\n            x, y = queries[qidx]\n            while nums and x <= nums[-1][0]:\n                xnum, ynum = nums.pop()\n                while stack and stack[-1][1] <= xnum + ynum:\n                    stack.pop()\n                if not stack or stack[-1][0] < ynum:\n                    stack.append((ynum, xnum + ynum))\n            idx = bisect_left(stack, (y, 0))\n            ans[qidx] = stack[idx][1] if idx < len(stack) else -1\n        return ans","date":"2023-11-17"}],"tagList":["栈","树状数组","线段树","数组","二分查找","排序","单调栈"],"level":"Hard"}},{"problemName":"2739.总行驶距离.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2739.总行驶距离.json","problemData":{"id":"2857","name":"2739.总行驶距离","url":"https://leetcode.cn/problems/total-distance-traveled","desc":"卡车有两个油箱。给你两个整数，mainTank 表示主油箱中的燃料（以升为单位），additionalTank 表示副油箱中的燃料（以升为单位）。该卡车每耗费 1 升燃料都可以行驶 10 km。每当主油箱使用了 5 升燃料时，如果副油箱至少有 1 升燃料，则会将 1 升燃料从副油箱转移到主油箱。返回卡车可以行驶的最大距离。","solutions":[{"script":"cpp","time":8,"memory":5.9,"desc":"遍历。","code":"class Solution {\npublic:\n    int distanceTraveled(int mainTank, int additionalTank) {\n        int used = 0, res = 0;\n        while (mainTank) {\n            used++;\n            mainTank--;\n            res += 10;\n            if (used % 5 == 0 && additionalTank) {\n                mainTank++;\n                additionalTank--;\n            }\n        }\n        return res;\n    }\n};","date":"2023-06-18"},{"script":"python","time":104,"memory":16.2,"desc":"同上。","code":"class Solution:\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\n        used = res = 0\n        while mainTank:\n            used+=1\n            mainTank-=1\n            res+=10\n            if used % 5 == 0 and additionalTank:\n                mainTank+=1\n                additionalTank-=1\n        return res","date":"2023-06-18"},{"script":"rust","time":4,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn distance_traveled(mut main_tank: i32, mut additional_tank: i32) -> i32 {\n        let mut used = 0;\n        let mut res = 0;\n        while main_tank != 0 {\n            used += 1;\n            main_tank -= 1;\n            res += 10;\n            if used % 5 == 0 && additional_tank != 0 {\n                main_tank += 1;\n                additional_tank -= 1;\n            }\n        }\n        res\n    }\n}","date":"2023-06-18"},{"script":"python","time":58,"memory":16.45,"desc":"遍历。","code":"class Solution:\n    def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\n        res = 0\n        while mainTank >= 5:\n            res += 5 * 10\n            mainTank -= 5\n            if additionalTank:\n                mainTank += 1\n                additionalTank -= 1\n        return res + mainTank * 10","date":"2024-04-25"}],"tagList":["数学","模拟"],"level":"Easy"}},{"problemName":"2740.找出分区值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2740.找出分区值.json","problemData":{"id":"2845","name":"2740.找出分区值","url":"https://leetcode.cn/problems/find-the-value-of-the-partition","desc":"返回表示分区值的整数。","solutions":[{"script":"python","time":118,"memory":27.98,"desc":"遍历。","code":"class Solution:\n    def findValueOfPartition(self, nums: List[int]) -> int:\n        return min(n2 - n1 for n1, n2 in pairwise(sorted(nums)))","date":"2024-07-26"}],"tagList":["数组","排序"],"level":"Medium"}},{"problemName":"2741.特别的排列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2741.特别的排列.json","problemData":{"id":"2848","name":"2741.特别的排列","url":"https://leetcode.cn/problems/special-permutations","desc":"请你返回特别排列的总数目，由于答案可能很大，请将它对 109 + 7 取余 后返回。","solutions":[{"script":"python","time":3193,"memory":128.91,"desc":"dfs。","code":"class Solution:\n    def specialPerm(self, nums: List[int]) -> int:\n        n = len(nums)\n        @cache\n        def dfs(last: int, mask: int) -> int:\n            if mask == (1 << n) - 1: return 1\n            return sum(\n                dfs(nums[i], mask | (1 << i))\n                for i in range(n)\n                if mask & (1 << i) == 0 and (last % nums[i] == 0 or nums[i] % last == 0)\n            )\n        return sum(dfs(nums[i], 1 << i) for i in range(n)) % (10 ** 9 + 7)","date":"2024-06-26"}],"tagList":["位运算","数组","动态规划","状态压缩"],"level":"Medium"}},{"problemName":"2742.给墙壁刷油漆.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2742.给墙壁刷油漆.json","problemData":{"id":"2808","name":"2742.给墙壁刷油漆","url":"https://leetcode.cn/problems/painting-the-walls","desc":"请你返回刷完 n 堵墙最少开销为多少。","solutions":[{"script":"python","time":2024,"memory":492.34,"desc":"dfs。","code":"class Solution:\n    def paintWalls(self, cost: List[int], time: List[int]) -> int:\n        n = len(cost)\n        @cache\n        def dfs(idx: int, cur_time: int) -> int:\n            if cur_time >= n - idx: return 0\n            if idx == n: return inf\n            return min(\n                dfs(idx + 1, cur_time + time[idx]) + cost[idx],\n                dfs(idx + 1, cur_time - 1)\n            )\n        return dfs(0, 0)","date":"2024-06-29"}],"tagList":["数组","动态规划"],"level":"Hard"}},{"problemName":"2744.最大字符串配对数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2744.最大字符串配对数目.json","problemData":{"id":"2847","name":"2744.最大字符串配对数目","url":"https://leetcode.cn/problems/find-maximum-number-of-string-pairs","desc":"请你返回数组 words 中的 最大 匹配数目。","solutions":[{"script":"python","time":44,"memory":16.88,"desc":"遍历。","code":"class Solution:\n    def maximumNumberOfStringPairs(self, words: List[str]) -> int:\n        return sum(words[i1][::-1] == words[i2] for i1 in range(len(words)) for i2 in range(0, i1))","date":"2024-01-17"}],"tagList":["数组","哈希表","字符串","模拟"],"level":"Easy"}},{"problemName":"2748.美丽下标对的数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2748.美丽下标对的数目.json","problemData":{"id":"2831","name":"2748.美丽下标对的数目","url":"https://leetcode.cn/problems/number-of-beautiful-pairs","desc":"返回 nums 中 美丽下标对 的总数目。","solutions":[{"script":"python","time":385,"memory":16.5,"desc":"遍历。","code":"class Solution:\n    def countBeautifulPairs(self, nums: List[int]) -> int:\n        return sum(\n            gcd(int(str(nums[i])[-1]), int(str(nums[j])[0])) == 1\n            for i in range(len(nums))\n            for j in range(i)\n        )","date":"2024-06-20"}],"tagList":["数组","哈希表","数学","计数","数论"],"level":"Easy"}},{"problemName":"2760.最长奇偶子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2760.最长奇偶子数组.json","problemData":{"id":"2866","name":"2760.最长奇偶子数组","url":"https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold","desc":"给你一个下标从 0 开始的整数数组 nums 和一个整数 threshold 。以整数形式返回满足题目要求的最长子数组的长度。","solutions":[{"script":"cpp","time":104,"memory":88.9,"desc":"遍历。","code":"class Solution {\npublic:\n    int longestAlternatingSubarray(vector<int>& nums, int threshold) {\n        int n = nums.size(), res = 0;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] % 2 != 0 || nums[i] > threshold) continue;\n            int cnt = 1;\n            for (int j = i + 1; j < n; j++) {\n                if (nums[j] % 2 == nums[j - 1] % 2 || nums[j] > threshold) break;\n                cnt++;\n            }\n            res = max(res, cnt);\n        }\n        return res;\n    }\n};","date":"2023-07-02"},{"script":"python","time":296,"memory":16.1,"desc":"同上。","code":"class Solution:\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\n        n = len(nums)\n        res = 0\n        for i in range(n):\n            if nums[i] % 2 != 0 or nums[i] > threshold:\n                continue\n            cnt = 1\n            for j in range(i+1, n):\n                if nums[j] % 2 == nums[j-1] % 2 or nums[j] > threshold:\n                    break\n                cnt += 1\n            res = max(res, cnt)\n        return res","date":"2023-07-02"},{"script":"rust","time":12,"memory":1.9,"desc":"同上。","code":"impl Solution {\n    pub fn longest_alternating_subarray(nums: Vec<i32>, threshold: i32) -> i32 {\n        let n = nums.len();\n        let mut res = 0;\n        for i in 0..n {\n            if nums[i] % 2 != 0 || nums[i] > threshold {\n                continue;\n            }\n            let mut cnt = 1;\n            for j in i + 1..n {\n                if nums[j] % 2 == nums[j - 1] % 2 || nums[j] > threshold {\n                    break;\n                }\n                cnt += 1;\n            }\n            res = res.max(cnt);\n        }\n        res\n    }\n}","date":"2023-07-02"},{"script":"python","time":96,"memory":15.67,"desc":"遍历。","code":"class Solution:\n    def longestAlternatingSubarray(self, nums: List[int], threshold: int) -> int:\n        n = len(nums)\n        i = 0\n        ans = 0\n        while i < n:\n            if nums[i] <= threshold and nums[i] % 2 == 0:\n                start = i\n                while i + 1 < n and nums[i + 1] % 2 != nums[i] % 2 and nums[i + 1] <= threshold:\n                    i += 1\n                ans = max(ans, i - start + 1)\n            i += 1\n        return ans","date":"2023-11-16"}],"tagList":["数组","滑动窗口"],"level":"Easy"}},{"problemName":"2761.和等于目标值的质数对.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2761.和等于目标值的质数对.json","problemData":{"id":"2873","name":"2761.和等于目标值的质数对","url":"https://leetcode.cn/problems/prime-pairs-with-target-sum","desc":"给你一个整数 n 。请你以二维有序列表的形式返回符合题目要求的所有 [xi, yi] ，列表需要按 xi 的 非递减顺序 排序。如果不存在符合要求的质数对，则返回一个空数组。","solutions":[{"script":"cpp","time":1256,"memory":110.4,"desc":"线性筛。","code":"unordered_set<int> s;\nvector<int> get_primes(int n) {\n    vector<int> primes(n, 0);\n    for (int i = 2; i < n; i++) {\n        if (primes[i] == 0) {\n            primes[++primes[0]] = i;\n            s.insert(i);\n        }\n        for (int j = 1; j <= primes[0] && i * primes[j] < n; j++) {\n            primes[i * primes[j]] = 1;\n            if (i % primes[j] == 0) break;\n        }\n    }\n    return primes;\n}\nvector<int> primes = get_primes(10000000);\n\nclass Solution {\npublic:\n    vector<vector<int>> findPrimePairs(int n) {\n        vector<vector<int>> res;\n        if (s.count(n - 2)) res.push_back({2, n - 2});\n        for (int i = 3; i <= n / 2; i += 2) {\n            if (!s.count(i) || !s.count(n - i)) continue;\n            res.push_back({i,n-i});\n        }\n        return res;\n    }\n};","date":"2023-07-02"},{"script":"cpp","time":364,"memory":32.4,"desc":"埃氏筛。","code":"vector<bool> get_primes2(int n) {\n    vector<bool> primes(n + 3, true);\n    primes[0] = primes[1] = false;\n    for (int i = 2; i < n; i++) {\n        if (!primes[i]) continue;\n        for (int j = 2; i * j < n; j++) {\n            primes[i * j] = false;\n        }\n    }\n    return primes;\n}\nclass Solution {\npublic:\n    vector<vector<int>> findPrimePairs(int n) {\n        auto primes = get_primes2(n);\n        vector<vector<int>> res;\n        if (n >= 2 && primes[n - 2]) res.push_back({ 2, n - 2 });\n        for (int i = 3; i <= n / 2; i += 2) {\n            if (primes[i] && primes[n - i]) {\n                res.push_back({ i, n - i });\n            }\n        }\n        return res;\n    }\n};","date":"2023-07-02"},{"script":"python","time":744,"memory":27.6,"desc":"同上。","code":"def get_primes2(n: int) -> List[bool]:\n        n += 3\n        primes = [True for _ in range(n)]\n        primes[0] = primes[1] = False\n        for i in range(2, n):\n            if primes[i]:\n                j = 2\n                while i * j < n:\n                    primes[i*j] = False\n                    j += 1\n        return primes\n    \n    primes = get_primes2(1000000)\n    \n    class Solution:\n        def findPrimePairs(self, n: int) -> List[List[int]]:\n            res = []\n            if n >= 2 and primes[n-2]:\n                res.append([2, n-2])\n            for i in range(3, n//2 + 1, 2):\n                if primes[i] and primes[n-i]:\n                    res.append([i, n-i])\n            return res","date":"2023-07-02"},{"script":"rust","time":224,"memory":3.6,"desc":"同上。","code":"pub fn get_primes2(mut n: usize) -> Vec<bool> {\n    n += 3;\n    let mut primes = vec![true; n];\n    primes[0] = false;\n    primes[1] = false;\n    for i in 2..n {\n        if primes[i] {\n            let mut j = 2;\n            while i * j < n {\n                primes[i * j] = false;\n                j += 1;\n            }\n        }\n    }\n    primes\n}\n\nimpl Solution {\n    pub fn find_prime_pairs(n: i32) -> Vec<Vec<i32>> {\n        let n = n as usize;\n        let primes = get_primes2(n);\n        let mut res = vec![];\n        if n >= 2 && primes[n - 2] {\n            res.push(vec![2, (n as i32) - 2]);\n        }\n        let mut i = 3;\n        while i <= n / 2 {\n            if primes[i] && primes[n - i] {\n                res.push(vec![i as i32, (n - i) as i32]);\n            }\n            i += 2;\n        }\n        res\n    }\n}","date":"2023-07-02"}],"tagList":["数组","数学","枚举","数论"],"level":"Medium"}},{"problemName":"2762.不间断子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2762.不间断子数组.json","problemData":{"id":"2868","name":"2762.不间断子数组","url":"https://leetcode.cn/problems/continuous-subarrays","desc":"给你一个下标从 0 开始的整数数组 nums 。请你返回 不间断 子数组的总数目。","solutions":[{"script":"cpp","time":1256,"memory":110.4,"desc":"平衡树。","code":"struct Node {\n    int idx, num;\n    Node(int idx, int num): idx(idx), num(num) {}\n    bool operator<(const Node &o) const {\n        return num < o.num;\n    }\n};\nclass Solution {\npublic:\n    long long continuousSubarrays(vector<int>& nums) {\n        int n = nums.size(), prev = 0;\n        long long res = 1;\n        multiset<Node> s;\n        s.insert(Node(0, nums[0]));\n        for (int i = 1; i < n; i++) {\n            int num = nums[i];\n            if (s.size()) {\n                auto it = s.begin();\n                while (s.size() && abs(num - it->num) > 2) {\n                    prev = max(prev, it->idx + 1);\n                    s.erase(it++);\n                }\n            }\n            if (s.size()) {\n                auto it = s.end();\n                it--;\n                while (s.size() && abs(num - it->num) > 2) {\n                    prev = max(prev, it->idx + 1);\n                    s.erase(it--);\n                }\n            }\n            s.insert(Node(i, num));\n            res += i - prev + 1;\n        }\n        return res;\n    }\n};","date":"2023-07-02"}],"tagList":["队列","数组","有序集合","滑动窗口","单调队列","堆（优先队列）"],"level":"Medium"}},{"problemName":"2763.所有子数组中不平衡数字之和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2763.所有子数组中不平衡数字之和.json","problemData":{"id":"2849","name":"2763.所有子数组中不平衡数字之和","url":"https://leetcode.cn/problems/sum-of-imbalance-numbers-of-all-subarrays","desc":"给你一个下标从 0 开始的整数数组 nums ，请你返回它所有 子数组 的 不平衡数字 之和。","solutions":[{"script":"cpp","time":816,"memory":137.5,"desc":"平衡树。","code":"class Solution {\npublic:\n    int sumImbalanceNumbers(vector<int>& nums) {\n        int n = nums.size(), res = 0;\n        for (int i = 1; i < n; i++) {\n            map<int, int> m;\n            int cnt = 0;\n            for (int j = i; j >= 0; j--) {\n                m[nums[j]]++;\n                if (m[nums[j]] > 1) {\n                    res += cnt;\n                    continue;\n                }\n                auto it = m.find(nums[j]);\n                auto prev = it;\n                if (prev != m.begin()) {\n                    prev--;\n                    if (nums[j] - prev->first > 1) cnt++;\n                }\n\n                auto next = it;\n                next++;\n                if (next != m.end()) {\n                    if (next->first - nums[j] > 1) cnt++;\n                }\n                if (it != m.begin() && next != m.end()) cnt--;\n                res += cnt;\n            }\n        }\n        return res;\n    }\n};","date":"2023-07-02"}],"tagList":["数组","哈希表","有序集合"],"level":"Hard"}},{"problemName":"2765.最长交替子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2765.最长交替子数组.json","problemData":{"id":"2870","name":"2765.最长交替子数组","url":"https://leetcode.cn/problems/longest-alternating-subarray","desc":"请你返回 nums 中所有 交替 子数组中，最长的长度，如果不存在交替子数组，请你返回 -1 。","solutions":[{"script":"python","time":57,"memory":16.51,"desc":"一次遍历，记录当前下标为结尾的最大值。","code":"class Solution:\n    def alternatingSubarray(self, nums: List[int]) -> int:\n        n = len(nums)\n        ans = res = 2 if nums[1] - nums[0] == 1 else 0\n        for i in range(2, n):\n            if res and nums[i] == nums[i - 2]:\n                res += 1\n            elif nums[i] - nums[i - 1] == 1:\n                res = 2\n            else:\n                res = 0\n            ans = max(ans, res)\n        return ans if ans else -1","date":"2024-01-23"}],"tagList":["数组","枚举"],"level":"Easy"}},{"problemName":"2766.重新放置石块.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2766.重新放置石块.json","problemData":{"id":"2834","name":"2766.重新放置石块","url":"https://leetcode.cn/problems/relocate-marbles","desc":"完成这些操作后，请你按升序返回所有 有 石块的位置。","solutions":[{"script":"python","time":102,"memory":35.38,"desc":"set存储。","code":"class Solution:\n    def relocateMarbles(self, nums: List[int], moveFrom: List[int], moveTo: List[int]) -> List[int]:\n        s = set(nums)\n        for i in range(len(moveFrom)):\n            s.remove(moveFrom[i])\n            s.add(moveTo[i])\n        return sorted(s)","date":"2024-07-24"}],"tagList":["数组","哈希表","排序","模拟"],"level":"Medium"}},{"problemName":"2769.找出最大的可达成数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2769.找出最大的可达成数字.json","problemData":{"id":"2812","name":"2769.找出最大的可达成数字","url":"https://leetcode.cn/problems/find-the-maximum-achievable-number","desc":"返回所有可达成数字中的最大值。","solutions":[{"script":"python","time":31,"memory":16.53,"desc":"贪心直接计算最大可能。","code":"class Solution:\n    def theMaximumAchievableX(self, num: int, t: int) -> int:\n        return num + 2 * t","date":"2024-05-21"}],"tagList":["数学"],"level":"Easy"}},{"problemName":"2779.数组的最大美丽值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2779.数组的最大美丽值.json","problemData":{"id":"2891","name":"2779.数组的最大美丽值","url":"https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation","desc":"对数组 nums 执行上述操作任意次后，返回数组可能取得的 最大 美丽值。","solutions":[{"script":"python","time":29,"memory":16.29,"desc":"直接判断两个字符串是否相等。","code":"class Solution:\n    def findLUSlength(self, a: str, b: str) -> int:\n        return max(len(a), len(b)) if a != b else -1","date":"2024-06-16"}],"tagList":["数组","二分查找","排序","滑动窗口"],"level":"Medium"}},{"problemName":"2786.访问数组中的位置使分数最大.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2786.访问数组中的位置使分数最大.json","problemData":{"id":"2893","name":"2786.访问数组中的位置使分数最大","url":"https://leetcode.cn/problems/visit-array-positions-to-maximize-score","desc":"请你返回你能得到的 最大 得分之和。","solutions":[{"script":"python","time":264,"memory":31.34,"desc":"遍历时存储前面最大的奇偶值。","code":"class Solution:\n    def maxScore(self, nums: List[int], x: int) -> int:\n        prev = [0, 0]\n        prev[nums[0] & 1] = nums[0]\n        prev[nums[0] & 1 ^ 1] = nums[0] - x\n        for num in nums[1:]:\n            v = max(prev[num & 1] + num, prev[num & 1 ^ 1] + num - x)\n            prev[num & 1] = max(prev[num & 1], v)\n        return max(prev)","date":"2024-06-14"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"2788.按分隔符拆分字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2788.按分隔符拆分字符串.json","problemData":{"id":"2881","name":"2788.按分隔符拆分字符串","url":"https://leetcode.cn/problems/split-strings-by-separator","desc":"返回一个由拆分后的新字符串组成的字符串数组，不包括空字符串 。","solutions":[{"script":"typescript","time":111,"memory":59.37,"desc":"分割后平铺。","code":"function splitWordsBySeparator(words: string[], separator: string): string[] {\n    const sarr = separator.split('')\n    return words\n            .map(word => sarr.map(s => word.split(s)))\n            .flat(3)\n            .filter(Boolean)\n};","date":"2024-01-20"}],"tagList":["数组","字符串"],"level":"Easy"}},{"problemName":"2789.合并后数组中的最大元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2789.合并后数组中的最大元素.json","problemData":{"id":"2872","name":"2789.合并后数组中的最大元素","url":"https://leetcode.cn/problems/largest-element-in-an-array-after-merge-operations","desc":"返回你可以从最终数组中获得的 最大 元素的值。","solutions":[{"script":"python","time":123,"memory":32.3,"desc":"从后往前遍历。","code":"class Solution:\n    def maxArrayValue(self, nums: List[int]) -> int:\n        for i in range(len(nums) - 2, -1, -1):\n            if nums[i] <= nums[i + 1]:\n                nums[i] += nums[i + 1]\n        return max(nums)","date":"2024-03-14"}],"tagList":["贪心","数组"],"level":"Medium"}},{"problemName":"2798.满足目标工作时长的员工数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2701-2800/2798.满足目标工作时长的员工数目.json","problemData":{"id":"2876","name":"2798.满足目标工作时长的员工数目","url":"https://leetcode.cn/problems/number-of-employees-who-met-the-target","desc":"请你用整数表示并返回工作至少 target 小时的员工数。","solutions":[{"script":"python","time":40,"memory":16.41,"desc":"遍历。","code":"class Solution:\n    def numberOfEmployeesWhoMetTarget(self, hours: List[int], target: int) -> int:\n        return len(list(filter(lambda v: v >= target, hours)))","date":"2024-04-30"}],"tagList":["数组"],"level":"Easy"}}]},{"dirName":"2801-2900","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\2801-2900","problems":[{"problemName":"2806.取整购买后的账户余额.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2801-2900/2806.取整购买后的账户余额.json","problemData":{"id":"2955","name":"2806.取整购买后的账户余额","url":"https://leetcode.cn/problems/account-balance-after-rounded-purchase","desc":"请你返回一个整数，表示你在愿意支出金额为 purchaseAmount 块钱的前提下，购买之后剩下的余额。","solutions":[{"script":"python","time":24,"memory":16.45,"desc":"遍历。","code":"class Solution:\n    def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n        cnt = 0\n        while (cnt + 1) * 10 < purchaseAmount: cnt += 1\n        if abs(cnt * 10 - purchaseAmount) < abs((cnt + 1) * 10 - purchaseAmount):\n            return 100 - 10 * cnt\n        else:\n            return 100 - 10 * (cnt + 1)","date":"2024-06-12"}],"tagList":["数学"],"level":"Easy"}},{"problemName":"2807.在链表中插入最大公约数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2801-2900/2807.在链表中插入最大公约数.json","problemData":{"id":"2903","name":"2807.在链表中插入最大公约数","url":"https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list","desc":"请你返回插入之后的链表。","solutions":[{"script":"python","time":72,"memory":19.92,"desc":"遍历。","code":"def gcd(a: int, b: int) -> int:\n        return gcd(b, a % b) if b != 0 else a\n    class Solution:\n        def insertGreatestCommonDivisors(self, head: Optional[ListNode]) -> Optional[ListNode]:\n            p = head\n            while p.next:\n                p.next = ListNode(gcd(p.val, p.next.val), p.next)\n                p = p.next.next\n            return head","date":"2024-01-06"},{"script":"rust","time":8,"memory":2.83,"desc":"同上。","code":"fn gcd(a: i32, b: i32) -> i32 {\n    if a < b {\n        gcd(b, a)\n    } else if b == 0 {\n        a\n    } else {\n        gcd(b, a % b)\n    }\n}\nimpl Solution {\n    pub fn insert_greatest_common_divisors(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\n        let mut head = head.unwrap();\n        let mut p = &mut head;\n        while let Some(mut next) = p.next.take() {\n            let mut new_next = Box::new(ListNode::new(gcd(p.val, next.val)));\n            new_next.next = Some(next);\n            p.next = Some(new_next);\n            p = p.next.as_mut().unwrap().next.as_mut().unwrap();\n        }\n        Some(head)\n    }\n}","date":"2024-01-06"}],"tagList":["链表","数学","数论"],"level":"Medium"}},{"problemName":"2808.使循环数组所有元素相等的最少秒数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2801-2900/2808.使循环数组所有元素相等的最少秒数.json","problemData":{"id":"2920","name":"2808.使循环数组所有元素相等的最少秒数","url":"https://leetcode.cn/problems/minimum-seconds-to-equalize-a-circular-array","desc":"请你返回将数组 nums 中所有元素变成相等元素所需要的 最少 秒数。","solutions":[{"script":"python","time":300,"memory":48.3,"desc":"记录下标，判断下标之间的最大距离。","code":"class Solution:\n    def minimumSeconds(self, nums: List[int]) -> int:\n        n = len(nums)\n        map = defaultdict(list)\n        for i in range(n):\n            map[nums[i]].append(i)\n        ans = inf\n        for arr in map.values():\n            cur = ceil((arr[0] + n - 1 - arr[-1]) / 2)\n            for i in range(1, len(arr)):\n                cur = max(cur, ceil((arr[i] - arr[i - 1] - 1) / 2))\n            ans = min(ans, cur)\n        return ans","date":"2024-01-30"},{"script":"rust","time":53,"memory":13.54,"desc":"同上。","code":"impl Solution {\n    pub fn minimum_seconds(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        let mut map: std::collections::HashMap<i32, Vec<usize>> = Default::default();\n        for i in 0..n {\n            map.entry(nums[i]).or_default().push(i);\n        }\n        map.into_iter()\n            .map(|(_, arr)| {\n                let mut cur = ((arr[0] + n - 1 - arr.last().unwrap()) as f64 / 2.0).ceil() as i32;\n                for i in 1..arr.len() {\n                    cur = cur.max((((arr[i] - arr[i - 1] - 1) as f64) / 2.0).ceil() as i32);\n                }\n                cur\n            })\n            .min()\n            .unwrap()\n    }\n}","date":"2024-01-30"}],"tagList":["数组","哈希表"],"level":"Medium"}},{"problemName":"2810.故障键盘.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2801-2900/2810.故障键盘.json","problemData":{"id":"2886","name":"2810.故障键盘","url":"https://leetcode.cn/problems/faulty-keyboard","desc":"你的笔记本键盘存在故障，每当你在上面输入字符 'i' 时，它会反转你所写的字符串。而输入其他字符则可以正常工作。给你一个下标从 0 开始的字符串 s ，请你用故障键盘依次输入每个字符。返回最终笔记本屏幕上输出的字符串。","solutions":[{"script":"python","time":43,"memory":16.4,"desc":"遍历。","code":"class Solution:\n    def finalString(self, s: str) -> str:\n        ans = ''\n        for c in s:\n            if c == 'i': ans = ans[::-1]\n            else: ans += c\n        return ans","date":"2024-04-01"}],"tagList":["字符串","模拟"],"level":"Easy"}},{"problemName":"2813.子序列最大优雅度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2801-2900/2813.子序列最大优雅度.json","problemData":{"id":"2894","name":"2813.子序列最大优雅度","url":"https://leetcode.cn/problems/maximum-elegance-of-a-k-length-subsequence","desc":"你的任务是从 items 所有长度为 k 的子序列中，找出 最大优雅度 。","solutions":[{"script":"python","time":237,"memory":42.13,"desc":"从大到小收益排序后，遍历时记录当前类目存在的次数。","code":"class Solution:\n    def findMaximumElegance(self, items: List[List[int]], k: int) -> int:\n        items.sort(key = lambda item: -item[0])\n        print(items)\n        set1 = set()\n        stack2 = []\n        cur = 0\n        for i in range(k):\n            item = items[i]\n            cur += item[0]\n            if item[1] in set1:\n                stack2.append(item[0])\n            else:\n                set1.add(item[1])\n        res = cur + len(set1) ** 2\n        for i in range(k, len(items)):\n            item = items[i]\n            if item[1] not in set1 and len(stack2):\n                cur += item[0] - stack2.pop()\n                set1.add(item[1])\n            res = max(res, cur + len(set1) ** 2)\n        return res","date":"2024-06-13"}],"tagList":["栈","贪心","数组","哈希表","排序","堆（优先队列）"],"level":"Hard"}},{"problemName":"2824.统计和小于目标的下标对数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2801-2900/2824.统计和小于目标的下标对数目.json","problemData":{"id":"2917","name":"2824.统计和小于目标的下标对数目","url":"https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target","desc":"给你一个下标从 0 开始长度为 n 的整数数组 nums 和一个整数 target ，请你返回满足 0 <= i < j < n 且 nums[i] + nums[j] < target 的下标对 (i, j) 的数目。","solutions":[{"script":"python","time":52,"memory":16.1,"desc":"枚举。","code":"class Solution:\n    def countPairs(self, nums: List[int], target: int) -> int:\n        return sum(nums[i] + nums[j] < target for i in range(len(nums)) for j in range(i))","date":"2023-11-24"}],"tagList":["数组","双指针","二分查找","排序"],"level":"Easy"}},{"problemName":"2828.判别首字母缩略词.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2801-2900/2828.判别首字母缩略词.json","problemData":{"id":"2977","name":"2828.判别首字母缩略词","url":"https://leetcode.cn/problems/check-if-a-string-is-an-acronym-of-words","desc":"给你一个字符串数组 words 和一个字符串 s ，请你判断 s 是不是 words 的 首字母缩略词 。如果可以按顺序串联 words 中每个字符串的第一个字符形成字符串 s ，则认为 s 是 words 的首字母缩略词。","solutions":[{"script":"python","time":56,"memory":17.75,"desc":"字符串拼接。","code":"class Solution:\n    def isAcronym(self, words: List[str], s: str) -> bool:\n        return ''.join(w[0] for w in words) == s","date":"2023-12-20"}],"tagList":["数组","字符串"],"level":"Easy"}},{"problemName":"2831.找出最长等值子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2801-2900/2831.找出最长等值子数组.json","problemData":{"id":"2832","name":"2831.找出最长等值子数组","url":"https://leetcode.cn/problems/find-the-longest-equal-subarray","desc":"从 nums 中删除最多 k 个元素后，返回可能的最长等值子数组的长度。","solutions":[{"script":"python","time":623,"memory":74.98,"desc":"遍历,哈希存储相同数字的下标。","code":"class Solution:\n    def longestEqualSubarray(self, nums: List[int], k: int) -> int:\n        map = defaultdict(deque)\n        res = 0\n        for i in range(len(nums)):\n            q = map[nums[i]]\n            q.append(i)\n            while q[-1] - q[0] - len(q) + 1 > k: q.popleft()\n            res = max(res, len(q))\n        return res","date":"2024-05-23"}],"tagList":["数组","哈希表","二分查找","滑动窗口"],"level":"Medium"}},{"problemName":"2834.找出美丽数组的最小和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2801-2900/2834.找出美丽数组的最小和.json","problemData":{"id":"3026","name":"2834.找出美丽数组的最小和","url":"https://leetcode.cn/problems/find-the-minimum-possible-sum-of-a-beautiful-array","desc":"返回符合条件的美丽数组所可能具备的 最小 和，并对结果进行取模 109 + 7。","solutions":[{"script":"python","time":159,"memory":19.35,"desc":"贪心获取target前半段和target开始往后的数。","code":"class Solution:\n    def minimumPossibleSum(self, n: int, target: int) -> int:\n        val = min(n, target // 2)\n        sum = (1 + val) * val // 2\n        if n > target // 2:\n            n -= target // 2\n            sum += (target + target + n - 1) * n // 2\n        return sum % ((11-1) ** 9 + 7)","date":"2024-03-08"}],"tagList":["贪心","数学"],"level":"Medium"}},{"problemName":"2844.生成特殊数字的最少操作.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2801-2900/2844.生成特殊数字的最少操作.json","problemData":{"id":"3046","name":"2844.生成特殊数字的最少操作","url":"https://leetcode.cn/problems/minimum-operations-to-make-a-special-number","desc":"返回最少需要多少次操作可以使 num 变成特殊数字。","solutions":[{"script":"python","time":48,"memory":16.51,"desc":"判断结尾两位是否为特定字符串即可。","code":"class Solution:\n    def minimumOperations(self, num: str) -> int:\n        arr = [\"00\", \"25\", \"50\", \"75\"]\n        def run(end_num: str) -> int:\n            i = len(num) - 1\n            j = len(end_num) - 1\n            while i >= 0 and j >= 0:\n                if num[i] == end_num[j]: j -= 1\n                i -= 1\n            if j != -1: return len(num)\n            return len(num) - i - 1 - 2\n        return min(min(run(end_num) for end_num in arr), len(num) - num.count('0'))","date":"2024-07-25"}],"tagList":["贪心","数学","字符串","枚举"],"level":"Medium"}},{"problemName":"2850.将石头分散到网格图的最少移动次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2801-2900/2850.将石头分散到网格图的最少移动次数.json","problemData":{"id":"3092","name":"2850.将石头分散到网格图的最少移动次数","url":"https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid","desc":"请你返回每个格子恰好有一个石头的 最少移动次数 。","solutions":[{"script":"python","time":56,"memory":16.36,"desc":"暴力枚举。","code":"class Solution:\n    def minimumMoves(self, grid: List[List[int]]) -> int:\n        arr1 = [(i, j, grid[i][j]) for i in range(3) for j in range(3) if grid[i][j] > 1]\n        arr0 = [(i, j) for i in range(3) for j in range(3) if grid[i][j] == 0]\n        self.res = inf\n        def dfs(i0: int, cur: int = 0) -> int:\n            if i0 == len(arr0): self.res = min(self.res, cur)\n            else:\n                for i1 in range(len(arr1)):\n                    old_item = arr1[i1]\n                    if old_item[2] > 1:\n                        arr1[i1] = (old_item[0], old_item[1], old_item[2] - 1)\n                        dfs(i0 + 1, cur + abs(old_item[0] - arr0[i0][0]) + abs(old_item[1] - arr0[i0][1]))\n                        arr1[i1] = old_item\n        dfs(0)\n        return self.res","date":"2024-07-21"}],"tagList":["广度优先搜索","数组","动态规划","矩阵"],"level":"Medium"}},{"problemName":"2859.计算K置位下标对应元素的和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2801-2900/2859.计算K置位下标对应元素的和.json","problemData":{"id":"3093","name":"2859.计算K置位下标对应元素的和","url":"https://leetcode.cn/problems/sum-of-values-at-indices-with-k-set-bits","desc":"请你用整数形式返回 nums 中的特定元素之 和 ，这些特定元素满足：其对应下标的二进制表示中恰存在 k 个置位。","solutions":[{"script":"python","time":42,"memory":16.55,"desc":"遍历。","code":"class Solution:\n    def sumIndicesWithKSetBits(self, nums: List[int], k: int) -> int:\n        return sum(nums[i] if bin(i).count('1') == k else 0 for i in range(len(nums)))","date":"2024-01-25"}],"tagList":["位运算","数组"],"level":"Easy"}},{"problemName":"2861.最大合金数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2801-2900/2861.最大合金数.json","problemData":{"id":"3095","name":"2861.最大合金数","url":"https://leetcode.cn/problems/maximum-number-of-alloys","desc":"给你整数 n、k、budget，下标从 1 开始的二维数组 composition，两个下标从 1 开始的数组 stock 和 cost，请你在预算不超过 budget 金钱的前提下，最大化 公司制造合金的数量。","solutions":[{"script":"python","time":695,"memory":16.87,"desc":"二分。","code":"class Solution:\n    def maxNumberOfAlloys(self, n: int, k: int, budget: int, composition: List[List[int]], stock: List[int], cost: List[int]) -> int:\n        def check(count: int, comp: List[int]) -> bool:\n            return sum(cost[i] * max(count * comp[i] - stock[i], 0) for i in range(n)) <= budget\n\n        l, r = 0, 10 ** 10\n        while l < r:\n            m = (l + r + 1) // 2\n            if any(check(m, comp) for comp in composition):\n                l = m\n            else:\n                r = m - 1\n        return l","date":"2024-01-27"}],"tagList":["数组","二分查找"],"level":"Medium"}},{"problemName":"2864.最大二进制奇数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2801-2900/2864.最大二进制奇数.json","problemData":{"id":"3055","name":"2864.最大二进制奇数","url":"https://leetcode.cn/problems/maximum-odd-binary-number","desc":"以字符串形式，表示并返回可以由给定组合生成的最大二进制奇数。","solutions":[{"script":"python","time":39,"memory":16.34,"desc":"计数。","code":"class Solution:\n    def maximumOddBinaryNumber(self, s: str) -> str:\n        cnt1 = s.count('1')\n        return (cnt1 - 1) * '1' + (len(s) - cnt1) * '0' + '1'","date":"2024-03-13"}],"tagList":["贪心","数学","字符串"],"level":"Easy"}},{"problemName":"2865.美丽塔I.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2801-2900/2865.美丽塔I.json","problemData":{"id":"3114","name":"2865.美丽塔I","url":"https://leetcode.cn/problems/beautiful-towers-i","desc":"请你返回满足 美丽塔 要求的方案中，高度和的最大值 。","solutions":[{"script":"python","time":41,"memory":16.82,"desc":"单调栈。","code":"class Solution:\n    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:\n        n = len(maxHeights)\n        s = []\n        larr = [-1] * n\n        rarr = [n] * n\n        for i in range(n):\n            while s and maxHeights[s[-1]] >= maxHeights[i]: rarr[s.pop()] = i\n            if s: larr[i] = s[-1]\n            s.append(i)\n        lh = [0] * (n + 2)\n        rh = [0] * (n + 2)\n        for i in range(n):\n            lh[i + 1] = maxHeights[i] * (i - larr[i]) + lh[larr[i] + 1]\n        for i in range(n - 1, -1, -1):\n            rh[i + 1] = maxHeights[i] * (rarr[i] - i) + rh[rarr[i] + 1]\n        return max(lh[i + 1] + rh[i + 1] - maxHeights[i] for i in range(n))","date":"2024-01-24"}],"tagList":["栈","数组","单调栈"],"level":"Medium"}},{"problemName":"2866.美丽塔II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2801-2900/2866.美丽塔II.json","problemData":{"id":"3113","name":"2866.美丽塔II","url":"https://leetcode.cn/problems/beautiful-towers-ii","desc":"请你返回满足 美丽塔 要求的方案中，高度和的最大值 。","solutions":[{"script":"python","time":316,"memory":42.55,"desc":"字符串拼接。","code":"class Solution:\n    def maximumSumOfHeights(self, maxHeights: List[int]) -> int:\n        n = len(maxHeights)\n        prev = [-1] * n\n        next = [n] * n\n        s = []\n        for i in range(n):\n            while s and maxHeights[s[-1]] >= maxHeights[i]: s.pop()\n            if s: prev[i] = s[-1]\n            s.append(i)\n        s.clear()\n        for i in range(n):\n            while s and maxHeights[s[-1]] > maxHeights[i]: next[s.pop()] = i\n            s.append(i)\n        lsums = [0] * n\n        rsums = [0] * n\n        for i in range(n):\n            lsums[i] += (i - prev[i]) * maxHeights[i]\n            if prev[i] != -1: lsums[i] += lsums[prev[i]]\n        for i in range(n - 1, -1, -1):\n            rsums[i] += (next[i] - i) * maxHeights[i]\n            if next[i] != n: rsums[i] += rsums[next[i]]\n        return max(lsums[i] + rsums[i] - maxHeights[i] for i in range(n))","date":"2023-12-21"}],"tagList":["栈","数组","单调栈"],"level":"Medium"}},{"problemName":"2867.统计树中的合法路径数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2801-2900/2867.统计树中的合法路径数目.json","problemData":{"id":"3112","name":"2867.统计树中的合法路径数目","url":"https://leetcode.cn/problems/count-valid-paths-in-a-tree","desc":"请你返回树中的 合法路径数目 。","solutions":[{"script":"python","time":322,"memory":58.63,"desc":"预处理好质数表，通过遍历所有质数，找到以当前质数为根结点的时候，所有子树的长度，进行两两相乘。","code":"def get_primes2(n: int) -> List[bool]:\n        n += 1\n        primes = [True for _ in range(n)]\n        primes[0] = primes[1] = False\n        for i in range(2, n):\n            if primes[i]:\n                j = 2\n                while i * j < n:\n                    primes[i*j] = False\n                    j += 1\n        return primes\n    primes = get_primes2(10 ** 5 + 1)\n    \n    class Solution:\n        def countPaths(self, n: int, edges: List[List[int]]) -> int:\n            nodes = [[] for _ in range(n + 1)]\n            for n1, n2 in edges:\n                nodes[n1].append(n2)\n                nodes[n2].append(n1)\n            ans = 0\n    \n            cache = defaultdict(int)\n            def dfs(arr: List[int], node: int, parent: int):\n                if primes[node]: return\n                arr.append(node)\n                ans = 1\n                for child in nodes[node]:\n                    if not primes[child] and child != parent:\n                        ans += dfs(arr, child, node)\n                return ans\n    \n            for node in range(1, n + 1):\n                if primes[node]:\n                    cur = 0\n                    for child in nodes[node]:\n                        if not primes[child]:\n                            if child not in cache:\n                                arr = []\n                                res = dfs(arr, child, node)\n                                for item in arr: cache[item] = res\n                            ans += cache[child] * cur\n                            cur += cache[child]\n                    ans += cur\n        return ans","date":"2024-02-27"}],"tagList":["树","深度优先搜索","数学","动态规划","数论"],"level":"Hard"}}]},{"dirName":"2901-3000","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\2901-3000","problems":[{"problemName":"2908.元素和最小的山形三元组I.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2901-3000/2908.元素和最小的山形三元组I.json","problemData":{"id":"3176","name":"2908.元素和最小的山形三元组I","url":"https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-i","desc":"请你找出 nums 中 元素和最小 的山形三元组，并返回其 元素和 。","solutions":[{"script":"python","time":58,"memory":16.45,"desc":"遍历。","code":"class Solution:\n    def minimumSum(self, nums: List[int]) -> int:\n        ans = inf\n        for k in range(len(nums)):\n            for j in range(k):\n                for i in range(j):\n                    if nums[i] < nums[j] > nums[k]:\n                        ans = min(ans, nums[i] + nums[j] + nums[k])\n        return ans if ans != inf else -1","date":"2024-03-29"}],"tagList":["数组"],"level":"Easy"}},{"problemName":"2917.找出数组中的K-or值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2901-3000/2917.找出数组中的K-or值.json","problemData":{"id":"3183","name":"2917.找出数组中的K-or值","url":"https://leetcode.cn/problems/find-the-k-or-of-an-array","desc":"返回 nums 的 K-or 值。","solutions":[{"script":"python","time":89,"memory":16.48,"desc":"遍历。","code":"class Solution:\n    def findKOr(self, nums: List[int], k: int) -> int:\n        ans = 1-1\n        for i in range(32):\n            num = int(len(list(filter(lambda num: (num >> i) & 1, nums))) >= k)\n            ans |= num << i\n        return ans","date":"2024-03-06"}],"tagList":["位运算","数组"],"level":"Easy"}},{"problemName":"2923.找到冠军I.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2901-3000/2923.找到冠军I.json","problemData":{"id":"3188","name":"2923.找到冠军I","url":"https://leetcode.cn/problems/find-champion-i","desc":"返回这场比赛中将会成为冠军的队伍。","solutions":[{"script":"python","time":48,"memory":17.82,"desc":"每次找比当前大的第一个值进行递归遍历。","code":"class Solution:\n    def findChampion(self, grid: List[List[int]]) -> int:\n        def find(i :int) -> int:\n            for j in range(len(grid)):\n                if i != j and grid[i][j] == 0: return find(j)\n            return i\n        return find(0)","date":"2024-04-12"}],"tagList":["数组","矩阵"],"level":"Easy"}},{"problemName":"2924.找到冠军II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2901-3000/2924.找到冠军II.json","problemData":{"id":"3189","name":"2924.找到冠军II","url":"https://leetcode.cn/problems/find-champion-ii","desc":"如果这场比赛存在 唯一 一个冠军，则返回将会成为冠军的队伍。否则，返回 -1 。","solutions":[{"script":"python","time":78,"memory":17.43,"desc":"对所有队伍进行遍历，如果有比他强的就从队伍中删除，最后判断是否只剩下一个队伍。","code":"class Solution:\n    def findChampion(self, n: int, edges: List[List[int]]) -> int:\n        nodes = [i for i in range(n)]\n        for n1, n2 in edges:\n            if n2 in nodes:\n                nodes.remove(n2)\n        return nodes[0] if len(nodes) == 1 else -1","date":"2024-04-13"}],"tagList":["图"],"level":"Medium"}},{"problemName":"2928.给小朋友们分糖果I.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2901-3000/2928.给小朋友们分糖果I.json","problemData":{"id":"3199","name":"2928.给小朋友们分糖果I","url":"https://leetcode.cn/problems/distribute-candies-among-children-i","desc":"给你两个正整数 n 和 limit 。请你将 n 颗糖果分给 3 位小朋友，确保没有任何小朋友得到超过 limit 颗糖果，请你返回满足此条件下的 总方案数 。","solutions":[{"script":"python","time":280,"memory":31.78,"desc":"排序后遍历。","code":"class Solution:\n    @cache\n    def distributeCandies(self, n: int, limit: int, cnt: int = 3) -> int:\n        if cnt == 0: return int(n == 0)\n        return sum(self.distributeCandies(n - i, limit, cnt - 1) for i in range(limit + 1))","date":"2024-06-01"}],"tagList":["数学","组合数学","枚举"],"level":"Easy"}},{"problemName":"2938.区分黑球与白球.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2901-3000/2938.区分黑球与白球.json","problemData":{"id":"3195","name":"2938.区分黑球与白球","url":"https://leetcode.cn/problems/separate-black-and-white-balls","desc":"返回「将所有黑色球都移到右侧，所有白色球都移到左侧所需的 最小步数」。","solutions":[{"script":"python","time":104,"memory":43.7,"desc":"贪心把所有0都放左边。","code":"class Solution:\n    def minimumSteps(self, s: str) -> int:\n        cnt0 = 0\n        res = 0\n        for i in range(len(s)):\n            if s[i] == '0':\n                res += i - cnt0\n                cnt0 += 1\n        return res","date":"2024-06-06"}],"tagList":["贪心","双指针","字符串"],"level":"Medium"}},{"problemName":"2940.找到Alice和Bob可以相遇的建筑.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2901-3000/2940.找到Alice和Bob可以相遇的建筑.json","problemData":{"name":"2940.找到Alice和Bob可以相遇的建筑","url":"https://leetcode.cn/problems/find-building-where-alice-and-bob-can-meet","desc":"请你能返回一个数组 ans ，其中 ans[i] 是第 i 个查询中，Alice 和 Bob 可以相遇的 最左边的建筑 。如果对于查询 i ，Alice 和 Bob 不能相遇，令 ans[i] 为 -1 。","solutions":[{"script":"python","time":324,"memory":39.23,"desc":"离线处理queries，过滤能立即得出答案的，剩余的一定是h[i] > h[j]，此时从左往右遍历h，维护当前下标之前的所有需求最小堆。","code":"class Solution:\n    def leftmostBuildingQueries(self, heights: List[int], queries: List[List[int]]) -> List[int]:\n        res = [-1 for _ in range(len(queries))]\n        arr = [[] for _ in range(len(heights))]\n        for idx, (i, j) in enumerate(queries):\n            if i > j: i, j = j, i\n            if i == j or heights[i] < heights[j]: res[idx] = j\n            else: arr[j].append((heights[i], idx))\n\n        q = []\n        for cur_idx, h in enumerate(heights):\n            while q and q[0][0] < h:\n                idx = heappop(q)[1]\n                res[idx] = cur_idx\n            for v in arr[cur_idx]:\n                heappush(q, v)\n        return res","date":"2024-08-10"}],"tagList":[],"level":"Easy"}},{"problemName":"2951.找出峰值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2901-3000/2951.找出峰值.json","problemData":{"id":"3221","name":"2951.找出峰值","url":"https://leetcode.cn/problems/find-the-peaks","desc":"以数组形式返回给定数组中 峰值 的下标，顺序不限 。","solutions":[{"script":"python","time":34,"memory":16.45,"desc":"遍历。","code":"class Solution:\n    def findPeaks(self, mountain: List[int]) -> List[int]:\n        return [i for i in range(1, len(mountain) - 1) if mountain[i - 1] < mountain[i] > mountain[i + 1]]","date":"2024-05-28"}],"tagList":["数组","枚举"],"level":"Easy"}},{"problemName":"2952.需要添加的硬币的最小数量.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2901-3000/2952.需要添加的硬币的最小数量.json","problemData":{"id":"3231","name":"2952.需要添加的硬币的最小数量","url":"https://leetcode.cn/problems/minimum-number-of-coins-to-be-added","desc":"请你找出 nums 中 元素和最小 的山形三元组，并返回其 元素和 。","solutions":[{"script":"python","time":109,"memory":27.09,"desc":"记录当前所能表示的区间内，再依次增加数据。","code":"class Solution:\n    def minimumAddedCoins(self, coins: List[int], target: int) -> int:\n        coins.sort()\n        ans = 0\n        idx = 0\n        end = 1 # [0, end - 1]\n        while end - 1 < target:\n            if idx < len(coins) and coins[idx] <= end:\n                end += coins[idx]\n                idx += 1\n            else:\n                end += end\n                ans += 1\n        return ans","date":"2024-03-31"}],"tagList":["贪心","数组","排序"],"level":"Medium"}},{"problemName":"2956.找到两个数组中的公共元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2901-3000/2956.找到两个数组中的公共元素.json","problemData":{"id":"3206","name":"2956.找到两个数组中的公共元素","url":"https://leetcode.cn/problems/find-common-elements-between-two-arrays","desc":"请你返回一个长度为 2 的整数数组 answer ，按顺序 分别为以上两个数值。","solutions":[{"script":"python","time":63,"memory":16.57,"desc":"遍历。","code":"class Solution:\n    def findIntersectionValues(self, nums1: List[int], nums2: List[int]) -> List[int]:\n        return [\n            sum(num in nums2 for num in nums1),\n            sum(num in nums1 for num in nums2),\n        ]","date":"2024-07-16"}],"tagList":["数组","哈希表"],"level":"Easy"}},{"problemName":"2959.关闭分部的可行集合数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2901-3000/2959.关闭分部的可行集合数目.json","problemData":{"id":"3217","name":"2959.关闭分部的可行集合数目","url":"https://leetcode.cn/problems/number-of-possible-sets-of-closing-branches","desc":"请你返回关闭分部的可行方案数目，满足每个方案里剩余分部之间的最远距离不超过 maxDistance。","solutions":[{"script":"python","time":1863,"memory":16.52,"desc":"枚举所有可能，用短路算法求出两地之间的最短路径。","code":"class Solution:\n    def numberOfSets(self, n: int, maxDistance: int, roads: List[List[int]]) -> int:\n        def check(mask: int) -> int:\n            d = [[inf for _ in range(n)] for _ in range(n)]\n            for n1, n2, w in roads: d[n1][n2] = d[n2][n1] = min(d[n1][n2], d[n2][n1], w)\n            for k in range(n):\n                if mask & (1 << k):\n                    for i in range(n):\n                        if mask & (1 << k):\n                            for j in range(n):\n                                if mask & (1 << j):\n                                    d[i][j] = d[j][i] = min(d[i][j], d[i][k] + d[k][j])\n            for i in range(n):\n                if mask & (1 << i):\n                    for j in range(i):\n                        if mask & (1 << j):\n                            if d[i][j] > maxDistance:\n                                return False\n            return True\n        return sum(check(i) for i in range(2 ** n))","date":"2024-07-17"}],"tagList":["位运算","图","枚举","最短路","堆（优先队列）"],"level":"Hard"}},{"problemName":"2960.统计已测试设备.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2901-3000/2960.统计已测试设备.json","problemData":{"id":"3220","name":"2960.统计已测试设备","url":"https://leetcode.cn/problems/count-tested-devices-after-test-operations","desc":"返回一个整数，表示按顺序执行测试操作后 已测试设备 的数量。","solutions":[{"script":"python","time":54,"memory":16.46,"desc":"模拟。","code":"class Solution:\n    def countTestedDevices(self, batteryPercentages: List[int]) -> int:\n        res = 0\n        for i in range(len(batteryPercentages)):\n            if batteryPercentages[i] > 0:\n                for j in range(i + 1, len(batteryPercentages)):\n                    batteryPercentages[j] -= 1\n                res += 1\n        return res","date":"2024-05-10"}],"tagList":["数组","模拟"],"level":"Easy"}},{"problemName":"2961.双模幂运算.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2901-3000/2961.双模幂运算.json","problemData":{"id":"3234","name":"2961.双模幂运算","url":"https://leetcode.cn/problems/double-modular-exponentiation","desc":"返回一个由 好下标 组成的数组，顺序不限 。","solutions":[{"script":"python","time":44,"memory":16.5,"desc":"枚举每一个块与另一个块是否位置产生交集。","code":"class Solution:\n    def getGoodIndices(self, variables: List[List[int]], target: int) -> List[int]:\n        def f(i: int) -> int:\n            a, b, c, m = variables[i]\n            return pow(pow(a, b, 10), c, m)\n        return [i for i in range(len(variables)) if f(i) == target]","date":"2024-07-30"}],"tagList":["数组","数学","模拟"],"level":"Medium"}},{"problemName":"2965.找出缺失和重复的数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2901-3000/2965.找出缺失和重复的数字.json","problemData":{"id":"3227","name":"2965.找出缺失和重复的数字","url":"https://leetcode.cn/problems/find-missing-and-repeated-values","desc":"任务是找出重复的数字a 和缺失的数字 b 。","solutions":[{"script":"python","time":54,"memory":16.86,"desc":"排序后遍历。","code":"class Solution:\n    def findMissingAndRepeatedValues(self, grid: List[List[int]]) -> List[int]:\n        arr = sorted(cell for row in grid for cell in row)\n        res = [0, 0]\n        for i in range(1, len(arr)):\n            if arr[i] == arr[i - 1]: res[0] = arr[i]\n            if arr[i] == arr[i - 1] + 2: res[1] = arr[i] - 1\n        if arr[i] != len(arr): res[1] = len(arr)\n        if arr[0] != 1: res[1] = 1\n        return res","date":"2024-05-31"}],"tagList":["数组","哈希表","数学","矩阵"],"level":"Easy"}},{"problemName":"2970.统计移除递增子数组的数目I.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2901-3000/2970.统计移除递增子数组的数目I.json","problemData":{"id":"3252","name":"2970.统计移除递增子数组的数目I","url":"https://leetcode.cn/problems/count-the-number-of-incremovable-subarrays-i","desc":"给你一个下标从 0 开始的 正 整数数组 nums 。如果 nums 的一个子数组满足：移除这个子数组后剩余元素 严格递增 ，那么我们称这个子数组为 移除递增 子数组。比方说，[5, 3, 4, 6, 7] 中的 [3, 4] 是一个移除递增子数组，因为移除该子数组后，[5, 3, 4, 6, 7] 变为 [5, 6, 7] ，是严格递增的。请你返回 nums 中 移除递增 子数组的总数目。","solutions":[{"script":"python","time":261,"memory":16.5,"desc":"遍历。","code":"class Solution:\n    def incremovableSubarrayCount(self, nums: List[int]) -> int:\n        def check(nums: List[int]) -> int:\n            for i in range(1, len(nums)):\n                if nums[i - 1] >= nums[i]: return 0\n            return 1\n        return sum(check(nums[0:j] + nums[i:]) for i in range(len(nums) + 1) for j in range(i))","date":"2024-07-10"}],"tagList":["数组","双指针","二分查找","枚举"],"level":"Easy"}},{"problemName":"2974.最小数字游戏.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2901-3000/2974.最小数字游戏.json","problemData":{"id":"3226","name":"2974.最小数字游戏","url":"https://leetcode.cn/problems/minimum-number-game","desc":"返回结果数组 arr 。","solutions":[{"script":"python","time":49,"memory":16.31,"desc":"遍历。","code":"class Solution:\n    def numberGame(self, nums: List[int]) -> List[int]:\n        arr = []\n        nums.sort()\n        i = 0\n        while i < len(nums):\n            arr.append(nums[i + 1])\n            arr.append(nums[i])\n            i += 2\n        return arr","date":"2024-07-12"}],"tagList":["数组","排序","模拟","堆（优先队列）"],"level":"Easy"}},{"problemName":"2981.找出出现至少三次的最长特殊子字符串I.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2901-3000/2981.找出出现至少三次的最长特殊子字符串I.json","problemData":{"id":"3267","name":"2981.找出出现至少三次的最长特殊子字符串I","url":"https://leetcode.cn/problems/find-longest-special-substring-that-occurs-thrice-i","desc":"返回在 s 中出现 至少三次 的 最长特殊子字符串 的长度，如果不存在出现至少三次的特殊子字符串，则返回 -1 。","solutions":[{"script":"python","time":57,"memory":16.49,"desc":"遍历。","code":"class Solution:\n    def maximumLength(self, s: str) -> int:\n        n = len(s)\n        i = 0\n        counter = Counter()\n        while i < n:\n            j = i\n            while i < n and s[j] == s[i]: i += 1\n            for cnt in range(1, i - j + 1):\n                counter[s[j] * cnt] += i - j - cnt + 1\n        return max([len(item[0]) for item in counter.items() if item[1] >= 3], default = -1)","date":"2024-05-29"}],"tagList":["哈希表","字符串","二分查找","计数","滑动窗口"],"level":"Medium"}},{"problemName":"2982.找出出现至少三次的最长特殊子字符串II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/2901-3000/2982.找出出现至少三次的最长特殊子字符串II.json","problemData":{"id":"3266","name":"2982.找出出现至少三次的最长特殊子字符串II","url":"https://leetcode.cn/problems/find-longest-special-substring-that-occurs-thrice-ii","desc":"返回在 s 中出现 至少三次 的 最长特殊子字符串 的长度，如果不存在出现至少三次的特殊子字符串，则返回 -1 。","solutions":[{"script":"python","time":461,"memory":18.88,"desc":"哈希存储所有相同字符的串的长度，判断同类串的最大长度。","code":"def get_longest(arr: Counter) -> int:\n        max_key = max(arr.keys())\n        if arr[max_key] >= 3:\n            return max_key\n        elif arr[max_key] * 2 + arr[max_key - 1] >= 3:\n            return max_key - 1\n        return max_key - 2\n    class Solution:\n        def maximumLength(self, s: str) -> int:\n            n = len(s)\n            map = defaultdict(Counter)\n            i = 0\n            while i < n:\n                j = i\n                while i < n and s[j] == s[i]: i += 1\n                map[s[j]][i - j] += 1\n            vmax = max([get_longest(arr) for arr in map.values()])\n            return vmax if vmax else -1","date":"2024-05-30"}],"tagList":["哈希表","字符串","二分查找","计数","滑动窗口"],"level":"Medium"}}]},{"dirName":"3001-3100","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\3001-3100","problems":[{"problemName":"3011.判断一个数组是否可以变为有序.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/3001-3100/3011.判断一个数组是否可以变为有序.json","problemData":{"id":"3291","name":"3011.判断一个数组是否可以变为有序","url":"https://leetcode.cn/problems/find-if-array-can-be-sorted","desc":"如果你可以使数组变有序，请你返回 true ，否则返回 false 。","solutions":[{"script":"python","time":50,"memory":16.34,"desc":"遍历。","code":"class Solution:\n    def canSortArray(self, nums: List[int]) -> bool:\n        get = lambda num: bin(num).count('1')\n        res = []\n        cnt1 = -1\n        arr = []\n        for num in nums:\n            if cnt1 != get(num):\n                cnt1 = get(num)\n                res += sorted(arr)\n                arr.clear()\n            arr.append(num)\n        res += sorted(arr)\n        return all(res[i] <= res[i + 1] for i in range(len(res) - 1))","date":"2024-07-13"}],"tagList":["位运算","数组","排序"],"level":"Medium"}},{"problemName":"3038.相同分数的最大操作数目I.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/3001-3100/3038.相同分数的最大操作数目I.json","problemData":{"id":"3320","name":"3038.相同分数的最大操作数目I","url":"https://leetcode.cn/problems/maximum-number-of-operations-with-the-same-score-i","desc":"在确保 所有操作分数相同 的前提下，请你求出 最多 能进行多少次操作。请你返回按照上述要求 最多 可以进行的操作次数。","solutions":[{"script":"python","time":33,"memory":16.42,"desc":"遍历。","code":"class Solution:\n    def maxOperations(self, nums: List[int]) -> int:\n        prev = nums[0] + nums[1]\n        res = 1\n        for i in range(3, len(nums), 2):\n            if nums[i] + nums[i - 1] == prev:\n                res += 1\n            else:\n                break\n        return res","date":"2024-06-07"}],"tagList":["数组","模拟"],"level":"Easy"}},{"problemName":"3040.相同分数的最大操作数目II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/3001-3100/3040.相同分数的最大操作数目II.json","problemData":{"id":"3318","name":"3040.相同分数的最大操作数目II","url":"https://leetcode.cn/problems/maximum-number-of-operations-with-the-same-score-ii","desc":"在确保 所有操作分数相同 的前提下，请你求出 最多 能进行多少次操作。请你返回按照上述要求 最多 可以进行的操作次数。","solutions":[{"script":"python","time":2313,"memory":377.62,"desc":"dfs。","code":"class Solution:\n    def maxOperations(self, nums: List[int]) -> int:\n        n = len(nums)\n        @cache\n        def dfs(l: int, r: int, score: int) -> int:\n            if r - l + 1 < 2: return 0\n            res = 0\n            if nums[l] + nums[l + 1] == score:\n                res = max(res, 1 + dfs(l + 2, r, score))\n            if nums[r] + nums[r - 1] == score:\n                res = max(res, 1 + dfs(l, r - 2, score))\n            if nums[l] + nums[r] == score:\n                res = max(res, 1 + dfs(l + 1, r - 1, score))\n            return res\n        return 1 + max(\n            dfs(2, n - 1, nums[0] + nums[1]),\n            dfs(0, n - 1 - 2, nums[n - 1] + nums[n - 2]),\n            dfs(1, n - 1 - 1, nums[0] + nums[n - 1])\n        )","date":"2024-06-08"}],"tagList":["记忆化搜索","数组","动态规划"],"level":"Medium"}},{"problemName":"3067.在带权树网络中统计可连接服务器对数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/3001-3100/3067.在带权树网络中统计可连接服务器对数目.json","problemData":{"id":"3326","name":"3067.在带权树网络中统计可连接服务器对数目","url":"https://leetcode.cn/problems/count-pairs-of-connectable-servers-in-a-weighted-tree-network","desc":"请你返回一个长度为 n 的整数数组 count ，其中 count[i] 表示通过服务器 i 可连接 的服务器对的 数目 。","solutions":[{"script":"python","time":797,"memory":18.23,"desc":"模拟。","code":"class Solution:\n    def countPairsOfConnectableServers(self, edges: List[List[int]], signalSpeed: int) -> List[int]:\n        nodes = [[] for _ in range(len(edges) + 1)]\n        for n1, n2, w in edges:\n            nodes[n1].append((n2, w))\n            nodes[n2].append((n1, w))\n        def dfs(cur: int, prev: int, sum: int) -> int:\n            res = 0\n            if sum % signalSpeed == 0: res += 1\n            for next, w in nodes[cur]:\n                if next != prev:\n                    res += dfs(next, cur, sum + w)\n            return res\n        def get_cnt(cur: int) -> int:\n            if len(nodes[cur]) == 1: return 0\n            arr = [dfs(next, cur, w) for next, w in nodes[cur]]\n            vsum = sum(arr)\n            res = 0\n            for v in arr:\n                vsum -= v\n                res += v * vsum\n            return res\n        return [get_cnt(i) for i in range(len(nodes))]","date":"2024-06-04"}],"tagList":["树","深度优先搜索","数组"],"level":"Medium"}},{"problemName":"3072.将元素分配到两个数组中II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/3001-3100/3072.将元素分配到两个数组中II.json","problemData":{"id":"3350","name":"3072.将元素分配到两个数组中II","url":"https://leetcode.cn/problems/distribute-elements-into-two-arrays-ii","desc":"返回整数数组 result 。","solutions":[{"script":"python","time":6345,"memory":33.59,"desc":"有序数组存储后模拟。","code":"from sortedcontainers import SortedList\n    class Solution:\n        def resultArray(self, nums: List[int]) -> List[int]:\n            res1 = [nums[0]]\n            sorted1 = SortedList(res1)\n            res2 = [nums[1]]\n            sorted2 = SortedList(res2)\n            for num in nums[2:]:\n                cnt1 = len(res1) - bisect_right(sorted1, num)\n                cnt2 = len(res2) - bisect_right(sorted2, num)\n                if cnt1 > cnt2 or (cnt1 == cnt2 and len(res1) <= len(res2)):\n                    res1.append(num)\n                    sorted1.add(num)\n                else:\n                    res2.append(num)\n                    sorted2.add(num)\n            return res1 + res2","date":"2024-06-05"}],"tagList":["树状数组","线段树","数组","模拟"],"level":"Hard"}},{"problemName":"3096.得到更多分数的最少关卡数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/3001-3100/3096.得到更多分数的最少关卡数目.json","problemData":{"id":"3355","name":"3096.得到更多分数的最少关卡数目","url":"https://leetcode.cn/problems/minimum-levels-to-gain-more-points","desc":"请你返回 Alice 获得比 Bob 更多的分数所需要完成的 最少 关卡数目，如果 无法 达成，那么返回 -1 。","solutions":[{"script":"python","time":189,"memory":20.4,"desc":"遍历。","code":"class Solution:\n    def minimumLevels(self, possible: List[int]) -> int:\n        bob = sum(v if v else -1 for v in possible)\n        alice = 0\n        for i in range(len(possible) - 1):\n            v = possible[i] if possible[i] else -1\n            alice += v\n            bob -= v\n            if alice > bob: return i + 1\n        return -1","date":"2024-07-19"}],"tagList":["数组","前缀和"],"level":"Medium"}},{"problemName":"3098.求出所有子序列的能量和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/3001-3100/3098.求出所有子序列的能量和.json","problemData":{"id":"3316","name":"3098.求出所有子序列的能量和","url":"https://leetcode.cn/problems/find-the-sum-of-subsequence-powers","desc":"请你返回 nums 中长度 等于 k 的 所有 子序列的 能量和 。","solutions":[{"script":"python","time":3583,"memory":759.11,"desc":"dfs。","code":"class Solution:\n    def sumOfPowers(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        nums.sort()\n        @cache\n        def dfs(idx: int, k: int, prev_idx: int, cur_min: int) -> int:\n            if k == 0: return cur_min\n            if idx == n: return 0\n            next_min = cur_min if prev_idx == -1 else min(cur_min, nums[idx] - nums[prev_idx])\n            return dfs(idx + 1, k, prev_idx, cur_min) + dfs(idx + 1, k - 1, idx, next_min)\n        return dfs(0, k, -1, inf) % (10 ** 9 + 7)","date":"2024-07-23"}],"tagList":["数组","动态规划","排序"],"level":"Hard"}},{"problemName":"3099.哈沙德数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/3001-3100/3099.哈沙德数.json","problemData":{"id":"3371","name":"3099.哈沙德数","url":"https://leetcode.cn/problems/harshad-number","desc":"如果一个整数能够被其各个数位上的数字之和整除，则称之为 哈沙德数（Harshad number）。给你一个整数 x 。如果 x 是 哈沙德数 ，则返回 x 各个数位上的数字之和，否则，返回 -1 。","solutions":[{"script":"python","time":40,"memory":16.41,"desc":"遍历。","code":"class Solution:\n    def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:\n        num = sum(int(c) for c in str(x))\n        return num if x % num == 0 else -1","date":"2024-07-03"}],"tagList":["数学"],"level":"Easy"}}]},{"dirName":"301-400","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\301-400","problems":[{"problemName":"301.删除无效的括号.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/301.删除无效的括号.json","problemData":{"id":"301","name":"301.删除无效的括号","url":"https://leetcode.cn/problems/remove-invalid-parentheses","desc":"给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。","solutions":[{"date":"2021-10-27","time":104,"memory":46.3,"script":"typescript","desc":"dfs。","code":"const map: Record<string, string[]> = {};\nfunction removeInvalidParentheses(s: string): string[] {\n  if (map[s]) return map[s];\n  const replaceStr = s.replace(new RegExp('[(]|[)]', 'g'), '');\n  const leftList: number[] = [];\n  const rightList: number[] = [];\n  const n = s.length;\n  for (let i = 0; i < n; i++) {\n    const ch = s[i];\n    if (ch === '(') leftList.push(i);\n    if (ch === ')') rightList.push(i);\n  }\n  if (leftList.length === 0 || rightList.length === 0) return [replaceStr];\n  let max = replaceStr.length;\n  const ans = new Set<string>(['', replaceStr]);\n  for (const left of leftList) {\n    let rightIdx = findRight(left);\n    for (let rlen = rightList.length; rightIdx < rlen; rightIdx++) {\n      const right = rightList[rightIdx];\n      for (const s0 of removeInvalidParentheses(s.substring(0, left))) {\n        for (const s1 of removeInvalidParentheses(s.substring(left + 1, right))) {\n          for (const s2 of removeInvalidParentheses(s.substring(right + 1))) {\n            const str = `${s0}(${s1})${s2}`;\n            max = Math.max(max, str.length);\n            ans.add(str);\n          }\n        }\n      }\n    }\n  }\n  return (map[s] = Array.from(ans).filter(v => v.length === max));\n  function findRight(leftIdx: number) {\n    let left = 0;\n    let right = rightList.length - 1;\n    if (rightList[right] < leftIdx) return Infinity;\n    while (left < right) {\n      const mid = (left + right) >> 1;\n      if (rightList[mid] >= leftIdx) right = mid;\n      else left = mid + 1;\n    }\n    return left;\n  }\n}"}],"tagList":["广度优先搜索","字符串","回溯"],"level":"Hard"}},{"problemName":"303.区域和检索-数组不可变.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/303.区域和检索-数组不可变.json","problemData":{"id":"303","name":"303.区域和检索-数组不可变","url":"https://leetcode.cn/problems/range-sum-query-immutable","desc":"给定一个整数数组 nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。","solutions":[{"date":"2021-03-01","time":224,"memory":44.7,"script":"typescript","desc":"for 循环计算。","code":"class NumArray {\n  constructor(private nums: number[]) {}\n  sumRange(i: number, j: number): number {\n    let sum = 0;\n    for (let index = i; index <= j; index++) sum += this.nums[index];\n    return sum;\n  }\n}"},{"date":"2021-03-01","time":120,"memory":45.6,"script":"typescript","desc":"利用前缀和进行快速计算。","code":"class NumArray {\n  private sums: number[] = [];\n  constructor(private nums: number[]) {\n    let sum = 0;\n    for (let i = 0, l = nums.length; i < l; i++) {\n      this.sums[i] = sum += nums[i];\n    }\n  }\n  sumRange(i: number, j: number): number {\n    return this.sums[j] - this.sums[i] + this.nums[i];\n  }\n}"},{"script":"python","time":50,"memory":20.48,"desc":"前缀和。","code":"class NumArray:\n    def __init__(self, nums: List[int]):\n        self.sums = [0]\n        for num in nums:\n            self.sums.append(self.sums[-1] + num)\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.sums[right + 1] - self.sums[left]","date":"2024-03-18"}],"tagList":["设计","数组","前缀和"],"level":"Easy"}},{"problemName":"304.二维区域和检索-矩阵不可变.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/304.二维区域和检索-矩阵不可变.json","problemData":{"id":"304","name":"304.二维区域和检索-矩阵不可变","url":"https://leetcode.cn/problems/range-sum-query-2d-immutable","desc":"给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。","solutions":[{"date":"2021-03-02","time":120,"memory":42.9,"script":"typescript","desc":"利用前缀和进行快速计算。","code":"class NumMatrix {\n  private sumMatrix: number[][] = [];\n  constructor(matrix: number[][]) {\n    const rowLen = matrix.length;\n    if (rowLen === 0) return;\n    const colLen = matrix[0].length;\n    for (let row = 0; row < rowLen; row++) {\n      const arr: number[] = [];\n      for (let col = 0; col < colLen; col++) {\n        const num = matrix[row][col];\n        if (col === 0 && row === 0) {\n          arr.push(num);\n        } else if (col === 0) {\n          arr.push(this.sumMatrix[row - 1][col] + num);\n        } else if (row === 0) {\n          arr.push(arr[col - 1] + num);\n        } else {\n          arr.push(\n            this.sumMatrix[row - 1][col] + arr[col - 1] + num - this.sumMatrix[row - 1][col - 1]\n          );\n        }\n      }\n      this.sumMatrix.push(arr);\n    }\n  }\n  sumRegion(row1: number, col1: number, row2: number, col2: number): number {\n    return (\n      this.sumMatrix[row2][col2] -\n      (col1 > 0 ? this.sumMatrix[row2][col1 - 1] : 0) -\n      (row1 > 0 ? this.sumMatrix[row1 - 1][col2] : 0) +\n      (row1 > 0 && col1 > 0 ? this.sumMatrix[row1 - 1][col1 - 1] : 0)\n    );\n  }\n}"}],"tagList":["设计","数组","矩阵","前缀和"],"level":"Medium"}},{"problemName":"306.累加数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/306.累加数.json","problemData":{"id":"306","name":"306.累加数","url":"https://leetcode.cn/problems/additive-number","desc":"给你一个只包含数字 '0'-'9' 的字符串，编写一个算法来判断给定输入是否是 累加数 。如果是，返回 true ；否则，返回 false 。","solutions":[{"date":"2022-01-10","time":4,"memory":6,"script":"cpp","desc":"dfs。","code":"class Solution {\n   public:\n    bool isAdditiveNumber(string num) {\n        string prev1 = \"\", prev2 = \"\";\n        for (int end1 = 0; end1 < num.size(); end1++) {\n            prev1 += num[end1];\n            prev2 = \"\";\n            for (int end2 = end1 + 1; end2 < num.size(); end2++) {\n                prev2 += num[end2];\n                if (dfs(num, end2 + 1, 1, prev1, prev2)) return 1;\n                if (end2 == end1 + 1 && num[end2] == '0') break;\n            }\n            if (end1 == 0 && num[end1] == '0') break;\n        }\n        return 0;\n    }\n    string add(string s1, string s2) {\n        string ans = \"\";\n        int i1 = s1.size() - 1, i2 = s2.size() - 1, tag = 0;\n        while (i1 >= 0 || i2 >= 0) {\n            int num = (i1 < 0 ? 0 : s1[i1--] - '0') +\n                      (i2 < 0 ? 0 : s2[i2--] - '0') + tag;\n            if (num >= 10) {\n                num -= 10;\n                tag = 1;\n            } else\n                tag = 0;\n            ans = to_string(num) + ans;\n        }\n        if (tag) ans = \"1\" + ans;\n        return ans;\n    }\n    int dfs(string& num, int start, int init, string prev1, string prev2) {\n        if (start == num.size()) return !init;\n        string next = \"\";\n        for (int i = start; i < num.size(); i++) {\n            next += num[i];\n            if (next == add(prev1, prev2))\n                return dfs(num, i + 1, 0, prev2, next);\n            if (i == start && num[i] == '0') break;\n        }\n        return 0;\n    }\n};"}],"tagList":["字符串","回溯"],"level":"Medium"}},{"problemName":"307.区域和检索-数组可修改.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/307.区域和检索-数组可修改.json","problemData":{"id":"307","name":"307.区域和检索-数组可修改","url":"https://leetcode.cn/problems/range-sum-query-mutable","desc":"给你一个数组 nums ，请你完成两类查询，其中一类查询要求更新数组下标对应的值，另一类查询要求返回数组中某个范围内元素的总和。","solutions":[{"date":"2021-11-14","time":532,"memory":70.5,"script":"typescript","desc":"树状数组。","code":"class FenwickTree {\n  private arr: number[];\n  constructor(private n: number) {\n    this.arr = new Array(n + 1).fill(0);\n  }\n  add(idx: number, num: number): void {\n    while (idx <= this.n) {\n      this.arr[idx] += num;\n      idx += this.lowbit(idx);\n    }\n  }\n  at(idx: number): number {\n    return this.query(idx) - this.query(idx - 1);\n  }\n  query(idx: number): number {\n    let sum = 0;\n    while (idx) {\n      sum += this.arr[idx];\n      idx -= this.lowbit(idx);\n    }\n    return sum;\n  }\n  private lowbit(num: number) {\n    return num & -num;\n  }\n}\nclass NumArray {\n  private tree: FenwickTree;\n  constructor(nums: number[]) {\n    this.tree = new FenwickTree(nums.length);\n    for (let i = 0; i < nums.length; i++) {\n      this.tree.add(i + 1, nums[i]);\n    }\n  }\n  update(index: number, val: number): void {\n    this.tree.add(index + 1, val - this.tree.at(index + 1));\n  }\n  sumRange(left: number, right: number): number {\n    return this.tree.query(right + 1) - this.tree.query(left);\n  }\n}"},{"date":"2022-04-04","time":372,"memory":146.4,"script":"cpp","desc":"树状数组。","code":"class FenwickTree {\n   public:\n    int n;\n    vector<int> arr;\n    FenwickTree(int n) : n(n + 1), arr(vector<int>(n + 1, 0)) {}\n    int lowbit(int num) { return num & -num; }\n    void add(int idx, int num) {\n        idx += 1;\n        while (idx < n) {\n            arr[idx] += num;\n            idx += lowbit(idx);\n        }\n    }\n    int at(int idx) { return query(idx) - query(idx - 1); }\n    int query(int idx) {\n        idx += 1;\n        int num = 0;\n        while (idx) {\n            num += arr[idx];\n            idx -= lowbit(idx);\n        }\n        return num;\n    }\n};\nclass NumArray {\n   public:\n    FenwickTree tree;\n    NumArray(vector<int>& nums) : tree(nums.size()) {\n        for (int i = 0; i < nums.size(); i++) {\n            tree.add(i, nums[i]);\n        }\n    }\n    void update(int index, int val) { tree.add(index, val - tree.at(index)); }\n    int sumRange(int left, int right) {\n        return tree.query(right) - tree.query(left - 1);\n    }\n};"},{"script":"python","time":1216,"memory":33.27,"desc":"树状数组。","code":"class FenwickTree:\n    def __init__(self, n: int):\n        self.n = n\n        self.arr = [0] * (n + 1)\n\n    def add(self, idx: int, num: int):\n        while idx <= self.n:\n            self.arr[idx] += num\n            idx += self.lowbit(idx)\n    \n    def query(self, idx: int) -> int:\n        sum = 0\n        while idx > 0:\n            sum += self.arr[idx]\n            idx -= self.lowbit(idx)\n        return sum\n    \n    def at(self, idx: int) -> int:\n        return self.query(idx) - self.query(idx - 1)\n\n    def range(self, left: int, right: int) -> int:\n        return self.query(right) - self.query(left - 1)\n\n    def lowbit(self, num: int) -> int:\n        return num & -num\n\nclass NumArray:\n\n    def __init__(self, nums: List[int]):\n        self.tree = FenwickTree(len(nums))\n        self.nums = nums\n        for i, num in enumerate(nums): self.tree.add(i + 1, num)\n\n    def update(self, index: int, val: int) -> None:\n        self.tree.add(index + 1, val - self.nums[index])\n        self.nums[index] = val\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.tree.range(left + 1, right + 1)","date":"2023-11-13"}],"tagList":["设计","树状数组","线段树","数组"],"level":"Medium"}},{"problemName":"309.买卖股票的最佳时机含冷冻期.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/309.买卖股票的最佳时机含冷冻期.json","problemData":{"id":"309","name":"309.买卖股票的最佳时机含冷冻期","url":"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown","desc":"给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格，设计一个算法计算出最大利润。","solutions":[{"date":"2020-07-11","time":84,"memory":36.5,"script":"typescript","desc":"我们目前持有一支股票，对应的「累计最大收益」记为 f[i][0]f[i][0]；我们目前不持有任何股票，并且处于冷冻期中，对应的「累计最大收益」记为 f[i][1]f[i][1]；我们目前不持有任何股票，并且不处于冷冻期中，对应的「累计最大收益」记为 f[i][2]f[i][2]。","code":"function maxProfit(prices: number[]): number {\n  const len = prices.length;\n  if (len === 0) return 0;\n  const dp = new Array(len).fill(0).map(_ => new Array(3).fill(0));\n  dp[0][0] = -prices[0];\n  for (let i = 1; i < len; i++) {\n    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][2] - prices[i]);\n    dp[i][1] = dp[i - 1][0] + prices[i];\n    dp[i][2] = Math.max(dp[i - 1][1], dp[i - 1][2]);\n  }\n  return Math.max(dp[len - 1][1], dp[len - 1][2]);\n}"},{"script":"python","time":3408,"memory":560.76,"desc":"记忆化递归。","code":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        n = len(prices)\n        @cache\n        def dfs(idx: int, cooldown: bool, cur: int):\n            if idx == n: return 0\n            res = dfs(idx + 1, False, cur)\n            if not cooldown:\n                if cur != -inf: res = max(res, dfs(idx + 1, True, -inf) + prices[idx] - cur)\n                else: res = max(res, dfs(idx + 1, False, prices[idx]))\n            return res\n        return dfs(0, False, -inf)\n        \n","date":"2023-10-05"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"310.最小高度树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/310.最小高度树.json","problemData":{"id":"310","name":"310.最小高度树","url":"https://leetcode.cn/problems/minimum-height-trees","desc":"请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。","solutions":[{"date":"2022-03-14","time":180,"memory":77.6,"script":"cpp","desc":"从所有叶子节点开始遍历，由外到内。","code":"class Solution {\n   public:\n    struct node {\n        int idx, cnt;\n        unordered_set<int> chilren;\n    };\n    vector<int> findMinHeightTrees(int n, vector<vector<int>> &edges) {\n        if (n == 1) return vector(1, 0);\n        vector<node> list(n);\n        for (int i = 0; i < n; i++) {\n            list[i].idx = i;\n            list[i].cnt = 0;\n        }\n        for (auto &edge : edges) {\n            int n1 = edge[0], n2 = edge[1];\n            list[n1].cnt++;\n            list[n2].cnt++;\n            list[n1].chilren.insert(n2);\n            list[n2].chilren.insert(n1);\n        }\n        queue<int> q;\n        for (int i = 0; i < n; i++) {\n            if (list[i].cnt == 1) q.push(i);\n        }\n        vector<int> ans;\n        while (q.size()) {\n            ans.clear();\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                int node = q.front();\n                q.pop();\n                ans.push_back(node);\n                list[node].cnt--;\n                for (auto &child : list[node].chilren) {\n                    list[child].cnt--;\n                    if (list[child].cnt == 1) q.push(child);\n                }\n            }\n        }\n        return ans;\n    }\n};"},{"date":"2022-04-06","time":172,"memory":77.7,"script":"cpp","desc":"从外向内遍历。","code":"class Solution {\n   public:\n    struct node {\n        int val, cnt;\n        unordered_set<int> children;\n    };\n    vector<int> findMinHeightTrees(int n, vector<vector<int>>& edges) {\n        if (n == 1) return {0};\n        vector<node> list(n);\n        for (int i = 0; i < n; i++) {\n            list[i].val = i;\n            list[i].cnt = 0;\n        }\n        for (auto& edge : edges) {\n            int n0 = edge[0], n1 = edge[1];\n            list[n0].children.insert(n1);\n            list[n1].children.insert(n0);\n            list[n0].cnt++;\n            list[n1].cnt++;\n        }\n        queue<int> q;\n        for (auto& node : list) {\n            if (node.cnt == 1) q.push(node.val);\n        }\n        vector<int> ans;\n        int size = q.size();\n        while (q.size()) {\n            int idx = q.front();\n            ans.push_back(idx);\n            q.pop();\n            list[idx].cnt--;\n            for (auto& child : list[idx].children) {\n                if (--list[child].cnt != 1) continue;\n                q.push(child);\n            }\n            if (--size == 0) {\n                size = q.size();\n                if (size) ans.clear();\n            }\n        }\n        return ans;\n    }\n};"},{"script":"python","time":295,"memory":67.8,"desc":"dfs。","code":"class Solution:\n    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:\n        if n == 1: return [0]\n        if n == 2: return [0, 1]\n        nodes = [[] for _ in range(n)]\n        for n1, n2 in edges:\n            nodes[n1].append(n2)\n            nodes[n2].append(n1)\n        @cache\n        def dfs(node: int, parent: int) -> int:\n            return 1 + max(dfs(child, node) if child != parent else 0 for child in nodes[node])\n        ans_val = inf\n        ans_arr = []\n        for node in range(n):\n            if len(nodes[node]) == 1: continue\n            res = dfs(node, -1)\n            if res <= ans_val:\n                if res < ans_val: ans_arr.clear()\n                ans_val = res\n                ans_arr.append(node)\n        return ans_arr","date":"2024-03-17"}],"tagList":["深度优先搜索","广度优先搜索","图","拓扑排序"],"level":"Medium"}},{"problemName":"312.戳气球.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/312.戳气球.json","problemData":{"id":"312","name":"312.戳气球","url":"https://leetcode.cn/problems/burst-balloons","desc":"有 n 个气球，编号为 0 到 n-1，每个气球上都标有一个数字，这些数字存在数组  nums  中。现在要求你戳破所有的气球。如果你戳破气球 i ，就可以获得  nums[left] _ nums[i] _ nums[right]  个硬币。  这里的  left  和  right  代表和  i  相邻的两个气球的序号。注意当你戳破了气球 i 后，气球  left  和气球  right  就变成了相邻的气球。,求所能获得硬币的最大数量。","solutions":[{"date":"2020-07-25","time":124,"memory":40,"script":"typescript","desc":"dp[i][j] = 在 i 到 j 中的最大值。dp[i][j] = dp[i]*dp[k]*dp[j] + dp[i][k] + dp[k][j],k 为遍历。","code":"function maxCoins(nums: number[]): number {\n  const len = nums.length;\n  const val = [1, ...nums, 1];\n  const dp = new Array(len + 2).fill(0).map(_ => new Array(len + 2).fill(-1));\n  return solve(0, len + 1);\n  function solve(left: number, right: number): number {\n    if (left >= right - 1) return 0;\n    if (dp[left][right] !== -1) return dp[left][right];\n    for (let i = left + 1; i < right; i++) {\n      let sum = val[left] * val[i] * val[right];\n      sum += solve(left, i) + solve(i, right);\n      dp[left][right] = Math.max(dp[left][right], sum);\n    }\n    return dp[left][right];\n  }\n}"},{"date":"2020-07-25","time":104,"memory":40.2,"script":"typescript","desc":"根据题解 1 改为动态规划。","code":"function maxCoins(nums: number[]): number {\n  const len = nums.length;\n  const val = [1, ...nums, 1];\n  const dp = new Array(len + 2).fill(0).map(_ => new Array(len + 2).fill(0));\n  for (let i = len - 1; i >= 0; i--) {\n    for (let j = i + 2; j <= len + 1; j++) {\n      for (let k = i + 1; k < j; k++) {\n        const sum = val[i] * val[k] * val[j] + dp[i][k] + dp[k][j];\n        dp[i][j] = Math.max(dp[i][j], sum);\n      }\n    }\n  }\n  return dp[0][len + 1];\n}"},{"script":"python","time":3651,"memory":33,"desc":"dfs, 从下往上，刚开始没有气球，逐渐增加气球。","code":"class Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        nums = [1] + nums + [1]\n        @cache\n        def dfs(l: int, r: int) -> int:\n            return max((nums[m] * nums[l] * nums[r] + dfs(l, m) + dfs(m, r) for m in range(l + 1, r)), default = 0)\n        return dfs(0, len(nums) - 1)","date":"2024-06-09"}],"tagList":["数组","动态规划"],"level":"Hard"}},{"problemName":"315.计算右侧小于当前元素的个数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/315.计算右侧小于当前元素的个数.json","problemData":{"id":"315","name":"315.计算右侧小于当前元素的个数","url":"https://leetcode.cn/problems/count-of-smaller-numbers-after-self","desc":"给定一个整数数组 nums，按要求返回一个新数组  counts。数组 counts 有该性质： counts[i] 的值是   nums[i] 右侧小于  nums[i] 的元素的数量。","solutions":[{"date":"2020-07-11","time":828,"memory":38.8,"script":"typescript","desc":"双重循环。","code":"function countSmaller(nums: number[]): number[] {\n  const len = nums.length;\n  const res: number[] = [];\n  for (let i = 0; i < len; i++) {\n    let c = 0;\n    const num = nums[i];\n    for (let j = i + 1; j < len; j++) {\n      if (num > nums[j]) cpp;\n    }\n    res[i] = c;\n  }\n  return res;\n}"},{"date":"2021-05-14","time":368,"memory":64.5,"script":"typescript","desc":"分治，统计两部分中下标排序时计算。","code":"function countSmaller(nums: number[]): number[] {\n  const len = nums.length;\n  if (len === 0) return [];\n  const list = new Array(len).fill(0).map((_, i) => i);\n  const ans = new Array(len).fill(0);\n  const mergeSort = (left: number, right: number): void => {\n    if (left === right) return;\n    const mid = (left + right) >> 1;\n    mergeSort(left, mid);\n    mergeSort(mid + 1, right);\n    const temp = list.slice(left, mid + 1);\n    let p1 = 0,\n      end1 = mid - left,\n      p2 = mid + 1,\n      i = left;\n    while (p1 <= end1) {\n      if (p2 > right || nums[temp[p1]] <= nums[list[p2]]) {\n        const index = temp[p1++];\n        list[i++] = index;\n        ans[index] += p2 - mid - 1;\n      } else {\n        list[i++] = list[p2++];\n      }\n    }\n  };\n  mergeSort(0, len - 1);\n  return ans;\n}"}],"tagList":["树状数组","线段树","数组","二分查找","分治","有序集合","归并排序"],"level":"Hard"}},{"problemName":"316.去除重复字母.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/316.去除重复字母.json","problemData":{"id":"316","name":"316.去除重复字母","url":"https://leetcode.cn/problems/remove-duplicate-letters","desc":"给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。","solutions":[{"date":"2020-12-20","time":116,"memory":41.9,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/remove-duplicate-letters/solution/qu-chu-zhong-fu-zi-mu-by-leetcode-soluti-vuso/)。","code":"function removeDuplicateLetters(s: string): string {\n  const vis = new Array(26).fill(0);\n  const num = _.countBy(s);\n  const getCode = (c: string) => c.codePointAt(0)! - 'a'.codePointAt(0)!;\n  const stack = new Array();\n  let c: string;\n  for (let i = 0; i < s.length; i++) {\n    const ch = s[i];\n    if (!vis[getCode(ch)]) {\n      while (stack.length > 0 && (c = stack[stack.length - 1]) > ch) {\n        if (num[c] > 0) {\n          vis[getCode(c)] = 0;\n          stack.pop();\n        } else {\n          break;\n        }\n      }\n      vis[getCode(ch)] = 1;\n      stack.push(ch);\n    }\n    num[ch]--;\n  }\n  return stack.join('');\n}"},{"date":"2021-07-30","time":92,"memory":39.9,"script":"typescript","desc":"单调栈。","code":"function removeDuplicateLetters(s: string): string {\n  const map: Record<string, number> = {};\n  for (const c of s) map[c] = (map[c] ?? 0) + 1;\n  const stack: string[] = [];\n  const set = new Set<string>();\n  const toNum = (c: string) => c.codePointAt(0)! - 'a'.codePointAt(0)!;\n  for (const c of s) {\n    if (set.has(c)) {\n      map[c]--;\n      continue;\n    }\n    while (\n      stack.length &&\n      toNum(stack[stack.length - 1]) > toNum(c) &&\n      map[stack[stack.length - 1]] > 0\n    ) {\n      set.delete(stack.pop()!);\n    }\n    stack.push(c);\n    set.add(c);\n    map[c]--;\n  }\n  return stack.join('');\n}"}],"tagList":["栈","贪心","字符串","单调栈"],"level":"Medium"}},{"problemName":"318.最大单词长度乘积.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/318.最大单词长度乘积.json","problemData":{"id":"318","name":"318.最大单词长度乘积","url":"https://leetcode.cn/problems/maximum-product-of-word-lengths","desc":"给定一个字符串数组  words，找到  length(word[i]) \\* length(word[j])  的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。","solutions":[{"date":"2021-07-24","time":140,"memory":40.2,"script":"typescript","desc":"利用二进制从储存每个单词的哈希值。","code":"function maxProduct(words: string[]): number {\n  const map: Record<string, number> = {};\n  for (const word of words) {\n    let v = 0;\n    for (let i = 0, l = word.length; i < l; i++) {\n      v |= 1 << word.codePointAt(i)!;\n    }\n    map[word] = v;\n  }\n  let ans = 0;\n  for (let i = 0; i < words.length; i++) {\n    for (let j = i + 1; j < words.length; j++) {\n      if ((map[words[i]] & map[words[j]]) === 0) {\n        ans = Math.max(ans, words[i].length * words[j].length);\n      }\n    }\n  }\n  return ans;\n}"},{"date":"2021-11-17","time":96,"memory":41.5,"script":"typescript","desc":"位运算统计每个词出现的字母。","code":"function maxProduct(words: string[]): number {\n  const n = words.length;\n  const bit_words = new Array(n).fill(0);\n  for (let i = 0; i < n; i++) {\n    const word = words[i];\n    for (let pos = 0, l = word.length; pos < l; pos++) {\n      bit_words[i] |= 1 << (word.codePointAt(pos)! - 97);\n    }\n  }\n  let ans = 0;\n  for (let i = 0; i < n; i++) {\n    const len1 = words[i].length;\n    const bit1 = bit_words[i];\n    for (let j = i + 1; j < n; j++) {\n      const len2 = words[j].length;\n      const bit2 = bit_words[j];\n      if (bit1 & bit2) continue;\n      ans = Math.max(ans, len1 * len2);\n    }\n  }\n  return ans;\n}"},{"date":"2021-11-17","time":32,"memory":7.6,"script":"c","desc":"位运算统计每个词出现的字母。","code":"void formatWord(char *word, int *bit, int *size){\n    for(int i = 0; word[i] != '\\0'; i++){\n        *bit |= 1 << (word[i] - 'a');\n        *size += 1;\n    }\n}\nint maxProduct(char ** words, int wordsSize){\n    int word_bit[wordsSize], word_size[wordsSize];\n    for (int i = 0; i < wordsSize; i++) word_bit[i] = 0, word_size[i] = 0;\n    for (int i = 0; i < wordsSize; i++) {\n        char *word = words[i];\n        formatWord(word, &word_bit[i], &word_size[i]);\n    }\n    int ans = 0;\n    for (int i = 0; i < wordsSize; i++) {\n        for (int j = 0; j < wordsSize; j++) {\n            if (word_bit[i] & word_bit[j]) continue;\n            int len = word_size[i] * word_size[j];\n            ans = ans < len ? len : ans;\n        }\n    }\n    return ans;\n}"},{"date":"2021-12-24","time":364,"memory":20.4,"script":"cpp","desc":"用二进制存储每个字符串存在的字符，两个字符串值与运算为 0 说明无重复。","code":"class Solution {\n   public:\n    int s2i(string str) {\n        int ans = 0;\n        for (auto &ch : str) ans |= 1 << (ch - 'a');\n        return ans;\n    }\n    int maxProduct(vector<string> &words) {\n        unordered_map<string, int> mmap;\n        for (auto &word : words) mmap[word] = s2i(word);\n        int ans = 0;\n        for (int i = 0; i < words.size(); i++) {\n            for (int j = 0; j < i; j++) {\n                if (mmap[words[i]] & mmap[words[j]]) continue;\n                ans = max(ans, (int)(words[i].size() * words[j].size()));\n            }\n        }\n        return ans;\n    }\n};"},{"script":"python","time":844,"memory":18.57,"desc":"哈希存储。","code":"class Solution:\n    def maxProduct(self, words: List[str]) -> int:\n        m = { word: reduce(lambda n, c: n | 1 << ord(c), word, 0) for word in words}\n        return max(len(word1) * len(word2) if m[word1] & m[word2] == 0 else 0 for word1 in words for word2 in words)","date":"2023-11-06"}],"tagList":["位运算","数组","字符串"],"level":"Medium"}},{"problemName":"319.灯泡开关.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/319.灯泡开关.json","problemData":{"id":"319","name":"319.灯泡开关","url":"https://leetcode.cn/problems/bulb-switcher","desc":"找出并返回 n 轮后有多少个亮着的灯泡。","solutions":[{"date":"2021-11-15","time":76,"memory":39.4,"script":"typescript","desc":"求出完全平方数即亮灯个数。","code":"function bulbSwitch(n: number): number {\n  return Math.floor(Math.sqrt(n + 0.5));\n}"}],"tagList":["脑筋急转弯","数学"],"level":"Medium"}},{"problemName":"321.拼接最大数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/321.拼接最大数.json","problemData":{"id":"321","name":"321.拼接最大数","url":"https://leetcode.cn/problems/create-maximum-number","desc":"给定长度分别为  m  和  n  的两个数组，其元素由  0-9  构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k <= m + n)  个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。求满足该条件的最大数。结果返回一个表示该最大数的长度为  k  的数组。","solutions":[{"date":"2020-12-02","time":228,"memory":48.7,"script":"typescript","desc":"对于每个单调栈进行遍历。","code":"function maxNumber(nums1: number[], nums2: number[], k: number): number[] {\n  const ans: number[][] = [];\n  const pushArr = (nums: number[]) => {\n    const len = nums.length;\n    const arrLen = ans.length;\n    const elLen = ans[0]?.length;\n    if (arrLen === 0 || elLen === len) ans.push(nums);\n    else if (elLen < len) {\n      ans.length = 0;\n      ans.push(nums);\n    }\n  };\n  const getCache = (nums: number[], k: number): number[] => {\n    const len = nums.length;\n    const stack: number[] = [];\n    if (k === 0) return stack;\n    k = len - k;\n    if (k <= 0) return nums;\n    for (const num of nums) {\n      if (stack.length === 0) {\n        stack.push(num);\n      } else {\n        let top = stack[stack.length - 1];\n        while (num > top && k !== 0) {\n          stack.pop();\n          k--;\n          top = stack[stack.length - 1];\n        }\n        stack.push(num);\n      }\n    }\n    while (k-- > 0) stack.pop();\n    return stack;\n  };\n  for (let i = 0; i <= k; i++) {\n    const stack1 = getCache(nums1, i);\n    const stack2 = getCache(nums2, k - i);\n    const len1 = stack1.length;\n    const len2 = stack2.length;\n    if (len1 === 0) pushArr(stack2);\n    else if (len2 === 0) pushArr(stack1);\n    else {\n      const compare = (p1: number, p2: number): boolean =>\n        p2 >= len2\n          ? true\n          : p1 >= len1\n          ? false\n          : stack1[p1] > stack2[p2]\n          ? true\n          : stack1[p1] < stack2[p2]\n          ? false\n          : compare(p1 + 1, p2 + 1);\n      const arr: number[] = [];\n      let i1 = 0;\n      let i2 = 0;\n      while (i1 !== len1 || i2 !== len2) {\n        const num1 = stack1[i1];\n        const num2 = stack2[i2];\n        if (compare(i1, i2)) {\n          arr.push(num1);\n          i1++;\n        } else {\n          arr.push(num2);\n          i2++;\n        }\n      }\n      pushArr(arr);\n    }\n  }\n  const len = ans[0].length;\n  return ans.sort((nums1: number[], nums2: number[]) => {\n    let i1 = 0;\n    let i2 = 0;\n    while (i1 < len && i2 < len) {\n      const n1 = nums1[i1];\n      const n2 = nums2[i2];\n      if (n1 > n2) {\n        return -1;\n      } else if (n1 < n2) {\n        return 1;\n      } else {\n        i1++;\n        i2++;\n      }\n    }\n    return 0;\n  })[0];\n}"}],"tagList":["栈","贪心","数组","双指针","单调栈"],"level":"Hard"}},{"problemName":"322.零钱兑换.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/322.零钱兑换.json","problemData":{"id":"322","name":"322.零钱兑换","url":"https://leetcode.cn/problems/coin-change","desc":"给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回  -1。","solutions":[{"date":"2020-05-09","time":80,"memory":41,"script":"javascript","desc":"递推，每一项等于最小的前一项+1。","code":"/**\n * @param {number[]} coins\n * @param {number} amount\n * @return {number}\n */\nvar coinChange = function (coins, amount) {\n  if (coins.length === 0) return -1;\n  const minCoins = [];\n  minCoins[0] = 0;\n  let num, min;\n  for (let i = 1; i <= amount; i++) {\n    min = Infinity;\n    for (const coin of coins) {\n      if (i >= coin && min > (num = minCoins[i - coin])) {\n        min = num;\n      }\n    }\n    minCoins[i] = min + 1;\n  }\n  return minCoins[amount] === Infinity ? -1 : minCoins[amount];\n};"},{"date":"2021-09-13","time":1256,"memory":43.6,"script":"typescript","desc":"动态规划。","code":"function coinChange(coins: number[], amount: number): number {\n  if (amount === 0) return 0;\n  coins = coins.sort((a, b) => a - b).filter(v => v <= amount);\n  const dp = new Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n  coins.forEach(coin => (dp[coin] = 1));\n  for (let i = 1; i <= amount; i++) {\n    if (dp[i] !== Infinity) continue;\n    for (const coin of coins) {\n      if (i < coin) continue;\n      const maxCount = ~~(i / coin);\n      for (let c = maxCount; c >= 0; c--) {\n        dp[i] = Math.min(dp[i], dp[i - coin * c] + c);\n      }\n    }\n  }\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}"},{"date":"2021-09-13","time":104,"memory":43.5,"script":"javascript","desc":"动态规划。","code":"function coinChange(coins: number[], amount: number): number {\n  coins.sort((a, b) => a - b);\n  const dp = new Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n  for (let i = 1; i <= amount; i++) {\n    for (const coin of coins) {\n      if (coin > i) break;\n      dp[i] = Math.min(dp[i], dp[i - coin] + 1);\n    }\n  }\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}"},{"script":"python","time":803,"memory":16.73,"desc":"dp记录当前金额下的最小硬币数。","code":"class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        coins.sort()\n        dp = [inf] * (amount + 1)\n        dp[0] = 0\n        for cur in range(amount + 1):\n            for coin in coins:\n                if coin > cur: break\n                dp[cur] = min(dp[cur], dp[cur - coin] + 1)\n        return dp[amount] if dp[amount] != inf else -1","date":"2024-03-24"}],"tagList":["广度优先搜索","数组","动态规划"],"level":"Medium"}},{"problemName":"324.摆动排序II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/324.摆动排序II.json","problemData":{"id":"324","name":"324.摆动排序II","url":"https://leetcode.cn/problems/wiggle-sort-ii","desc":"汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1 。","solutions":[{"date":"2022-07-02","time":92,"memory":15.8,"script":"cpp","desc":"dp[i] = 当 i 为最后一个加油站时，最远能跑的公里数。","code":"class Solution {\n   public:\n    int minRefuelStops(int target, int startFuel,\n                       vector<vector<int>>& stations) {\n        int n = stations.size();\n        vector<long> dp(n + 1);\n        dp[0] = startFuel;\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j >= 0; j--) {\n                if (dp[j] >= stations[i][0]) {\n                    dp[j + 1] = max(dp[j + 1], dp[j] + stations[i][1]);\n                }\n            }\n        }\n        for (int i = 0; i <= n; i++) {\n            if (dp[i] >= target) return i;\n        }\n        return -1;\n    }\n};"}],"tagList":["贪心","数组","分治","快速选择","排序"],"level":"Medium"}},{"problemName":"326.3的幂.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/326.3的幂.json","problemData":{"id":"326","name":"326.3的幂","url":"https://leetcode.cn/problems/power-of-three","desc":"给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。","solutions":[{"date":"2021-09-23","time":236,"memory":47.6,"script":"javascript","desc":"循环。","code":"function isPowerOfThree(n: number): boolean {\n  let i = 0;\n  while (3 ** i < n) i++;\n  return 3 ** i === n;\n}"},{"date":"2021-09-23","time":224,"memory":47.6,"script":"javascript","desc":"利用最大值看是否模为 0。","code":"function isPowerOfThree(n: number): boolean {\n  return n > 0 && 3 ** 19 % n == 0;\n}"}],"tagList":["递归","数学"],"level":"Easy"}},{"problemName":"327.区间和的个数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/327.区间和的个数.json","problemData":{"id":"327","name":"327.区间和的个数","url":"https://leetcode.cn/problems/count-of-range-sum","desc":"给定一个整数数组 nums，返回区间和在 [lower, upper] 之间的个数，包含 lower 和 upper。","solutions":[{"date":"2020-11-07","time":280,"memory":40.4,"script":"typescript","desc":"暴力法循环所有数，此题有多种解法,[参考链接](https://leetcode-cn.com/problems/count-of-range-sum/solution/qu-jian-he-de-ge-shu-by-leetcode-solution/)。","code":"function countRangeSum(nums: number[], lower: number, upper: number): number {\n  const len = nums.length;\n  let c = 0;\n  for (let i = 0; i < len; i++) {\n    let sum = 0;\n    for (let j = i; j < len; j++) {\n      sum += nums[j];\n      if (lower <= sum && sum <= upper) cpp;\n    }\n  }\n  return c;\n}"},{"date":"2021-05-14","time":160,"memory":50.7,"script":"typescript","desc":"分治，统计两部分中的符合结果的前缀和。","code":"function countRangeSum(nums: number[], lower: number, upper: number): number {\n  const len = nums.length;\n  if (len === 0) return 0;\n  const prefixSumList = [0];\n  for (let i = 0; i < len; i++) prefixSumList[i + 1] = prefixSumList[i] + nums[i];\n  const count = (left: number, mid: number, right: number) => {\n    let i1 = left,\n      i2 = left,\n      ans = 0;\n    for (let i = mid + 1; i <= right; i++) {\n      const sum = prefixSumList[i];\n      const l = sum - upper;\n      const r = sum - lower;\n      while (i1 <= mid && prefixSumList[i1] < l) i1++;\n      while (i2 <= mid && prefixSumList[i2] <= r) i2++;\n      ans += i2 - i1;\n    }\n    return ans;\n  };\n  const mergeSort = (left: number, right: number): number => {\n    if (left === right) return 0;\n    const mid = (left + right) >> 1;\n    const ans = mergeSort(left, mid) + mergeSort(mid + 1, right) + count(left, mid, right);\n    const temp = prefixSumList.slice(left, mid + 1);\n    let p1 = 0,\n      end1 = mid - left,\n      p2 = mid + 1,\n      i = left;\n    while (p1 <= end1) {\n      if (p2 > right || temp[p1] <= prefixSumList[p2]) prefixSumList[i++] = temp[p1++];\n      else prefixSumList[i++] = prefixSumList[p2++];\n    }\n    return ans;\n  };\n  return mergeSort(0, len);\n}"}],"tagList":["树状数组","线段树","数组","二分查找","分治","有序集合","归并排序"],"level":"Hard"}},{"problemName":"328.奇偶链表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/328.奇偶链表.json","problemData":{"id":"328","name":"328.奇偶链表","url":"https://leetcode.cn/problems/odd-even-linked-list","desc":"给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。","solutions":[{"date":"2020-11-13","time":104,"memory":42,"script":"typescript","desc":"存入数组再一次赋值 next。","code":"function oddEvenList(head: ListNode | null): ListNode | null {\n  if (head === null) return null;\n  const cache: ListNode[] = [];\n  let temp: ListNode | null = head;\n  const load = () => {\n    while (temp !== null) {\n      cache.push(temp);\n      temp = temp.next?.next ? temp.next.next : null;\n    }\n  };\n  load();\n  temp = head.next;\n  load();\n  cache.forEach((v, i, arr) => (v.next = i === arr.length - 1 ? null : arr[i + 1]));\n  return head;\n}"},{"date":"2020-11-13","time":108,"memory":41.5,"script":"typescript","desc":"遍历 odd，even。","code":"function oddEvenList(head: ListNode | null): ListNode | null {\n  if (head === null) return null;\n  let odd: ListNode | null = head;\n  let even: ListNode | null = head.next;\n  const evenHead = head.next;\n  while (even !== null && even.next !== null) {\n    odd.next = even.next;\n    odd = odd.next;\n    even.next = odd.next;\n    even = even.next;\n  }\n  odd.next = evenHead;\n  return head;\n}"}],"tagList":["链表"],"level":"Medium"}},{"problemName":"329.矩阵中的最长递增路径.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/329.矩阵中的最长递增路径.json","problemData":{"id":"329","name":"329.矩阵中的最长递增路径","url":"https://leetcode.cn/problems/longest-increasing-path-in-a-matrix","desc":"给定一个整数矩阵，找出最长递增路径的长度。","solutions":[{"date":"2020-07-26","time":232,"memory":47.1,"script":"typescript","desc":"记忆化遍历。","code":"function longestIncreasingPath(matrix: number[][]): number {\n  const rowLen = matrix.length;\n  if (rowLen === 0) return 0;\n  const colLen = matrix[0].length;\n  const cache = new Map<string, number>();\n  const format = (row: number, col: number) => `${row}:${col}`;\n  let maxNum = 0;\n  const setMax = (num: number) => (maxNum = Math.max(maxNum, num));\n  for (let i = 0; i < rowLen; i++) for (let j = 0; j < colLen; j++) setMax(each(i, j));\n  return maxNum;\n  function each(row: number, col: number, set = new Set<string>()): number {\n    const num = matrix[row][col];\n    const name = format(row, col);\n    if (cache.has(name)) return cache.get(name)!;\n    set.add(name);\n    let max = 1;\n    const setMax = (num: number) => (max = Math.max(max, num));\n    if (row !== rowLen - 1 && matrix[row + 1][col] > num && !set.has(format(row + 1, col))) {\n      setMax(each(row + 1, col, set) + 1);\n    }\n    if (row !== 0 && matrix[row - 1][col] > num && !set.has(format(row - 1, col))) {\n      max = setMax(each(row - 1, col, set) + 1);\n    }\n    if (col !== 0 && matrix[row][col - 1] > num && !set.has(format(row, col - 1))) {\n      setMax(each(row, col - 1, set) + 1);\n    }\n    if (col !== colLen - 1 && matrix[row][col + 1] > num && !set.has(format(row, col + 1))) {\n      setMax(each(row, col + 1, set) + 1);\n    }\n    set.delete(name);\n    cache.set(name, max);\n    return max;\n  }\n}"},{"date":"2021-12-30","time":32,"memory":14.3,"script":"cpp","desc":"记忆化 dfs。","code":"class Solution {\n   public:\n    int dirs[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n    int dfs(int mmap[][200], vector<vector<int>>& matrix, int n, int m, int row,\n            int col) {\n        if (mmap[row][col]) return mmap[row][col];\n        int num = matrix[row][col], ans = 1;\n        for (int i = 0; i < 4; i++) {\n            int nrow = row + dirs[i][0];\n            int ncol = col + dirs[i][1];\n            if (nrow < 0 || ncol < 0 || nrow >= n || ncol >= m ||\n                matrix[nrow][ncol] <= num)\n                continue;\n            ans = max(ans, dfs(mmap, matrix, n, m, nrow, ncol) + 1);\n        }\n        return mmap[row][col] = ans;\n    }\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\n        int n = matrix.size(), m = matrix[0].size(), ans = 0, mmap[n][200];\n        memset(mmap, 0, sizeof(int) * n * 200);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                int tag = 1, num = matrix[i][j];\n                for (int k = 0; k < 4; k++) {\n                    int nrow = i + dirs[k][0];\n                    int ncol = j + dirs[k][1];\n                    if (nrow < 0 || ncol < 0 || nrow >= n || ncol >= m)\n                        continue;\n                    if (matrix[nrow][ncol] < num) {\n                        tag = 0;\n                        break;\n                    }\n                }\n                if (tag) ans = max(ans, dfs(mmap, matrix, n, m, i, j));\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["深度优先搜索","广度优先搜索","图","拓扑排序","记忆化搜索","数组","动态规划","矩阵"],"level":"Hard"}},{"problemName":"330.按要求补齐数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/330.按要求补齐数组.json","problemData":{"id":"330","name":"330.按要求补齐数组","url":"https://leetcode.cn/problems/patching-array","desc":"给定一个已排序的正整数数组 nums，和一个正整数  n 。从  [1, n]  区间内选取任意个数字补充到  nums  中，使得  [1, n]  区间内的任何数字都可以用  nums  中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。","solutions":[{"date":"2020-12-29","time":88,"memory":40.4,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/patching-array/solution/an-yao-qiu-bu-qi-shu-zu-by-leetcode-solu-klp1/)。","code":"function minPatches(nums: number[], n: number): number {\n  let patches = 0;\n  let x = 1;\n  const len = nums.length;\n  let i = 0;\n  while (x <= n) {\n    if (i < len && nums[i] <= x) {\n      x += nums[i];\n      i++;\n    } else {\n      x *= 2;\n      patches++;\n    }\n  }\n  return patches;\n}"}],"tagList":["贪心","数组"],"level":"Hard"}},{"problemName":"331.验证二叉树的前序序列化.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/331.验证二叉树的前序序列化.json","problemData":{"id":"331","name":"331.验证二叉树的前序序列化","url":"https://leetcode.cn/problems/verify-preorder-serialization-of-a-binary-tree","desc":"验证二叉树的前序序列化。","solutions":[{"date":"2021-03-12","time":88,"memory":39.6,"script":"typescript","desc":"计算深度。","code":"function isValidSerialization(preorder: string): boolean {\n  let degree = 1;\n  for (const char of preorder.split(',')) {\n    if (!degree) return false;\n    char === '#' ? degree-- : degree++;\n  }\n  return degree === 0;\n}"},{"date":"2021-03-19","time":100,"memory":39.3,"script":"typescript","desc":"逐级替换叶子节点。","code":"function isValidSerialization(preorder: string): boolean {\n  const leafReg = /d+,#,#/g;\n  while (leafReg.test(preorder)) preorder = preorder.replace(leafReg, '#');\n  return preorder === '#';\n}"},{"script":"python","time":40,"memory":16.61,"desc":"dfs，对每一个节点遍历左右子节点看是否匹配。","code":"class Solution:\n    def isValidSerialization(self, preorder: str) -> bool:\n        preorder = preorder.split(',')\n        def dfs(idx: int) -> int:\n            if idx == -1: return idx\n            if idx >= len(preorder): return -1\n            if preorder[idx] == '#': return idx + 1\n            return dfs(dfs(idx + 1))\n        return dfs(0) >= len(preorder)","date":"2024-03-31"}],"tagList":["栈","树","字符串","二叉树"],"level":"Medium"}},{"problemName":"332.重新安排行程.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/332.重新安排行程.json","problemData":{"id":"332","name":"332.重新安排行程","url":"https://leetcode.cn/problems/reconstruct-itinerary","desc":"给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。","solutions":[{"date":"2020-08-27","time":164,"memory":49.1,"script":"typescript","desc":"先进行排序字符，初始化数据，计算机票数量，再深度遍历","code":"function findItinerary(tickets: string[][]): string[] {\n  tickets.sort((a, b) => a[1].localeCompare(b[1]));\n  class Country {\n    to: Country[] = [];\n    constructor(public name: string) {}\n  }\n  const itinerary = new Map<string, number>();\n  const format = (from: string, to: string) => `${from}->${to}`;\n  const countries: Record<string, Country> = {};\n  const isOver = () => !Array.from(itinerary.values()).some(v => v > 0);\n  for (const [from, to] of tickets) {\n    let fromC = countries[from];\n    if (!fromC) countries[from] = fromC = new Country(from);\n    let toC = countries[to];\n    if (!toC) countries[to] = toC = new Country(to);\n    fromC.to.push(toC);\n    const formatName = format(from, to);\n    const num = itinerary.get(formatName);\n    itinerary.set(formatName, num === undefined ? 1 : num + 1);\n  }\n  const ans: string[][] = [];\n  const total: string[] = ['JFK'];\n  line('JFK');\n  return ans.sort((a, b) => (a.join('') < b.join('') ? -1 : 1))[0];\n  function line(countryName: string) {\n    // console.log('===');\n    // console.log(countryName);\n    // console.log(itinerary);\n    if (ans.length !== 0) return;\n    if (isOver()) {\n      ans.push([...total]);\n      return;\n    }\n    const country = countries[countryName];\n    for (const c of country.to) {\n      const formatName = format(countryName, c.name);\n      const num: number = itinerary.get(formatName)!;\n      if (num === 0) continue;\n      // console.log('---');\n      // console.log(formatName);\n      // console.log(num);\n      // console.log(total);\n      itinerary.set(formatName, num - 1);\n      total.push(c.name);\n      line(c.name);\n      total.pop();\n      itinerary.set(formatName, num);\n    }\n  }\n}"}],"tagList":["深度优先搜索","图","欧拉回路"],"level":"Hard"}},{"problemName":"334.递增的三元子序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/334.递增的三元子序列.json","problemData":{"id":"334","name":"334.递增的三元子序列","url":"https://leetcode.cn/problems/increasing-triplet-subsequence","desc":"给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。","solutions":[{"date":"2022-01-12","time":48,"memory":60.1,"script":"cpp","desc":"每遍历一个数值记录前面的值是否匹配。","code":"class Solution {\n   public:\n    bool increasingTriplet(vector<int>& nums) {\n        int pre1 = INT_MAX, pre2 = INT_MAX;\n        for (auto& num : nums) {\n            if (num > pre2) return 1;\n            if (num > pre1) pre2 = min(pre2, num);\n            pre1 = min(pre1, num);\n        }\n        return 0;\n    }\n};"}],"tagList":["贪心","数组"],"level":"Medium"}},{"problemName":"335.路径交叉.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/335.路径交叉.json","problemData":{"id":"335","name":"335.路径交叉","url":"https://leetcode.cn/problems/self-crossing","desc":"给你一个整数数组 distance 。判断你所经过的路径是否相交。如果相交，返回 true ；否则，返回 false 。","solutions":[{"date":"2021-10-29","time":96,"memory":41.7,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/self-crossing/solution/gong-shui-san-xie-fen-qing-kuang-tao-lun-zdrb/)。","code":"function isSelfCrossing(distance: number[]): boolean {\n  const n = distance.length;\n  if (n <= 3) return false;\n  for (let i = 3; i < n; i++) {\n    if (i >= 3 && distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3]) return true;\n    if (\n      i >= 4 &&\n      distance[i - 1] === distance[i - 3] &&\n      distance[i] + distance[i - 4] >= distance[i - 2]\n    )\n      return true;\n    if (\n      i >= 5 &&\n      distance[i - 1] <= distance[i - 3] &&\n      distance[i - 2] > distance[i - 4] &&\n      distance[i] + distance[i - 4] >= distance[i - 2] &&\n      distance[i - 1] + distance[i - 5] >= distance[i - 3]\n    )\n      return true;\n  }\n  return false;\n}"}],"tagList":["几何","数组","数学"],"level":"Hard"}},{"problemName":"337.打家劫舍III.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/337.打家劫舍III.json","problemData":{"id":"337","name":"337.打家劫舍III","url":"https://leetcode.cn/problems/house-robber-iii","desc":"计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。","solutions":[{"date":"2020-08-05","time":108,"memory":44,"script":"typescript","desc":"深度优先搜索，对每个节点进行判断偷与不偷的情况。","code":"function rob(root: TreeNode | null): number {\n  const f = new Map<TreeNode | null, number>();\n  const g = new Map<TreeNode | null, number>();\n  f.set(null, 0);\n  g.set(null, 0);\n  dfs(root);\n  return Math.max(f.get(root)!, g.get(root)!);\n  function dfs(node: TreeNode | null) {\n    if (node === null) return;\n    dfs(node.left);\n    dfs(node.right);\n    f.set(node, node.val + g.get(node.left)! + g.get(node.right)!);\n    g.set(\n      node,\n      Math.max(f.get(node.left)!, g.get(node.left)!) +\n        Math.max(f.get(node.right)!, g.get(node.right)!)\n    );\n  }\n}"},{"script":"cpp","time":28,"memory":30.57,"desc":"dfs时记录偷取当前节点和不偷取时的最大值。","code":"class Solution {\npublic:\n    vector<int> find(TreeNode *node) {\n        vector<int> res{0, 0};\n        if (node) {\n            auto l = find(node->left), r = find(node->right);\n            res[0] = max(l[0], l[1]) + max(r[0], r[1]);\n            res[1] = l[0] + r[0] + node->val;\n        }\n        return res;\n    }\n    int rob(TreeNode* root) {\n        auto res = find(root);\n        return max(res[0], res[1]);\n    }\n};\n","date":"2023-09-18"},{"script":"python","time":52,"memory":18.6,"desc":"同上。","code":"class Solution:\n    def rob(self, root: Optional[TreeNode]) -> int:\n        def find(node: Optional[TreeNode]) -> List[int]:\n            res = [0, 0]\n            if node:\n                l, r = find(node.left), find(node.right)\n                res[0] = max(l) + max(r)\n                res[1] = l[0] + r[0] + node.val\n            return res\n        return max(find(root))","date":"2023-09-18"},{"script":"rust","time":4,"memory":2.81,"desc":"同上。","code":"use std::cell::RefCell;\nuse std::rc::Rc;\nfn find(node: Option<&Rc<RefCell<TreeNode>>>) -> Vec<i32> {\n    let mut res = vec![0, 0];\n    if let Some(node) = node {\n        let node_ref = node.as_ref().borrow();\n        let l = find(node_ref.left.as_ref());\n        let r = find(node_ref.right.as_ref());\n        res[1] = l[0] + r[0] + node_ref.val;\n        res[0] = l.into_iter().max().unwrap() + r.into_iter().max().unwrap();\n    }\n    res\n}\nimpl Solution {\n    pub fn rob(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        let node = root.as_ref();\n        find(root.as_ref()).into_iter().max().unwrap()\n    }\n}","date":"2023-09-18"}],"tagList":["树","深度优先搜索","动态规划","二叉树"],"level":"Medium"}},{"problemName":"338.比特位计数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/338.比特位计数.json","problemData":{"id":"338","name":"338.比特位计数","url":"https://leetcode.cn/problems/counting-bits","desc":"给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。","solutions":[{"date":"2021-03-03","time":284,"memory":48.7,"script":"typescript","desc":"计算每一个数的 1 位。","code":"function countBits(num: number): number[] {\n  return new Array(num + 1).fill(0).map(\n    (_, i) =>\n      i\n        .toString(2)\n        .split('')\n        .filter(v => v === '1').length\n  );\n}"},{"date":"2021-03-03","time":120,"memory":50.4,"script":"typescript","desc":"计算每一个只含一个 1 的数，进行批量填充。","code":"function countBits(num: number): number[] {\n  const ans = [0, 1];\n  let max2 = 1;\n  while (max2 < num) {\n    max2 <<= 1;\n    ans.push(...ans.map(v => v + 1));\n  }\n  ans.length = num + 1;\n  return ans;\n}"},{"date":"2021-03-03","time":156,"memory":44.4,"script":"typescript","desc":"优化题解 2。","code":"function countBits(num: number): number[] {\n  if (num === 0) return [0];\n  const ans = [0, 1];\n  for (let i = 2; i <= num; i++) ans[i] = ans[~~(i / 2)] + (i & 1);\n  return ans;\n}"},{"date":"2021-12-23","time":8,"memory":8.4,"script":"cpp","desc":"当遇到 2 的指数幂后，从 0 开始重新遍历。","code":"class Solution {\n   public:\n    vector<int> countBits(int n) {\n        vector<int> ans;\n        ans.push_back(0);\n        if (n == 0) return ans;\n        ans.push_back(1);\n        if (n == 1) return ans;\n        for (int num = 2, i = 0; num <= n; num++, i++) {\n            if ((num & (num - 1)) == 0) i = 0;\n            ans.push_back(ans[i] + 1);\n        }\n        return ans;\n    }\n};"}],"tagList":["位运算","动态规划"],"level":"Easy"}},{"problemName":"341.扁平化嵌套列表迭代器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/341.扁平化嵌套列表迭代器.json","problemData":{"id":"341","name":"341.扁平化嵌套列表迭代器","url":"https://leetcode.cn/problems/flatten-nested-list-iterator","desc":"给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。","solutions":[{"date":"2021-03-23","time":128,"memory":49.2,"script":"typescript","desc":"递归重新载入。","code":"class NestedIterator {\n  private arr: number[] = [];\n  constructor(nestedList: NestedInteger[]) {\n    this.loadArray(nestedList);\n  }\n  hasNext(): boolean {\n    return this.arr.length > 0;\n  }\n  next(): number {\n    return this.arr.shift()!;\n  }\n  loadArray(nestedList: NestedInteger[]): void {\n    for (const nestedInteger of nestedList) {\n      if (nestedInteger.isInteger()) {\n        this.arr.push(nestedInteger.getInteger()!);\n      } else {\n        this.loadArray(nestedInteger.getList());\n      }\n    }\n  }\n}"}],"tagList":["栈","树","深度优先搜索","设计","队列","迭代器"],"level":"Medium"}},{"problemName":"342.4的幂.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/342.4的幂.json","problemData":{"id":"342","name":"342.4的幂","url":"https://leetcode.cn/problems/power-of-four","desc":"给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。","solutions":[{"date":"2021-05-31","time":124,"memory":39.7,"script":"typescript","desc":"换底公式。","code":"function isPowerOfFour(n: number): boolean {\n  const num = Math.log10(n) / Math.log10(4);\n  return num === ~~num;\n}"}],"tagList":["位运算","递归","数学"],"level":"Easy"}},{"problemName":"343.整数拆分.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/343.整数拆分.json","problemData":{"id":"343","name":"343.整数拆分","url":"https://leetcode.cn/problems/integer-break","desc":"给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。","solutions":[{"date":"2020-07-30","time":84,"memory":37.4,"script":"typescript","desc":"dp[i]=i 的最大值。","code":"function integerBreak(n: number): number {\n  const dp = new Array(n + 1).fill(0);\n  for (let i = 2; i <= n; i++) {\n    let max = 0;\n    for (let j = 1; j <= i - 1; j++) {\n      max = Math.max(max, j * Math.max(i - j, dp[i - j]));\n    }\n    dp[i] = max;\n  }\n  return dp[n];\n}"}],"tagList":["数学","动态规划"],"level":"Medium"}},{"problemName":"344.反转字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/344.反转字符串.json","problemData":{"id":"344","name":"344.反转字符串","url":"https://leetcode.cn/problems/reverse-string","desc":"编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。","solutions":[{"date":"2020-04-07","time":136,"memory":46.7,"script":"javascript","desc":"直接翻转即可。","code":"/**\n * @param {character[]} s\n * @return {void} Do not return anything, modify s in-place instead.\n */\nvar reverseString = function (s) {\n  s.reverse();\n};"},{"date":"2020-10-08","time":128,"memory":45.6,"script":"typescript","desc":"调用原生方法。","code":"function reverseString(s: string[]): void {\n  s.reverse();\n}"},{"date":"2020-10-08","time":140,"memory":46.1,"script":"typescript","desc":"双指针替换。","code":"function reverseString(s: string[]): void {\n  for (let l = 0, r = s.length - 1; l < r; l++, r--) {\n    [s[l], s[r]] = [s[r], s[l]];\n  }\n}"},{"date":"2020-10-08","time":128,"memory":45.6,"script":"typescript","desc":"调用原生方法。","code":"function reverseString(s: string[]): void {\n  s.reverse();\n}"},{"date":"2020-10-08","time":140,"memory":46.1,"script":"typescript","desc":"双指针替换。","code":"function reverseString(s: string[]): void {\n  for (let l = 0, r = s.length - 1; l < r; l++, r--) {\n    [s[l], s[r]] = [s[r], s[l]];\n  }\n}"},{"script":"cpp","time":20,"memory":22.15,"desc":"遍历。","code":"class Solution {\npublic:\n    void reverseString(vector<char>& s) {\n        int l = 0, r = s.size() - 1;\n        while (l < r) swap(s[l++], s[r--]);\n    }\n};","date":"2023-08-07"},{"script":"python","time":60,"memory":20.86,"desc":"同上。","code":"def swap(node: Optional[ListNode], cnt: int, max_cnt: int) -> (Optional[ListNode], Optional[ListNode]):\n    if not node:\n        return (None, None)\n    elif cnt == max_cnt:\n        node.next = swap(node.next, 1, max_cnt)[0]\n        return (node, node)\n    elif not node.next:\n        return (node, node)\n    else:\n        res = swap(node.next, cnt + 1, max_cnt)\n        node.next = res[1].next\n        res[1].next = node\n        return res\n\n    class Solution:\n        def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\n            return swap(head, 1, 2)[0]","date":"2023-08-07"},{"script":"rust","time":16,"memory":5.26,"desc":"同上。","code":"impl Solution {\n    pub fn reverse_string(s: &mut Vec<char>) {\n        let mut l = 0;\n        let mut r = s.len() - 1;\n        while l < r {\n            let (cl, cr) = (s[l], s[r]);\n            s[l] = cr;\n            s[r] = cl;\n            l += 1;\n            r -= 1;\n        }\n    }\n}","date":"2023-08-07"}],"tagList":["双指针","字符串"],"level":"Easy"}},{"problemName":"345.反转字符串中的元音字母.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/345.反转字符串中的元音字母.json","problemData":{"id":"345","name":"345.反转字符串中的元音字母","url":"https://leetcode.cn/problems/reverse-vowels-of-a-string","desc":"编写一个函数，以字符串作为输入，反转该字符串中的元音字母。","solutions":[{"date":"2020-04-07","time":120,"memory":44.6,"script":"javascript","desc":"构建元音集合进行倒序。","code":"/**\n * @param {string} s\n * @return {string}\n */\nvar reverseVowels = function (s) {\n  const vowels = new Set(['a', 'e', 'i', 'o', 'u']);\n  let result = [...s];\n  let tempNum = [];\n  let tempStr = [];\n  for (let i = 0, len = s.length; i < len; i++) {\n    if (vowels.has(s[i].toLowerCase())) {\n      tempNum.push(i);\n      tempStr.push(s[i]);\n    }\n  }\n  tempNum = tempNum.reverse();\n  for (const [index, num] of tempNum.entries()) {\n    result.splice(num, 1, tempStr[index]);\n  }\n  return result.join('');\n};"},{"date":"2021-08-19","time":88,"memory":46.3,"script":"typescript","desc":"逐个判断并反向取值。","code":"function reverseVowels(s: string): string {\n  const idxList: number[] = [];\n  const set = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']);\n  for (let i = 0; i < s.length; i++) if (set.has(s[i])) idxList.push(i);\n  const idxSet = new Set(idxList);\n  let ans = '';\n  for (let i = 0, pos = idxList.length - 1; i < s.length; i++) {\n    if (idxSet.has(i)) ans += s[idxList[pos--]];\n    else ans += s[i];\n  }\n  return ans;\n}"},{"date":"2021-08-19","time":96,"memory":45.4,"script":"typescript","desc":"优化内存。","code":"function reverseVowels(s: string): string {\n  const idxList: number[] = [];\n  const set = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']);\n  for (let i = 0; i < s.length; i++) if (set.has(s[i])) idxList.push(i);\n  let ans = '';\n  for (let i = 0, pos = idxList.length - 1; i < s.length; i++) {\n    if (set.has(s[i])) ans += s[idxList[pos--]];\n    else ans += s[i];\n  }\n  return ans;\n}"},{"date":"2021-08-19","time":180,"memory":45.2,"script":"typescript","desc":"优化内存。","code":"function reverseVowels(s: string): string {\n  const set = new Set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']);\n  let l = 0;\n  let r = s.length - 1;\n  while (l < r) {\n    if (set.has(s[r]) && set.has(s[l])) {\n      s = s.substring(0, l) + s[r] + s.substring(l + 1, r) + s[l] + s.substring(r + 1);\n      l++;\n      r--;\n    }\n    if (!set.has(s[l])) l++;\n    if (!set.has(s[r])) r--;\n  }\n  return s;\n}"}],"tagList":["双指针","字符串"],"level":"Easy"}},{"problemName":"347.前K个高频元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/347.前K个高频元素.json","problemData":{"id":"347","name":"347.前K个高频元素","url":"https://leetcode.cn/problems/top-k-frequent-elements","desc":"给定一个非空的整数数组，返回其中出现频率前 k 高的元素。","solutions":[{"date":"2020-09-07","time":108,"memory":41.5,"script":"typescript","desc":"构造堆进行遍历。","code":"class Frequent {\n  count = 1;\n  constructor(public num: number) {}\n}\nclass Heap<T> {\n  get size(): number {\n    return this._elemenets.length;\n  }\n  constructor(private _elemenets: T[], private compare: (e1: T, e2: T) => number) {\n    this.heapify();\n  }\n  heapify(): void {\n    for (let i = (this.size >> 1) - 1; i >= 0; i--) {\n      this.siftDown(i);\n    }\n  }\n  remove(): T {\n    const root = this._elemenets[0];\n    this._elemenets[0] = this._elemenets.pop() as T;\n    this.siftDown(0);\n    return root;\n  }\n  siftDown(index: number) {\n    const element = this._elemenets[index];\n    const half = this.size >> 1;\n    while (index < half) {\n      let childIndex = (index << 1) + 1;\n      let child = this._elemenets[childIndex];\n      const rightIndex = childIndex + 1;\n      if (rightIndex < this.size && this.compare(this._elemenets[rightIndex], child) > 0) {\n        child = this._elemenets[(childIndex = rightIndex)];\n      }\n      if (this.compare(element, child) >= 0) break;\n      this._elemenets[index] = child;\n      index = childIndex;\n    }\n    this._elemenets[index] = element;\n  }\n}\nfunction topKFrequent(nums: number[], k: number): number[] {\n  const frequents: Record<number, Frequent> = {};\n  for (const num of nums) {\n    if (frequents[num]) frequents[num].count++;\n    else frequents[num] = new Frequent(num);\n  }\n  const heap = new Heap(Object.values(frequents), (e1, e2) => e1.count - e2.count);\n  const ans: number[] = [];\n  while (k-- !== 0) {\n    ans.push(heap.remove().num);\n  }\n  return ans;\n}"}],"tagList":["数组","哈希表","分治","桶排序","计数","快速选择","排序","堆（优先队列）"],"level":"Medium"}},{"problemName":"349.两个数组的交集.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/349.两个数组的交集.json","problemData":{"id":"349","name":"349.两个数组的交集","url":"https://leetcode.cn/problems/intersection-of-two-arrays","desc":"给定两个数组，编写一个函数来计算它们的交集。","solutions":[{"date":"2020-02-28","time":104,"memory":34.9,"script":"javascript","desc":"使用 Set 对象去重后再遍历。","code":"/**\n * @param {number[]} nums1\n * @param {number[]} nums2\n * @return {number[]}\n */\nvar intersection = function (nums1, nums2) {\n  const set1 = new Set(nums1);\n  const set2 = new Set(nums2);\n  const result = [];\n  for (const num of set2) {\n    if (set1.has(num)) {\n      result.push(num);\n    }\n  }\n  return result;\n};"},{"date":"2020-02-28","time":48,"memory":34.8,"script":"javascript","desc":"使用 Set 对象去重后用 filter 遍历。","code":"var intersection = function (nums1, nums2) {\n  const a = new Set(nums1);\n  const b = new Set(nums2);\n  return [...new Set([...a].filter(x => b.has(x)))];\n};"},{"date":"2020-11-02","time":96,"memory":40.2,"script":"typescript","desc":"利用 set 去重搜索。","code":"function intersection(nums1: number[], nums2: number[]): number[] {\n  const set = new Set(nums1);\n  const arr: number[] = [];\n  for (const num of nums2) {\n    set.has(num) && arr.push(num);\n  }\n  return [...new Set(arr)];\n}"},{"date":"2021-11-30","time":4,"memory":6.4,"script":"c","desc":"二分查找。","code":"int comp(const void *a, const void *b) {\n    return *(int *)a - *(int *)b;\n}\nint bs(int *nums, int n, int num) {\n    int l = 0, r = n - 1, m;\n    if (nums[l] > num || nums[r] < num) return 0;\n    while (l < r) {\n        m = (l + r) >> 1;\n        if (nums[m] == num) return 1;\n        if (nums[m] > num) r = m - 1;\n        else l = m + 1;\n    }\n    return nums[l] == num ? 1 : 0;\n}\nint* intersection(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\n    qsort(nums2, nums2Size, sizeof(int), comp);\n    qsort(nums1, nums1Size, sizeof(int), comp);\n    int *ans = (int *)malloc(sizeof(int) * (nums1Size + nums2Size));\n    *returnSize = 0;\n    for (int i = 0; i < nums1Size; i++) {\n        if (i < nums1Size - 1 && nums1[i] == nums1[i + 1]) continue;\n        int num = nums1[i];\n        int check = bs(nums2, nums2Size, num);\n        if (check) ans[(*returnSize)++] = num;\n    }\n    return ans;\n}"}],"tagList":["数组","哈希表","双指针","二分查找","排序"],"level":"Easy"}},{"problemName":"350.两个数组的交集II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/350.两个数组的交集II.json","problemData":{"id":"350","name":"350.两个数组的交集II","url":"https://leetcode.cn/problems/intersection-of-two-arrays-ii","desc":"给定两个数组，编写一个函数来计算它们的交集。","solutions":[{"date":"2020-07-13","time":76,"memory":37.1,"script":"typescript","desc":"利用 map 来储存 num 和显示次数。","code":"function intersect(nums1: number[], nums2: number[]): number[] {\n  const map = new Map();\n  const ans: number[] = [];\n  for (const num of nums1) {\n    const c = map.get(num);\n    map.set(num, 1 + (c ? c : 0));\n  }\n  for (const num of nums2) {\n    const c = map.get(num);\n    if (c) {\n      ans.push(num);\n      map.set(num, c - 1);\n    }\n  }\n  return ans;\n}"},{"date":"2021-11-30","time":8,"memory":6.2,"script":"c","desc":"二分查找。","code":"int comp(const void *a, const void *b) {\n    return *(int *)a - *(int *)b;\n}\nint* intersect(int* nums1, int nums1Size, int* nums2, int nums2Size, int* returnSize){\n    qsort(nums2, nums2Size, sizeof(int), comp);\n    qsort(nums1, nums1Size, sizeof(int), comp);\n    int i1 = 0, i2 = 0, *ans = (int *)malloc(sizeof(int) * nums1Size);\n    *returnSize = 0;\n    while (i1 < nums1Size && i2 < nums2Size) {\n        if (nums1[i1] == nums2[i2]) {\n            ans[(*returnSize)++] = nums1[i1];\n            i1++;\n            i2++;\n            continue ;\n        } else if (nums1[i1] > nums2[i2]) {\n            i2++;\n        } else {\n            i1++;\n        }\n    }\n    return ans;\n}"}],"tagList":["数组","哈希表","双指针","二分查找","排序"],"level":"Easy"}},{"problemName":"352.将数据流变为多个不相交区间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/352.将数据流变为多个不相交区间.json","problemData":{"id":"352","name":"352.将数据流变为多个不相交区间","url":"https://leetcode.cn/problems/data-stream-as-disjoint-intervals","desc":"给你一个由非负整数 a1, a2, ..., an 组成的数据流输入，请你将到目前为止看到的数字总结为不相交的区间列表。","solutions":[{"date":"2021-10-09","time":180,"memory":48.5,"script":"typescript","desc":"二分插入。","code":"class SummaryRanges {\n  private set = new Set<number>();\n  private list: number[] = [];\n  addNum(val: number): void {\n    if (this.set.has(val)) return;\n    this.set.add(val);\n    let l = 0;\n    let r = this.list.length - 1;\n    if (this.list[r] < val) {\n      this.list.push(val);\n      return;\n    }\n    while (l < r) {\n      const mid = (l + r) >> 1;\n      if (this.list[mid] > val) r = mid;\n      else l = mid + 1;\n    }\n    this.list.splice(l, 0, val);\n  }\n  getIntervals(): number[][] {\n    const ans: number[][] = [];\n    for (let i = 0, l = this.list.length; i < l; i++) {\n      const num = this.list[i];\n      const last = ans[ans.length - 1];\n      if (ans.length === 0 || last[1] + 1 < num) {\n        ans.push([num, num]);\n      } else {\n        last[1] = num;\n      }\n    }\n    return ans;\n  }\n}"}],"tagList":["设计","二分查找","有序集合"],"level":"Hard"}},{"problemName":"354.俄罗斯套娃信封问题.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/354.俄罗斯套娃信封问题.json","problemData":{"id":"354","name":"354.俄罗斯套娃信封问题","url":"https://leetcode.cn/problems/russian-doll-envelopes","desc":"请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。","solutions":[{"date":"2021-03-04","time":444,"memory":42.2,"script":"typescript","desc":"动态规划。","code":"function maxEnvelopes(envelopes: number[][]): number {\n  const len = envelopes.length;\n  if (len === 0) return 0;\n  envelopes.sort(([w1], [w2]) => w1 - w2);\n  const dp: number[] = [1];\n  for (let i = 1; i < len; i++) {\n    const [w, h] = envelopes[i];\n    let max = 1;\n    for (let j = 0; j < i; j++) {\n      const envelope = envelopes[j];\n      if (w > envelope[0] && h > envelope[1]) max = Math.max(dp[j] + 1, max);\n    }\n    dp[i] = max;\n  }\n  return Math.max(...dp);\n}"}],"tagList":["数组","二分查找","动态规划","排序"],"level":"Hard"}},{"problemName":"355.设计推特.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/355.设计推特.json","problemData":{"id":"355","name":"355.设计推特","url":"https://leetcode.cn/problems/design-twitter","desc":"设计一个简化版的推特(Twitter)，可以让用户实现发送推文，关注/取消关注其他用户，能够看见关注人（包括自己）的最近十条推文。","solutions":[{"date":"2020-04-13","time":152,"memory":46.8,"script":"javascript","desc":"难点在于自己关注自己的情况和自己取关自己。","code":"let count = 0;\nclass Tweet {\n  constructor(id) {\n    this.id = id;\n    this.time = count++;\n  }\n}\nclass User {\n  followSet = new Set();\n  tweet = new Set();\n  constructor() {}\n  postTweet(tweetId) {\n    this.tweet.add(new Tweet(tweetId));\n  }\n  follow(followeeUser) {\n    this.followSet.add(followeeUser);\n  }\n  unFollow(followeeUser) {\n    if (this.followSet.has(followeeUser)) {\n      this.followSet.delete(followeeUser);\n    }\n  }\n  getNewsFeed() {\n    let arr = [...this.tweet];\n    for (const user of this.followSet) {\n      arr = arr.concat([...user.tweet]);\n    }\n    return [\n      ...new Set(\n        arr\n          .sort((a, b) => b.time - a.time)\n          .map(v => v.id)\n          .filter((_, index) => index < 10)\n      ),\n    ];\n  }\n}\nclass Twitter {\n  user = {};\n  /**\n   * Compose a new tweet.\n   * @param {number} userId\n   * @param {number} tweetId\n   * @return {void}\n   */\n  postTweet(userId, tweetId) {\n    const user = this.user[userId];\n    if (user) {\n      user.postTweet(tweetId);\n    } else {\n      const newUser = new User();\n      newUser.postTweet(tweetId);\n      this.user[userId] = newUser;\n    }\n  }\n  /**\n   * Follower follows a followee. If the operation is invalid, it should be a no-op.\n   * @param {number} followerId\n   * @param {number} followeeId\n   * @return {void}\n   */\n  follow(followerId, followeeId) {\n    if (followerId === followeeId) return;\n    let followerUser = this.user[followerId];\n    let followeeUser = this.user[followeeId];\n    if (!followerUser) this.user[followerId] = followerUser = new User();\n    if (!followeeUser) this.user[followeeId] = followeeUser = new User();\n    followerUser.follow(followeeUser);\n  }\n  /**\n   * Follower unfollows a followee. If the operation is invalid, it should be a no-op.\n   * @param {number} followerId\n   * @param {number} followeeId\n   * @return {void}\n   */\n  unfollow(followerId, followeeId) {\n    const followerUser = this.user[followerId];\n    const followeeUser = this.user[followeeId];\n    if (followerUser && followeeUser) {\n      followerUser.unFollow(followeeUser);\n    }\n  }\n  /**\n   * Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.\n   * @param {number} userId\n   * @return {number[]}\n   */\n  getNewsFeed(userId) {\n    const user = this.user[userId];\n    if (user) {\n      return user.getNewsFeed();\n    } else {\n      return [];\n    }\n  }\n}"}],"tagList":["设计","哈希表","链表","堆（优先队列）"],"level":"Medium"}},{"problemName":"357.统计各位数字都不同的数字个数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/357.统计各位数字都不同的数字个数.json","problemData":{"id":"357","name":"357.统计各位数字都不同的数字个数","url":"https://leetcode.cn/problems/count-numbers-with-unique-digits","desc":"给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x < 10n 。","solutions":[{"date":"2022-03-17","time":0,"memory":5.9,"script":"cpp","desc":"提前计算答案进行累加。","code":"class Solution {\n   public:\n    int lists[8] = {9, 81, 648, 4536, 27216, 136080, 544320, 1632960};\n    int countNumbersWithUniqueDigits(int n) {\n        int ans = 1;\n        for (int i = 1; i <= n; i++) {\n            ans += lists[i - 1];\n        }\n        return ans;\n    }\n};"},{"date":"2022-03-17","time":0,"memory":5.9,"script":"cpp","desc":"计算每位数有几种可能性。","code":"class Solution {\n   public:\n    int countNumbersWithUniqueDigits(int n) {\n        if (n == 0) return 1;\n        vector<int> dp(n + 1);\n        dp[0] = 1;\n        dp[1] = 9;\n        for (int i = 2, num = 9; i <= n; i++, num--) dp[i] = dp[i - 1] * num;\n        int ans = 0;\n        for (int i = 0; i <= n; i++) ans += dp[i];\n        return ans;\n    }\n};"},{"date":"2022-04-11","time":0,"memory":5.9,"script":"cpp","desc":"遍历统计每种情况的可能数量。","code":"class Solution {\n   public:\n    int countNumbersWithUniqueDigits(int n) {\n        if (n == 0) return 1;\n        if (n == 1) return 10;\n        int ans = 10, num = 9;\n        for (int i = 2, cur = 9; i <= n; i++, cur--) {\n            num *= cur;\n            ans += num;\n        }\n        return ans;\n    }\n};"}],"tagList":["数学","动态规划","回溯"],"level":"Medium"}},{"problemName":"363.矩形区域不超过K的最大数值和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/363.矩形区域不超过K的最大数值和.json","problemData":{"id":"363","name":"363.矩形区域不超过K的最大数值和","url":"https://leetcode.cn/problems/max-sum-of-rectangle-no-larger-than-k","desc":"给你一个 m x n 的矩阵 matrix 和一个整数 k ，找出并返回矩阵内部矩形区域的不超过 k 的最大数值和。","solutions":[{"date":"2021-04-22","time":408,"memory":39.7,"script":"typescript","desc":"暴力循环四次。","code":"function maxSumSubmatrix(matrix: number[][], k: number): number {\n  const rowLen = matrix.length;\n  const colLen = matrix[0].length;\n  const dp: number[][] = new Array(rowLen + 1).fill(0).map(_ => new Array(colLen + 1).fill(0));\n  let max = -Infinity;\n  for (let row = 0; row < rowLen; row++) {\n    for (let col = 0; col < colLen; col++) {\n      let num = matrix[row][col] + dp[row + 1][col] + dp[row][col + 1] - dp[row][col];\n      if (num === k) return k;\n      dp[row + 1][col + 1] = matrix[row][col] + dp[row + 1][col] + dp[row][col + 1] - dp[row][col];\n      for (let i = 0; i <= row; i++) {\n        for (let j = 0; j <= col; j++) {\n          const areaNum = num - dp[i][col + 1] - dp[row + 1][j] + dp[i][j];\n          if (areaNum === k) return k;\n          else if (areaNum < k) max = Math.max(max, areaNum);\n        }\n      }\n    }\n  }\n  return max;\n}"}],"tagList":["数组","二分查找","矩阵","有序集合","前缀和"],"level":"Hard"}},{"problemName":"365.水壶问题.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/365.水壶问题.json","problemData":{"id":"365","name":"365.水壶问题","url":"https://leetcode.cn/problems/water-and-jug-problem","desc":"有两个容量分别为 x 升 和 y 升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z 升 的水？。","solutions":[{"date":"2021-07-21","time":2516,"memory":81.7,"script":"typescript","desc":"广度优先，遍历所有可能。","code":"function canMeasureWater(\n  jug1Capacity: number,\n  jug2Capacity: number,\n  targetCapacity: number\n): boolean {\n  type State = [number, number];\n  const format = (x: number, y: number) => `${x}::${y}`;\n  const set = new Set<string>([format(0, 0)]);\n  const queue: State[] = [[0, 0]];\n  return find();\n  function find(): boolean {\n    while (queue.length !== 0) {\n      const cur = queue.shift()!;\n      const next = findNext(cur);\n      if (next.some(([x, y]) => x + y === targetCapacity)) return true;\n      next.forEach(v => {\n        const str = format(...v);\n        if (!set.has(str)) {\n          set.add(str);\n          queue.push(v);\n        }\n      });\n    }\n    return false;\n  }\n  function findNext([x, y]: State): State[] {\n    return [\n      [0, y],\n      [x, 0],\n      [jug1Capacity, y],\n      [x, jug2Capacity],\n      [Math.max(x - (jug2Capacity - y), 0), Math.min(y + x, jug2Capacity)],\n      [Math.min(x + y, jug1Capacity), Math.max(y - (jug1Capacity - x), 0)],\n    ];\n  }\n}"},{"script":"python","time":2181,"memory":67.66,"desc":"bfs。","code":"class Solution:\n    def canMeasureWater(self, jug1Capacity: int, jug2Capacity: int, targetCapacity: int) -> bool:\n        used = defaultdict(defaultdict)\n        q = deque()\n        q.append((0, 0))\n        used[0][0] = True\n        while q:\n            jug1, jug2 = q.popleft()\n            if jug1 == targetCapacity or jug2 == targetCapacity or jug1 + jug2 == targetCapacity:\n                return True\n            arr =[\n                [jug1Capacity, jug2],\n                [0, jug2],\n                [min(jug1Capacity, jug1 + jug2), jug2 - (min(jug1Capacity, jug1 + jug2) - jug1)],\n                [jug1, jug2Capacity],\n                [jug1, 0],\n                [jug1 - (min(jug2Capacity, jug1 + jug2) - jug2), min(jug2Capacity, jug1 + jug2)]\n            ]\n            for jug1, jug2 in arr:\n                if jug2 not in used[jug1]:\n                    q.append((jug1, jug2))\n                    used[jug1][jug2] = True\n        return False","date":"2024-01-28"},{"script":"rust","time":441,"memory":21.37,"desc":"同上。","code":"impl Solution {\n    pub fn can_measure_water(jug1_capacity: i32, jug2_capacity: i32, target_capacity: i32) -> bool {\n        use std::cmp::min;\n        use std::collections::{HashMap, VecDeque};\n        let mut used: HashMap<i32, HashMap<i32, bool>> = Default::default();\n        let mut q: VecDeque<(i32, i32)> = Default::default();\n        q.push_back((0, 0));\n        used.entry(0).or_default().entry(0).or_insert(true);\n        while let Some((jug1, jug2)) = q.pop_front() {\n            if jug1 == target_capacity || jug2 == target_capacity || jug1 + jug2 == target_capacity\n            {\n                return true;\n            }\n            let next = [\n                [jug1_capacity, jug2],\n                [0, jug2],\n                [\n                    min(jug1_capacity, jug1 + jug2),\n                    jug2 - (min(jug1_capacity, jug1 + jug2) - jug1),\n                ],\n                [jug1, jug2_capacity],\n                [jug1, 0],\n                [\n                    jug1 - (min(jug2_capacity, jug1 + jug2) - jug2),\n                    min(jug2_capacity, jug1 + jug2),\n                ],\n            ];\n            for [jug1, jug2] in next {\n                let item = used.entry(jug1).or_default().entry(jug2).or_default();\n                if !*item {\n                    q.push_back((jug1, jug2));\n                    *item = true;\n                }\n            }\n        }\n        false\n    }\n}","date":"2024-01-28"}],"tagList":["深度优先搜索","广度优先搜索","数学"],"level":"Medium"}},{"problemName":"367.有效的完全平方数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/367.有效的完全平方数.json","problemData":{"id":"367","name":"367.有效的完全平方数","url":"https://leetcode.cn/problems/valid-perfect-square","desc":"给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。","solutions":[{"date":"2021-11-04","time":80,"memory":39.3,"script":"typescript","desc":"Math.sqrt。","code":"function isPerfectSquare(num: number): boolean {\n  const s = Math.sqrt(num);\n  return s === Math.floor(s);\n}"},{"date":"2021-11-04","time":76,"memory":39.3,"script":"typescript","desc":"二分。","code":"function isPerfectSquare(num: number): boolean {\n  if (num === 1) return true;\n  let l = 1,\n    r = num / 2;\n  while (l <= r) {\n    const mid = (l + r) >> 1;\n    const midNum = mid ** 2;\n    if (midNum === num) return true;\n    if (midNum > num) r = mid - 1;\n    else l = mid + 1;\n  }\n  return false;\n}"}],"tagList":["数学","二分查找"],"level":"Easy"}},{"problemName":"368.最大整除子集.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/368.最大整除子集.json","problemData":{"id":"368","name":"368.最大整除子集","url":"https://leetcode.cn/problems/largest-divisible-subset","desc":"给你一个由 无重复 正整数组成的集合 nums ，请你找出并返回其中最大的整除子集 answer。","solutions":[{"date":"2021-04-23","time":124,"memory":41,"script":"typescript","desc":"动态规划。","code":"function largestDivisibleSubset(nums: number[]): number[] {\n  nums.sort((a, b) => a - b);\n  const len = nums.length;\n  let maxSize = 1;\n  let maxVal = nums[0];\n  const dp = new Array(len).fill(1);\n  for (let i = 1; i < len; i++) {\n    const num = nums[i];\n    for (let j = 0; j < i; j++) {\n      if (num % nums[j] === 0) dp[i] = Math.max(dp[i], dp[j] + 1);\n    }\n    if (dp[i] > maxSize) {\n      maxSize = dp[i];\n      maxVal = num;\n    }\n  }\n  const ans: number[] = [];\n  for (let i = len - 1; i >= 0; i--) {\n    const num = nums[i];\n    if (dp[i] === maxSize && maxVal % num === 0) {\n      ans.unshift(num);\n      maxSize--;\n      maxVal = num;\n    }\n  }\n  return ans;\n}"}],"tagList":["数组","数学","动态规划","排序"],"level":"Medium"}},{"problemName":"372.超级次方.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/372.超级次方.json","problemData":{"id":"372","name":"372.超级次方","url":"https://leetcode.cn/problems/super-pow","desc":"你的任务是计算 ab 对 1337 取模，a 是一个正整数，b 是一个非常大的正整数且会以数组形式给出。","solutions":[{"date":"2021-12-05","time":84,"memory":39.7,"script":"typescript","desc":"99^(2345) === (99^234)^10 \\* 99^5。","code":"const MOD = 1337;\nfunction pow(a: number, b: number) {\n  let ans = 1;\n  while (b--) ans = (ans * a) % MOD;\n  return ans;\n}\nfunction superPow(a: number, b: number[]): number {\n  let ans = 1;\n  for (let i = 0; i < b.length; i++) {\n    ans = (pow(ans, 10) * pow(a, b[i])) % MOD;\n  }\n  return ans;\n}"},{"date":"2021-12-11","time":152,"memory":44.3,"script":"typescript","desc":"拆解次方，快速幂相乘。","code":"const mod = 1337n;\nfunction pow(a: bigint, b: bigint): bigint {\n  let ans = 1n;\n  let num = a;\n  while (b) {\n    if (b & 1n) ans = (ans * num) % mod;\n    num = (num * num) % mod;\n    b >>= 1n;\n  }\n  return ans;\n}\nfunction superPow(a: number, b: number[]): number {\n  let ans = 1n;\n  const biga = BigInt(a);\n  for (const num of b) {\n    ans = (pow(ans, 10n) * pow(biga, BigInt(num))) % mod;\n  }\n  return Number(ans);\n}"}],"tagList":["数学","分治"],"level":"Medium"}},{"problemName":"373.查找和最小的K对数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/373.查找和最小的K对数字.json","problemData":{"id":"373","name":"373.查找和最小的K对数字","url":"https://leetcode.cn/problems/find-k-pairs-with-smallest-sums","desc":"找到和最小的 k 对数字 (u1,v1), (u2,v2) ... (uk,vk)。","solutions":[{"date":"2021-04-09","time":2136,"memory":77,"script":"typescript","desc":"构建堆。","code":"class Heap<T> {\n  private arr: T[] = [];\n  get isEmpty() {\n    return this.size === 0;\n  }\n  get size() {\n    return this.arr.length;\n  }\n  constructor(private compare: (num1: T, num2: T) => number) {}\n  add(num: T): void {\n    this.arr.push(num);\n    this.shiftUp(this.size - 1);\n  }\n  remove(): T {\n    const num = this.arr.shift()!;\n    if (this.size) {\n      this.arr.unshift(this.arr.pop()!);\n      this.shiftDown(0);\n    }\n    return num;\n  }\n  private shiftUp(index: number): void {\n    if (index === 0) return;\n    const parentIndex = (index - 1) >> 1;\n    if (this.compare(this.arr[index], this.arr[parentIndex]) > 0) {\n      [this.arr[index], this.arr[parentIndex]] = [this.arr[parentIndex], this.arr[index]];\n      this.shiftUp(parentIndex);\n    }\n  }\n  private shiftDown(index: number): void {\n    let childrenIndex = index * 2 + 1;\n    if (childrenIndex > this.size - 1) return;\n    if (\n      childrenIndex + 1 < this.size - 1 &&\n      this.compare(this.arr[childrenIndex + 1], this.arr[childrenIndex]) > 0\n    ) {\n      childrenIndex++;\n    }\n    if (this.compare(this.arr[childrenIndex], this.arr[index]) > 0) {\n      [this.arr[childrenIndex], this.arr[index]] = [this.arr[index], this.arr[childrenIndex]];\n      this.shiftDown(childrenIndex);\n    }\n  }\n}\n\nfunction kSmallestPairs(nums1: number[], nums2: number[], k: number): number[][] {\n  const sum = (arr: number[]) => arr.reduce((total, cur) => total + cur, 0);\n  const heap = new Heap<number[]>((nums1, nums2) => sum(nums2) - sum(nums1));\n  nums1.forEach(num1 => nums2.forEach(num2 => heap.add([num1, num2])));\n  const ans: number[][] = [];\n  while (heap.size && k--) ans.push(heap.remove());\n  return ans;\n}"},{"date":"2022-01-14","time":924,"memory":62.6,"script":"cpp","desc":"堆。","code":"class Solution {\n   public:\n    struct node {\n        int num1, num2, sum;\n        bool operator<(const node& obj) const {\n            return sum == obj.sum\n                       ? num2 == obj.num2 ? num1 < obj.num1 : num2 < obj.num2\n                       : sum < obj.sum;\n        }\n    };\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2,\n                                       int k) {\n        priority_queue<node> q;\n        int isBreak = 0, len = min(k, (int)(nums1.size() * nums2.size()));\n        // cout << \"len = \" << len << endl;\n        vector<vector<int>> ans(len, vector<int>(2));\n        for (auto& num1 : nums1) {\n            if (isBreak) break;\n            for (auto& num2 : nums2) {\n                if (q.size() >= len && num1 > 0 && num2 > 0 &&\n                    num1 > q.top().sum && num2 > q.top().sum)\n                    isBreak = 1;\n                if (isBreak) break;\n                if (q.size() < len) {\n                    q.push((node){num1, num2, num1 + num2});\n                } else if (q.top().sum > num1 + num2) {\n                    // cout << q.top().num1 << ',' << q.top().num2;\n                    // if (q.top() )\n                    q.pop();\n                    q.push((node){num1, num2, num1 + num2});\n                }\n            }\n        }\n        while (q.size()) {\n            node n = q.top();\n            q.pop();\n            ans[len - 1][0] = n.num1;\n            ans[len - 1][1] = n.num2;\n            len--;\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","堆（优先队列）"],"level":"Medium"}},{"problemName":"374.猜数字大小.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/374.猜数字大小.json","problemData":{"id":"374","name":"374.猜数字大小","url":"https://leetcode.cn/problems/guess-number-higher-or-lower","desc":"返回我选出的数字。","solutions":[{"date":"2021-06-14","time":84,"memory":37.7,"script":"typescript","desc":"二分搜索。","code":"var guessNumber = function (n) {\n  const find = (start = 1, end = n) => {\n    if (start === end) return start;\n    const mid = ~~((end + start) / 2);\n    const res = guess(mid);\n    if (res === 1) return find(mid + 1, end);\n    else if (res === -1) return find(start, mid - 1);\n    else return mid;\n  };\n  return find();\n};"}],"tagList":["二分查找","交互"],"level":"Easy"}},{"problemName":"375.猜数字大小II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/375.猜数字大小II.json","problemData":{"id":"375","name":"375.猜数字大小II","url":"https://leetcode.cn/problems/guess-number-higher-or-lower-ii","desc":"给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。","solutions":[{"date":"2021-11-12","time":140,"memory":41.3,"script":"typescript","desc":"动态规划。","code":"function getMoneyAmount(n: number): number {\n  const dp: number[][] = new Array(n + 1).fill(0).map(_ => new Array(n + 1).fill(0));\n  for (let i = n; i >= 1; i--) {\n    for (let j = i + 1; j <= n; j++) {\n      let min = Infinity;\n      for (let k = i; k < j; k++) {\n        min = Math.min(min, k + Math.max(dp[i][k - 1], dp[k + 1][j]));\n      }\n      dp[i][j] = min;\n    }\n  }\n  return dp[1][n];\n}"}],"tagList":["数学","动态规划","博弈"],"level":"Medium"}},{"problemName":"377.组合总和Ⅳ.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/377.组合总和Ⅳ.json","problemData":{"id":"377","name":"377.组合总和Ⅳ","url":"https://leetcode.cn/problems/combination-sum-iv","desc":"给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。","solutions":[{"date":"2021-04-24","time":104,"memory":40,"script":"typescript","desc":"动态规划。","code":"function combinationSum4(nums: number[], target: number): number {\n  const dp = new Array(target + 1).fill(0);\n  dp[0] = 1;\n  for (let i = 1; i <= target; i++) {\n    for (const num of nums) {\n      if (i >= num) {\n        dp[i] += dp[i - num];\n      }\n    }\n  }\n  return dp[target];\n}"},{"date":"2021-09-14","time":84,"memory":40,"script":"javascript","desc":"动态规划。","code":"function combinationSum4(nums: number[], target: number): number {\n  nums.sort((a, b) => a - b);\n  const dp = new Array(target + 1).fill(0);\n  dp[0] = 1;\n  for (let i = 1; i <= target; i++) {\n    for (const num of nums) {\n      if (i < num) break;\n      dp[i] += dp[i - num];\n    }\n  }\n  return dp[target];\n}"},{"script":"python","time":44,"memory":16.5,"desc":"dfs。","code":"class Solution:\n    def combinationSum4(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        @cache\n        def dfs(target: int) -> int:\n            if target == 0: return 1\n            res = 0\n            for num in nums:\n                if num > target: break\n                res += dfs(target - num)\n            return res\n        return dfs(target)","date":"2024-04-22"},{"script":"python","time":37,"memory":16.5,"desc":"dp[i]表示i为target时的最大次数。","code":"class Solution:\n    def combinationSum4(self, nums: List[int], target: int) -> int:\n        nums.sort()\n        dp = [0 for _ in range(target + 1)]\n        dp[0] = 1\n        for cur_target in range(1, target + 1):\n            for num in nums:\n                if num > cur_target: break\n                dp[cur_target] += dp[cur_target - num]\n        return dp[target]","date":"2024-04-23"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"378.有序矩阵中第K小的元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/378.有序矩阵中第K小的元素.json","problemData":{"id":"378","name":"378.有序矩阵中第K小的元素","url":"https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix","desc":"给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。","solutions":[{"date":"2020-07-02","time":100,"memory":52.8,"script":"typescript","desc":"构建小顶堆进行读取。","code":"class Heap {\n  get size(): number {\n    return this._elemenets.length;\n  }\n  constructor(private _elemenets: number[]) {\n    this.heapify();\n  }\n  heapify(): void {\n    for (let i = (this.size >> 1) - 1; i >= 0; i--) {\n      this.siftDown(i);\n    }\n  }\n  remove(): number {\n    const root = this._elemenets[0];\n    this._elemenets[0] = this._elemenets.pop() as number;\n    this.siftDown(0);\n    return root;\n  }\n  siftDown(index: number) {\n    const element = this._elemenets[index];\n    const half = this.size >> 1;\n    while (index < half) {\n      let childIndex = (index << 1) + 1;\n      let child = this._elemenets[childIndex];\n      const rightIndex = childIndex + 1;\n      if (rightIndex < this.size && this._elemenets[rightIndex] < child) {\n        child = this._elemenets[(childIndex = rightIndex)];\n      }\n      if (element <= child) break;\n      this._elemenets[index] = child;\n      index = childIndex;\n    }\n    this._elemenets[index] = element;\n  }\n}\nfunction kthSmallest(matrix: number[][], k: number): number {\n  const heap = new Heap(matrix.reduce((total, value) => total.concat(value), []));\n  while (--k !== 0) {\n    heap.remove();\n  }\n  return heap.remove();\n}"},{"date":"2020-07-02","time":112,"memory":51.4,"script":"typescript","desc":"拍平后排序输出。","code":"function kthSmallest(matrix: number[][], k: number): number {\n  return matrix.reduce((total, value) => total.concat(value), []).sort((a, b) => a - b)[k - 1];\n}"},{"date":"2021-11-30","time":32,"memory":8.1,"script":"c","desc":"二分查找，根据矩阵有序特性。","code":"int check(int **matrix, int n, int num) {\n    int row = n - 1, col = 0, cnt = 0;\n    while (row >= 0) {\n        while(col < n && matrix[row][col] <= num) col++;\n        cnt += col;\n        row--;\n    }\n    return cnt;\n}\nint kthSmallest(int** matrix, int matrixSize, int* matrixColSize, int k){\n    int l = matrix[0][0], r = matrix[matrixSize - 1][matrixSize - 1], m;\n    while (l < r) {\n        m = (l + r) >> 1;\n        int cnt = check(matrix, matrixSize, m);\n        if (cnt >= k) r = m;\n        else l = m + 1;\n    }\n    return l;\n}"}],"tagList":["数组","二分查找","矩阵","排序","堆（优先队列）"],"level":"Medium"}},{"problemName":"380.O(1)时间插入、删除和获取随机元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/380.O(1)时间插入、删除和获取随机元素.json","problemData":{"id":"380","name":"380.O(1)时间插入、删除和获取随机元素","url":"https://leetcode.cn/problems/insert-delete-getrandom-o1","desc":"设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构。","solutions":[{"date":"2021-07-30","time":500,"memory":88.1,"script":"typescript","desc":"利用哈希表快速删增。","code":"class RandomizedSet {\n  private set = new Set<number>();\n  insert(val: number): boolean {\n    if (this.set.has(val)) return false;\n    this.set.add(val);\n    return true;\n  }\n  remove(val: number): boolean {\n    if (!this.set.has(val)) return false;\n    this.set.delete(val);\n    return true;\n  }\n  getRandom(): number {\n    return [...this.set][this.random(0)];\n  }\n  private random(minNum: number) {\n    const maxNum = this.set.size - 1;\n    return parseInt((Math.random() * (maxNum - minNum + 1) + minNum) as any, 10);\n  }\n}"},{"date":"2021-07-30","time":420,"memory":87.2,"script":"typescript","desc":"优化 O(1)。","code":"class RandomizedSet {\n  private map = new Map<number, number>();\n  private list: number[] = [];\n  insert(val: number): boolean {\n    if (this.map.has(val)) return false;\n    this.map.set(val, this.list.length);\n    this.list.push(val);\n    return true;\n  }\n  remove(val: number): boolean {\n    if (!this.map.has(val)) return false;\n    const curIdx = this.map.get(val)!;\n    const lastIdx = this.list.length - 1;\n    this.map.set(this.list[lastIdx], curIdx);\n    this.map.delete(val);\n    [this.list[curIdx], this.list[lastIdx]] = [this.list[lastIdx], this.list[curIdx]];\n    this.list.pop();\n    return true;\n  }\n  getRandom(): number {\n    return this.list[this.random()];\n  }\n  private random() {\n    const minNum = 0;\n    const maxNum = this.list.length - 1;\n    return parseInt((Math.random() * (maxNum - minNum + 1) + minNum) as any, 10);\n  }\n}"},{"date":"2022-04-13","time":188,"memory":94.7,"script":"cpp","desc":"利用队列末尾增删 O1 来维护时间复杂度。","code":"class RandomizedSet {\n   public:\n    vector<int> list;\n    unordered_map<int, int> m;\n    RandomizedSet() { srand((int)time(0)); }\n    bool insert(int val) {\n        if (m.count(val)) return false;\n        m[val] = list.size();\n        list.push_back(val);\n        return true;\n    }\n    bool remove(int val) {\n        if (!m.count(val)) return false;\n        int idx = m[val], last_idx = list.size() - 1;\n        m[list[last_idx]] = idx;\n        swap(list[idx], list[last_idx]);\n        list.pop_back();\n        m.erase(val);\n        return true;\n    }\n    int getRandom() {\n        int idx = random() % list.size();\n        return list[idx];\n    }\n};"}],"tagList":["设计","数组","哈希表","数学","随机化"],"level":"Medium"}},{"problemName":"381.O(1)时间插入、删除和获取随机元素-允许重复.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/381.O(1)时间插入、删除和获取随机元素-允许重复.json","problemData":{"id":"381","name":"381.O(1)时间插入、删除和获取随机元素-允许重复","url":"https://leetcode.cn/problems/insert-delete-getrandom-o1-duplicates-allowed","desc":"设计一个支持在平均 时间复杂度 O(1) 下， 执行以下操作的数据结构。","solutions":[{"date":"2020-11-02","time":15,"memory":45.3,"script":"java","desc":"[参考链接](https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/solution/o1-shi-jian-cha-ru-shan-chu-he-huo-qu-sui-ji-yua-5/)。","code":"class RandomizedCollection {\n        Map<Integer, Set<Integer>> idx;\n        List<Integer> nums;\n\n        /** Initialize your data structure here. */\n        public RandomizedCollection() {\n            idx = new HashMap<Integer, Set<Integer>>();\n            nums = new ArrayList<Integer>();\n        }\n\n        /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\n        public boolean insert(int val) {\n            nums.add(val);\n            Set<Integer> set = idx.getOrDefault(val, new HashSet<Integer>());\n            set.add(nums.size() - 1);\n            idx.put(val, set);\n            return set.size() == 1;\n        }\n\n        /** Removes a value from the collection. Returns true if the collection contained the specified element. */\n        public boolean remove(int val) {\n            if (!idx.containsKey(val)) {\n                return false;\n            }\n            Iterator<Integer> it = idx.get(val).iterator();\n            int i = it.next();\n            int lastNum = nums.get(nums.size() - 1);\n            nums.set(i, lastNum);\n            idx.get(val).remove(i);\n            idx.get(lastNum).remove(nums.size() - 1);\n            if (i < nums.size() - 1) {\n                idx.get(lastNum).add(i);\n            }\n            if (idx.get(val).size() == 0) {\n                idx.remove(val);\n            }\n            nums.remove(nums.size() - 1);\n            return true;\n        }\n\n        /** Get a random element from the collection. */\n        public int getRandom() {\n            return nums.get((int) (Math.random() * nums.size()));\n        }\n    }"}],"tagList":["设计","数组","哈希表","数学","随机化"],"level":"Hard"}},{"problemName":"383.赎金信.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/383.赎金信.json","problemData":{"id":"383","name":"383.赎金信","url":"https://leetcode.cn/problems/ransom-note","desc":"给你一个赎金信 (ransomNote) 字符串和一个杂志(magazine)字符串，判断 ransomNote 能不能由 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false 。","solutions":[{"date":"2021-12-04","time":92,"memory":41,"script":"typescript","desc":"遍历。","code":"function canConstruct(ransomNote: string, magazine: string): boolean {\n  const map: Record<string, number> = {};\n  for (const c of magazine) map[c] = (map[c] ?? 0) + 1;\n  for (const c of ransomNote) {\n    if (!map[c]) return false;\n    map[c]--;\n  }\n  return true;\n}"},{"date":"2021-12-04","time":156,"memory":6.4,"script":"c","desc":"遍历。","code":"bool canConstruct(char * ransomNote, char * magazine){\n    int ans[26] = {0};\n    for (int i = 0; i < strlen(magazine); i++) ans[magazine[i] - 'a']++;\n    for (int i = 0; i < strlen(ransomNote); i++) {\n        if (!ans[ransomNote[i] - 'a']) return 0;\n        ans[ransomNote[i] - 'a']--;\n    }\n    return 1;\n}"},{"script":"python","time":48,"memory":17.06,"desc":"遍历。","code":"class Solution:\n    def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n        map = Counter(magazine)\n        for c in ransomNote:\n            map[c] -= 1\n            if map[c] < 0: return False\n        return True","date":"2024-01-07"}],"tagList":["哈希表","字符串","计数"],"level":"Easy"}},{"problemName":"384.打乱数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/384.打乱数组.json","problemData":{"id":"384","name":"384.打乱数组","url":"https://leetcode.cn/problems/shuffle-an-array","desc":"给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。","solutions":[{"date":"2021-07-30","time":236,"memory":54.1,"script":"typescript","desc":"生成随机数，利用交换打乱。","code":"class Solution {\n  constructor(private nums: number[]) {}\n  reset(): number[] {\n    return this.nums;\n  }\n  shuffle(): number[] {\n    const ans: number[] = this.nums.slice();\n    for (let i = 0; i < ans.length; i++) {\n      const random = this.random(i);\n      [ans[i], ans[random]] = [ans[random], ans[i]];\n    }\n    return ans;\n  }\n  private random(minNum: number) {\n    const maxNum = this.nums.length - 1;\n    return parseInt((Math.random() * (maxNum - minNum + 1) + minNum) as any, 10);\n  }\n}"},{"date":"2021-08-20","time":228,"memory":52.6,"script":"typescript","desc":"随机交换下标。","code":"class Solution {\n  constructor(public nums: number[]) {}\n  reset(): number[] {\n    return this.nums;\n  }\n  shuffle(): number[] {\n    const arr = [...this.nums];\n    for (let i = 0; i < arr.length; i++) {\n      const random = this.random(i, arr.length - 1);\n      [arr[i], arr[random]] = [arr[random], arr[i]];\n    }\n    return arr;\n  }\n  random(min: number, max: number): number {\n    return min + ~~(Math.random() * (max - min + 1));\n  }\n}"}],"tagList":["数组","数学","随机化"],"level":"Medium"}},{"problemName":"385.迷你语法分析器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/385.迷你语法分析器.json","problemData":{"id":"385","name":"385.迷你语法分析器","url":"https://leetcode.cn/problems/mini-parser","desc":"给定一个字符串 s 表示一个整数嵌套列表，实现一个解析它的语法分析器并返回解析的结果 NestedInteger 。","solutions":[{"date":"2022-03-19","time":12,"memory":12.9,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    NestedInteger deserialize(string s) {\n        if (s[0] == '[') return analysis(s.substr(1, s.size() - 2));\n        NestedInteger ans;\n        ans.setInteger(stoi(s));\n        return ans;\n    }\n    NestedInteger analysis(const string &s) {\n        NestedInteger ans;\n        vector<int> res = find_split(s);\n        int prev = -1;\n        for (auto &split : res) {\n            ans.add(deserialize(s.substr(prev + 1, split - prev - 1)));\n            prev = split;\n        }\n        string last = s.substr(prev + 1, s.size() - prev - 1);\n        if (last != \"\") ans.add(deserialize(last));\n        return ans;\n    }\n    vector<int> find_split(const string &s) {\n        int deep = 0;\n        vector<int> ans;\n        for (int i = 0; i < s.size(); i++) {\n            if (deep == 0 && s[i] == ',')\n                ans.push_back(i);\n            else if (s[i] == '[')\n                deep++;\n            else if (s[i] == ']')\n                deep--;\n        }\n        return ans;\n    }\n};"},{"date":"2022-04-15","time":8,"memory":12.3,"script":"cpp","desc":"递归遍历。","code":"class Solution {\n   public:\n    NestedInteger deserialize(string s) {\n        NestedInteger res;\n        if (s == \"[]\")\n            return res;\n        else if (s[0] == '[')\n            split(res, s.substr(1, s.size() - 2));\n        else\n            res.setInteger(stoi(s));\n        return res;\n    }\n    void split(NestedInteger &obj, string s) {\n        int level = 0, start = 0, n = s.size();\n        for (int i = 0; i < n; i++) {\n            char ch = s[i];\n            if (ch == '[')\n                level++;\n            else if (ch == ']')\n                level--;\n            else if (ch == ',' && level == 0)\n                obj.add(deserialize(s.substr(start, i - start))), start = i + 1;\n        }\n        obj.add(deserialize(s.substr(start, n - start)));\n    }\n};"}],"tagList":["栈","深度优先搜索","字符串"],"level":"Medium"}},{"problemName":"386.字典序排数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/386.字典序排数.json","problemData":{"id":"386","name":"386.字典序排数","url":"https://leetcode.cn/problems/lexicographical-numbers","desc":"给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。","solutions":[{"date":"2022-03-21","time":16,"memory":11.2,"script":"cpp","desc":"dfs 遍历每一层。","code":"class Solution {\n   public:\n    vector<int> lexicalOrder(int n) {\n        vector<int> ans;\n        for (int i = 1; i <= 9; i++) dfs(ans, n, i);\n        return ans;\n    }\n    void dfs(vector<int> &ans, int &max, int num) {\n        if (num > max) return;\n        ans.push_back(num);\n        for (int i = 0; i <= 9; i++) dfs(ans, max, num * 10 + i);\n    }\n};"},{"date":"2022-04-18","time":12,"memory":11.2,"script":"cpp","desc":"dfs。","code":"class Solution {\n   public:\n    vector<int> lexicalOrder(int n) {\n        vector<int> ans;\n        for (int i = 1; i <= 9; i++) dfs(ans, n, i);\n        return ans;\n    }\n    void dfs(vector<int> &ans, int &n, int num) {\n        if (num > n) return;\n        ans.push_back(num);\n        for (int i = 0; i <= 9; i++) dfs(ans, n, num * 10 + i);\n    }\n};"},{"date":"2022-04-18","time":8,"memory":10.2,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    vector<int> lexicalOrder(int n) {\n        vector<int> ans(n);\n        int num = 1;\n        for (int i = 0; i < n; i++) {\n            ans[i] = num;\n            if (num * 10 <= n)\n                num *= 10;\n            else {\n                while (num % 10 == 9 || num + 1 > n) num /= 10;\n                num++;\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["深度优先搜索","字典树"],"level":"Medium"}},{"problemName":"387.字符串中的第一个唯一字符.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/387.字符串中的第一个唯一字符.json","problemData":{"id":"387","name":"387.字符串中的第一个唯一字符","url":"https://leetcode.cn/problems/first-unique-character-in-a-string","desc":"给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。","solutions":[{"date":"2020-12-23","time":160,"memory":43.4,"script":"typescript","desc":"遍历后储存成 set。","code":"function firstUniqChar(s: string): number {\n  const dict: Record<string, number> = {};\n  for (const c of s) {\n    dict[c] = (dict[c] ?? 0) + 1;\n  }\n  const set = new Set(\n    Object.entries(dict)\n      .filter(([, v]) => v === 1)\n      .map(([k]) => k)\n  );\n  for (let i = 0, l = s.length; i < l; i++) {\n    if (set.has(s[i])) return i;\n  }\n  return -1;\n}"}],"tagList":["队列","哈希表","字符串","计数"],"level":"Easy"}},{"problemName":"388.文件的最长绝对路径.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/388.文件的最长绝对路径.json","problemData":{"id":"388","name":"388.文件的最长绝对路径","url":"https://leetcode.cn/problems/longest-absolute-file-path","desc":"给定一个以上述格式表示文件系统的字符串 input ，返回文件系统中 指向 文件 的 最长绝对路径 的长度 。 如果系统中没有文件，返回 0。","solutions":[{"date":"2022-03-24","time":68,"memory":42.4,"script":"typescript","desc":"遍历，栈存储父级。","code":"class FNode {\n  parent: FNode | null = null;\n  constructor(public name: string, public level: number) {}\n  path() {\n    let res = this.name;\n    let parent = this.parent;\n    while (parent) {\n      res = parent.name + '/' + res;\n      parent = parent.parent;\n    }\n    return res;\n  }\n  isFile() {\n    return this.name.includes('.');\n  }\n}\nfunction format(str: string): [number, string] {\n  let level = 0;\n  while (str[level] == '\\t') level++;\n  return [level, str.substr(level)];\n}\nfunction lengthLongestPath(input: string): number {\n  const stack: FNode[] = [];\n  let ans = '';\n  for (const item of input.split('\\n')) {\n    const [level, str] = format(item);\n    const node = new FNode(str, level);\n    while (stack.length && stack[stack.length - 1].level >= level) stack.pop();\n    if (stack.length) {\n      const parent = stack[stack.length - 1];\n      node.parent = parent;\n    }\n    stack.push(node);\n    if (node.isFile()) {\n      const path = node.path();\n      ans = ans.length < path.length ? path : ans;\n    }\n  }\n  return ans.length;\n}"},{"date":"2022-04-20","time":0,"memory":6.4,"script":"cpp","desc":"栈。","code":"class Solution {\n   public:\n    int lengthLongestPath(string input) {\n        vector<string> s;\n        istringstream iss(input);\n        string tmp;\n        int ans = 0;\n        while (getline(iss, tmp, '\n')) {\n            int idx = 0;\n            while (idx < tmp.size() && tmp[idx] == '\t') idx++;\n            while (s.size() && s.size() > idx) s.pop_back();\n            string next = tmp.substr(idx, tmp.size() - idx);\n            s.push_back(next);\n            if (next.rfind(\".\") < next.size()) ans = max(ans, format(s));\n        }\n        return ans;\n    }\n    int format(vector<string> &s) {\n        int res = s.size() - 1;\n        for (auto &str : s) res += str.size();\n        return res;\n    }\n};"}],"tagList":["栈","深度优先搜索","字符串"],"level":"Medium"}},{"problemName":"389.找不同.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/389.找不同.json","problemData":{"id":"389","name":"389.找不同","url":"https://leetcode.cn/problems/find-the-difference","desc":"给定两个字符串 s 和 t，它们只包含小写字母。字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。请找出在 t 中被添加的字母。","solutions":[{"date":"2020-12-18","time":96,"memory":40.5,"script":"typescript","desc":"利用哈希表储存。","code":"function findTheDifference(s: string, t: string): string {\n  const cache: Record<string, number> = {};\n  const setCache = (num: number) => (c: string) => (cache[c] = num + (cache[c] ?? 0));\n  const add = setCache(1);\n  const minus = setCache(-1);\n  for (const c of s) add(c);\n  for (const c of t) {\n    if (!cache[c]) return c;\n    minus(c);\n  }\n  return '';\n}"}],"tagList":["位运算","哈希表","字符串","排序"],"level":"Easy"}},{"problemName":"390.消除游戏.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/390.消除游戏.json","problemData":{"id":"390","name":"390.消除游戏","url":"https://leetcode.cn/problems/elimination-game","desc":"给你整数 n ，返回 arr 最后剩下的数字。","solutions":[{"date":"2022-01-04","time":0,"memory":5.8,"script":"cpp","desc":"dfs, 每次减少后都为等差数列，记录每次的头值和间隔。","code":"class Solution {\n   public:\n    /*\n    cnt 有多少个\n    step 每个间隔多少\n    start 起始值\n    dir 方向\n    */\n    int dfs(int cnt, int step, int start, int dir) {\n        if (cnt == 1) return start;\n        return dfs(cnt >> 1, step << 1,\n                   start + (dir == 1 || cnt & 1 ? step : 0), dir * -1);\n    }\n    int lastRemaining(int n) { return dfs(n, 1, 1, 1); }\n};"}],"tagList":["递归","数学"],"level":"Medium"}},{"problemName":"391.完美矩形.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/391.完美矩形.json","problemData":{"id":"391","name":"391.完美矩形","url":"https://leetcode.cn/problems/perfect-rectangle","desc":"如果所有矩形一起精确覆盖了某个矩形区域，则返回 true ；否则，返回 false 。","solutions":[{"date":"2021-11-16","time":272,"memory":62.8,"script":"typescript","desc":"计数判断面积和顶点重合次数。","code":"function isRectangleCover(rectangles: number[][]): boolean {\n  /**\n           完美矩形要满足:\n           1. 最左上、左下、右上、右下四个顶点只出现1次;\n           2. 重合顶点重合次数必须为2、4，不能出现一次。\n           3. 大矩形面积等于小矩形面积之和。\n           */\n  type Data = { cnt: number; point: number[] };\n  const set = new Set<string>();\n  const map: Record<string, Data> = {};\n  const format = (x: number, y: number) => `${x}:${y}`;\n  const map_add = (x: number, y: number) => {\n    const formatStr = format(x, y);\n    let data = map[formatStr];\n    if (!data) map[formatStr] = data = { cnt: 0, point: [x, y] };\n    data.cnt++;\n  };\n  let sum = 0;\n  const vertex: number[] = [];\n  const is_vertex = (x: number, y: number) =>\n    (x === vertex[0] && y === vertex[1]) ||\n    (x === vertex[2] && y === vertex[3]) ||\n    (x === vertex[0] && y === vertex[3]) ||\n    (x === vertex[2] && y === vertex[1]);\n  for (const [x, y, a, b] of rectangles) {\n    const formatStr = format(x, y) + ':' + format(a, b);\n    if (set.has(formatStr)) return false;\n    set.add(formatStr);\n    if (vertex[0] === undefined || vertex[0] > x || vertex[1] > y) {\n      vertex[0] = x;\n      vertex[1] = y;\n    }\n    if (vertex[2] === undefined || vertex[2] < a || vertex[3] < b) {\n      vertex[2] = a;\n      vertex[3] = b;\n    }\n    sum += (a - x) * (b - y);\n    map_add(x, y);\n    map_add(a, b);\n    map_add(x, b);\n    map_add(a, y);\n  }\n  if ((vertex[2] - vertex[0]) * (vertex[3] - vertex[1]) !== sum) return false;\n  for (const {\n    cnt,\n    point: [x, y],\n  } of Object.values(map)) {\n    if ((cnt === 1 && !is_vertex(x, y)) || (cnt !== 1 && cnt !== 2 && cnt !== 4)) {\n      return false;\n    }\n  }\n  return true;\n}"}],"tagList":["数组","扫描线"],"level":"Hard"}},{"problemName":"392.判断子序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/392.判断子序列.json","problemData":{"id":"392","name":"392.判断子序列","url":"https://leetcode.cn/problems/is-subsequence","desc":"给定字符串 s 和 t ，判断 s 是否为 t 的子序列。","solutions":[{"date":"2020-07-27","time":88,"memory":38,"script":"typescript","desc":"循环一次进行判断是否包含。","code":"function isSubsequence(s: string, t: string): boolean {\n  const arr = s.split('');\n  for (const c of t) {\n    if (arr.length === 0) break;\n    if (c === arr[0]) arr.shift();\n  }\n  return arr.length === 0;\n}"}],"tagList":["双指针","字符串","动态规划"],"level":"Easy"}},{"problemName":"393.UTF-8编码验证.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/393.UTF-8编码验证.json","problemData":{"id":"393","name":"393.UTF-8编码验证","url":"https://leetcode.cn/problems/utf-8-validation","desc":"给定一个表示数据的整数数组 data ，返回它是否为有效的 UTF-8 编码。","solutions":[{"date":"2022-03-13","time":4,"memory":13.5,"script":"cpp","desc":"遍历。","code":"#define MAXBIT 7\n·class Solution {\n   public:\n    bool validUtf8(vector<int>& data) {\n        int n = data.size(), remain = 0;\n        for (auto& byte : data) {\n            if (remain) {\n                // 有残留但不是10\n                if (!check10(byte)) return false;\n                remain--;\n                continue;\n            }\n            if ((byte & 1 << MAXBIT) == 0) continue;\n            // 无残留但是10\n            if (check10(byte)) return false;\n            while (remain < MAXBIT && (1 << (MAXBIT - remain - 1) & byte) > 0)\n                remain++;\n            // 剩余残留>3\n            if (remain >= 4) return false;\n        }\n        return remain == 0;\n    }\n    bool check10(int byte) {\n        return (byte & 1 << MAXBIT) > 0 && (byte & 1 << (MAXBIT - 1)) == 0;\n    }\n};"}],"tagList":["位运算","数组"],"level":"Medium"}},{"problemName":"394.字符串解码.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/394.字符串解码.json","problemData":{"id":"394","name":"394.字符串解码","url":"https://leetcode.cn/problems/decode-string","desc":"给定一个经过编码的字符串，返回它解码后的字符串。","solutions":[{"date":"2020-05-28","time":64,"memory":32.3,"script":"typescript","desc":"判断是数字还是字母还是[]符号，然后递归遍历。","code":"const numReg = /\\d/;\nconst charReg = /[a-zA-Z]{1}/;\nvar decodeString = function (s: string): string {\n  let res = '';\n  let numCache = '';\n  for (let i = 0, len = s.length; i < len; i++) {\n    const c = s[i];\n    if (charReg.test(c)) {\n      res += c;\n    } else if (numReg.test(c)) {\n      numCache += c;\n    } else if (c === '[') {\n      let count = 1;\n      let lastIndex = i;\n      while (count !== 0 && lastIndex < len) {\n        lastIndex++;\n        if (s[lastIndex] === '[') count++;\n        if (s[lastIndex] === ']') count--;\n      }\n      const inS = decodeString(s.substring(i + 1, lastIndex));\n      i = lastIndex;\n      let insert = '';\n      for (let j = 0; j < +numCache; j++) insert += inS;\n      res += insert;\n      numCache = '';\n    }\n  }\n  return res;\n};"},{"date":"2021-05-07","time":132,"memory":39.3,"script":"typescript","desc":"栈储存。","code":"function decodeString(s: string): string {\n  const numReg = /\\d/;\n  const stack: string[] = [];\n  for (const c of s) {\n    if (c === ']') {\n      let str = '';\n      while (stack[stack.length - 1] !== '[') str = stack.pop()! + str;\n      stack.pop();\n      let numStr = '';\n      while (stack.length !== 0 && numReg.test(stack[stack.length - 1]))\n        numStr = stack.pop() + numStr;\n      str = str.repeat(+numStr);\n      stack.push(str);\n    } else {\n      stack.push(c);\n    }\n  }\n  return stack.join('');\n}"}],"tagList":["栈","递归","字符串"],"level":"Medium"}},{"problemName":"395.至少有K个重复字符的最长子串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/395.至少有K个重复字符的最长子串.json","problemData":{"id":"395","name":"395.至少有K个重复字符的最长子串","url":"https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters","desc":"给你一个二维整数数组 matrix， 返回 matrix 的 转置矩阵 。","solutions":[{"date":"2021-02-27","time":148,"memory":42.2,"script":"typescript","desc":"读取可能值进行最长比较。","code":"function longestSubstring(s: string, k: number): number {\n  const len = s.length;\n  if (len === 1) return +(k === 1);\n  const map: Record<string, number> = {};\n  for (const c of s) map[c] = (map[c] ?? 0) + 1;\n  const set = new Set(\n    Object.entries(map)\n      .filter(([, v]) => v < k)\n      .map(([k]) => k)\n  );\n  const runtimeMap = new Map<string, number>();\n  const runtimeSet = new Set<string>();\n  let ans = 0;\n  for (let i = 0; i < len; i++) {\n    const c = s[i];\n    if (set.has(c)) continue;\n    runtimeMap.clear();\n    runtimeSet.clear();\n    runtimeMap.set(c, 1);\n    if (k > 1) runtimeSet.add(c);\n    let lastIndex = i;\n    while (++lastIndex < len) {\n      const newChar = s[lastIndex];\n      if (set.has(newChar)) break;\n      const charCount = (runtimeMap.get(newChar) ?? 0) + 1;\n      runtimeMap.set(newChar, charCount);\n      charCount >= k ? runtimeSet.delete(newChar) : runtimeSet.add(newChar);\n      if (runtimeSet.size === 0) ans = Math.max(ans, lastIndex - i + 1);\n    }\n  }\n  return ans;\n}"},{"date":"2021-02-27","time":100,"memory":40.4,"script":"typescript","desc":"递归,分治。","code":"function longestSubstring(s: string, k: number): number {\n  const len = s.length;\n  if (len === 0) return 0;\n  if (len === 1) return +(k === 1);\n  const map: Record<string, number> = {};\n  for (const c of s) map[c] = (map[c] ?? 0) + 1;\n  const regStr = Object.entries(map)\n    .filter(([, v]) => v < k)\n    .map(([k]) => k)\n    .join('|');\n  if (regStr.length === 0) return s.length;\n  const arr = s.split(new RegExp(regStr));\n  return Math.max(...arr.map(str => longestSubstring(str, k)));\n}"},{"date":"2021-02-27","time":88,"memory":40.3,"script":"typescript","desc":"递归,分治。","code":"function longestSubstring(s: string, k: number): number {\n  const len = s.length;\n  if (len === 0) return 0;\n  if (len === 1) return +(k === 1);\n  const map: Record<string, number> = {};\n  for (const c of s) map[c] = (map[c] ?? 0) + 1;\n  const regStr = Object.keys(map)\n    .filter(key => map[key] < k)\n    .join('|');\n  if (regStr.length === 0) return s.length;\n  const arr = s.split(new RegExp(regStr));\n  return Math.max(...arr.map(str => longestSubstring(str, k)));\n}"},{"date":"2021-02-27","time":88,"memory":40.3,"script":"typescript","desc":"递归,分治。","code":"function longestSubstring(s: string, k: number): number {\n  const len = s.length;\n  if (len === 0) return 0;\n  if (len === 1) return +(k === 1);\n  const map: Record<string, number> = {};\n  for (const c of s) map[c] = (map[c] ?? 0) + 1;\n  const regStr = Object.keys(map)\n    .filter(key => map[key] < k)\n    .join('|');\n  if (regStr.length === 0) return s.length;\n  const arr = s.split(new RegExp(regStr));\n  return Math.max(...arr.map(str => longestSubstring(str, k)));\n}"},{"date":"2021-07-29","time":80,"memory":40.4,"script":"typescript","desc":"分割字符串分别统计。","code":"function longestSubstring(s: string, k: number): number {\n  const map: Record<string, number> = {};\n  for (const c of s) map[c] = (map[c] ?? 0) + 1;\n  const splits: number[] = [];\n  for (let i = 0; i < s.length; i++) {\n    if (map[s[i]] < k) splits.push(i);\n  }\n  splits.push(s.length);\n  if (splits.length === 1) return s.length;\n  let pre = 0;\n  let ans = 0;\n  for (const p of splits) {\n    const len = p - pre;\n    if (len >= k) {\n      ans = Math.max(ans, longestSubstring(s.substr(pre, len), k));\n    }\n    pre = p + 1;\n  }\n  return ans;\n}"}],"tagList":["哈希表","字符串","分治","滑动窗口"],"level":"Medium"}},{"problemName":"396.旋转函数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/396.旋转函数.json","problemData":{"id":"396","name":"396.旋转函数","url":"https://leetcode.cn/problems/rotate-function","desc":"返回 F(0), F(1), ..., F(n-1)中的最大值 。","solutions":[{"date":"2022-04-22","time":140,"memory":93.6,"script":"cpp","desc":"每一次的值可以从上一次推导过来 f(n) = f(n-1) + sum - n \\* nums[i]。","code":"class Solution {\n   public:\n    int maxRotateFunction(vector<int>& nums) {\n        int sum = 0, prev = 0, n = nums.size();\n        for (int i = 0; i < n; i++) {\n            sum += nums[i];\n            prev += nums[i] * i;\n        }\n        int ans = prev;\n        for (int i = n - 1; i > 0; i--, ans = max(ans, prev))\n            prev = prev + sum - n * nums[i];\n        return ans;\n    }\n};"}],"tagList":["数组","数学","动态规划"],"level":"Medium"}},{"problemName":"397.整数替换.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/397.整数替换.json","problemData":{"id":"397","name":"397.整数替换","url":"https://leetcode.cn/problems/integer-replacement","desc":"给定一个正整数 n ，n 变为 1 所需的最小替换次数是多少？。","solutions":[{"date":"2021-11-19","time":80,"memory":39.4,"script":"typescript","desc":"dfs。","code":"const map: Record<number, number> = { 1: 0 };\nfunction integerReplacement(n: number): number {\n  if (map[n] !== undefined) return map[n];\n  const ans =\n    (n & 1\n      ? Math.min(integerReplacement(n + 1), integerReplacement(n - 1))\n      : integerReplacement(n / 2)) + 1;\n  return (map[n] = ans);\n}"}],"tagList":["贪心","位运算","记忆化搜索","动态规划"],"level":"Medium"}},{"problemName":"398.随机数索引.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/398.随机数索引.json","problemData":{"id":"398","name":"398.随机数索引","url":"https://leetcode.cn/problems/random-pick-index","desc":"给定一个可能含有重复元素的整数数组，要求随机输出给定的数字的索引。 您可以假设给定的数字一定存在于数组中。","solutions":[{"date":"2022-04-25","time":92,"memory":37.3,"script":"cpp","desc":"排序后二分遍历。","code":"class Solution {\n   public:\n    vector<int> idxs, nums;\n    int n;\n    Solution(vector<int> &nums) {\n        srand(time(0));\n        this->nums = nums;\n        n = nums.size();\n        for (int i = 0; i < n; i++) idxs.push_back(i);\n        sort(idxs.begin(), idxs.end(),\n             [&](int &i1, int &i2) -> bool { return nums[i1] < nums[i2]; });\n    }\n    int pick(int target) {\n        int start = find1(0, n, target);\n        int end = find2(start, n - 1, target);\n        return idxs[random(start, end)];\n    }\n    int find1(int l, int r, int target) {\n        int m;\n        while (l < r) {\n            m = (l + r) >> 1;\n            if (nums[idxs[m]] >= target)\n                r = m;\n            else\n                l = m + 1;\n        }\n        return l;\n    }\n    int find2(int l, int r, int target) {\n        int m;\n        while (l < r) {\n            m = (l + r + 1) >> 1;\n            if (nums[idxs[m]] <= target)\n                l = m;\n            else\n                r = m - 1;\n        }\n        return l;\n    }\n    int random(int a, int b) { return rand() % (b - a + 1) + a; }\n};"},{"date":"2022-04-25","time":44,"memory":34.7,"script":"cpp","desc":"水塘抽样。","code":"class Solution {\n   public:\n    vector<int> nums;\n    int n;\n    Solution(vector<int>& nums) {\n        this->nums = nums;\n        n = nums.size();\n        srand(time(0));\n    }\n    int pick(int target) {\n        int cnt = 0, ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] != target) continue;\n            if (rand() % ++cnt == 0) {\n                ans = i;\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["水塘抽样","哈希表","数学","随机化"],"level":"Medium"}},{"problemName":"400.第N位数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/301-400/400.第N位数字.json","problemData":{"id":"400","name":"400.第N位数字","url":"https://leetcode.cn/problems/nth-digit","desc":"给你一个整数 n ，请你在无限的整数序列 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...] 中找出并返回第 n 位数字。","solutions":[{"date":"2021-11-30","time":68,"memory":39.4,"script":"typescript","desc":"直接分区间查找。","code":"// 每一段具有相同位数的数字算一个区间\nfunction findNthDigit(n: number): number {\n  // 当前数字占几位\n  let bit = 1;\n  // 当前区间最大值\n  let max = 9;\n  // 当前区间最小值\n  let min = 1;\n  // 前区间占用位数\n  let cnt = 0;\n  // 判断n是否大于下一个区间数量，大于则移动至下一区间\n  while (n > cnt + (max - Math.floor(max / 10)) * bit) {\n    cnt += (max - Math.floor(max / 10)) * bit++;\n    max = max * 10 + 9;\n    min *= 10;\n  }\n  // 删除前一区间的量\n  n -= cnt;\n  // 计算当前区间中所指向的数字\n  const num = Math.floor((n - 1) / bit) + min;\n  return +num.toString()[(n - 1) % bit];\n}"}],"tagList":["数学","二分查找"],"level":"Medium"}}]},{"dirName":"3101-3200","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\3101-3200","problems":[{"problemName":"3101.交替子数组计数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/3101-3200/3101.交替子数组计数.json","problemData":{"id":"3374","name":"3101.交替子数组计数","url":"https://leetcode.cn/problems/count-alternating-subarrays","desc":"返回数组 nums 中交替子数组的数量。","solutions":[{"script":"python","time":102,"memory":20.2,"desc":"遍历时获取最长交替子数组用等差数列求和。","code":"class Solution:\n    def countAlternatingSubarrays(self, nums: List[int]) -> int:\n        n = len(nums)\n        res = cur = 0\n        while cur < n:\n            start = cur\n            while cur + 1 < n and nums[cur] != nums[cur + 1]: cur += 1\n            res += (1 + (cur - start + 1)) * (cur - start + 1) // 2\n            cur += 1\n        return res","date":"2024-07-06"}],"tagList":["数组","数学"],"level":"Medium"}},{"problemName":"3106.满足距离约束且字典序最小的字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/3101-3200/3106.满足距离约束且字典序最小的字符串.json","problemData":{"id":"3346","name":"3106.满足距离约束且字典序最小的字符串","url":"https://leetcode.cn/problems/lexicographically-smallest-string-after-operations-with-constraint","desc":"你可以对字符串 s 执行 任意次 操作。在每次操作中，可以将 s 中的一个字母 改变 为 任意 其他小写英文字母。返回一个字符串，表示在执行一些操作后你可以得到的 字典序最小 的字符串 t ，且满足 distance(s, t) <= k 。","solutions":[{"script":"python","time":48,"memory":16.46,"desc":"贪心遍历。","code":"class Solution:\n    def getSmallestString(self, s: str, k: int) -> str:\n        arr = list(s)\n        orda = ord('a')\n        for i in range(len(arr)):\n            ordc = ord(arr[i])\n            min_to_a = min(ordc - orda, orda + 26 - ordc)\n            if min_to_a <= k:\n                arr[i] = 'a'\n                k -= min_to_a\n            else:\n                ordc -= orda\n                arr[i] = chr(orda + min(ordc - k, (ordc + k) % 26))\n                break\n        return ''.join(arr)","date":"2024-07-27"}],"tagList":["贪心","字符串"],"level":"Medium"}},{"problemName":"3111.覆盖所有点的最少矩形数目.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/3101-3200/3111.覆盖所有点的最少矩形数目.json","problemData":{"id":"3390","name":"3111.覆盖所有点的最少矩形数目","url":"https://leetcode.cn/problems/minimum-rectangles-to-cover-points","desc":"请你在确保每个点都 至少 被一个矩形覆盖的前提下，最少 需要多少个矩形。","solutions":[{"script":"python","time":128,"memory":47.47,"desc":"排序后贪心放置矩形。","code":"class Solution:\n    def minRectanglesToCoverPoints(self, points: List[List[int]], w: int) -> int:\n        points.sort(key = lambda p: p[0])\n        res = 0\n        last = -1\n        for point in points:\n            if point[0] <= last: continue\n            res += 1\n            last = point[0] + w\n        return res","date":"2024-07-31"}],"tagList":["贪心","数组","排序"],"level":"Medium"}},{"problemName":"3112.访问消失节点的最少时间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/3101-3200/3112.访问消失节点的最少时间.json","problemData":{"id":"3389","name":"3112.访问消失节点的最少时间","url":"https://leetcode.cn/problems/minimum-time-to-visit-disappearing-nodes","desc":"请你返回数组 answer ，answer[i] 表示从节点 0 到节点 i 需要的 最少 单位时间。如果从节点 0 出发 无法 到达节点 i ，那么 answer[i] 为 -1 。","solutions":[{"script":"python","time":921,"memory":72.21,"desc":"图短路求出当前点到其他点的最短时间。","code":"class Solution:\n    def minimumTime(self, n: int, edges: List[List[int]], disappear: List[int]) -> List[int]:\n        nodes = [defaultdict(lambda :inf) for _ in range(n)]\n        for n1, n2, v in edges:\n            if n1 != n2:\n                nodes[n1][n2] = nodes[n2][n1] = min(nodes[n1][n2], v)\n        q = [(0, 0)]\n        res = [-1] * n\n        res[0] = 0\n        used = [False] * n\n        while q:\n            t, node = heappop(q)\n            if used[node]: continue\n            used[node] = True\n            res[node] = t\n            for child in nodes[node].keys():\n                next_t = t + nodes[node][child]\n                if not used[child] and next_t < disappear[child]:\n                    heappush(q, (next_t, child))\n        return res","date":"2024-07-18"}],"tagList":["图","数组","最短路","堆（优先队列）"],"level":"Medium"}},{"problemName":"3115.质数的最大距离.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/3101-3200/3115.质数的最大距离.json","problemData":{"id":"3373","name":"3115.质数的最大距离","url":"https://leetcode.cn/problems/maximum-prime-difference","desc":"返回两个（不一定不同的）质数在 nums 中 下标 的 最大距离。","solutions":[{"script":"python","time":403,"memory":28.54,"desc":"遍历。","code":"def is_prime(num: int) -> bool:\n    if num < 2: return False\n    for v in range(2, num):\n        if num % v == 0: return False\n    return True\narr = [is_prime(num) for num in range(103)]\n\nclass Solution:\n    def maximumPrimeDifference(self, nums: List[int]) -> int:\n        v1 = v2 = -1\n        for i in range(len(nums)):\n            if is_prime(nums[i]):\n                if v1 == -1: v1 = i\n                v2 = i\n        return v2 - v1\n                    ","date":"2024-07-02"},{"script":"python","time":84,"memory":28.54,"desc":"遍历。","code":"def is_prime(num: int) -> bool:\n    if num < 2: return False\n    for v in range(2, num):\n        if num % v == 0: return False\n    return True\narr = [is_prime(num) for num in range(103)]\n\nclass Solution:\n    def maximumPrimeDifference(self, nums: List[int]) -> int:\n        v1 = v2 = -1\n        for i in range(len(nums)):\n            if arr[nums[i]]:\n                if v1 == -1: v1 = i\n                v2 = i\n        return v2 - v1","date":"2024-07-03"}],"tagList":["数组","数学","数论"],"level":"Medium"}},{"problemName":"3128.直角三角形.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/3101-3200/3128.直角三角形.json","problemData":{"id":"3388","name":"3128.直角三角形","url":"https://leetcode.cn/problems/right-triangles","desc":"给你一个二维 boolean 矩阵 grid 。请你返回使用 grid 中的 3 个元素可以构建的 直角三角形 数目，且满足 3 个元素值 都 为 1 。","solutions":[{"script":"python","time":476,"memory":44.82,"desc":"遍历每一个1，查找垂直和水平方向上的所有的其他1的个数。","code":"class Solution:\n    def numberOfRightTriangles(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        m = len(grid[0])\n        rows = [sum(grid[i][j] for j in range(m)) for i in range(n)]\n        cols = [sum(grid[i][j] for i in range(n)) for j in range(m)]\n        return sum(\n            (rows[i] - 1) * (cols[j] - 1)\n            for i in range(n)\n            for j in range(m)\n            if grid[i][j]\n        )","date":"2024-08-02"}],"tagList":["数组","哈希表","数学","组合数学","计数"],"level":"Medium"}},{"problemName":"3131.找出与数组相加的整数I.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/3101-3200/3131.找出与数组相加的整数I.json","problemData":{"name":"3131.找出与数组相加的整数I","url":"https://leetcode.cn/problems/find-the-integer-added-to-array-i","desc":"给你两个长度相等的数组 nums1 和 nums2。数组 nums1 中的每个元素都与变量 x 所表示的整数相加。如果 x 为负数，则表现为元素值的减少。在与 x 相加后，nums1 和 nums2 相等 。当两个数组中包含相同的整数，并且这些整数出现的频次相同时，两个数组 相等 。返回整数 x 。","solutions":[{"script":"python","time":33,"memory":16.32,"desc":"一定存在x使其相等，则直接找对应位置的数字进行求差值。","code":"class Solution:\n    def addedInteger(self, nums1: List[int], nums2: List[int]) -> int:\n        return max(nums2) - max(nums1)","date":"2024-08-08"}],"tagList":[],"level":"Easy"}},{"problemName":"3132.找出与数组相加的整数II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/3101-3200/3132.找出与数组相加的整数II.json","problemData":{"name":"3132.找出与数组相加的整数II","url":"https://leetcode.cn/problems/find-the-integer-added-to-array-ii/","desc":"给你两个整数数组 nums1 和 nums2。从 nums1 中移除两个元素，并且所有其他元素都与变量 x 所表示的整数相加。如果 x 为负数，则表现为元素值的减少。执行上述操作后，nums1 和 nums2 相等 。当两个数组中包含相同的整数，并且这些整数出现的频次相同时，两个数组 相等 。返回能够实现数组相等的 最小 整数 x 。","solutions":[{"script":"python","time":562,"memory":16.57,"desc":"排序后暴力枚举。","code":"class Solution:\n    def minimumAddedInteger(self, nums1: List[int], nums2: List[int]) -> int:\n        nums1.sort()\n        nums2.sort()\n        n = len(nums1)\n        res = inf\n        for i in range(n):\n            for j in range(i):\n                i1 = 0\n                while i1 < n and (i1 == i or i1 == j): i1 += 1\n                i2 = 0\n                diff = nums2[i2] - nums1[i1]\n                need_skip = False\n                while i1 < n:\n                    if nums2[i2] - nums1[i1] != diff:\n                        need_skip = True\n                        break\n                    i1 += 1\n                    while i1 < n and (i1 == i or i1 == j): i1 += 1\n                    i2 += 1\n                if not need_skip:\n                    res = min(res, diff)\n        return res","date":"2024-08-09"}],"tagList":[],"level":"Easy"}},{"problemName":"3143.正方形中的最多点数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/3101-3200/3143.正方形中的最多点数.json","problemData":{"id":"3419","name":"3143.正方形中的最多点数","url":"https://leetcode.cn/problems/maximum-points-inside-the-square","desc":"请你返回 合法 正方形中可以包含的 最多 点数。","solutions":[{"script":"python","time":154,"memory":47.63,"desc":"排序后遍历。","code":"class Solution:\n    def maxPointsInsideSquare(self, points: List[List[int]], s: str) -> int:\n        get_edge = lambda i: max(abs(points[i][0]), abs(points[i][1]))\n        idxs = sorted([i for i in range(len(points))], key = get_edge)\n        used = set()\n        res = i = 0\n        while i < len(idxs):\n            edge = get_edge(idxs[i])\n            cnt = 1\n            if s[idxs[i]] in used: break\n            used.add(s[idxs[i]])\n            while i + 1 < len(idxs) and get_edge(idxs[i + 1]) == edge:\n                i += 1\n                if s[idxs[i]] in used: return res\n                used.add(s[idxs[i]])\n                cnt += 1\n            res += cnt\n            i += 1\n        return res","date":"2024-08-03"}],"tagList":["数组","哈希表","字符串","二分查找","排序"],"level":"Medium"}}]},{"dirName":"401-500","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\401-500","problems":[{"problemName":"401.二进制手表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/401.二进制手表.json","problemData":{"id":"401","name":"401.二进制手表","url":"https://leetcode.cn/problems/binary-watch","desc":"二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。","solutions":[{"date":"2021-06-21","time":96,"memory":42.2,"script":"typescript","desc":"全排列。","code":"const getTime = (hour: number, minute: number): string =>\n  `${hour}:${minute < 10 ? '0' + minute : minute}`;\nconst getList = (count: number, data: number[], maxNumber) => {\n  const ans: Set<number> = new Set();\n  if (count >= data.length) return ans;\n  if (count === 0) {\n    ans.add(0);\n    return ans;\n  }\n  for (let i = 0, len = data.length; i < len; i++) {\n    const num = 1 << data[i];\n    const list = getList(count - 1, [...data.slice(0, i), ...data.slice(i + 1)], maxNumber);\n    if (list.size === 0) ans.add(num);\n    else {\n      list.forEach(v => {\n        const item = v | num;\n        item <= maxNumber && ans.add(item);\n      });\n    }\n  }\n  return ans;\n};\nconst getHourList = (count: number) =>\n  getList(\n    count,\n    new Array(4).fill(0).map((_, i) => i),\n    11\n  );\nconst getMinuteList = (count: number) =>\n  getList(\n    count,\n    new Array(6).fill(0).map((_, i) => i),\n    59\n  );\nfunction readBinaryWatch(turnedOn: number): string[] {\n  if (turnedOn >= 9) return [];\n  if (turnedOn === 0) return ['0:00'];\n  return new Array(Math.min(4, turnedOn) + 1)\n    .fill(0)\n    .map((_, i) => {\n      return [i, turnedOn - i];\n    })\n    .map(([hour, minute]) => {\n      const ans: string[] = [];\n      const hourList = getHourList(hour);\n      const minuteList = getMinuteList(minute);\n      if (hourList.size === 0 || minuteList.size === 0) return ans;\n      for (const hour of hourList) {\n        for (const minute of minuteList) {\n          ans.push(getTime(hour, minute));\n        }\n      }\n      return ans;\n    })\n    .flat();\n}"}],"tagList":["位运算","回溯"],"level":"Easy"}},{"problemName":"402.移掉K位数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/402.移掉K位数字.json","problemData":{"id":"402","name":"402.移掉K位数字","url":"https://leetcode.cn/problems/remove-k-digits","desc":"给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。","solutions":[{"date":"2020-11-15","time":104,"memory":41.2,"script":"typescript","desc":"贪心，单调性，越小的数字在前面。","code":"function removeKdigits(num: string, k: number): string {\n  const stack: number[] = [];\n  const isEmpty = () => stack.length === 0;\n  for (const c of num) {\n    const toNum = Number(c);\n    if (isEmpty()) {\n      stack.push(toNum);\n    } else {\n      let top = stack[stack.length - 1];\n      while (toNum < top && k !== 0) {\n        stack.pop();\n        k--;\n        top = stack[stack.length - 1];\n      }\n      stack.push(toNum);\n    }\n  }\n  while (k-- !== 0) stack.pop();\n  while (!isEmpty() && stack[0] === 0) stack.shift();\n  return isEmpty() ? '0' : stack.join('');\n}"},{"date":"2021-07-30","time":92,"memory":40.2,"script":"typescript","desc":"单调栈。","code":"function removeKdigits(num: string, k: number): string {\n  const stack: number[] = [];\n  for (let i = 0; i < num.length; i++) {\n    const v = num.codePointAt(i)! - '0'.codePointAt(0)!;\n    while (k && stack.length && stack[stack.length - 1] > v) {\n      stack.pop();\n      k--;\n    }\n    stack.push(v);\n  }\n  while (stack.length && k) {\n    stack.pop();\n    k--;\n  }\n  while (stack.length && stack[0] === 0) stack.shift();\n  return stack.join('') || '0';\n}"}],"tagList":["栈","贪心","字符串","单调栈"],"level":"Medium"}},{"problemName":"403.青蛙过河.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/403.青蛙过河.json","problemData":{"id":"403","name":"403.青蛙过河","url":"https://leetcode.cn/problems/frog-jump","desc":"一只青蛙想要过河。","solutions":[{"date":"2021-04-29","time":948,"memory":44.5,"script":"typescript","desc":"动态规划，记录每个石头可跳的步数。","code":"function canCross(stones: number[]): boolean {\n  const len = stones.length;\n  const dp: Set<number>[] = new Array(len).fill(0).map(_ => new Set<number>());\n  dp[0].add(0);\n  for (let i = 1; i < len; i++) {\n    const stone = stones[i];\n    for (let j = 0; j < i; j++) {\n      const minus = stone - stones[j];\n      const set = dp[j];\n      if (set.size === 0) continue;\n      if (set.has(minus) || set.has(minus - 1) || set.has(minus + 1)) {\n        dp[i].add(minus);\n      }\n    }\n  }\n  return dp[len - 1].size !== 0;\n}"}],"tagList":["数组","动态规划"],"level":"Hard"}},{"problemName":"404.左叶子之和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/404.左叶子之和.json","problemData":{"id":"404","name":"404.左叶子之和","url":"https://leetcode.cn/problems/sum-of-left-leaves","desc":"计算给定二叉树的所有左叶子之和。","solutions":[{"date":"2020-09-19","time":88,"memory":39.6,"script":"typescript","desc":"递归。","code":"function sumOfLeftLeaves(root: TreeNode | null): number {\n  let sum = 0;\n  order(root);\n  return sum;\n  function order(root: TreeNode | null): void {\n    if (root === null) return;\n    root.left && !root.left.left && !root.left.right && (sum += root.left.val);\n    order(root.left);\n    order(root.right);\n  }\n}"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉树"],"level":"Easy"}},{"problemName":"405.数字转换为十六进制数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/405.数字转换为十六进制数.json","problemData":{"id":"405","name":"405.数字转换为十六进制数","url":"https://leetcode.cn/problems/convert-a-number-to-hexadecimal","desc":"给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。","solutions":[{"date":"2021-10-02","time":80,"memory":39.4,"script":"typescript","desc":"哈希。","code":"function toHex(num: number): string {\n  if (num === 0) return '0';\n  const map = '0123456789abcdef';\n  if (num < 0) num = 2 ** 32 + num;\n  let ans = '';\n  while (num) {\n    ans = map[num % 16] + ans;\n    num = ~~(num / 16);\n  }\n  return ans;\n}"}],"tagList":["位运算","数学"],"level":"Easy"}},{"problemName":"406.根据身高重建队列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/406.根据身高重建队列.json","problemData":{"id":"406","name":"406.根据身高重建队列","url":"https://leetcode.cn/problems/queue-reconstruction-by-height","desc":"假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对 (h, k) 表示，其中 h 是这个人的身高，k 是应该排在这个人前面且身高大于或等于 h 的人数。 例如：[5,2] 表示前面应该有 2 个身高大于等于 5 的人，而 [5,0] 表示前面不应该存在身高大于等于 5 的人。编写一个算法，根据每个人的身高 h 重建这个队列，使之满足每个整数对 (h, k) 中对人数 k 的要求。","solutions":[{"date":"2020-11-17","time":112,"memory":44.2,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/queue-reconstruction-by-height/solution/gen-ju-shen-gao-zhong-jian-dui-lie-by-leetcode-sol/)。","code":"function reconstructQueue(people: number[][]): number[][] {\n  people.sort(([h1, k1], [h2, k2]) => (h1 === h2 ? k1 - k2 : h2 - h1));\n  const ans: number[][] = [];\n  for (const p of people) {\n    const [, k] = p;\n    ans.splice(k, 0, p);\n  }\n  return ans;\n}"}],"tagList":["树状数组","线段树","数组","排序"],"level":"Medium"}},{"problemName":"409.最长回文串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/409.最长回文串.json","problemData":{"id":"409","name":"409.最长回文串","url":"https://leetcode.cn/problems/longest-palindrome","desc":"给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。","solutions":[{"date":"2022-03-15","time":0,"memory":6.6,"script":"cpp","desc":"统计字符的奇偶性。","code":"class Solution {\n   public:\n    int longestPalindrome(string s) {\n        unordered_map<char, int> m;\n        for (auto &c : s) m[c]++;\n        int ans = 0, odd = 0;\n        for (auto &item : m) {\n            if (item.second & 1) {\n                odd = 1;\n                item.second -= 1;\n            }\n            ans += item.second;\n        }\n        return ans + odd;\n    }\n};"}],"tagList":["贪心","哈希表","字符串"],"level":"Easy"}},{"problemName":"410.分割数组的最大值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/410.分割数组的最大值.json","problemData":{"id":"410","name":"410.分割数组的最大值","url":"https://leetcode.cn/problems/split-array-largest-sum","desc":"给定一个非负整数数组 nums 和一个整数 k ，你需要将这个数组分成 k 个非空的连续子数组。设计一个算法使得这 k 个子数组各自和的最大值最小。","solutions":[{"date":"2020-07-25","script":"typescript","time":188,"memory":39.68,"desc":"dp[i][j] = 分成i份时，只有前j个元素时的最小值。","code":"function splitArray(nums: number[], m: number): number {\n    const n = nums.length;\n    const dp = new Array(n + 1)\n        .fill(0)\n        .map((_) => new Array(m + 1).fill(Infinity));\n    dp[0][0] = 0;\n    const sub = new Array(n + 1).fill(0);\n    for (let i = 0; i < n; i++) sub[i + 1] = sub[i] + nums[i];\n    for (let i = 1; i <= n; i++) {\n        for (let j = 1; j <= Math.min(i, m); j++) {\n        for (let k = 0; k < i; k++) {\n            dp[i][j] = Math.min(dp[i][j], Math.max(dp[k][j - 1], sub[i] - sub[k]));\n        }\n        }\n    }\n    return dp[n][m];\n}"},{"script":"python","time":7699,"memory":16.83,"desc":"dp[i][j] = 分成i份时，只有前j个元素时的最小值。","code":"class Solution:\n    def splitArray(self, nums: List[int], k: int) -> int:\n        n = len(nums)\n        dp = [[inf] * (n + 1) for _ in range(k + 1)]\n        dp[1][0] = 0\n        for i in range(1, n + 1): dp[1][i] = dp[1][i - 1] + nums[i - 1]\n        for k in range(2, k + 1):\n            for i in range(k, n + 1):\n                num = 0\n                for j in range(i, k - 1, -1):\n                    num += nums[j - 1]\n                    dp[k][i] = min(dp[k][i], max(dp[k - 1][j - 1], num))\n        return dp[k][n]","date":"2024-01-21"}],"tagList":["贪心","数组","二分查找","动态规划","前缀和"],"level":"Hard"}},{"problemName":"412.FizzBuzz.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/412.FizzBuzz.json","problemData":{"id":"412","name":"412.FizzBuzz","url":"https://leetcode.cn/problems/fizz-buzz","desc":"写一个程序，输出从 1 到 n 数字的字符串表示。1. 如果  n  是 3 的倍数，输出“Fizz”；2. 如果  n  是 5 的倍数，输出“Buzz”；3.如果  n  同时是 3 和 5 的倍数，输出 “FizzBuzz”。","solutions":[{"date":"2021-10-13","time":68,"memory":39.8,"script":"typescript","desc":"遍历。","code":"function fizzBuzz(n: number): string[] {\n  const ans: string[] = [];\n  for (let i = 1; i <= n; i++) {\n    let item = '';\n    if (i % 3 === 0) item += 'Fizz';\n    if (i % 5 === 0) item += 'Buzz';\n    if (!item) item += i;\n    ans.push(item);\n  }\n  return ans;\n}"}],"tagList":["数学","字符串","模拟"],"level":"Easy"}},{"problemName":"413.等差数列划分.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/413.等差数列划分.json","problemData":{"id":"413","name":"413.等差数列划分","url":"https://leetcode.cn/problems/arithmetic-slices","desc":"给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。","solutions":[{"date":"2021-08-10","time":84,"memory":39.2,"script":"typescript","desc":"动态规划。","code":"function numberOfArithmeticSlices(nums: number[]): number {\n  const n = nums.length;\n  const dp = new Array(n).fill(0);\n  let ans = 0;\n  for (let i = 2; i < n; i++) {\n    if (nums[i] - nums[i - 1] === nums[i - 1] - nums[i - 2]) ans += dp[i] = dp[i - 1] + 1;\n  }\n  return ans;\n}"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"414.第三大的数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/414.第三大的数.json","problemData":{"id":"414","name":"414.第三大的数","url":"https://leetcode.cn/problems/third-maximum-number","desc":"给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。","solutions":[{"date":"2021-10-06","time":84,"memory":40.7,"script":"typescript","desc":"堆。","code":"class Heap<T = number> {\n  private arr: T[] = [];\n  get isEmpty() {\n    return this.size === 0;\n  }\n  get size() {\n    return this.arr.length;\n  }\n  get top() {\n    return this.arr[0];\n  }\n  constructor(private compare: (t1: T, t2: T) => number) {}\n  add(num: T): void {\n    this.arr.push(num);\n    this.shiftUp(this.size - 1);\n  }\n  remove(): T {\n    const num = this.arr.shift()!;\n    if (this.size) {\n      this.arr.unshift(this.arr.pop()!);\n      this.shiftDown(0);\n    }\n    return num;\n  }\n  private shiftUp(index: number): void {\n    if (index === 0) return;\n    const parentIndex = (index - 1) >> 1;\n    if (this.compare(this.arr[index], this.arr[parentIndex]) > 0) {\n      [this.arr[index], this.arr[parentIndex]] = [this.arr[parentIndex], this.arr[index]];\n      this.shiftUp(parentIndex);\n    }\n  }\n  private shiftDown(index: number): void {\n    let childrenIndex = index * 2 + 1;\n    if (childrenIndex > this.size - 1) return;\n    if (\n      childrenIndex + 1 <= this.size - 1 &&\n      this.compare(this.arr[childrenIndex + 1], this.arr[childrenIndex]) > 0\n    ) {\n      childrenIndex++;\n    }\n    if (this.compare(this.arr[childrenIndex], this.arr[index]) > 0) {\n      [this.arr[childrenIndex], this.arr[index]] = [this.arr[index], this.arr[childrenIndex]];\n      this.shiftDown(childrenIndex);\n    }\n  }\n  *[Symbol.iterator](): IterableIterator<T> {\n    for (const t of this.arr) {\n      yield t;\n    }\n  }\n}\nfunction thirdMax(nums: number[]): number {\n  const heap = new Heap((t1, t2) => t1 - t2);\n  [...new Set(nums)].forEach(num => heap.add(num));\n  if (heap.size < 3) return heap.remove();\n  let ans = 0;\n  for (let i = 0; i < 3; i++) ans = heap.remove();\n  return ans;\n}"},{"date":"2021-10-06","time":80,"memory":40.1,"script":"typescript","desc":"排序。","code":"function thirdMax(nums: number[]): number {\n  nums = [...new Set(nums)].sort((a, b) => b - a);\n  return nums[2] ?? nums[0];\n}"}],"tagList":["数组","排序"],"level":"Easy"}},{"problemName":"415.字符串相加.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/415.字符串相加.json","problemData":{"id":"415","name":"415.字符串相加","url":"https://leetcode.cn/problems/add-strings","desc":"给定两个字符串形式的非负整数 num1 和 num2 ，计算它们的和。","solutions":[{"date":"2020-08-03","time":92,"memory":40.2,"script":"typescript","desc":"每个字符进行累加。","code":"function addStrings(num1: string, num2: string): string {\n  const arr1 = num1.split('').reverse();\n  const arr2 = num2.split('').reverse();\n  const ans: number[] = [];\n  let go = 0;\n  while (arr1.length !== 0 && arr2.length !== 0) {\n    const num1 = arr1.shift() as string;\n    const num2 = arr2.shift() as string;\n    let num = parseInt(num1) + parseInt(num2) + go;\n    if (num >= 10) {\n      go = 1;\n      num -= 10;\n    } else go = 0;\n    ans.push(num);\n  }\n  while (arr1.length !== 0) {\n    let num = parseInt(arr1.shift()!) + go;\n    if (num >= 10) {\n      go = 1;\n      num -= 10;\n    } else go = 0;\n    ans.push(num);\n  }\n  while (arr2.length !== 0) {\n    let num = parseInt(arr2.shift()!) + go;\n    if (num >= 10) {\n      go = 1;\n      num -= 10;\n    } else go = 0;\n    ans.push(num);\n  }\n  if (go === 1) ans.push(1);\n  while (ans.length > 1 && ans[ans.length - 1] === 0) ans.pop();\n  return ans.reverse().join('');\n}"},{"script":"cpp","time":8,"memory":54.4,"desc":"遍历。","code":"class Solution {\npublic:\n    string addStrings(string num1, string num2) {\n        if (num1.size() < num2.size()) swap(num1, num2);\n        string res = \"\";\n        reverse(num1.begin(), num1.end());\n        reverse(num2.begin(), num2.end());\n        int i = 0, add = 0;\n        while (i < num1.size() || i < num2.size()) {\n            int num = num1[i] - '0' + add;\n            if (i < num2.size()) num += num2[i] - '0';\n            if (num >= 10) {\n                num -= 10;\n                add = 1;\n            } else {\n                add = 0;\n            }\n            res = to_string(num) + res;\n            i++;\n        }\n        if (add) res = \"1\" + res;\n        return res;\n    }\n};","date":"2023-07-17"},{"script":"python","time":56,"memory":15.9,"desc":"同上。","code":"class Solution:\n    def addStrings(self, s1: str, s2: str) -> str:\n        if len(s1) < len(s2):\n            s1, s2 = s2, s1\n        res = \"\"\n        num1, num2 = list(s1), list(s2)\n        num1.reverse()\n        num2.reverse()\n        i = add = 0\n        while i < len(num1) or i < len(num2):\n            num = ord(num1[i]) - ord('0') + add\n            if i < len(num2):\n                num += ord(num2[i]) - ord('0')\n            if num >= 10:\n                num -= 10\n                add = 1\n            else:\n                add = 0\n            res = str(num) + res\n            i += 1\n        if add:\n            res = \"1\" + res\n        return res","date":"2023-07-17"},{"script":"rust","time":0,"memory":2.1,"desc":"同上。","code":"pub fn str_to_vec(s: &String) -> Vec<char> {\n    s.chars().collect()\n}\nimpl Solution {\n    pub fn add_strings(num1: String, num2: String) -> String {\n        let mut num1 = str_to_vec(&num1);\n        let mut num2 = str_to_vec(&num2);\n        num1.reverse();\n        num2.reverse();\n        if num1.len() < num2.len() {\n            std::mem::swap(&mut num1, &mut num2);\n        }\n        let mut res = vec![];\n        let mut i = 0;\n        let mut add = 0;\n        while i < num1.len() || i < num2.len() {\n            let mut num = num1[i].to_digit(10).unwrap() as u8 + add;\n            if i < num2.len() {\n                num += num2[i].to_digit(10).unwrap() as u8;\n            }\n            if num >= 10 {\n                num -= 10;\n                add = 1;\n            } else {\n                add = 0;\n            }\n            res.push(num + b'0');\n            i += 1;\n        }\n        if add != 0 {\n            res.push(b'1');\n        }\n        res.reverse();\n        String::from_utf8(res).unwrap()\n    }\n}","date":"2023-07-17"}],"tagList":["数学","字符串","模拟"],"level":"Easy"}},{"problemName":"416.分割等和子集.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/416.分割等和子集.json","problemData":{"id":"416","name":"416.分割等和子集","url":"https://leetcode.cn/problems/partition-equal-subset-sum","desc":"给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。","solutions":[{"date":"2020-10-11","time":132,"memory":40.4,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/partition-equal-subset-sum/solution/fen-ge-deng-he-zi-ji-by-leetcode-solution/)。","code":"function canPartition(nums: number[]): boolean {\n  const len = nums.length;\n  // 如果只有一个元素，不可能平分\n  if (len < 2) return false;\n  let sum = nums.reduce((total, cur) => total + cur, 0);\n  let maxNum = Math.max(...nums);\n  // 如果总和是奇数，不可能平分\n  if (sum & 1) return false;\n  const target = sum / 2;\n  // 如果有数大于平分值，不可能评分\n  if (maxNum > target) return false;\n  const dp: boolean[] = new Array(target + 1).fill(false);\n  dp[0] = true;\n  for (const num of nums) {\n    for (let j = target; j >= num; j--) {\n      dp[j] = dp[j] || dp[j - num];\n    }\n  }\n  return dp[target];\n}"},{"date":"2021-09-13","time":228,"memory":60.5,"script":"typescript","desc":"动态规划。","code":"function canPartition(nums: number[]): boolean {\n  const n = nums.length;\n  const sum = nums.reduce((total, cur) => total + cur, 0);\n  if (sum % 2 !== 0) return false;\n  const halfSum = sum / 2;\n  const dp: boolean[][] = new Array(n + 1).fill(0).map(_ => new Array(halfSum + 1).fill(false));\n  for (let num = 0; num <= halfSum; num++) dp[0][num] = true;\n  dp[1][nums[0]] = true;\n  for (let i = 2; i <= n; i++) {\n    const num = nums[i - 1];\n    dp[i][0] = dp[i][num] = true;\n    for (let j = 1; j <= halfSum; j++) {\n      dp[i][j] = dp[i - 1][j];\n      if (j < num) continue;\n      dp[i][j] ||= dp[i - 1][j - num];\n    }\n    if (dp[i][halfSum]) return true;\n  }\n  return false;\n}"},{"date":"2021-09-13","time":132,"memory":40.4,"script":"typescript","desc":"动态规划优化。","code":"function canPartition(nums: number[]): boolean {\n  const n = nums.length;\n  const sum = nums.reduce((total, cur) => total + cur, 0);\n  if (sum % 2 !== 0) return false;\n  const halfSum = sum / 2;\n  const dp: boolean[][] = new Array(2).fill(0).map(_ => new Array(halfSum + 1).fill(false));\n  dp[1][nums[0]] = true;\n  for (let i = 2; i <= n; i++) {\n    const idx = i % 2;\n    const prevIdx = idx ^ 1;\n    const num = nums[i - 1];\n    dp[idx][0] = dp[idx][num] = true;\n    for (let j = 1; j <= halfSum; j++) {\n      dp[idx][j] = dp[prevIdx][j];\n      if (j >= num) dp[idx][j] ||= dp[prevIdx][j - num];\n    }\n    if (dp[idx][halfSum]) return true;\n  }\n  return false;\n}"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"417.太平洋大西洋水流问题.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/417.太平洋大西洋水流问题.json","problemData":{"id":"417","name":"417.太平洋大西洋水流问题","url":"https://leetcode.cn/problems/pacific-atlantic-water-flow","desc":"返回 网格坐标 result 的 2D 列表 ，其中 result[i] = [ri, ci] 表示雨水可以从单元格 (ri, ci) 流向 太平洋和大西洋 。","solutions":[{"date":"2022-04-27","time":28,"memory":18,"script":"cpp","desc":"dfs，上山。","code":"int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nclass Solution {\n   public:\n    int n, m;\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\n        n = heights.size(), m = heights[0].size();\n        vector<vector<int>> arr(n, vector(m, 0));\n        for (int row = 0; row < n; row++) {\n            arr[row][0] |= 0b01;\n            arr[row][m - 1] |= 0b10;\n            dfs(row, 0, arr, heights);\n            dfs(row, m - 1, arr, heights);\n        }\n        for (int col = 0; col < m; col++) {\n            arr[0][col] |= 0b01;\n            arr[n - 1][col] |= 0b10;\n            dfs(0, col, arr, heights);\n            dfs(n - 1, col, arr, heights);\n        }\n        vector<vector<int>> ans;\n        for (int row = 0; row < n; row++) {\n            for (int col = 0; col < m; col++) {\n                if (arr[row][col] != 0b11) continue;\n                vector<int> item(2);\n                item[0] = row;\n                item[1] = col;\n                ans.push_back(item);\n            }\n        }\n        return ans;\n    }\n    void dfs(int row, int col, vector<vector<int>>& arr,\n             vector<vector<int>>& heights) {\n        for (int i = 0; i < 4; i++) {\n            int nrow = row + dirs[i][0], ncol = col + dirs[i][1];\n            if (nrow < 0 || ncol < 0 || nrow == n || ncol == m) continue;\n            if (heights[nrow][ncol] < heights[row][col]) continue;\n            if (arr[row][col] == arr[nrow][ncol]) continue;\n            arr[nrow][ncol] |= arr[row][col];\n            dfs(nrow, ncol, arr, heights);\n        }\n    }\n};"}],"tagList":["深度优先搜索","广度优先搜索","数组","矩阵"],"level":"Medium"}},{"problemName":"419.棋盘上的战舰.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/419.棋盘上的战舰.json","problemData":{"id":"419","name":"419.棋盘上的战舰","url":"https://leetcode.cn/problems/battleships-in-a-board","desc":"给你一个大小为 m x n 的矩阵 board 表示甲板，其中，每个单元格可以是一艘战舰 'X' 或者是一个空位 '.' ，返回在甲板 board 上放置的 战舰 的数量。","solutions":[{"date":"2021-12-18","time":80,"memory":41.1,"script":"typescript","desc":"并查集。","code":"class UnionFind {\n  elements: number[];\n  constructor(public size: number) {\n    this.elements = new Array(size).fill(0).map((_, i) => i);\n  }\n  same(v1: number, v2: number): boolean {\n    return this.find(v1) === this.find(v2);\n  }\n  find(v: number): number {\n    return v === this.elements[v] ? v : (this.elements[v] = this.find(this.elements[v]));\n  }\n  union(v1: number, v2: number): void {\n    const e1 = this.find(v1);\n    const e2 = this.find(v2);\n    if (e1 !== e2) {\n      this.elements[e1] = e2;\n      this.size--;\n    }\n  }\n}\nconst dirs = [\n  [1, 0],\n  [0, 1],\n  [-1, 0],\n  [0, -1],\n];\nfunction countBattleships(board: string[][]): number {\n  const n = board.length;\n  const m = board[0].length;\n  const uf = new UnionFind(n * m);\n  const getIdx = (row: number, col: number) => row * m + col;\n  let cnt = 0;\n  for (let row = 0; row < n; row++) {\n    for (let col = 0; col < m; col++) {\n      if (board[row][col] !== 'X') {\n        cnt++;\n      } else {\n        for (let i = 0; i < 4; i++) {\n          const next_row = row + dirs[i][0];\n          const next_col = col + dirs[i][1];\n          if (\n            next_row < 0 ||\n            next_row >= n ||\n            next_col < 0 ||\n            next_col >= m ||\n            board[next_row][next_col] === '.'\n          )\n            continue;\n          uf.union(getIdx(row, col), getIdx(next_row, next_col));\n        }\n      }\n    }\n  }\n  return uf.size - cnt;\n}"},{"date":"2021-12-18","time":80,"memory":39.7,"script":"typescript","desc":"dfs。","code":"function setDot(board: string[][], n: number, m: number, row: number, col: number): void {\n  if (row < 0 || row >= n || col < 0 || col >= m || board[row][col] === '.') return;\n  board[row][col] = '.';\n  setDot(board, n, m, row + 1, col);\n  setDot(board, n, m, row - 1, col);\n  setDot(board, n, m, row, col + 1);\n  setDot(board, n, m, row, col - 1);\n}\nfunction countBattleships(board: string[][]): number {\n  const n = board.length;\n  const m = board[0].length;\n  let ans = 0;\n  for (let row = 0; row < n; row++) {\n    for (let col = 0; col < m; col++) {\n      if (board[row][col] === '.') continue;\n      ans++;\n      setDot(board, n, m, row, col);\n    }\n  }\n  return ans;\n}"},{"date":"2021-12-18","time":72,"memory":39.7,"script":"typescript","desc":"每次遍历只统计每个战舰左上角的 X。","code":"function countBattleships(board: string[][]): number {\n  const n = board.length;\n  const m = board[0].length;\n  let ans = 0;\n  for (let row = 0; row < n; row++) {\n    for (let col = 0; col < m; col++) {\n      if (\n        board[row][col] === '.' ||\n        (row > 0 && board[row - 1][col] === 'X') ||\n        (col > 0 && board[row][col - 1] === 'X')\n      )\n        continue;\n      ans++;\n    }\n  }\n  return ans;\n}"},{"script":"python","time":37,"memory":18.76,"desc":"dfs。","code":"dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\nclass Solution:\n    def countBattleships(self, board: List[List[str]]) -> int:\n        n = len(board)\n        m = len(board[0])\n        res = 0\n        def check(i: int, j: int) -> int:\n            board[i][j] = '.'\n            for dir in dirs:\n                ni = i + dir[0]\n                nj = j + dir[1]\n                if 0 <= ni < n and 0 <= nj < m and board[ni][nj] == 'X':\n                    check(ni, nj)\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] == 'X':\n                    res += 1\n                    check(i, j)\n        return res","date":"2024-06-11"}],"tagList":["深度优先搜索","数组","矩阵"],"level":"Medium"}},{"problemName":"421.数组中两个数的最大异或值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/421.数组中两个数的最大异或值.json","problemData":{"id":"421","name":"421.数组中两个数的最大异或值","url":"https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array","desc":"给你一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j < n 。","solutions":[{"date":"2021-05-16","time":6480,"memory":40.4,"script":"typescript","desc":"O(n2)循环。","code":"function findMaximumXOR(nums: number[]): number {\n  let ans = -Infinity;\n  nums.forEach(v1 => nums.forEach(v2 => (ans = Math.max(ans, v1 ^ v2))));\n  return ans;\n}"},{"date":"2021-05-16","time":156,"memory":49.2,"script":"typescript","desc":"利用 trie 储存二进制，每次寻找尽可能大的数。","code":"class Trie {\n  /** 左 0  */\n  left: Trie | null = null;\n  /** 右 1  */\n  right: Trie | null = null;\n}\nfunction findMaximumXOR(nums: number[]): number {\n  const len = nums.length;\n  if (len === 1) return 0;\n  const root = new Trie();\n  let ans = -Infinity;\n  const add = (num: number) => {\n    let trie = root;\n    for (let i = 30; i >= 0; i--) {\n      const v = (num >> i) & 1;\n      if (v === 1) {\n        trie = trie.right ?? (trie.right = new Trie());\n      } else {\n        trie = trie.left ?? (trie.left = new Trie());\n      }\n    }\n  };\n  const check = (num: number): number => {\n    let trie = root;\n    let xorNum = 0;\n    for (let i = 30; i >= 0; i--) {\n      const v = (num >> i) & 1;\n      if (v === 1) {\n        if (trie.left) {\n          trie = trie.left;\n          xorNum = (xorNum << 1) + 1;\n        } else {\n          trie = trie.right!;\n          xorNum <<= 1;\n        }\n      } else {\n        if (trie.right) {\n          trie = trie.right;\n          xorNum = (xorNum << 1) + 1;\n        } else {\n          trie = trie.left!;\n          xorNum <<= 1;\n        }\n      }\n    }\n    return xorNum;\n  };\n  for (let i = 1; i < len; i++) {\n    add(nums[i - 1]);\n    ans = Math.max(ans, check(nums[i]));\n  }\n  return ans;\n}"},{"date":"2021-10-25","time":788,"memory":67.5,"script":"typescript","desc":"二叉字典树。","code":"const MAX = 31;\nclass BitTrieNode {\n  // 0\n  left: BitTrieNode | null = null;\n  // 1\n  right: BitTrieNode | null = null;\n  val = -1;\n}\nclass BitTrie {\n  root = new BitTrieNode();\n  add(num: number) {\n    const str = num.toString(2).padStart(MAX, '0');\n    let node = this.root;\n    for (let i = 0, l = str.length; i < l; i++) {\n      const ch = str[i];\n      if (ch === '0') node = node.left ?? (node.left = new BitTrieNode());\n      else node = node.right ?? (node.right = new BitTrieNode());\n    }\n    node.val = num;\n  }\n  find(num: number) {\n    const str = num.toString(2).padStart(MAX, '0');\n    let node = this.root;\n    for (let i = 0, l = str.length; i < l; i++) {\n      if (!node.left && !node.right) break;\n      const ch = str[i];\n      if (ch === '0') {\n        node = node.right ?? node.left!;\n      } else {\n        node = node.left ?? node.right!;\n      }\n    }\n    return node;\n  }\n}\nfunction findMaximumXOR(nums: number[]): number {\n  const trie = new BitTrie();\n  nums.forEach(num => trie.add(num));\n  let ans = -Infinity;\n  nums.forEach(num => {\n    ans = Math.max(ans, trie.find(num).val ^ num);\n  });\n  return ans;\n}"},{"script":"cpp","time":716,"memory":172.36,"desc":"同上。","code":"struct TrieNode {\n    TrieNode* left = nullptr;\n    TrieNode* right = nullptr;\n};\n\nvoid add(TrieNode* node, int num) {\n    int pos = 30;\n    while (pos >= 0) {\n        int v = (num >> pos) & 1;\n        if (v) {\n            if (!node->left) node->left = new TrieNode();\n            node = node->left;\n        } else {\n            if (!node->right) node->right = new TrieNode();\n            node = node->right;\n        }\n        pos -= 1;\n    }\n}\n\nint find(TrieNode* node, int num) {\n    int pos = 30, ans = 0;\n    while (pos >= 0 && node) {\n        int v = (num >> pos) & 1;\n        if (v) {\n            if (node->right) {\n                ans |= 1 << pos;\n                node = node->right;\n            } else node = node->left;\n        } else {\n            if (node->left) {\n                ans |= 1 << pos;\n                node = node->left;\n            } else node = node->right;\n        }\n        pos -= 1;\n    }\n    return ans;\n}\n\nclass Solution {\npublic:\n    int findMaximumXOR(vector<int>& nums) {\n        TrieNode *root = new TrieNode();\n        int ans = 0;\n        for (auto &num : nums) {\n            add(root, num);\n            ans = max(ans, find(root, num));\n        }\n        return ans;\n    }\n};","date":"2023-11-04"},{"script":"python","time":9296,"memory":444.3,"desc":"同上。","code":"class TrieNode:\n    def __init__(self):\n        self.left = self.right = None\n    \ndef add(node, num: int, pos: int):\n    while pos >= 0:\n        v = (num >> pos) & 1\n        if v:\n            if not node.left: node.left = TrieNode()\n            node = node.left\n        else:\n            if not node.right: node.right = TrieNode()\n            node = node.right\n        pos -= 1\n        \n\ndef find(node, num: int, pos: int):\n    ans = 0\n    while pos >= 0 and node:\n        v = (num >> pos) & 1\n        if v: \n            if node.right:\n                ans |= 1 << pos\n                node = node.right\n            else:\n                node = node.left\n        else:\n            if node.left:\n                ans |= 1 << pos\n                node = node.left\n            else:\n                node = node.right\n        pos -= 1\n    return ans\n\nclass Solution:\n    def findMaximumXOR(self, nums: List[int]) -> int:\n        root = TrieNode()\n        ans = 0\n        for num in nums: \n            add(root, num, 30)\n            ans = max(ans, find(root, num, 30))\n        return ans","date":"2023-11-04"},{"script":"rust","time":564,"memory":85,"desc":"同上。","code":"struct TrieNode {\n    left: Option<Box<TrieNode>>,\n    right: Option<Box<TrieNode>>,\n}\nimpl TrieNode {\n    fn new() -> Self {\n        Self {\n            left: None,\n            right: None,\n        }\n    }\n}\n\nfn add(mut node: &mut Box<TrieNode>, num: i32) {\n    let mut pos = 30;\n    while pos >= 0 {\n        let v = (num >> pos) & 1;\n        if v != 0 {\n            if node.left.is_none() {\n                node.left = Some(Box::new(TrieNode::new()));\n            }\n            node = node.left.as_mut().unwrap()\n        } else {\n            if node.right.is_none() {\n                node.right = Some(Box::new(TrieNode::new()));\n            }\n            node = node.right.as_mut().unwrap()\n        }\n        pos -= 1;\n    }\n}\n\nfn find(mut node: &Box<TrieNode>, num: i32) -> i32 {\n    let mut pos = 30;\n    let mut ans = 0;\n    let mut node = Some(node);\n    while pos >= 0 && node.is_some() {\n        let node_ref = node.unwrap();\n        let v = (num >> pos) & 1;\n        if v != 0 {\n            if node_ref.right.is_some() {\n                ans |= 1 << pos;\n                node = Some(node_ref.right.as_ref().unwrap());\n            } else if node_ref.left.is_some() {\n                node = Some(node_ref.left.as_ref().unwrap());\n            } else {\n                node = None;\n            }\n        } else {\n            if node_ref.left.is_some() {\n                ans |= 1 << pos;\n                node = Some(node_ref.left.as_ref().unwrap());\n            } else if node_ref.right.is_some() {\n                node = Some(node_ref.right.as_ref().unwrap());\n            } else {\n                node = None;\n            }\n        }\n        pos -= 1;\n    }\n    ans\n}\n\nimpl Solution {\n    pub fn find_maximum_xor(nums: Vec<i32>) -> i32 {\n        let mut root = Box::new(TrieNode::new());\n        let mut ans = 0;\n        for num in &nums {\n            add(&mut root, *num);\n        }\n        for num in &nums {\n            ans = ans.max(find(&root, *num));\n        }\n        ans\n    }\n}","date":"2023-11-04"}],"tagList":["位运算","字典树","数组","哈希表"],"level":"Medium"}},{"problemName":"423.从英文中重建数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/423.从英文中重建数字.json","problemData":{"id":"423","name":"423.从英文中重建数字","url":"https://leetcode.cn/problems/reconstruct-original-digits-from-english","desc":"给你一个字符串 s ，其中包含字母顺序打乱的用英文单词表示的若干数字（0-9）。按 升序 返回原始的数字。","solutions":[{"date":"2021-11-24","time":124,"memory":41.3,"script":"typescript","desc":"对于数字一次排序删减。","code":"const dict: Record<number, string[]> = {\n  1: 'one'.split(''),\n  2: 'two'.split(''), // w\n  3: 'three'.split(''), //t\n  4: 'four'.split(''), // u\n  5: 'five'.split(''), // f\n  6: 'six'.split(''), // x\n  7: 'seven'.split(''), // v\n  8: 'eight'.split(''), // g\n  9: 'nine'.split(''), // i\n  0: 'zero'.split(''), // z\n};\nconst checkList = [\n  { num: 2, key: 'w' },\n  { num: 6, key: 'x' },\n  { num: 0, key: 'z' },\n  { num: 8, key: 'g' },\n  { num: 3, key: 't' },\n  { num: 4, key: 'u' },\n  { num: 5, key: 'f' },\n  { num: 7, key: 'v' },\n  { num: 9, key: 'i' },\n  { num: 1, key: 'o' },\n];\nfunction originalDigits(s: string): string {\n  const map: Record<string, number> = {};\n  for (const c of s) map[c] = (map[c] ?? 0) + 1;\n  const list: number[] = new Array(10).fill(0);\n  for (const { num, key } of checkList) {\n    if (!map[key]) continue;\n    const cnt = map[key];\n    list[num] += cnt;\n    for (const ch of dict[num]) map[ch] -= cnt;\n  }\n  return list.reduce((ans, cnt, num) => ans + num.toString().repeat(cnt), '');\n}"},{"date":"2021-11-24","time":276,"memory":6.3,"script":"c","desc":"对于数字一次排序删减。","code":"struct {\n    int num;\n    char key;\n} checkList[10] = {\n    {2, 'w'}, {6, 'x'}, {0, 'z'}, {8, 'g'}, {3, 't'},\n    {4, 'u'}, {5, 'f'}, {7, 'v'}, {9, 'i'}, {1, 'o'}\n};\nchar dict[10][6] = {\n    {\"zero\"}, {\"one\"}, {\"two\"},{\"three\"}, {\"four\"},\n    {\"five\"}, {\"six\"}, {\"seven\"}, {\"eight\"}, {\"nine\"}\n};\nchar * originalDigits(char * s){\n    int map[26] = {0}, list[10] = {0}, sum = 0;\n    for (int i = 0; i < strlen(s); i++) map[s[i] - 'a']++;\n    for (int i = 0; i < 10; i++) {\n        char key = checkList[i].key;\n        int num = checkList[i].num;\n        if (!map[key - 'a']) continue;\n        int cnt = map[key - 'a'];\n        list[num] += cnt;\n        sum += cnt;\n        for (int i = 0; i < strlen(dict[num]); i++) {\n            char ch = dict[num][i];\n            map[ch - 'a'] -=cnt;\n        }\n    }\n    int idx = 0;\n    char *ans = (char *)malloc(sizeof(char) * (sum + 1));\n    ans[sum] = '\\0';\n    for (int num = 0; num < 10; num++) {\n        int cnt = list[num];\n        if (!cnt) continue;\n        memset(ans + idx, num + '0', sizeof(char) * cnt);\n        idx += cnt;\n        // printf(\"sum = %d, num = %d, cnt = %d, ans = %s\\n\", sum, num, cnt, ans);\n    }\n    // printf(\"ans = %s\\n\", ans);\n    return ans;\n}"}],"tagList":["哈希表","数学","字符串"],"level":"Medium"}},{"problemName":"424.替换后的最长重复字符.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/424.替换后的最长重复字符.json","problemData":{"id":"424","name":"424.替换后的最长重复字符","url":"https://leetcode.cn/problems/longest-repeating-character-replacement","desc":"给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。","solutions":[{"date":"2021-02-02","time":140,"memory":41.6,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/longest-repeating-character-replacement/solution/ti-huan-hou-de-zui-chang-zhong-fu-zi-fu-n6aza/)。","code":"function characterReplacement(s: string, k: number): number {\n  const num = new Array(26).fill(0);\n  const n = s.length;\n  const compute = (i: number) => s[i].charCodeAt(0) - 'A'.charCodeAt(0);\n  let max = 0,\n    left = 0,\n    right = 0;\n  while (right < n) {\n    num[compute(right)]++;\n    max = Math.max(max, num[compute(right)]);\n    if (right - left + 1 - max > k) {\n      num[compute(left)]--;\n      left++;\n    }\n    right++;\n  }\n  return right - left;\n}"}],"tagList":["哈希表","字符串","滑动窗口"],"level":"Medium"}},{"problemName":"427.建立四叉树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/427.建立四叉树.json","problemData":{"id":"772","name":"427.建立四叉树","url":"https://leetcode.cn/problems/construct-quad-tree","desc":"你需要返回能表示矩阵的 四叉树 的根结点。","solutions":[{"date":"2022-04-29","time":24,"memory":23.7,"script":"cpp","desc":"dfs。","code":"class Solution {\n   public:\n    Node *construct(vector<vector<int>> &grid) {\n        int n = grid.size(), check;\n        return dfs(grid, 0, n - 1, 0, n - 1, &check);\n    }\n    Node *dfs(vector<vector<int>> &grid, int srow, int erow, int scol, int ecol,\n              int *check) {\n        if (srow == erow && scol == ecol) {\n            *check = 1;\n            return getNode(grid[srow][scol], true);\n        }\n        int mrow = (erow + srow) >> 1, mcol = (ecol + scol) >> 1;\n        int checkTL, checkTR, checkBL, checkBR;\n        Node *tl = dfs(grid, srow, mrow, scol, mcol, &checkTL),\n             *tr = dfs(grid, srow, mrow, mcol + 1, ecol, &checkTR),\n             *bl = dfs(grid, mrow + 1, erow, scol, mcol, &checkBL),\n             *br = dfs(grid, mrow + 1, erow, mcol + 1, ecol, &checkBR);\n        if (tl->val == tr->val && tl->val == bl->val && tl->val == br->val &&\n            checkTL & checkTR & checkBL & checkBR) {\n            *check = 1;\n            int val = tl->val;\n            free(tl);\n            free(tr);\n            free(bl);\n            free(br);\n            return getNode(val, true);\n        }\n        Node *node = getNode(tl->val ^ tr->val ^ bl->val ^ br->val, false);\n        *check = 0;\n        node->topLeft = tl;\n        node->topRight = tr;\n        node->bottomLeft = bl;\n        node->bottomRight = br;\n        return node;\n    }\n    Node *getNode(bool val, bool isLeaf) {\n        Node *node = (Node *)malloc(sizeof(Node));\n        node->isLeaf = isLeaf;\n        node->val = val;\n        node->topLeft = node->topRight = node->bottomLeft = node->bottomRight =\n            nullptr;\n        return node;\n    }\n};"},{"date":"2022-04-29","time":12,"memory":6.5,"script":"go","desc":"递归看是否成树。","code":"func construct(grid [][]int) *Node {\n    n := len(grid)\n    return dfs(grid, 0, n-1, 0, n-1)\n}\nfunc dfs(grid [][]int, srow, erow, scol, ecol int) *Node {\n    mrow, mcol := (srow+erow)>>1, (scol+ecol)>>1\n    for i := srow; i <= erow; i++ {\n        for j := scol; j <= ecol; j++ {\n            if grid[i][j] != grid[srow][scol] {\n                return &Node{\n                    Val:         false,\n                    IsLeaf:      false,\n                    TopLeft:     dfs(grid, srow, mrow, scol, mcol),\n                    TopRight:    dfs(grid, srow, mrow, mcol+1, ecol),\n                    BottomLeft:  dfs(grid, mrow+1, erow, scol, mcol),\n                    BottomRight: dfs(grid, mrow+1, erow, mcol+1, ecol),\n                }\n            }\n        }\n    }\n    return &Node{Val: grid[srow][scol] == 1, IsLeaf: true}\n}"}],"tagList":["树","数组","分治","矩阵"],"level":"Medium"}},{"problemName":"429.N叉树的层序遍历.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/429.N叉树的层序遍历.json","problemData":{"id":"764","name":"429.N叉树的层序遍历","url":"https://leetcode.cn/problems/n-ary-tree-level-order-traversal","desc":"给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。","solutions":[{"date":"2022-04-08","time":12,"memory":11.5,"script":"cpp","desc":"层序遍历。","code":"class Solution {\n   public:\n    vector<vector<int>> levelOrder(Node *root) {\n        vector<vector<int>> ans;\n        if (!root) return ans;\n        queue<Node *> q;\n        q.push(root);\n        int size = 1;\n        vector<int> cur;\n        while (q.size()) {\n            Node *node = q.front();\n            q.pop();\n            cur.push_back(node->val);\n            for (auto child : node->children) q.push(child);\n            if (--size == 0) {\n                size = q.size();\n                ans.push_back(cur);\n                cur.clear();\n            }\n        }\n        return ans;\n    }\n};"},{"script":"python","time":54,"memory":18.05,"desc":"bfs。","code":"class Solution:\n    def levelOrder(self, root: 'Node') -> List[List[int]]:\n        if not root: return []\n        q = deque() \n        q.append(root)\n        size = 1\n        ans = [[root.val]]\n        while q:\n            node = q.popleft()\n            for child in node.children: q.append(child)\n            size -= 1\n            if size == 0:\n                size = len(q)\n                if q: ans.append([node.val for node in q])\n        return ans","date":"2024-02-17"}],"tagList":["树","广度优先搜索"],"level":"Medium"}},{"problemName":"430.扁平化多级双向链表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/430.扁平化多级双向链表.json","problemData":{"id":"766","name":"430.扁平化多级双向链表","url":"https://leetcode.cn/problems/flatten-a-multilevel-doubly-linked-list","desc":"多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表，请你扁平化列表，使所有结点出现在单级双链表中。","solutions":[{"date":"2021-07-25","time":72,"memory":39.8,"script":"typescript","desc":"递归格式化每一层。","code":"function flatten(head: Node | null): Node | null {\n  if (head === null) return null;\n  let p: Node | null = head;\n  while (p) {\n    format(p);\n    p = p.next;\n  }\n  return head;\n  function format(node: Node) {\n    if (!node.child) return;\n    const { next, child } = node;\n    if (next) {\n      next.prev = null;\n      let prev: Node | null = null;\n      let p: Node | null = child;\n      while (p) {\n        format(p);\n        prev = p;\n        p = p.next;\n      }\n      prev!.next = next;\n      next.prev = prev;\n    }\n    node.child = null;\n    node.next = child;\n    child.prev = node;\n  }\n}"},{"date":"2021-09-24","time":64,"memory":39.7,"script":"javascript","desc":"递归格式化。","code":"function flatten(head: Node | null): Node | null {\n  if (head === null) return null;\n  return format(head)[0];\n  function format(node: Node): [Node, Node] {\n    if (node.child === null && node.next === null) return [node, node];\n    node.prev = null;\n    let prev: Node = node;\n    let p: Node | null = node;\n    while (p) {\n      const next = p.next;\n      if (p.child) {\n        const [first, last] = format(p.child);\n        p.next = first;\n        first.prev = p;\n        last.next = next;\n        if (next) next.prev = last;\n        prev = last;\n      } else {\n        prev = p;\n      }\n      p.child = null;\n      p = next;\n    }\n    return [node, prev];\n  }\n}"}],"tagList":["深度优先搜索","链表","双向链表"],"level":"Medium"}},{"problemName":"432.全O(1)的数据结构.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/432.全O(1)的数据结构.json","problemData":{"id":"432","name":"432.全O(1)的数据结构","url":"https://leetcode.cn/problems/all-oone-data-structure","desc":"请你设计一个用于存储字符串计数的数据结构，并能够返回计数最小和最大的字符串。","solutions":[{"date":"2022-03-16","time":136,"memory":55.9,"script":"cpp","desc":"利用哈希删查 O1，链表增删 O1 来维护结构。","code":"class VNode {\n   public:\n    int cnt;\n    string value;\n    VNode(string _value) {\n        value = _value;\n        cnt = 1;\n    }\n};\nclass CNode {\n   public:\n    int value;\n    CNode *prev, *next;\n    unordered_set<VNode *> children;\n    CNode(int _value, CNode *_prev = NULL) {\n        value = _value;\n        prev = _prev;\n        next = NULL;\n        if (prev) {\n            insert(prev);\n        }\n    }\n    void insert(CNode *prev) {\n        CNode *next = prev->next;\n        prev->next = this;\n        next->prev = this;\n        this->next = next;\n        this->prev = prev;\n    };\n    void remove() {\n        if (prev) prev->next = next;\n        if (next) next->prev = prev;\n        prev = NULL;\n        next = NULL;\n    };\n};\nclass AllOne {\n   public:\n    unordered_map<string, VNode *> vmap;\n    unordered_map<int, CNode *> cmap;\n    // first min | last max\n    CNode *first = new CNode(-1), *last = new CNode(-1);\n    void\n    log() { /*\n    cout << \"======START LOG=====\" << endl;\n    cout << \"CNode : first -> \";\n    CNode *p = first->next;\n    while (p != last) {\n        cout << \"(\" << p->prev->value << \", \" << p->value << \", \"\n             << p->next->value << \") -> \";\n        p = p->next;\n    }\n    cout << \"last\" << endl;\n\n    cout << \"VMap\" << endl;\n    for (auto &it : vmap) {\n        cout << \"(\" << it.first << \", \" << it.second->cnt << \")\" << endl;\n    }\n\n    cout << \"CMap\" << endl;\n    for (auto &it : cmap) {\n        cout << \"(\" << it.first << \", \" << it.second->children.size() << \")\"\n             << endl;\n    }\n    cout << \"======END LOG=====\" << endl;*/\n    }\n    AllOne() {\n        first->next = last;\n        last->prev = first;\n    }\n    /*\n    ~AllOne() {\n        last = NULL;\n        CNode *p = first;\n        while (p) {\n            CNode *cur = p;\n            p = p->next;\n            cur->remove();\n            delete cur;\n        }\n    }\n    */\n    void inc(string key) {\n        // cout << \"inc \" << key << endl;\n        if (vmap.count(key))\n            inc_key(key);\n        else\n            inc_nokey(key);\n        log();\n    }\n    // 增加key且当前存在\n    void inc_key(string key) {\n        VNode *vnode = vmap[key];\n        CNode *cnode = cmap[vnode->cnt];\n        cnode->children.erase(vnode);\n        if (cnode->children.size() == 0) {\n            CNode *prev = cnode->prev;\n            cnode->remove();\n            cmap.erase(cnode->value);\n            delete cnode;\n            cnode = prev;\n        }\n        vnode->cnt += 1;\n        if (cnode->next->value == vnode->cnt) {\n            cnode->next->children.insert(vnode);\n        } else {\n            CNode *cnode_next = new CNode(vnode->cnt, cnode);\n            cnode_next->children.insert(vnode);\n            cmap[vnode->cnt] = cnode_next;\n        }\n    }\n    // 增加key且当前不存在\n    void inc_nokey(string key) {\n        VNode *vnode = new VNode(key);\n        vmap[key] = vnode;\n        CNode *cnode =\n            first->next->value == 1 ? cmap[1] : (cmap[1] = new CNode(1, first));\n        cnode->children.insert(vnode);\n    }\n    void dec(string key) {\n        // cout << \"dec \" << key << endl;\n        if (vmap[key]->cnt == 1) {\n            dec_nokey(key);\n        } else {\n            dec_key(key);\n        }\n        log();\n    }\n    // 减少key且当前存在\n    void dec_key(string key) {\n        VNode *vnode = vmap[key];\n        CNode *cnode = cmap[vnode->cnt], *prev = cnode->prev;\n        cnode->children.erase(vnode);\n        if (cnode->children.size() == 0) {\n            cnode->remove();\n            cmap.erase(vnode->cnt);\n            delete cnode;\n        }\n        if (prev != first && prev->value == vnode->cnt - 1) {\n            prev->children.insert(vnode);\n        } else {\n            CNode *cnode_new = new CNode(vnode->cnt - 1, prev);\n            cmap[vnode->cnt - 1] = cnode_new;\n            cnode_new->children.insert(vnode);\n        }\n        vnode->cnt -= 1;\n    }\n    // 减少key且当前不存在\n    void dec_nokey(string key) {\n        VNode *vnode = vmap[key];\n        CNode *cnode = cmap[vnode->cnt];\n        cnode->children.erase(vnode);\n        if (cnode->children.size() == 0) {\n            cnode->remove();\n            cmap.erase(vnode->cnt);\n            delete cnode;\n        }\n        vmap.erase(vnode->value);\n        delete vnode;\n    }\n    string getMaxKey() {\n        if (first->next == last) return \"\";\n        auto it = last->prev->children.begin();\n        return (*it)->value;\n    }\n\n    string getMinKey() {\n        if (first->next == last) return \"\";\n        auto it = first->next->children.begin();\n        return (*it)->value;\n    }\n};"}],"tagList":["设计","哈希表","链表","双向链表"],"level":"Hard"}},{"problemName":"433.最小基因变化.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/433.最小基因变化.json","problemData":{"id":"433","name":"433.最小基因变化","url":"https://leetcode.cn/problems/minimum-genetic-mutation","desc":"给你两个基因序列 start 和 end ，以及一个基因库 bank ，请你找出并返回能够使  start 变化为 end 所需的最少变化次数。如果无法完成此基因变化，返回 -1 。","solutions":[{"date":"2022-05-07","time":0,"memory":6.4,"script":"cpp","desc":"bfs。","code":"class Solution {\npublic:\n    int minMutation(string start, string end, vector<string>& bank) {\n        unordered_set<string> s;\n        for (auto &v : bank) s.insert(v);\n        queue<string> q;\n        q.push(start);\n        int level = 0, size = 1;\n        while (q.size()) {\n            string cur = q.front(); q.pop();\n            if (cur == end) return level;\n            for (auto &s : next(s, cur)) q.push(s);\n            if (--size == 0) { size = q.size(); level++; }\n        }\n        return -1;\n    }\n    char list[4] = {'A', 'C', 'G', 'T'};\n    vector<string> next(unordered_set<string> &s, string &str) {\n        vector<string> ans;\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 4; j++) {\n                if (str[i] == list[j]) continue;\n                string next = str;\n                next[i] = list[j];\n                if (s.count(next)) {\n                    ans.emplace_back(next);\n                    s.erase(next);\n                }\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["广度优先搜索","哈希表","字符串"],"level":"Medium"}},{"problemName":"434.字符串中的单词数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/434.字符串中的单词数.json","problemData":{"id":"434","name":"434.字符串中的单词数","url":"https://leetcode.cn/problems/number-of-segments-in-a-string","desc":"统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。","solutions":[{"date":"2021-10-07","time":80,"memory":39.1,"script":"typescript","desc":"分割。","code":"function countSegments(s: string): number {\n  return s.split(' ').filter(v => v.length).length;\n}"},{"date":"2021-10-07","time":72,"memory":39.5,"script":"typescript","desc":"遍历。","code":"function countSegments(s: string): number {\n  let ans = 0;\n  let f = false;\n  for (const c of s) {\n    if (c === ' ') {\n      if (f) {\n        ans++;\n        f = false;\n      }\n      f = false;\n    } else {\n      f = true;\n    }\n  }\n  if (f) ans++;\n  return ans;\n}"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"435.无重叠区间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/435.无重叠区间.json","problemData":{"id":"435","name":"435.无重叠区间","url":"https://leetcode.cn/problems/non-overlapping-intervals","desc":"给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。","solutions":[{"date":"2020-12-31","time":92,"memory":40.4,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/non-overlapping-intervals/solution/wu-zhong-die-qu-jian-by-leetcode-solutio-cpsb/)。","code":"function eraseOverlapIntervals(intervals: number[][]): number {\n  if (!intervals.length) {\n    return 0;\n  }\n  intervals.sort((a, b) => a[1] - b[1]);\n  const n = intervals.length;\n  let right = intervals[0][1];\n  let ans = 1;\n  for (let i = 1; i < n; ++i) {\n    if (intervals[i][0] >= right) {\n      ++ans;\n      right = intervals[i][1];\n    }\n  }\n  return n - ans;\n}"}],"tagList":["贪心","数组","动态规划","排序"],"level":"Medium"}},{"problemName":"436.寻找右区间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/436.寻找右区间.json","problemData":{"id":"436","name":"436.寻找右区间","url":"https://leetcode.cn/problems/find-right-interval","desc":"返回一个由每个区间 i 的 右侧区间 的最小起始位置组成的数组。如果某个区间 i 不存在对应的 右侧区间 ，则下标 i 处的值设为 -1 。","solutions":[{"date":"2022-05-20","time":60,"memory":23.3,"script":"cpp","desc":"bs。","code":"class Solution {\n   public:\n    vector<int> findRightInterval(vector<vector<int>> &intervals) {\n        int n = intervals.size();\n        vector<int> ans(n, -1);\n        vector<int> list(n);\n        for (int i = 0; i < n; i++) list[i] = i;\n        sort(list.begin(), list.end(), [&](int &a, int &b) -> bool {\n            if (intervals[a][0] == intervals[b][0])\n                return intervals[a][1] < intervals[b][1];\n            return intervals[a][0] < intervals[b][0];\n        });\n        for (int i = 0; i < n; i++)\n            ans[i] = bs(intervals, list, intervals[i][1]);\n        return ans;\n    }\n    int bs(vector<vector<int>> &intervals, vector<int> &list, int num) {\n        int l = 0, r = intervals.size(), m;\n        while (l < r) {\n            m = (l + r) >> 1;\n            if (intervals[list[m]][0] >= num)\n                r = m;\n            else\n                l = m + 1;\n        }\n        if (r == intervals.size()) return -1;\n        return list[l];\n    }\n};"}],"tagList":["数组","二分查找","排序"],"level":"Medium"}},{"problemName":"438.找到字符串中所有字母异位词.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/438.找到字符串中所有字母异位词.json","problemData":{"id":"438","name":"438.找到字符串中所有字母异位词","url":"https://leetcode.cn/problems/find-all-anagrams-in-a-string","desc":"给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。","solutions":[{"date":"2021-11-28","time":140,"memory":44.9,"script":"typescript","desc":"遍历后存储数组，滑动窗口比较。","code":"function findAnagrams(s: string, p: string): number[] {\n  const sn = s.length;\n  const pn = p.length;\n  if (sn < pn) return [];\n  const arr: number[] = new Array(26).fill(0);\n  for (let i = 0; i < pn; i++) arr[p.codePointAt(i)! - 97]++;\n  const str = arr.join('#');\n  arr.fill(0);\n  const ans: number[] = [];\n  let l = 0;\n  let r = 0;\n  while (r < pn) arr[s.codePointAt(r++)! - 97]++;\n  while (r < sn) {\n    if (str === arr.join('#')) ans.push(l);\n    arr[s.codePointAt(l++)! - 97]--;\n    arr[s.codePointAt(r++)! - 97]++;\n  }\n  if (str === arr.join('#')) ans.push(l);\n  return ans;\n}"}],"tagList":["哈希表","字符串","滑动窗口"],"level":"Medium"}},{"problemName":"440.字典序的第K小数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/440.字典序的第K小数字.json","problemData":{"id":"440","name":"440.字典序的第K小数字","url":"https://leetcode.cn/problems/k-th-smallest-in-lexicographical-order","desc":"给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。","solutions":[{"date":"2021-10-26","time":76,"memory":39.4,"script":"typescript","desc":"构建字典树，计算每个字数包含的节点数。","code":"function findKthNumber(n: number, k: number): number {\n  for (let i = 1; i <= 9; i++) {\n    const c = count(i);\n    if (c < k) k -= c;\n    else return find(i, k);\n  }\n  return 0;\n  function find(prifix: number, k: number): number {\n    if (k === 1) return prifix;\n    k--;\n    for (let i = 0; i <= 9; i++) {\n      const next = prifix * 10 + i;\n      if (next > n) continue;\n      const c = count(next);\n      if (c >= k) return find(next, k);\n      else k -= c;\n    }\n    return 0;\n  }\n  function count(prifix: number): number {\n    let nextPrifix = prifix + 1;\n    let ans = 0;\n    while (prifix <= n) {\n      ans += Math.min(n + 1, nextPrifix) - prifix;\n      prifix *= 10;\n      nextPrifix *= 10;\n    }\n    return ans;\n  }\n}"}],"tagList":["字典树"],"level":"Hard"}},{"problemName":"441.排列硬币.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/441.排列硬币.json","problemData":{"id":"441","name":"441.排列硬币","url":"https://leetcode.cn/problems/arranging-coins","desc":"给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。","solutions":[{"date":"2021-10-10","time":104,"memory":39.5,"script":"typescript","desc":"计算填满 n 行所需要的硬币数。","code":"function arrangeCoins(n: number): number {\n  if (n === 1) return 1;\n  for (let i = 1; i <= n; i++) {\n    if (((1 + i) * i) / 2 > n) return i - 1;\n  }\n  return 0;\n}"}],"tagList":["数学","二分查找"],"level":"Easy"}},{"problemName":"442.数组中重复的数据.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/442.数组中重复的数据.json","problemData":{"id":"442","name":"442.数组中重复的数据","url":"https://leetcode.cn/problems/find-all-duplicates-in-an-array","desc":"给你一个长度为 n 的整数数组 nums ，其中 nums 的所有整数都在范围 [1, n] 内，且每个整数出现 一次 或 两次 。请你找出所有出现 两次 的整数，并以数组形式返回。","solutions":[{"date":"2022-05-08","time":80,"memory":43.5,"script":"cpp","desc":"哈希存储。","code":"class Solution {\n   public:\n    vector<int> findDuplicates(vector<int>& nums) {\n        unordered_set<int> s;\n        vector<int> ans;\n        for (auto& num : nums) {\n            if (s.count(num))\n                ans.push_back(num);\n            else\n                s.insert(num);\n        }\n        return ans;\n    }\n};"},{"date":"2022-05-08","time":24,"memory":32.7,"script":"cpp","desc":"遍历，与对应索引的位置进行交换，如果索引上已存在说明重复。","code":"class Solution {\n   public:\n    vector<int> findDuplicates(vector<int>& nums) {\n        vector<int> ans;\n        for (int i = 0; i < nums.size(); i++) {\n            while (nums[i] != nums[nums[i] - 1])\n                swap(nums[i], nums[nums[i] - 1]);\n        }\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] != i + 1) ans.push_back(nums[i]);\n        }\n        return ans;\n    }\n};"},{"date":"2022-05-08","time":48,"memory":32.7,"script":"cpp","desc":"遍历，对应位置取负。","code":"class Solution {\n   public:\n    vector<int> findDuplicates(vector<int>& nums) {\n        vector<int> ans;\n        for (int i = 0; i < nums.size(); i++) {\n            int num = abs(nums[i]);\n            if (nums[num - 1] < 0)\n                ans.push_back(num);\n            else\n                nums[num - 1] *= -1;\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表"],"level":"Medium"}},{"problemName":"443.压缩字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/443.压缩字符串.json","problemData":{"id":"443","name":"443.压缩字符串","url":"https://leetcode.cn/problems/string-compression","desc":"给你一个字符数组 chars ，请在 修改完输入数组后 ，返回该数组的新长度。","solutions":[{"date":"2021-08-21","time":84,"memory":40.2,"script":"typescript","desc":"双指针。","code":"function compress(chars: string[]): number {\n  let pos = 0;\n  const n = chars.length;\n  for (let i = 0; i < n; ) {\n    const c = chars[i];\n    let count = 1;\n    while (i + count < n && chars[i + count] === c) count++;\n    i += count;\n    chars[pos++] = c;\n    if (count > 1) {\n      let countStr = '';\n      while (count) {\n        countStr = (count % 10) + countStr;\n        count = ~~(count / 10);\n      }\n      for (const c of countStr) chars[pos++] = c;\n    }\n  }\n  return pos;\n}"}],"tagList":["双指针","字符串"],"level":"Medium"}},{"problemName":"445.两数相加II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/445.两数相加II.json","problemData":{"id":"445","name":"445.两数相加II","url":"https://leetcode.cn/problems/add-two-numbers-ii","desc":"给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。","solutions":[{"date":"2020-04-14","time":140,"memory":38.6,"script":"javascript","desc":"压栈后依次出栈。","code":"/**\n * Definition for singly-linked list.\n * function ListNode(val) {\n *     this.val = val;\n *     this.next = null;\n * }\n */\n/**\n * @param {ListNode} l1\n * @param {ListNode} l2\n * @return {ListNode}\n */\nvar addTwoNumbers = function (l1, l2) {\n  let res;\n  const arr1 = [];\n  while (true) {\n    arr1.push(l1);\n    if (l1.next === null) break;\n    l1 = l1.next;\n  }\n  const arr2 = [];\n  while (true) {\n    arr2.push(l2);\n    if (l2.next === null) break;\n    l2 = l2.next;\n  }\n  let f = false;\n  while (arr1.length !== 0 && arr2.length !== 0) {\n    let num = arr1.pop().val + arr2.pop().val;\n    if (f) num++;\n    if (num >= 10) {\n      num = num - 10;\n      f = true;\n    } else {\n      f = false;\n    }\n    let temp = new ListNode(num);\n    temp.next = res;\n    res = temp;\n  }\n  while (arr1.length !== 0) {\n    let temp = arr1.pop();\n    if (f) {\n      temp.val++;\n      if (temp.val >= 10) temp.val = temp.val - 10;\n      else f = false;\n    }\n    temp.next = res;\n    res = temp;\n  }\n  while (arr2.length !== 0) {\n    let temp = arr2.pop();\n    if (f) {\n      temp.val++;\n      if (temp.val >= 10) temp.val = temp.val - 10;\n      else f = false;\n    }\n    temp.next = res;\n    res = temp;\n  }\n  if (f) {\n    let temp = new ListNode(1);\n    temp.next = res;\n    res = temp;\n  }\n  return res;\n};"},{"script":"cpp","time":24,"memory":68.9,"desc":"递归。","code":"class Solution {\npublic:\n    int get_len(ListNode *l) {\n        int cnt = 0;\n        for (ListNode *p = l; p; p = p->next) cnt++;\n        return cnt;\n    }\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        int len1 = get_len(l1), len2 = get_len(l2);\n        if (len2 > len1) {\n            swap(len1, len2);\n            swap(l1, l2);\n        }\n        while (len1 > len2) {\n            ListNode *head = new ListNode(0, l2);\n            l2 = head;\n            len2++;\n        }\n        auto res = dfs(l1, l2);\n        if (res.first) {\n            ListNode *head = new ListNode(1, l1);\n            l1 = head;\n        }\n        return l1;\n    }\n    pair<int, ListNode*> dfs(ListNode* l1, ListNode* l2) {\n        if (!l1) return make_pair(0, l2);\n        if (!l2) return make_pair(0, l1);\n        auto res = dfs(l1->next, l2->next);\n        l1->next = res.second;\n        l1->val += l2->val + res.first;\n        int add = 0;\n        if (l1->val >= 10) {\n            l1->val -= 10;\n            add = 1;\n        }\n        return make_pair(add, l1);\n    }\n};","date":"2023-07-03"},{"script":"python","time":88,"memory":15.9,"desc":"同上。","code":"def getLen(l: Optional[ListNode]):\n    if not l:\n        return 0\n    cnt = 0\n    while l:\n        cnt += 1\n        l = l.next\n    return cnt\n\n\ndef dfs(l1: Optional[ListNode], l2: Optional[ListNode]) -> Tuple[int, ListNode]:\n    if not l1:\n        return (0, l2)\n    if not l2:\n        return (0, l1)\n    add, next = dfs(l1.next, l2.next)\n    l1.next = next\n    l1.val += l2.val + add\n    add = 0\n    if l1.val >= 10:\n        l1.val -= 10\n        add = 1\n    return (add, l1)\n\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        len1, len2 = getLen(l1), getLen(l2)\n        if len2 > len1:\n            len1, len2 = len2, len1\n            l1, l2 = l2, l1\n        while len1 > len2:\n            head = ListNode(0, l2)\n            l2 = head\n            len2 += 1\n        add, node = dfs(l1, l2)\n        if add:\n            head = ListNode(1, l1)\n            l1 = head\n        return l1","date":"2023-07-03"},{"script":"rust","time":0,"memory":1.9,"desc":"同上。","code":"fn get_len(l: &Option<Box<ListNode>>) -> usize {\n    match l {\n        Some(ref node) => get_len(&node.next) + 1,\n        None => 0,\n    }\n}\nfn dfs(\n    mut l1: Option<Box<ListNode>>,\n    mut l2: Option<Box<ListNode>>,\n) -> (i32, Option<Box<ListNode>>) {\n    if l1.is_none() {\n        (0, l2)\n    } else if l2.is_none() {\n        (0, l1)\n    } else {\n        let node1 = l1.as_mut().unwrap();\n        let node2 = l2.as_mut().unwrap();\n        let (mut add, next) = dfs(node1.next.take(), node2.next.take());\n        node1.val += node2.val + add;\n        node1.next = next;\n        add = 0;\n        if node1.val >= 10 {\n            node1.val -= 10;\n            add = 1;\n        }\n        (add, l1)\n    }\n}\nimpl Solution {\n    pub fn add_two_numbers(\n        mut l1: Option<Box<ListNode>>,\n        mut l2: Option<Box<ListNode>>,\n    ) -> Option<Box<ListNode>> {\n        let (mut len1, mut len2) = (get_len(&l1), get_len(&l2));\n        if len2 > len1 {\n            std::mem::swap(&mut len1, &mut len2);\n            std::mem::swap(&mut l1, &mut l2);\n        }\n        while len1 > len2 {\n            let mut head = Box::new(ListNode::new(0));\n            head.next = l2.take();\n            l2 = Some(head);\n            len2 += 1;\n        }\n        let (add, mut node) = dfs(l1, l2);\n        if add != 0 {\n            let mut head = Box::new(ListNode::new(1));\n            let next = node.take();\n            head.next = next;\n            node = Some(head);\n        }\n        node\n    }\n}","date":"2023-07-03"}],"tagList":["栈","链表","数学"],"level":"Medium"}},{"problemName":"446.等差数列划分II-子序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/446.等差数列划分II-子序列.json","problemData":{"id":"446","name":"446.等差数列划分II-子序列","url":"https://leetcode.cn/problems/arithmetic-slices-ii-subsequence","desc":"给你一个整数数组 nums ，返回 nums 中所有 等差子序列 的数目。","solutions":[{"date":"2021-08-11","time":396,"memory":73.1,"script":"typescript","desc":"动态规划,dp[i]=以 nums[i]结尾的公差映射。","code":"function numberOfArithmeticSlices(nums: number[]): number {\n  const map = new Map<number, Map<number, number>>(\n    nums.map((_, i) => [i, new Map<number, number>()])\n  );\n  const n = nums.length;\n  let ans = 0;\n  for (let i = 0; i < n; i++) {\n    const num = nums[i];\n    for (let j = 0; j < i; j++) {\n      const v = num - nums[j];\n      const c = map.get(j)!.get(v) ?? 0;\n      ans += c;\n      map.get(i)!.set(v, (map.get(i)!.get(v) ?? 0) + c + 1);\n    }\n  }\n  return ans;\n}"}],"tagList":["数组","动态规划"],"level":"Hard"}},{"problemName":"447.回旋镖的数量.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/447.回旋镖的数量.json","problemData":{"id":"447","name":"447.回旋镖的数量","url":"https://leetcode.cn/problems/number-of-boomerangs","desc":"返回平面上所有回旋镖的数量。","solutions":[{"date":"2021-09-13","time":252,"memory":60.9,"script":"typescript","desc":"map 储存。","code":"function numberOfBoomerangs(points: number[][]): number {\n  const n = points.length;\n  const getDistance = ([x1, y1]: number[], [x2, y2]: number[]) => (x1 - x2) ** 2 + (y1 - y2) ** 2;\n  const pointMap: Map<number[], Map<number, number>> = new Map();\n  let ans = 0;\n  for (let i = 0; i < n; i++) {\n    const p1 = points[i];\n    let map1 = pointMap.get(p1);\n    if (!map1) pointMap.set(p1, (map1 = new Map()));\n    for (let j = i + 1; j < n; j++) {\n      const p2 = points[j];\n      let map2 = pointMap.get(p2);\n      if (!map2) pointMap.set(p2, (map2 = new Map()));\n      const distance = getDistance(p1, p2);\n      const count1 = map1.get(distance) ?? 0;\n      map1.set(distance, count1 + 1);\n      ans += count1 * 2;\n      const count2 = map2.get(distance) ?? 0;\n      map2.set(distance, count2 + 1);\n      ans += count2 * 2;\n    }\n  }\n  return ans;\n}"},{"script":"python","time":788,"memory":17.06,"desc":"以一个点为中点，遍历所有其他点判断次数。","code":"class Solution:\n    def numberOfBoomerangs(self, points: List[List[int]]) -> int:\n        ans = 0\n        for p1 in points:\n            map = Counter()n\n            for p2 in points:\n                d = (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n                ans += map[d] * 2\n                map[d] += 1\n        return ans","date":"2024-01-08"}],"tagList":["数组","哈希表","数学"],"level":"Medium"}},{"problemName":"448.找到所有数组中消失的数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/448.找到所有数组中消失的数字.json","problemData":{"id":"448","name":"448.找到所有数组中消失的数字","url":"https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array","desc":"给定一个范围在   1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。找到所有在 [1, n] 范围之间没有出现在数组中的数字。","solutions":[{"date":"2021-02-13","time":152,"memory":50.7,"script":"typescript","desc":"利用 set 储存。","code":"function findDisappearedNumbers(nums: number[]): number[] {\n  const set = new Set(nums);\n  const ans: number[] = [];\n  for (let i = 1, l = nums.length; i <= l; i++) {\n    if (!set.has(i)) ans.push(i);\n  }\n  return ans;\n}"},{"date":"2021-02-13","time":116,"memory":46.4,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/solution/zhao-dao-suo-you-shu-zu-zhong-xiao-shi-d-mabl/)。","code":"function findDisappearedNumbers(nums: number[]): number[] {\n  const n = nums.length;\n  nums.forEach(v => (nums[(v - 1) % n] += n));\n  const ret: number[] = [];\n  nums.forEach((v, i) => v <= n && ret.push(i + 1));\n  return ret;\n}"}],"tagList":["数组","哈希表"],"level":"Easy"}},{"problemName":"449.序列化和反序列化二叉搜索树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/449.序列化和反序列化二叉搜索树.json","problemData":{"id":"449","name":"449.序列化和反序列化二叉搜索树","url":"https://leetcode.cn/problems/serialize-and-deserialize-bst","desc":"给你一棵二叉树，它的根为 root 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。 。","solutions":[{"date":"2021-08-14","time":108,"memory":46.1,"script":"typescript","desc":"JSON 序列化。","code":"function serialize(root: TreeNode | null): string {\n  return JSON.stringify(root);\n}\nfunction deserialize(data: string): TreeNode | null {\n  return JSON.parse(data);\n}"},{"date":"2022-05-11","time":64,"memory":45.7,"script":"cpp","desc":"递归。","code":"class Codec {\n   public:\n    string serialize(TreeNode *root) {\n        if (root == nullptr) return \"(-1)\";\n        return \"(\" + to_string(root->val) + \",\" + serialize(root->left) + \",\" +\n               serialize(root->right) + \")\";\n    }\n    TreeNode *deserialize(string data) {\n        if (data == \"(-1)\") return nullptr;\n        string l, r;\n        int val = analysis(data, l, r);\n        TreeNode *ans = new TreeNode(val);\n        ans->left = deserialize(l);\n        ans->right = deserialize(r);\n        return ans;\n    }\n    int analysis(string &data, string &l, string &r) {\n        int level = 0, n = data.size(), val;\n        int i = 0, prev = 1, cnt = 0;\n        for (; i < n; i++) {\n            int ch = data[i];\n            if (ch == '(') {\n                level++;\n            } else if (ch == ')') {\n                level--;\n            } else if (ch == ',' && level == 1) {\n                string substr = data.substr(prev, i - prev);\n                if (cnt == 0)\n                    val = stoi(substr);\n                else if (cnt == 1)\n                    l = substr;\n                cnt++;\n                prev = i + 1;\n            }\n        }\n        r = data.substr(prev, i - prev - 1);\n        return val;\n    }\n};"},{"script":"python","time":248,"memory":19.74,"desc":"同上。","code":"class Codec:\n\n    def serialize(self, node: Optional[TreeNode]) -> str:\n        \"\"\"Encodes a tree to a single string.\n        \"\"\"\n        if not node:\n            return \"N\"\n        return f\"{node.val},({self.serialize(node.left)}),({self.serialize(node.right)})\"\n\n    def deserialize(self, s: str) -> Optional[TreeNode]:\n        \"\"\"Decodes your encoded data to tree.\n        \"\"\"\n        if s == \"N\":\n            return None\n        s1 = s2 = s3 = ''\n        split_idx = -1\n        level = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                level += 1\n            elif s[i] == ')':\n                level -= 1\n            elif s[i] == ',' and level == 0:\n                if split_idx == -1:\n                    s1 = s[:i]\n                    split_idx = i + 1\n                else:\n                    s2 = s[split_idx + 1:i - 1]\n                    s3 = s[i + 2:-1]\n        return TreeNode(int(s1), self.deserialize(s2), self.deserialize(s3))\n\n","date":"2023-09-04"},{"script":"python","time":248,"memory":19.74,"desc":"同上。","code":"class Codec:\n\n    def serialize(self, node: Optional[TreeNode]) -> str:\n        \"\"\"Encodes a tree to a single string.\n        \"\"\"\n        if not node:\n            return \"N\"\n        return f\"{node.val},({self.serialize(node.left)}),({self.serialize(node.right)})\"\n\n    def deserialize(self, s: str) -> Optional[TreeNode]:\n        \"\"\"Decodes your encoded data to tree.\n        \"\"\"\n        if s == \"N\":\n            return None\n        s1 = s2 = s3 = ''\n        split_idx = -1\n        level = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                level += 1\n            elif s[i] == ')':\n                level -= 1\n            elif s[i] == ',' and level == 0:\n                if split_idx == -1:\n                    s1 = s[:i]\n                    split_idx = i + 1\n                else:\n                    s2 = s[split_idx + 1:i - 1]\n                    s3 = s[i + 2:-1]\n        return TreeNode(int(s1), self.deserialize(s2), self.deserialize(s3))\n\n","date":"2023-09-04"},{"script":"python","time":248,"memory":19.74,"desc":"同上。","code":"class Codec:\n\n    def serialize(self, node: Optional[TreeNode]) -> str:\n        \"\"\"Encodes a tree to a single string.\n        \"\"\"\n        if not node:\n            return \"N\"\n        return f\"{node.val},({self.serialize(node.left)}),({self.serialize(node.right)})\"\n\n    def deserialize(self, s: str) -> Optional[TreeNode]:\n        \"\"\"Decodes your encoded data to tree.\n        \"\"\"\n        if s == \"N\":\n            return None\n        s1 = s2 = s3 = ''\n        split_idx = -1\n        level = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                level += 1\n            elif s[i] == ')':\n                level -= 1\n            elif s[i] == ',' and level == 0:\n                if split_idx == -1:\n                    s1 = s[:i]\n                    split_idx = i + 1\n                else:\n                    s2 = s[split_idx + 1:i - 1]\n                    s3 = s[i + 2:-1]\n        return TreeNode(int(s1), self.deserialize(s2), self.deserialize(s3))\n\n","date":"2023-09-04"},{"script":"python","time":248,"memory":19.74,"desc":"同上。","code":"class Codec:\n\n    def serialize(self, node: Optional[TreeNode]) -> str:\n        \"\"\"Encodes a tree to a single string.\n        \"\"\"\n        if not node:\n            return \"N\"\n        return f\"{node.val},({self.serialize(node.left)}),({self.serialize(node.right)})\"\n\n    def deserialize(self, s: str) -> Optional[TreeNode]:\n        \"\"\"Decodes your encoded data to tree.\n        \"\"\"\n        if s == \"N\":\n            return None\n        s1 = s2 = s3 = ''\n        split_idx = -1\n        level = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                level += 1\n            elif s[i] == ')':\n                level -= 1\n            elif s[i] == ',' and level == 0:\n                if split_idx == -1:\n                    s1 = s[:i]\n                    split_idx = i + 1\n                else:\n                    s2 = s[split_idx + 1:i - 1]\n                    s3 = s[i + 2:-1]\n        return TreeNode(int(s1), self.deserialize(s2), self.deserialize(s3))\n\n","date":"2023-09-04"},{"script":"python","time":248,"memory":19.74,"desc":"同上。","code":"class Codec:\n\n    def serialize(self, node: Optional[TreeNode]) -> str:\n        \"\"\"Encodes a tree to a single string.\n        \"\"\"\n        if not node:\n            return \"N\"\n        return f\"{node.val},({self.serialize(node.left)}),({self.serialize(node.right)})\"\n\n    def deserialize(self, s: str) -> Optional[TreeNode]:\n        \"\"\"Decodes your encoded data to tree.\n        \"\"\"\n        if s == \"N\":\n            return None\n        s1 = s2 = s3 = ''\n        split_idx = -1\n        level = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                level += 1\n            elif s[i] == ')':\n                level -= 1\n            elif s[i] == ',' and level == 0:\n                if split_idx == -1:\n                    s1 = s[:i]\n                    split_idx = i + 1\n                else:\n                    s2 = s[split_idx + 1:i - 1]\n                    s3 = s[i + 2:-1]\n        return TreeNode(int(s1), self.deserialize(s2), self.deserialize(s3))\n\n","date":"2023-09-04"}],"tagList":["树","深度优先搜索","广度优先搜索","设计","二叉搜索树","字符串","二叉树"],"level":"Medium"}},{"problemName":"450.删除二叉搜索树中的节点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/450.删除二叉搜索树中的节点.json","problemData":{"id":"450","name":"450.删除二叉搜索树中的节点","url":"https://leetcode.cn/problems/delete-node-in-a-bst","desc":"给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。","solutions":[{"date":"2020-02-23","time":0,"memory":41.7,"script":"java","desc":"判断根是否为 null，以及是否为单节点，然后循环获取 key 所在节点，若节点不存在则返回根，若存在则判断节点的度，度为 2 则获取后继节点，删除后继节点，在判断是否为根节点以及在父节点的左右情况。","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode deleteNode(TreeNode root, int key) {\n\t\tif (root == null)\n\t\t\treturn null;\n\t\tif (root.left == null && root.right == null) {\n\t\t\tif (root.val == key)\n\t\t\t\treturn null;\n\t\t\tif (root.val != key)\n\t\t\t\treturn root;\n\t\t}\n\t\tTreeNode node = root;\n\t\tTreeNode parent = null;\n\t\twhile (node!=null&&node.val != key) {\n\t\t\tif (key > node.val) {\n\t\t\t\tparent = node;\n\t\t\t\tnode = node.right;\n\t\t\t}\n\t\t\tif (key < node.val) {\n\t\t\t\tparent = node;\n\t\t\t\tnode = node.left;\n\t\t\t}\n\t\t}\n\t\tif (node == null)\n\t\t\treturn root;\n\t\tif (node.left != null && node.right != null) {\n\t\t\tTreeNode oldNode = node;\n\t\t\tparent = node;\n\t\t\tnode = node.right;\n\t\t\twhile (node.left != null) {\n\t\t\t\tparent = node;\n\t\t\t\tnode = node.left;\n\t\t\t}\n\t\t\toldNode.val = node.val;\n\t\t}\n\t\tif (parent == null) {\n\t\t\tif (node.left != null)\n\t\t\t\treturn node.left;\n\t\t\tif (node.right != null)\n\t\t\t\treturn node.right;\n\t\t}\n\t\tif (node.left == null && node.right == null) {\n\t\t\tif (parent.left == node) {\n\t\t\t\tparent.left = null;\n\t\t\t} else {\n\t\t\t\tparent.right = null;\n\t\t\t}\n\t\t} else {\n\t\t\tif (parent.left == node) {\n\t\t\t\tif(node.left!=null)parent.left = node.left;\n\t\t\t\telse parent.left = node.right;\n\t\t\t} else {\n\t\t\t\tif(node.left!=null)parent.right = node.left;\n\t\t\t\telse parent.right = node.right;\n\t\t\t}\n\t\t}\n\t\treturn root;\n\t}\n}"},{"date":"2021-08-07","time":104,"memory":47.3,"script":"typescript","desc":"分别计算度，进行递归删除。","code":"function predecessor(node: TreeNode): TreeNode {\n  let ans = node.left!;\n  while (ans.right) ans = ans.right;\n  return ans;\n}\nfunction deleteNode(root: TreeNode | null, key: number): TreeNode | null {\n  if (root === null) return null;\n  if (root.val > key) {\n    root.left = deleteNode(root.left, key);\n  } else if (root.val < key) {\n    root.right = deleteNode(root.right, key);\n  } else {\n    if (root.left === null || root.right === null) return root.left ?? root.right;\n    const p = predecessor(root);\n    [p.val, root.val] = [root.val, p.val];\n    root.left = deleteNode(root.left, p.val);\n  }\n  return root;\n}"},{"date":"2022-06-02","time":24,"memory":31.9,"script":"typescript","desc":"dfs。","code":"class Solution {\n   public:\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        if (!root) return root;\n        if (root->val > key)\n            root->left = deleteNode(root->left, key);\n        else if (root->val < key)\n            root->right = deleteNode(root->right, key);\n        else {\n            if (root->left == nullptr || root->right == nullptr) {\n                TreeNode* child =\n                    root->left == nullptr ? root->right : root->left;\n                root = child;\n            } else {\n                TreeNode* tmp = root->right;\n                while (tmp->left) tmp = tmp->left;\n                root->val = tmp->val;\n                root->right = deleteNode(root->right, tmp->val);\n            }\n        }\n        return root;\n    }\n};"}],"tagList":["树","二叉搜索树","二叉树"],"level":"Medium"}},{"problemName":"452.用最少数量的箭引爆气球.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/452.用最少数量的箭引爆气球.json","problemData":{"id":"452","name":"452.用最少数量的箭引爆气球","url":"https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons","desc":"给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。","solutions":[{"date":"2020-11-24","time":140,"memory":45.9,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/solution/yong-zui-shao-shu-liang-de-jian-yin-bao-qi-qiu-1-2/)。","code":"function findMinArrowShots(points: number[][]): number {\n  if (points.length === 0) return 0;\n  points.sort(([, p1], [, p2]) => p1 - p2);\n  let [, pos] = points[0];\n  let ans = 1;\n  for (let [b0, b1] of points) {\n    if (b0 > pos) {\n      pos = b1;\n      ans++;\n    }\n  }\n  return ans;\n}"}],"tagList":["贪心","数组","排序"],"level":"Medium"}},{"problemName":"453.最小操作次数使数组元素相等.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/453.最小操作次数使数组元素相等.json","problemData":{"id":"453","name":"453.最小操作次数使数组元素相等","url":"https://leetcode.cn/problems/minimum-moves-to-equal-array-elements","desc":"给你一个长度为 n 的整数数组，每次操作将会使 n - 1 个元素增加 1 。返回让数组所有元素相等的最小操作次数。","solutions":[{"date":"2021-10-20","time":92,"memory":41.4,"script":"typescript","desc":"每次 n-1 个元素加一，理解为每次 1 个元素减一。","code":"function minMoves(nums: number[]): number {\n  const min = Math.min(...nums);\n  return nums.reduce((ans, num) => ans + num - min, 0);\n}"}],"tagList":["数组","数学"],"level":"Medium"}},{"problemName":"454.四数相加II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/454.四数相加II.json","problemData":{"id":"454","name":"454.四数相加II","url":"https://leetcode.cn/problems/4sum-ii","desc":"给定四个包含整数的数组列表  A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得  A[i] + B[j] + C[k] + D[l] = 0。","solutions":[{"date":"2020-11-27","time":532,"memory":71.1,"script":"typescript","desc":"分组储存。","code":"function fourSumCount(A: number[], B: number[], C: number[], D: number[]): number {\n  let ans = 0;\n  const cache: Record<number, number> = {};\n  const setCache = (c: number) => {\n    cache[c] = 1 + (cache[c] ? cache[c] : 0);\n  };\n  for (const n1 of A)\n    for (const n2 of B) {\n      setCache(n1 + n2);\n    }\n  for (const n1 of C)\n    for (const n2 of D) {\n      ans += cache[-n1 - n2] ?? 0;\n    }\n  return ans;\n}"}],"tagList":["数组","哈希表"],"level":"Medium"}},{"problemName":"455.分发饼干.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/455.分发饼干.json","problemData":{"id":"455","name":"455.分发饼干","url":"https://leetcode.cn/problems/assign-cookies","desc":"假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。","solutions":[{"date":"2020-12-25","time":136,"memory":41.9,"script":"typescript","desc":"排序后逐个比较，贪心。","code":"function findContentChildren(g: number[], s: number[]): number {\n  const sort = (a: number, b: number) => a - b;\n  g.sort(sort);\n  s.sort(sort);\n  const gLen = g.length;\n  const sLen = s.length;\n  let gI = 0;\n  let sI = 0;\n  let ans = 0;\n  while (gI < gLen) {\n    if (sI === sLen) return ans;\n    if (g[gI] <= s[sI]) {\n      gI++;\n      sI++;\n      ans++;\n    } else {\n      sI++;\n    }\n  }\n  return ans;\n}"}],"tagList":["贪心","数组","双指针","排序"],"level":"Easy"}},{"problemName":"456.132模式.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/456.132模式.json","problemData":{"id":"456","name":"456.132模式","url":"https://leetcode.cn/problems/132-pattern","desc":"给定一个整数序列：a1, a2, ..., an，一个 132 模式的子序列  ai, aj, ak  被定义为：当 i < j < k 时，ai < ak < aj。设计一个算法，当给定有  n 个数字的序列时，验证这个序列中是否含有 132 模式的子序列。","solutions":[{"date":"2021-03-24","time":112,"memory":40.1,"script":"typescript","desc":"单调栈。","code":"function find132pattern(nums: number[]): boolean {\n  const len = nums.length;\n  if (len < 3) return false;\n  const stack: number[] = [];\n  let num2: number = -Infinity;\n  for (let i = len - 1; i >= 0; i--) {\n    const num = nums[i];\n    if (num < num2) return true;\n    while (stack.length > 0 && stack[stack.length - 1] < num) num2 = stack.pop()!;\n    stack.push(num);\n  }\n  return false;\n}"},{"date":"2021-07-20","time":92,"memory":53.2,"script":"typescript","desc":"找当前值，左侧最小值和右侧不大于当前值的最大值。","code":"function find132pattern(nums: number[]): boolean {\n  const n = nums.length;\n  const l: number[] = [Infinity];\n  for (let i = 1; i < n; i++) l[i] = Math.min(l[i - 1], nums[i - 1]);\n  const stack: number[] = [];\n  for (let i = n - 1; i >= 0; i--) {\n    const mid = nums[i];\n    let r: number | null = null;\n    while (stack.length && stack[stack.length - 1] < mid) r = stack.pop()!;\n    if (r && mid > r && mid > l[i] && r > l[i]) return true;\n    stack.push(mid);\n  }\n  return false;\n}"}],"tagList":["栈","数组","二分查找","有序集合","单调栈"],"level":"Medium"}},{"problemName":"457.环形数组是否存在循环.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/457.环形数组是否存在循环.json","problemData":{"id":"457","name":"457.环形数组是否存在循环","url":"https://leetcode.cn/problems/circular-array-loop","desc":"如果 nums 中存在循环，返回 true ；否则，返回 false 。","solutions":[{"date":"2021-08-07","time":644,"memory":89,"script":"typescript","desc":"bfs。","code":"function circularArrayLoop(nums: number[]): boolean {\n  const n = nums.length;\n  const queue: [number, Set<number>][] = new Array(n).fill(0).map((_, i) => [i, new Set([i])]);\n  while (queue.length) {\n    const [idx, set] = queue.shift()!;\n    const next = getNextIdx(idx, nums[idx]);\n    if (next === idx) continue;\n    if (set.has(next)) return true;\n    if ((nums[idx] > 0 && nums[next] < 0) || (nums[idx] < 0 && nums[next] > 0) || set.size === n)\n      continue;\n    set.add(next);\n    queue.push([next, set]);\n  }\n  return false;\n  function getNextIdx(idx: number, step: number): number {\n    let ans = idx + step;\n    while (ans >= n) ans -= n;\n    while (ans < 0) ans += n;\n    return ans;\n  }\n}"},{"date":"2022-01-08","time":0,"memory":7,"script":"cpp","desc":"对于每个起点进行双指针遍历。","code":"class Solution {\n   public:\n    int getNext(int i, vector<int>& nums) {\n        int delta = 1000 * nums.size(), n = nums.size();\n        if (nums[i] < 0) delta *= -1;\n        nums[i] += delta;\n        return ((i + nums[i]) % n + n) % n;\n    }\n    bool circularArrayLoop(vector<int>& nums) {\n        for (int i = 0; i < nums.size(); i++) {\n            if (abs(nums[i]) > 1000) continue;\n            int p = i, q = i;\n            do {\n                p = getNext(p, nums);\n                q = getNext(getNext(q, nums), nums);\n            } while (p != q);\n            int a = 0, b = 0, l = 0;\n            do {\n                if (nums[p] > 0)\n                    a++;\n                else\n                    b++;\n                l++;\n                p = getNext(p, nums);\n            } while (p != q);\n            if (l > 1 && (a == 0 || b == 0)) return 1;\n        }\n        return 0;\n    }\n};"}],"tagList":["数组","哈希表","双指针"],"level":"Medium"}},{"problemName":"459.重复的子字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/459.重复的子字符串.json","problemData":{"id":"459","name":"459.重复的子字符串","url":"https://leetcode.cn/problems/repeated-substring-pattern","desc":"给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过 10000。","solutions":[{"date":"2020-08-24","time":100,"memory":39.3,"script":"typescript","desc":"获取每个子字符串进行判断","code":"function repeatedSubstringPattern(s: string): boolean {\n  const l = s.length;\n  for (let i = 1; i < l; i++) {\n    if (\n      s[i - 1] === s[l - 1] &&\n      l % i === 0 &&\n      s.replace(new RegExp(s.substring(0, i), 'g'), '') === ''\n    )\n      return true;\n  }\n  return false;\n}"},{"date":"2021-10-15","time":80,"memory":44.7,"script":"typescript","desc":"kmp。","code":"function repeatedSubstringPattern(s: string): boolean {\n  const next = [-1];\n  const n = s.length;\n  for (let i = 1, j = -1; i < n; i++) {\n    while (j !== -1 && s[j + 1] !== s[i]) j = next[j];\n    if (s[j + 1] === s[i]) j++;\n    next[i] = j;\n  }\n  const idx = next[n - 1];\n  return idx !== -1 && n % (n - idx - 1) === 0;\n}"}],"tagList":["字符串","字符串匹配"],"level":"Easy"}},{"problemName":"460.LFU缓存.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/460.LFU缓存.json","problemData":{"id":"460","name":"460.LFU缓存","url":"https://leetcode.cn/problems/lfu-cache","desc":"请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。它应该支持以下操作：get 和 put。","solutions":[{"date":"2020-04-09","time":1136,"memory":78.2,"script":"javascript","desc":"使用 Node 储存次数和值，进行判断，难点没有就是细节需要考虑。","code":"class Node {\n  count = 0;\n  value;\n  constructor(value) {\n    this.value = value;\n  }\n}\nclass LFUCache {\n  _capacity;\n  _cache = new Map();\n  newest = [];\n  constructor(capacity) {\n    this._capacity = capacity;\n  }\n  get(key) {\n    // console.log('====GET-' + key);\n    // console.log(this._cache);\n    if (this._capacity === 0 || !this._cache.has(key)) return -1;\n    const node = this._cache.get(key);\n    node.count++;\n    this.setNewest(key);\n    return node.value;\n  }\n  setNewest(key) {\n    if (this.newest[this.newest.length - 1] === key) return;\n    this.newest = this.newest.filter(v => v !== key);\n    this.newest.push(key);\n  }\n  getMinKey() {\n    const arr = [];\n    let minValue = Number.MAX_VALUE;\n    for (let [_, node] of this._cache) {\n      if (node.count < minValue) {\n        minValue = node.count;\n      }\n    }\n    for (let [key, node] of this._cache) {\n      if (node.count === minValue) arr.push(key);\n    }\n    return arr;\n  }\n  put(key, value) {\n    // console.log('====PUT-' + key + '-' + value);\n    // console.log(key, value);\n    if (this._capacity === 0) return;\n    if (this._cache.has(key)) {\n      const node = this._cache.get(key);\n      node.value = value;\n      node.count++;\n      this.setNewest(key);\n      return;\n    }\n    const node = new Node(value);\n    if (this._cache.size < this._capacity) {\n      this._cache.set(key, node);\n      this.setNewest(key);\n      return;\n    }\n    const mins = this.getMinKey();\n    if (mins.length === 1) {\n      this._cache.delete(mins[0]);\n      this._cache.set(key, node);\n      this.setNewest(key);\n      return;\n    }\n    // console.log('mins:' + mins);\n    // console.log('newest:' + this.newest);\n    for (let item of this.newest) {\n      if (mins.includes(item)) {\n        this._cache.delete(item);\n        this._cache.set(key, node);\n        this.setNewest(key);\n        return;\n      }\n    }\n  }\n}"},{"script":"python","time":720,"memory":77.2,"desc":"链表。","code":"class NodeBase:\n    def __init__(self, prev, next):\n        self.prev = prev\n        self.next = next\n\n    def append(self, prev):\n        next = prev.next\n        prev.next, next.prev, self.prev, self.next = self, self, prev, next\n        return self\n\n    def remove(self):\n        if self.prev:\n            self.prev.next, self.next.prev, self.next, self.prev = self.next, self.prev, None, None\n\nclass ListBase:\n    def __init__(self, cstr):\n        self.cstr = cstr\n        self.head = cstr()\n        self.tail = cstr()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n    \n    def is_empty(self):\n        return self.head.next == self.tail\n\n\nclass Node(NodeBase):\n    def __init__(self, key=0, val=0, cnt=0, cntNode=None, prev=None, next=None):\n        self.key = key\n        self.val = val\n        self.cnt = cnt\n        self.cntNode = cntNode\n        NodeBase.__init__(self, prev, next)\n\n\nclass CntNode(NodeBase, ListBase):\n    def __init__(self, cnt = 0, prev=None, next=None):\n        self.cnt = cnt\n        ListBase.__init__(self, Node)\n        NodeBase.__init__(self, prev, next)\n\nclass LFUCache(ListBase):\n\n    def __init__(self, capacity: int):\n        self.cntCache = {}\n        self.cache = {}\n        self.capacity = capacity\n        self.size = 0\n        ListBase.__init__(self, CntNode)\n\n    def get_next_cntnode(self, node):\n        if node.next.cnt == node.cnt + 1:\n            return node.next\n        next = CntNode(node.cnt + 1)\n        next.append(node)\n        self.cntCache[next.cnt] = next\n        return next\n\n    def check_cntnode_empty(self, node):\n        if node.is_empty():\n            node.remove()\n            del self.cntCache[node.cnt]\n    \n    def upgrade_node(self, key: int, update):\n        node = self.cache[key]\n        update(node)\n        node.cnt += 1\n        nextCntNode = self.get_next_cntnode(node.cntNode)\n        node.remove()\n        if node.cntNode != self.head: self.check_cntnode_empty(node.cntNode)\n        node.append(nextCntNode.head)\n        node.cntNode = nextCntNode\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        self.upgrade_node(key, lambda node: node)\n        return self.cache[key].val\n\n    def put(self, key: int, value: int) -> None:\n        if key not in self.cache:\n            self.cache[key] = Node(key, value, 0, self.head)\n            self.size += 1\n            if self.size > self.capacity:\n                self.size -= 1\n                firstCntNode = self.head.next\n                removeNode = firstCntNode.tail.prev\n                removeNode.remove()\n                del self.cache[removeNode.key]\n                self.check_cntnode_empty(firstCntNode)\n            if self.head.next.cnt != 1:\n                self.cntCache[1] = CntNode(1).append(self.head)\n        def update(node): node.val = value\n        self.upgrade_node(key, update)","date":"2023-09-25"}],"tagList":["设计","哈希表","链表","双向链表"],"level":"Hard"}},{"problemName":"461.汉明距离.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/461.汉明距离.json","problemData":{"id":"461","name":"461.汉明距离","url":"https://leetcode.cn/problems/hamming-distance","desc":"两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。","solutions":[{"date":"2021-05-27","time":92,"memory":40.2,"script":"typescript","desc":"利用异或计算不同位置的 1 和 0。","code":"function hammingDistance(x: number, y: number): number {\n  const newVal = x ^ y;\n  let ans = 0;\n  for (let i = 0; i <= 31; i++) if ((newVal >> i) & 1) ans++;\n  return ans;\n}"}],"tagList":["位运算"],"level":"Easy"}},{"problemName":"462.最小操作次数使数组元素相等II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/462.最小操作次数使数组元素相等II.json","problemData":{"id":"462","name":"462.最小操作次数使数组元素相等II","url":"https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii","desc":"给定一个非空整数数组，找到使所有数组元素相等所需的最小移动数，其中每次移动可将选定的一个元素加 1 或减 1。 您可以假设数组的长度最多为 10000。","solutions":[{"date":"2021-08-20","time":88,"memory":39.9,"script":"typescript","desc":"找中间值。","code":"function minMoves2(nums: number[]): number {\n  nums.sort((a, b) => a - b);\n  const midNum = nums[(0 + nums.length - 1) >> 1];\n  let ans = 0;\n  for (const num of nums) {\n    ans += Math.abs(num - midNum);\n  }\n  return ans;\n}"},{"date":"2021-09-20","time":84,"memory":39.9,"script":"javascript","desc":"选取中间值，减少差值。","code":"function minMoves2(nums: number[]): number {\n  const n = nums.length;\n  nums.sort((a, b) => a - b);\n  const midNum = nums[n >> 1];\n  let c = 0;\n  for (const num of nums) {\n    c += Math.abs(num - midNum);\n  }\n  return c;\n}"},{"date":"2022-05-19","time":8,"memory":10.5,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    int minMoves2(vector<int> &nums) {\n        sort(nums.begin(), nums.end());\n        int m = nums[nums.size() / 2];\n        int ans = 0;\n        for (auto &num : nums) {\n            ans += abs(m - num);\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","数学","排序"],"level":"Medium"}},{"problemName":"463.岛屿的周长.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/463.岛屿的周长.json","problemData":{"id":"463","name":"463.岛屿的周长","url":"https://leetcode.cn/problems/island-perimeter","desc":"给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地  0 表示水域。网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。","solutions":[{"date":"2020-10-30","time":196,"memory":47.7,"script":"typescript","desc":"循环遍历每一个 1 进行计数。","code":"function islandPerimeter(grid: number[][]): number {\n  const rowLen = grid.length;\n  const colLen = grid[0].length;\n  let ans = 0;\n  for (let i = 0; i < rowLen; i++) {\n    for (let j = 0; j < colLen; j++) {\n      if (grid[i][j] === 1) {\n        ans += count(i, j);\n      }\n    }\n  }\n  return ans;\n  function count(row: number, col: number): number {\n    let ans = 0;\n    if (row === 0 || grid[row - 1][col] !== 1) ans++;\n    if (col === 0 || grid[row][col - 1] !== 1) ans++;\n    if (row === rowLen - 1 || grid[row + 1][col] !== 1) ans++;\n    if (col === colLen - 1 || grid[row][col + 1] !== 1) ans++;\n    return ans;\n  }\n}"}],"tagList":["深度优先搜索","广度优先搜索","数组","矩阵"],"level":"Easy"}},{"problemName":"464.我能赢吗.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/464.我能赢吗.json","problemData":{"id":"464","name":"464.我能赢吗","url":"https://leetcode.cn/problems/can-i-win","desc":"判断先出手的玩家是否能稳赢。","solutions":[{"date":"2021-07-29","time":1008,"memory":161.2,"script":"javascript","desc":"记忆化 dfs。","code":"var canIWin = function (maxChoosableInteger, desiredTotal) {\n  if (((maxChoosableInteger + 1) * maxChoosableInteger) / 2 < desiredTotal) return false;\n  const map = {};\n  return dfs();\n  function dfs(num = 0, total = desiredTotal) {\n    if (map[num]) return map[num];\n    if (total <= 0) return (map[num] = true);\n    for (let i = 1; i <= maxChoosableInteger; i++) {\n      if (num & (1 << i)) continue;\n      if (i >= total || !dfs(num | (1 << i), total - i)) return (map[num] = true);\n    }\n    return (map[num] = false);\n  }\n};"},{"date":"2022-05-22","time":856,"memory":85.7,"script":"cpp","desc":"dfs,记忆化，当前人赢的时候说明下一层级需要输。","code":"class Solution {\n   public:\n    int maxChoosableInteger, desiredTotal, maxBit;\n    unordered_map<int, bool> m;\n    bool canIWin(int maxChoosableInteger, int desiredTotal) {\n        if ((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal)\n            return false;\n        this->maxBit = 1 << maxChoosableInteger;\n        this->maxChoosableInteger = maxChoosableInteger;\n        this->desiredTotal = desiredTotal;\n        return dfs(0, 0);\n    }\n    bool dfs(int used, int sum) {\n        if (m.count(used)) return m[used];\n        if (sum >= desiredTotal) return m[used] = true;\n        if (check(used, sum)) return m[used] = true;\n        int ans = false;\n        for (int i = 1; i <= maxChoosableInteger; i++) {\n            int bit = 1 << i;\n            if (used & bit) continue;\n            ans = ans || !dfs(used | bit, sum + i);\n        }\n        return m[used] = ans;\n    }\n    bool check(int used, int sum) {\n        int num = desiredTotal - sum;\n        if (num > maxChoosableInteger) return false;\n        for (int i = num; i <= maxChoosableInteger; i++) {\n            int bit = 1 << i;\n            if (!(used & bit)) return true;\n        }\n        return false;\n    }\n};"}],"tagList":["位运算","记忆化搜索","数学","动态规划","状态压缩","博弈"],"level":"Medium"}},{"problemName":"466.统计重复个数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/466.统计重复个数.json","problemData":{"id":"466","name":"466.统计重复个数","url":"https://leetcode.cn/problems/count-the-repetitions","desc":"由 n 个连接的字符串 s 组成字符串 S，记作  S = [s,n]。例如，[\"abc\",3]=“abcabcabc”。如果我们可以从 s2  中删除某些字符使其变为 s1，则称字符串 s1  可以从字符串 s2 获得。例如，根据定义，\"abc\" 可以从 “abdbec” 获得，但不能从 “acbbe” 获得。现在给你两个非空字符串 s1  和 s2（每个最多 100 个字符长）和两个整数 0 ≤ n1 ≤ 106  和 1 ≤ n2 ≤ 106。现在考虑字符串 S1 和 S2，其中 S1=[s1,n1] 、S2=[s2,n2] 。请你找出一个可以满足使[S2,M] 从 S1  获得的最大整数 M 。","solutions":[{"date":"2020-04-20","time":4132,"memory":34.7,"script":"javascript","desc":"循环判断字符串长度，如果匹配 index+1。","code":"/**\n * @param {string} s1\n * @param {number} n1\n * @param {string} s2\n * @param {number} n2\n * @return {number}\n */\nvar getMaxRepetitions = function (s1, n1, s2, n2) {\n  const len1 = s1.length;\n  const len2 = s2.length;\n  let index2 = 0,\n    count = 0;\n  for (let i = 0; i < n1; i++) {\n    for (let j = 0; j < len1; j++) {\n      if (s1[j] === s2[index2]) index2++;\n      if (index2 === len2) {\n        index2 = 0;\n        count++;\n      }\n    }\n  }\n  return parseInt(count / n2);\n};"},{"script":"rust","time":260,"memory":10.65,"desc":"同上。","code":"fn str_to_vec(s: &String) -> Vec<char> {\n    s.chars().collect()\n}\nimpl Solution {\n    pub fn get_max_repetitions(s1: String, n1: i32, s2: String, n2: i32) -> i32 {\n        let (n1, n2) = (n1 as usize, n2 as usize);\n        let s1 = str_to_vec(&s1);\n        let s2 = str_to_vec(&s2);\n        let (len1, len2) = (s1.len(), s2.len());\n        let (mut k, mut idx, mut cnt) = (0, 0, 0);\n        let mut arr = vec![0];\n        while k < n1 {\n            for i in 0..len1 {\n                if s2[idx] == s1[i] {\n                    idx = (idx + 1) % len2;\n                    if idx == 0 {\n                        cnt += 1;\n                    }\n                }\n            }\n            k += 1;\n            arr.push(cnt);\n            if idx == 0 {\n                break;\n            }\n        }\n        ((cnt * (n1 / k) + arr[n1 % k]) / n2) as i32\n    }\n}","date":"2024-01-02"}],"tagList":["字符串","动态规划"],"level":"Hard"}},{"problemName":"467.环绕字符串中唯一的子字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/467.环绕字符串中唯一的子字符串.json","problemData":{"id":"467","name":"467.环绕字符串中唯一的子字符串","url":"https://leetcode.cn/problems/unique-substrings-in-wraparound-string","desc":"现在给定另一个字符串 p 。返回 s 中 唯一 的 p 的 非空子串 的数量 。 。","solutions":[{"date":"2022-05-25","time":8,"memory":8,"script":"cpp","desc":"遍历，每次储存以当前值结尾的最长长度。","code":"class Solution {\n   public:\n    int findSubstringInWraproundString(string p) {\n        int n = p.size(), ans = 0;\n        vector<int> dp(n);\n        unordered_map<char, int> m;\n        dp[0] = 1;\n        m[p[0]] = 1;\n        for (int i = 1; i < n; i++) {\n            int next = p[i - 1] == 'z' ? 'a' : p[i - 1] + 1;\n            if (next != p[i])\n                dp[i] = 1;\n            else\n                dp[i] = dp[i - 1] + 1;\n            m[p[i]] = max(m[p[i]], dp[i]);\n        }\n        for (auto& item : m) ans += item.second;\n        return ans;\n    }\n};"}],"tagList":["字符串","动态规划"],"level":"Medium"}},{"problemName":"468.验证IP地址.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/468.验证IP地址.json","problemData":{"id":"468","name":"468.验证IP地址","url":"https://leetcode.cn/problems/validate-ip-address","desc":"编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址。","solutions":[{"date":"2021-11-07","time":72,"memory":39.5,"script":"typescript","desc":"每一个片段进行解析。","code":"function checkIpv4(query: string) {\n  const list = query.split('.');\n  if (list.length !== 4) return false;\n  for (const section of list) {\n    if (\n      section === '' ||\n      (section.length > 1 && section[0] === '0') ||\n      /[a-zA-Z]+/.test(section) ||\n      +section >= 256\n    )\n      return false;\n  }\n  return true;\n}\nfunction checkIpv6(query: string) {\n  const list = query.split(':');\n  if (list.length !== 8) return false;\n  for (const section of list) {\n    if (section === '0') continue;\n    if (section === '' || section.length > 4 || /[g-zG-Z]+/.test(section)) return false;\n  }\n  return true;\n}\nfunction validIPAddress(queryIP: string): string {\n  let ipv4 = false;\n  let ipv6 = false;\n  for (const c of queryIP) {\n    if (c === '.') {\n      ipv4 = true;\n      break;\n    } else if (c === ':') {\n      ipv6 = true;\n      break;\n    }\n  }\n  if (ipv4 && checkIpv4(queryIP)) return 'IPv4';\n  if (ipv6 && checkIpv6(queryIP)) return 'IPv6';\n  return 'Neither';\n}"},{"date":"2022-05-29","time":64,"memory":42.5,"script":"typescript","desc":"遍历，检测。","code":"const ipv4Reg = /^[0-9]+$/;\nfunction _checkIPV4(item: string): boolean {\n  if (!ipv4Reg.test(item)) return false;\n  if (item.length > 1 && item[0] === '0') return false;\n  if (parseInt(item) > 255) return false;\n  return true;\n}\nfunction checkIPV4(str: string): boolean {\n  const items = str.split('.');\n  if (items.length !== 4) return false;\n  return items.every(_checkIPV4);\n}\nconst ipv6Reg = /^[0-9a-fA-F]*$/;\nfunction _checkIPV6(item: string): boolean {\n  if (!ipv6Reg.test(item)) return false;\n  if (item.length > 4 || item.length === 0) return false;\n  return true;\n}\nfunction checkIPV6(str: string): boolean {\n  const items = str.split(':');\n  if (items.length !== 8) return false;\n  return items.every(_checkIPV6);\n}\nfunction validIPAddress(queryIP: string): string {\n  if (checkIPV4(queryIP)) return 'IPv4';\n  if (checkIPV6(queryIP)) return 'IPv6';\n  return 'Neither';\n}"}],"tagList":["字符串"],"level":"Medium"}},{"problemName":"470.用Rand7()实现Rand10().json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/470.用Rand7()实现Rand10().json","problemData":{"id":"903","name":"470.用Rand7()实现Rand10()","url":"https://leetcode.cn/problems/implement-rand10-using-rand7","desc":"已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。","solutions":[{"date":"2021-05-08","time":140,"memory":46.3,"script":"typescript","desc":"利用两次 rand7 进行值判断。","code":"function rand10(): number {\n  let row: number, col: number, idx: number;\n  do {\n    row = rand7();\n    col = rand7();\n    idx = col + (row - 1) * 7;\n  } while (idx > 40);\n  return 1 + ((idx - 1) % 10);\n}"},{"date":"2021-09-05","time":108,"memory":46.5,"script":"typescript","desc":"rand7 转换为下标。","code":"function rand10(): number {\n  let num!: number;\n  do num = (rand7() - 1) * 7 + rand7();\n  while (num > 40);\n  return (num % 10) + 1;\n}"}],"tagList":["数学","拒绝采样","概率与统计","随机化"],"level":"Medium"}},{"problemName":"472.连接词.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/472.连接词.json","problemData":{"id":"472","name":"472.连接词","url":"https://leetcode.cn/problems/concatenated-words","desc":"给你一个 不含重复 单词的字符串数组 words ，请你找出并返回 words 中的所有 连接词 。","solutions":[{"date":"2021-12-28","time":4684,"memory":72.9,"script":"typescript","desc":"trie。","code":"class TrieNode {\n  end = false;\n  children: TrieNode[] = [];\n  constructor(public val: string) {}\n}\nclass Trie {\n  root = new TrieNode('');\n  insert(word: string): void {\n    let node = this.root;\n    for (const ch of word) {\n      const idx = this.getIdx(ch);\n      if (!node.children[idx]) node.children[idx] = new TrieNode(ch);\n      node = node.children[idx];\n    }\n    node.end = true;\n  }\n  findNode(word: string): TrieNode | null {\n    let node = this.root;\n    for (const ch of word) {\n      const idx = this.getIdx(ch);\n      if (!node.children[idx]) return null;\n      node = node.children[idx];\n    }\n    return node;\n  }\n  search(word: string): boolean {\n    return !!this.findNode(word)?.end;\n  }\n  startsWith(prefix: string): boolean {\n    return !!this.findNode(prefix);\n  }\n  getIdx(ch: string) {\n    return ch.codePointAt(0)! - 'a'.codePointAt(0)!;\n  }\n}\n\nfunction check(trie: Trie, word: string, init = true): boolean {\n  if (!init && trie.search(word)) return true;\n  for (let i = 0, n = word.length; i < n; i++) {\n    if (trie.search(word.substring(0, i)) && check(trie, word.substring(i), false)) return true;\n  }\n  return false;\n}\nfunction findAllConcatenatedWordsInADict(words: string[]): string[] {\n  const trie = new Trie();\n  return words\n    .sort((w1, w2) => w1.length - w2.length)\n    .filter(word => {\n      if (!word) return false;\n      if (check(trie, word)) return true;\n      trie.insert(word);\n      return false;\n    });\n}"}],"tagList":["深度优先搜索","字典树","数组","字符串","动态规划"],"level":"Hard"}},{"problemName":"473.火柴拼正方形.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/473.火柴拼正方形.json","problemData":{"id":"473","name":"473.火柴拼正方形","url":"https://leetcode.cn/problems/matchsticks-to-square","desc":"输入为小女孩拥有火柴的数目，每根火柴用其长度表示。输出即为是否能用所有的火柴拼成正方形。","solutions":[{"date":"2021-07-25","time":344,"memory":40.7,"script":"typescript","desc":"dfs+剪枝，当前桶容量小于最小木棍时，舍弃。","code":"function makesquare(matchsticks: number[]): boolean {\n  matchsticks.sort((a, b) => b - a);\n  const sum = matchsticks.reduce((total, cur) => total + cur, 0);\n  const list: number[] = new Array(4).fill(sum / 4);\n  return dfs();\n  function dfs(index = 0): boolean {\n    if (index === matchsticks.length) return list.every(v => v === 0);\n    const num = matchsticks[index];\n    for (let i = 0; i < 4; i++) {\n      if (list[i] < num) continue;\n      if (list[i] < matchsticks[matchsticks.length - 1]) return false;\n      list[i] -= num;\n      if (dfs(index + 1)) return true;\n      list[i] += num;\n    }\n    return false;\n  }\n}"},{"date":"2022-06-01","time":224,"memory":9.5,"script":"typescript","desc":"dfs。","code":"class Solution {\n   public:\n    bool makesquare(vector<int> &matchsticks) {\n        int sum = 0;\n        for (auto &num : matchsticks) sum += num;\n        int edge = sum / 4;\n        if (edge * 4 != sum) return false;\n        sort(matchsticks.begin(), matchsticks.end(),\n             [&](int a, int b) -> bool { return b < a; });\n        vector<int> list(4, 0);\n        return dfs(edge, list, 0, matchsticks);\n    }\n    bool dfs(int &edge, vector<int> &list, int idx, vector<int> &matchsticks) {\n        if (idx == matchsticks.size()) {\n            for (auto &num : list) {\n                if (num != edge) return false;\n            }\n            return true;\n        }\n        for (int i = 0; i < 4; i++) {\n            if (list[i] >= edge || list[i] + matchsticks[idx] > edge) continue;\n            list[i] += matchsticks[idx];\n            if (dfs(edge, list, idx + 1, matchsticks)) return true;\n            list[i] -= matchsticks[idx];\n        }\n        return false;\n    }\n};"}],"tagList":["位运算","数组","动态规划","回溯","状态压缩"],"level":"Medium"}},{"problemName":"474.一和零.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/474.一和零.json","problemData":{"id":"474","name":"474.一和零","url":"https://leetcode.cn/problems/ones-and-zeroes","desc":"请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。","solutions":[{"date":"2021-09-13","time":576,"memory":102.2,"script":"javascript","desc":"动态规划。","code":"var findMaxForm = function (strs, m, n) {\n  const length = strs.length;\n  const dp = new Array(length + 1)\n    .fill(0)\n    .map(() => new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0)));\n  for (let i = 1; i <= length; i++) {\n    const zerosOnes = getZerosOnes(strs[i - 1]);\n    let zeros = zerosOnes[0],\n      ones = zerosOnes[1];\n    for (let j = 0; j <= m; j++) {\n      for (let k = 0; k <= n; k++) {\n        dp[i][j][k] = dp[i - 1][j][k];\n        if (j >= zeros && k >= ones) {\n          dp[i][j][k] = Math.max(dp[i][j][k], dp[i - 1][j - zeros][k - ones] + 1);\n        }\n      }\n    }\n  }\n  return dp[length][m][n];\n};\n\nconst getZerosOnes = str => {\n  const zerosOnes = new Array(2).fill(0);\n  const length = str.length;\n  for (let i = 0; i < length; i++) {\n    zerosOnes[str[i].charCodeAt() - '0'.charCodeAt()]++;\n  }\n  return zerosOnes;\n};"},{"date":"2021-09-13","time":260,"memory":40.3,"script":"typescript","desc":"动态规划。","code":"function findMaxForm(strs: string[], m: number, n: number): number {\n  const len = strs.length;\n  const dp = new Array(2)\n    .fill(0)\n    .map(_ => new Array(m + 1).fill(0).map(_ => new Array(n + 1).fill(0)));\n  for (let i = 1; i <= len; i++) {\n    const { count0, count1 } = getCount(strs[i - 1]);\n    const idx = i % 2;\n    const prevIdx = idx ^ 1;\n    for (let j = 0; j <= m; j++) {\n      for (let k = 0; k <= n; k++) {\n        dp[idx][j][k] = dp[prevIdx][j][k];\n        if (count1 <= k && count0 <= j)\n          dp[idx][j][k] = Math.max(dp[prevIdx][j][k], dp[prevIdx][j - count0][k - count1] + 1);\n      }\n    }\n  }\n  return dp[len % 2][m][n];\n  function getCount(str: string): { count0: number; count1: number } {\n    let count0 = 0;\n    let count1 = 0;\n    for (let i = 0, n = str.length; i < n; i++)\n      if (str[i] === '0') count0++;\n      else count1++;\n    return { count0, count1 };\n  }\n}"}],"tagList":["数组","字符串","动态规划"],"level":"Medium"}},{"problemName":"475.供暖器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/475.供暖器.json","problemData":{"id":"475","name":"475.供暖器","url":"https://leetcode.cn/problems/heaters","desc":"现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。","solutions":[{"date":"2021-07-23","time":100,"memory":42.4,"script":"typescript","desc":"遍历房子取最近供暖器。","code":"function findRadius(houses: number[], heaters: number[]): number {\n  heaters.sort((a, b) => a - b);\n  let ans = -Infinity;\n  for (const house of houses) {\n    const i = bs(house);\n    ans = Math.max(\n      ans,\n      i === 0\n        ? Math.abs(heaters[i] - house)\n        : i === heaters.length\n        ? Math.abs(heaters[heaters.length - 1] - house)\n        : Math.min(heaters[i] - house, house - heaters[i - 1])\n    );\n  }\n  return ans;\n  function bs(target: number): number {\n    let l = 0;\n    let r = heaters.length - 1;\n    while (r - l > 3) {\n      const mid = (r + l) >> 1;\n      if (heaters[mid] >= target) r = mid;\n      else l = mid + 1;\n    }\n    for (let i = l; i <= r; i++) if (heaters[i] >= target) return i;\n    return heaters.length;\n  }\n}"},{"date":"2021-12-20","time":108,"memory":42.6,"script":"typescript","desc":"二分答案。","code":"function bs(houses: number[], n: number, heaters: number[], m: number, rad: number): boolean {\n  let idx = 0;\n  for (let i = 0; i < m && idx < n; i++) {\n    const heater = heaters[i];\n    while (idx < n && Math.abs(heater - houses[idx]) <= rad) idx++;\n  }\n  return idx === n;\n}\nfunction findRadius(houses: number[], heaters: number[]): number {\n  houses.sort((a, b) => a - b);\n  heaters.sort((a, b) => a - b);\n  const houseLen = houses.length;\n  const heaterLen = heaters.length;\n  let l = 0;\n  let r = 1e9;\n  while (l < r) {\n    const m = (l + r) >> 1;\n    if (bs(houses, houseLen, heaters, heaterLen, m)) r = m;\n    else l = m + 1;\n  }\n  return l;\n}"}],"tagList":["数组","双指针","二分查找","排序"],"level":"Medium"}},{"problemName":"476.数字的补数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/476.数字的补数.json","problemData":{"id":"476","name":"476.数字的补数","url":"https://leetcode.cn/problems/number-complement","desc":"给你一个 正 整数 num ，输出它的补数。补数是对该数的二进制表示取反。","solutions":[{"date":"2021-10-18","time":68,"memory":39.2,"script":"typescript","desc":"利用字符串翻转。","code":"function findComplement(num: number): number {\n  const bitStr = num\n    .toString(2)\n    .split('')\n    .map(v => (v === '1' ? '0' : '1'))\n    .join('');\n  return parseInt(bitStr, 2);\n}"},{"date":"2021-10-18","time":72,"memory":39.1,"script":"typescript","desc":"获取最高位进行翻转，利用异或取反。","code":"function findComplement(num: number): number {\n  let bit = 0;\n  for (; bit <= 30; bit++) if (num < 1 << bit) break;\n  if (bit === 31) bit = 0x7fffffff;\n  bit = (1 << bit) - 1;\n  return bit ^ num;\n}"}],"tagList":["位运算"],"level":"Easy"}},{"problemName":"477.汉明距离总和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/477.汉明距离总和.json","problemData":{"id":"477","name":"477.汉明距离总和","url":"https://leetcode.cn/problems/total-hamming-distance","desc":"两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。","solutions":[{"date":"2021-05-28","time":156,"memory":41.7,"script":"typescript","desc":"逐位统计个数。","code":"function totalHammingDistance(nums: number[]): number {\n  const len = nums.length;\n  let ans = 0;\n  for (let i = 0; i <= 31; i++) {\n    let count = 0;\n    nums.forEach(num => (count += (num >> i) & 1));\n    ans += count * (len - count);\n  }\n  return ans;\n}"}],"tagList":["位运算","数组","数学"],"level":"Medium"}},{"problemName":"478.在圆内随机生成点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/478.在圆内随机生成点.json","problemData":{"id":"915","name":"478.在圆内随机生成点","url":"https://leetcode.cn/problems/generate-random-point-in-a-circle","desc":"给定圆的半径和圆心的位置，实现函数 randPoint ，在圆中产生均匀随机点。","solutions":[{"date":"2022-06-05","time":128,"memory":58.3,"script":"typescript","desc":"忽略边上的点。","code":"class Solution {\n  constructor(public radius: number, public x_center: number, public y_center: number) {}\n  randPoint(): number[] {\n    while (true) {\n      const [x, y] = [\n        2 * Math.random() * this.radius - this.radius,\n        2 * Math.random() * this.radius - this.radius,\n      ];\n      if (x ** 2 + y ** 2 <= this.radius * this.radius)\n        return [x + this.x_center, y + this.y_center];\n    }\n  }\n}"}],"tagList":["几何","数学","拒绝采样","随机化"],"level":"Medium"}},{"problemName":"479.最大回文数乘积.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/479.最大回文数乘积.json","problemData":{"id":"479","name":"479.最大回文数乘积","url":"https://leetcode.cn/problems/largest-palindrome-product","desc":"给定一个整数 n ，返回 可表示为两个 n 位整数乘积的 最大回文整数 。因为答案可能非常大，所以返回它对 1337 取余 。 。","solutions":[{"date":"2022-04-16","time":0,"memory":5.7,"script":"cpp","desc":"枚举。","code":"long long arr[8] = {9,          9009,         906609,         99000099,\n                    9966006699, 999000000999, 99956644665999, 9999000000009999};\nclass Solution {\n    public:\n     int largestPalindrome(int n) { return arr[n - 1] % 1337; }\n};"}],"tagList":["数学","枚举"],"level":"Hard"}},{"problemName":"480.滑动窗口中位数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/480.滑动窗口中位数.json","problemData":{"id":"480","name":"480.滑动窗口中位数","url":"https://leetcode.cn/problems/sliding-window-median","desc":"给你一个数组 nums，有一个大小为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。","solutions":[{"date":"2021-02-03","time":168,"memory":44,"script":"typescript","desc":"利用队列维护。","code":"class BestQueue {\n  get len() {\n    return this.queue.length;\n  }\n  constructor(public queue: number[]) {}\n  add(val: number, l = 0, r = this.len) {\n    if (l >= r) {\n      this.queue.splice(l, 0, val);\n    } else {\n      const mid = ~~((l + r) / 2);\n      const num = this.queue[mid];\n      if (num > val) {\n        this.add(val, l, mid);\n      } else if (num < val) {\n        this.add(val, mid + 1, r);\n      } else {\n        this.queue.splice(mid, 0, val);\n      }\n    }\n  }\n  del(val: number) {\n    this.queue.splice(this.queue.indexOf(val), 1);\n  }\n  findMid() {\n    return this.len & 1\n      ? this.queue[(this.len - 1) / 2]\n      : (this.queue[this.len / 2] + this.queue[this.len / 2 - 1]) / 2;\n  }\n}\nfunction medianSlidingWindow(nums: number[], k: number): number[] {\n  const queue = new BestQueue(nums.slice(0, k).sort((a, b) => a - b));\n  const ans = [queue.findMid()];\n  for (let i = k, l = nums.length; i < l; i++) {\n    queue.del(nums[i - k]);\n    queue.add(nums[i]);\n    ans.push(queue.findMid());\n  }\n  return ans;\n}"}],"tagList":["数组","哈希表","滑动窗口","堆（优先队列）"],"level":"Hard"}},{"problemName":"481.神奇字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/481.神奇字符串.json","problemData":{"id":"481","name":"481.神奇字符串","url":"https://leetcode.cn/problems/magical-string","desc":"给你一个整数 n ，返回在神奇字符串 s 的前 n 个数字中 1 的数目。","solutions":[{"date":"2022-10-31","time":8,"memory":8.5,"script":"cpp","desc":"双指针记录。","code":"class Solution {\npublic:\n    int magicalString(int n) {\n        vector<int> list(max(3, n));\n        list[0] = 1; list[1] = list[2] = 2;\n        int ans = 1, i1 = 2, i2 = 3, surplus = 2, curVal = 1, curMode = 1;\n        while (i2 < n) {\n            if (surplus == 0) {\n                surplus = list[++i1];\n                curVal += curMode;\n                curMode = -curMode;\n            }\n            list[i2++] = curVal;\n            surplus--;\n            if (curVal == 1) ans++;\n        }\n        return ans;\n    }\n};"}],"tagList":["双指针","字符串"],"level":"Medium"}},{"problemName":"482.密钥格式化.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/482.密钥格式化.json","problemData":{"id":"482","name":"482.密钥格式化","url":"https://leetcode.cn/problems/license-key-formatting","desc":"给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。","solutions":[{"date":"2021-10-04","time":84,"memory":43.4,"script":"typescript","desc":"遍历。","code":"function licenseKeyFormatting(s: string, k: number): string {\n  s = s.toUpperCase().replace(/-/g, '');\n  const sum = s.length;\n  if (sum <= k) return s;\n  const mod = sum % k || k;\n  let ans = s.substr(0, mod) + '-';\n  for (let i = 0, end = sum - mod; i < end; i++) {\n    if (i !== 0 && i % k === 0) ans += '-';\n    ans += s[i + mod];\n  }\n  return ans;\n}"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"485.最大连续1的个数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/485.最大连续1的个数.json","problemData":{"id":"485","name":"485.最大连续1的个数","url":"https://leetcode.cn/problems/max-consecutive-ones","desc":"给定一个二进制数组， 计算其中最大连续 1 的个数。","solutions":[{"date":"2021-02-15","time":96,"memory":41.4,"script":"typescript","desc":"遍历。","code":"function findMaxConsecutiveOnes(nums: number[]): number {\n  let max = 0;\n  let num = 0;\n  nums.forEach(v => {\n    if (v & 1) {\n      num++;\n    } else {\n      max = Math.max(max, num);\n      num = 0;\n    }\n  });\n  return Math.max(max, num);\n}"}],"tagList":["数组"],"level":"Easy"}},{"problemName":"486.预测赢家.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/486.预测赢家.json","problemData":{"id":"486","name":"486.预测赢家","url":"https://leetcode.cn/problems/predict-the-winner","desc":"请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。","solutions":[{"date":"2020-09-02","time":120,"memory":40.2,"script":"typescript","desc":"直接利用正则判断。","code":"function isNumber(s: string): boolean {\n  return /^[+-]?(\\d+(\\.\\d*)?|(\\.\\d+))(e[+-]?\\d+)?$/i.test(s.trim());\n}"}],"tagList":["递归","数组","数学","动态规划","博弈"],"level":"Medium"}},{"problemName":"488.祖玛游戏.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/488.祖玛游戏.json","problemData":{"id":"488","name":"488.祖玛游戏","url":"https://leetcode.cn/problems/zuma-game","desc":"给你一个字符串 board ，表示桌面上最开始的那排球。另给你一个字符串 hand ，表示手里的彩球。请你按上述操作步骤移除掉桌上所有球，计算并返回所需的 最少 球数。如果不能移除桌上所有的球，返回 -1 。","solutions":[{"date":"2021-11-09","time":800,"memory":64.7,"script":"typescript","desc":"dfs。","code":"function format(board: string): string {\n  let flag = false;\n  let n = board.length;\n  do {\n    flag = false;\n    for (let i = 0; i < n - 1; i++) {\n      const ball = board[i];\n      let end = i;\n      let cnt = 1;\n      while (end < n - 1 && ball === board[end + 1]) {\n        end++;\n        cnt++;\n      }\n      if (cnt < 3) {\n        i = end;\n        continue;\n      }\n      board = board.substring(0, i) + board.substring(end + 1);\n      n = board.length;\n      flag = true;\n    }\n  } while (flag);\n  return board;\n}\nfunction findMinStep(board: string, hand: string): number {\n  const cache: Record<string, number> = {};\n  const map: Record<string, number> = { R: 0, Y: 0, B: 0, G: 0, W: 0 };\n  for (const ball of hand) map[ball]++;\n  return dfs(board, 0, map);\n  function dfs(board: string, cnt: number, map: Record<string, number>): number {\n    if (cache[board]) return cache[board];\n    if (board === '') return cnt;\n    const n = board.length;\n    const list = Object.entries(map)\n      .filter(([, v]) => v > 0)\n      .map(([k]) => k);\n    let ans = Infinity;\n    for (let i = 0; i < n; i++) {\n      for (let j = 0; j < list.length; j++) {\n        const ball = list[j];\n        map[ball]--;\n        const nextBoard = board.substring(0, i) + ball + board.substring(i);\n        const res = dfs(format(nextBoard), cnt + 1, map);\n        if (res !== -1) ans = Math.min(ans, res);\n        map[ball]++;\n      }\n    }\n    return (cache[board] = ans === Infinity ? -1 : ans);\n  }\n}"}],"tagList":["栈","广度优先搜索","记忆化搜索","字符串","动态规划"],"level":"Hard"}},{"problemName":"491.非递减子序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/491.非递减子序列.json","problemData":{"id":"491","name":"491.非递减子序列","url":"https://leetcode.cn/problems/non-decreasing-subsequences","desc":"给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是 2。","solutions":[{"date":"2020-08-25","time":292,"memory":55.9,"script":"typescript","desc":"深度遍历每种可能,剪纸+回溯","code":"function findSubsequences(nums: number[]): number[][] {\n  const len = nums.length;\n  if (len === 0) return [];\n  const arr: number[][] = [];\n  const arrSet = new Set<string>();\n  findNext();\n  return arr.filter(v => v.length !== 1);\n  function findNext(now: number[] = [], i = 0): void {\n    for (; i < len; i++) {\n      const num = nums[i];\n      if (now[now.length - 1] > num) continue;\n      now.push(num);\n      const clone = [...now];\n      const cloneSetStr = clone.join(',');\n      if (!arrSet.has(cloneSetStr)) {\n        arr.push(clone);\n        arrSet.add(cloneSetStr);\n      }\n      findNext(now, i + 1);\n      now.pop();\n    }\n  }\n}"}],"tagList":["位运算","数组","哈希表","回溯"],"level":"Medium"}},{"problemName":"492.构造矩形.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/492.构造矩形.json","problemData":{"id":"492","name":"492.构造矩形","url":"https://leetcode.cn/problems/construct-the-rectangle","desc":"你需要按顺序输出你设计的页面的长度 L 和宽度 W。","solutions":[{"date":"2021-10-23","time":84,"memory":39.4,"script":"typescript","desc":"从平方根开始找。","code":"function constructRectangle(area: number): number[] {\n  let l = ~~Math.sqrt(area);\n  while (l >= 1 && area % l !== 0) l--;\n  return [area / l, l];\n}"}],"tagList":["数学"],"level":"Easy"}},{"problemName":"494.目标和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/494.目标和.json","problemData":{"id":"494","name":"494.目标和","url":"https://leetcode.cn/problems/target-sum","desc":"返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。","solutions":[{"script":"python","time":200,"memory":43.27,"desc":"dfs。","code":"class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        @cache\n        def dfs(idx: int, target: int) -> int:\n            if idx == len(nums): return int(0 == target) \n            return dfs(idx + 1, target + nums[idx]) + dfs(idx + 1, target - nums[idx])\n        return dfs(0, target)","date":"2024-06-30"}],"tagList":["数组","动态规划","回溯"],"level":"Medium"}},{"problemName":"495.提莫攻击.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/495.提莫攻击.json","problemData":{"id":"495","name":"495.提莫攻击","url":"https://leetcode.cn/problems/teemo-attacking","desc":"返回艾希处于中毒状态的 总 秒数。","solutions":[{"date":"2021-11-10","time":76,"memory":42.2,"script":"typescript","desc":"遍历。","code":"function findPoisonedDuration(timeSeries: number[], duration: number): number {\n  let ans = 0;\n  for (let i = 0, n = timeSeries.length; i < n - 1; i++) {\n    const time = timeSeries[i];\n    const next_time = timeSeries[i + 1];\n    if (time + duration - 1 >= next_time) ans += next_time - time;\n    else ans += duration;\n  }\n  ans += duration;\n  return ans;\n}"}],"tagList":["数组","模拟"],"level":"Easy"}},{"problemName":"496.下一个更大元素I.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/496.下一个更大元素I.json","problemData":{"id":"496","name":"496.下一个更大元素I","url":"https://leetcode.cn/problems/next-greater-element-i","desc":"请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。","solutions":[{"date":"2021-07-20","time":76,"memory":39.9,"script":"typescript","desc":"单调递减栈。","code":"function nextGreaterElement(nums1: number[], nums2: number[]): number[] {\n  const map: Record<number, number> = {};\n  const n2 = nums2.length;\n  for (let i = 0; i < n2; i++) map[nums2[i]] = i;\n  const stack: number[] = [];\n  const arr = new Array(n2).fill(-1);\n  for (let i = 0; i < n2; i++) {\n    const num = nums2[i];\n    while (stack.length && nums2[stack[stack.length - 1]] < num) arr[stack.pop()!] = num;\n    stack.push(i);\n  }\n  return nums1.map(num => arr[map[num]]);\n}"},{"date":"2021-10-26","time":76,"memory":40.2,"script":"typescript","desc":"单调栈。","code":"function nextGreaterElement(nums1: number[], nums2: number[]): number[] {\n  const map = new Map<number, number>();\n  nums1.forEach((v, i) => map.set(v, i));\n  const ans: number[] = new Array(nums1.length).fill(-1);\n  const stack: number[] = [];\n  for (const num2 of nums2) {\n    while (stack.length && stack[stack.length - 1] < num2) {\n      const num = stack.pop()!;\n      if (map.has(num)) ans[map.get(num)!] = num2;\n    }\n    stack.push(num2);\n  }\n  return ans;\n}"}],"tagList":["栈","数组","哈希表","单调栈"],"level":"Easy"}},{"problemName":"498.对角线遍历.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/498.对角线遍历.json","problemData":{"id":"498","name":"498.对角线遍历","url":"https://leetcode.cn/problems/diagonal-traverse","desc":"给你一个大小为 m x n 的矩阵 mat ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。","solutions":[{"date":"2022-06-14","time":24,"memory":17.9,"script":"cpp","desc":"遍历，内嵌两个 while 进行反复循环。","code":"class Solution {\n   public:\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\n        int n = mat.size(), m = mat[0].size(), i = 0, j = 0;\n        vector<int> ans;\n        while (i != n - 1 || j != m - 1) {\n            while (i != -1 && j != m) ans.push_back(mat[i--][j++]);\n            i++;\n            if (j == m) j--, i++;\n            if (i == n - 1 && j == m - 1) break;\n            while (i != n && j != -1) ans.push_back(mat[i++][j--]);\n            j++;\n            if (i == n) i--, j++;\n            if (i == n - 1 && j == m - 1) break;\n        }\n        ans.push_back(mat[i][j]);\n        return ans;\n    }\n};"}],"tagList":["数组","矩阵","模拟"],"level":"Medium"}},{"problemName":"500.键盘行.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/401-500/500.键盘行.json","problemData":{"id":"500","name":"500.键盘行","url":"https://leetcode.cn/problems/keyboard-row","desc":"给你一个字符串数组 words ，只返回可以使用在 美式键盘 同一行的字母打印出来的单词。","solutions":[{"date":"2021-10-31","time":76,"memory":39.3,"script":"typescript","desc":"哈希。","code":"function findWords(words: string[]): string[] {\n  const data: Set<string>[] = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm'].map(\n    str => new Set<string>(str.split(''))\n  );\n  return words.filter(word => {\n    word = word.toLowerCase();\n    const set = data.find(set => set.has(word[0]))!;\n    for (const ch of word) {\n      if (!set.has(ch)) return false;\n    }\n    return true;\n  });\n}"}],"tagList":["数组","哈希表","字符串"],"level":"Easy"}}]},{"dirName":"501-600","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\501-600","problems":[{"problemName":"501.二叉搜索树中的众数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/501.二叉搜索树中的众数.json","problemData":{"id":"501","name":"501.二叉搜索树中的众数","url":"https://leetcode.cn/problems/find-mode-in-binary-search-tree","desc":"给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。","solutions":[{"date":"2020-09-24","time":120,"memory":47.2,"script":"typescript","desc":"中序遍历。","code":"function findMode(root: TreeNode | null): number[] {\n  const cache: Record<number, number> = {};\n  const setCache = (val: number) => {\n    if (!cache[val]) cache[val] = 0;\n    cache[val] += 1;\n  };\n  const inorder = (root: TreeNode | null) => {\n    if (root === null) return;\n    inorder(root.left);\n    setCache(root.val);\n    inorder(root.right);\n  };\n  inorder(root);\n  return Object.entries(cache)\n    .sort(([, c1], [, c2]) => c2 - c1)\n    .filter(([, c], _, arr) => c === arr[0][1])\n    .map(([val]) => parseInt(val));\n}"},{"date":"2020-09-24","time":88,"memory":44.1,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/solution/er-cha-sou-suo-shu-zhong-de-zhong-shu-by-leetcode-/)。","code":"function findMode(root: TreeNode | null): number[] {\n  let base = 0;\n  let count = 0;\n  let maxCount = 0;\n  let answer: number[] = [];\n  const update = (x: number) => {\n    if (x === base) count++;\n    else {\n      count = 1;\n      base = x;\n    }\n    if (count === maxCount) answer.push(base);\n    if (count > maxCount) {\n      maxCount = count;\n      answer = [base];\n    }\n  };\n\n  let cur = root,\n    pre = null;\n  while (cur !== null) {\n    if (cur.left === null) {\n      update(cur.val);\n      cur = cur.right;\n      continue;\n    }\n    pre = cur.left;\n    while (pre.right !== null && pre.right !== cur) pre = pre.right;\n    if (pre.right === null) {\n      pre.right = cur;\n      cur = cur.left;\n    } else {\n      pre.right = null;\n      update(cur.val);\n      cur = cur.right;\n    }\n  }\n  return answer;\n}"},{"date":"2021-08-07","time":88,"memory":47.1,"script":"typescript","desc":"中序遍历。","code":"function findMode(root: TreeNode | null): number[] {\n  if (root === null) return [];\n  const map = new Map<number, number>();\n  inorder(root);\n  return [...map.entries()]\n    .sort(([, v1], [, v2]) => v2 - v1)\n    .filter(([, v], _, list) => v === list[0][1])\n    .map(([k]) => k);\n  function inorder(node: TreeNode | null): void {\n    if (node === null) return;\n    inorder(node.left);\n    map.set(node.val, 1 + (map.get(node.val) ?? 0));\n    inorder(node.right);\n  }\n}"}],"tagList":["树","深度优先搜索","二叉搜索树","二叉树"],"level":"Easy"}},{"problemName":"502.IPO.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/502.IPO.json","problemData":{"id":"502","name":"502.IPO","url":"https://leetcode.cn/problems/ipo","desc":"从给定项目中选择 最多 k 个不同项目的列表，以 最大化最终资本 ，并输出最终可获得的最多资本。","solutions":[{"date":"2021-09-08","time":336,"memory":66.9,"script":"typescript","desc":"利用堆快速找出当前利润最大值。","code":"class Heap<T = number> {\n  private arr: T[] = [];\n  get isEmpty() {\n    return this.size === 0;\n  }\n  get size() {\n    return this.arr.length;\n  }\n  get top() {\n    return this.arr[0];\n  }\n  constructor(private compare: (t1: T, t2: T) => number) {}\n  add(num: T): void {\n    this.arr.push(num);\n    this.shiftUp(this.size - 1);\n  }\n  remove(): T {\n    const num = this.arr.shift()!;\n    if (this.size) {\n      this.arr.unshift(this.arr.pop()!);\n      this.shiftDown(0);\n    }\n    return num;\n  }\n  private shiftUp(index: number): void {\n    if (index === 0) return;\n    const parentIndex = (index - 1) >> 1;\n    if (this.compare(this.arr[index], this.arr[parentIndex]) > 0) {\n      [this.arr[index], this.arr[parentIndex]] = [this.arr[parentIndex], this.arr[index]];\n      this.shiftUp(parentIndex);\n    }\n  }\n  private shiftDown(index: number): void {\n    let childrenIndex = index * 2 + 1;\n    if (childrenIndex > this.size - 1) return;\n    if (\n      childrenIndex + 1 <= this.size - 1 &&\n      this.compare(this.arr[childrenIndex + 1], this.arr[childrenIndex]) > 0\n    ) {\n      childrenIndex++;\n    }\n    if (this.compare(this.arr[childrenIndex], this.arr[index]) > 0) {\n      [this.arr[childrenIndex], this.arr[index]] = [this.arr[index], this.arr[childrenIndex]];\n      this.shiftDown(childrenIndex);\n    }\n  }\n  *[Symbol.iterator](): IterableIterator<T> {\n    for (const t of this.arr) {\n      yield t;\n    }\n  }\n}\ntype Data = {\n  cost: number;\n  profit: number;\n};\nfunction findMaximizedCapital(k: number, w: number, profits: number[], capital: number[]): number {\n  const n = profits.length;\n  const list: Data[] = [];\n  for (let i = 0; i < n; i++)\n    list.push({\n      cost: capital[i],\n      profit: profits[i],\n    });\n  list.sort((a, b) => a.cost - b.cost);\n  const heap = new Heap<Data>((t1, t2) => t1.profit - t2.profit);\n  if (w >= list[list.length - 1].cost) {\n    return list\n      .sort((a, b) => b.profit - a.profit)\n      .slice(0, k)\n      .reduce((total, cur) => (total += cur.profit), w);\n  }\n  let idx = 0;\n  while (k > 0) {\n    while (idx < n && list[idx].cost <= w) {\n      heap.add(list[idx++]);\n    }\n    if (heap.size === 0) break;\n    const data = heap.remove();\n    w += data.profit;\n    k--;\n  }\n  return w;\n}"}],"tagList":["贪心","数组","排序","堆（优先队列）"],"level":"Hard"}},{"problemName":"503.下一个更大元素II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/503.下一个更大元素II.json","problemData":{"id":"503","name":"503.下一个更大元素II","url":"https://leetcode.cn/problems/next-greater-element-ii","desc":"给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。","solutions":[{"date":"2021-03-06","time":576,"memory":44.8,"script":"typescript","desc":"直接 for 循环判断下一值。","code":"function nextGreaterElements(nums: number[]): number[] {\n  const len = nums.length;\n  const ans: number[] = [];\n  for (let i = 0; i < len; i++) {\n    const num = nums[i];\n    for (let j = i === len - 1 ? 0 : i + 1; ; j = (j + 1) % len) {\n      if (nums[j] > num) {\n        ans[i] = nums[j];\n        break;\n      }\n      if (j === i) {\n        ans[i] = -1;\n        break;\n      }\n    }\n  }\n  return ans;\n}"},{"date":"2021-03-06","time":128,"memory":44.5,"script":"typescript","desc":"利用栈储存下标。","code":"function nextGreaterElements(nums: number[]): number[] {\n  const len = nums.length;\n  const ans = new Array(len).fill(-1);\n  const stack: number[] = [];\n  for (let i = 0, l = len * 2 - 1; i < l; i++) {\n    const num = nums[i % len];\n    while (stack.length && nums[stack[stack.length - 1]] < num) {\n      ans[stack[stack.length - 1]] = num;\n      stack.pop();\n    }\n    stack.push(i % len);\n  }\n  return ans;\n}"},{"script":"python","time":57,"memory":18.21,"desc":"单调栈。","code":"class Solution:\n    def nextGreaterElements(self, nums: List[int]) -> List[int]:\n        n = len(nums)\n        arr = [-1] * n\n        s = []\n        def run(need_append):\n            for i in range(n):\n                while s and nums[s[-1]] < nums[i]: arr[s.pop()] = nums[i]\n                if need_append: s.append(i)\n        run(True)\n        run(False)\n        return arr","date":"2024-06-24"}],"tagList":["栈","数组","单调栈"],"level":"Medium"}},{"problemName":"504.七进制数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/504.七进制数.json","problemData":{"id":"504","name":"504.七进制数","url":"https://leetcode.cn/problems/base-7","desc":"给定一个整数 num，将其转化为 7 进制，并以字符串形式输出。","solutions":[{"date":"2021-08-20","time":84,"memory":39.4,"script":"typescript","desc":"计数法。","code":"function convertToBase7(num: number): string {\n  if (num === 0) return '0';\n  let f = false;\n  if (num < 0) {\n    f = true;\n    num = -1 * num;\n  }\n  let ans = '';\n  while (num !== 0) {\n    ans = (num % 7) + ans;\n    num = ~~(num / 7);\n  }\n  return (f ? '-' : '') + ans;\n}"},{"date":"2022-03-07","time":0,"memory":5.8,"script":"cpp","desc":"短除法。","code":"class Solution {\n   public:\n    string convertToBase7(int num) {\n        int f = 0;\n        if (num < 0) {\n            num = -num;\n            f = 1;\n        }\n        string ans = \"\";\n        while (num >= 7) {\n            ans = to_string(num % 7) + ans;\n            num /= 7;\n        }\n        ans = to_string(num) + ans;\n        if (f) ans = \"-\" + ans;\n        return ans;\n    }\n};"}],"tagList":["数学"],"level":"Easy"}},{"problemName":"506.相对名次.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/506.相对名次.json","problemData":{"id":"506","name":"506.相对名次","url":"https://leetcode.cn/problems/relative-ranks","desc":"使用长度为 n 的数组 answer 返回获奖，其中 answer[i] 是第 i 位运动员的获奖情况。","solutions":[{"date":"2021-12-02","time":96,"memory":40.9,"script":"typescript","desc":"排序。","code":"function findRelativeRanks(score: number[]): string[] {\n  const n = score.length;\n  const idxs = new Array(n)\n    .fill(0)\n    .map((_, i) => i)\n    .sort((a, b) => score[b] - score[a]);\n  const ans: string[] = [];\n  for (let i = 0; i < n; i++) {\n    const str =\n      i === 0 ? 'Gold Medal' : i === 1 ? 'Silver Medal' : i === 2 ? 'Bronze Medal' : `${i + 1}`;\n    ans[idxs[i]] = str;\n  }\n  return ans;\n}"},{"date":"2021-12-02","time":16,"memory":7.9,"script":"c","desc":"遍历。","code":"int *g_score;\nint comp(const void *a, const void *b) {\n    return g_score[*(int *)b] - g_score[*(int *)a];\n}\nchar ** findRelativeRanks(int* score, int scoreSize, int* returnSize){\n    g_score = score;\n    *returnSize = scoreSize;\n    int *idxs = (int *)malloc(sizeof(int) * scoreSize);\n    for (int i = 0; i < scoreSize; i++) idxs[i] = i;\n    qsort(idxs, scoreSize, sizeof(int), comp);\n    char **ans = (char **)malloc(sizeof(char *) * scoreSize);\n    for (int i = 0; i < scoreSize; i++) {\n        if (i == 0) ans[idxs[i]] = \"Gold Medal\";\n        else if (i == 1) ans[idxs[i]] = \"Silver Medal\";\n        else if (i == 2) ans[idxs[i]] = \"Bronze Medal\";\n        else {\n            ans[idxs[i]] = (char *)malloc(10);\n            sprintf(ans[idxs[i]], \"%d\", i + 1);\n        }\n    }\n    return ans;\n\n}"}],"tagList":["数组","排序","堆（优先队列）"],"level":"Easy"}},{"problemName":"507.完美数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/507.完美数.json","problemData":{"id":"507","name":"507.完美数","url":"https://leetcode.cn/problems/perfect-number","desc":"对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。","solutions":[{"date":"2021-12-31","time":0,"memory":5.9,"script":"cpp","desc":"遍历后获取每个因数。","code":"class Solution {\n   public:\n    bool checkPerfectNumber(int num) {\n        if (num == 1) return 0;\n        int ans = 1;\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i) continue;\n            ans += i;\n            if (i * i < num) ans += num / i;\n        }\n        return ans == num;\n    }\n};"}],"tagList":["数学"],"level":"Easy"}},{"problemName":"509.斐波那契数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/509.斐波那契数.json","problemData":{"id":"1013","name":"509.斐波那契数","url":"https://leetcode.cn/problems/fibonacci-number","desc":"斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。","solutions":[{"date":"2020-02-11","time":64,"memory":33.6,"script":"javascript","desc":"创建对象，循环赋值，若对象里不存在则储存，存在则直接取值。","code":"var fib = function (N) {\n  let obj = {\n    0: 0,\n    1: 1,\n  };\n  for (let i = 2; i <= N; i++) {\n    obj[i] = obj[i - 1] + obj[i - 2];\n  }\n  return obj[N];\n};"},{"date":"2021-01-04","time":88,"memory":40.2,"script":"typescript","desc":"动态规划,依次累加。","code":"function fib(n: number): number {\n  if (n === 0) return 0;\n  if (n === 1) return 1;\n  let num0 = 0;\n  let num1 = 1;\n  for (let i = 2; i <= n; i++) [num0, num1] = [num1, num0 + num1];\n  return num1;\n}"}],"tagList":["递归","记忆化搜索","数学","动态规划"],"level":"Easy"}},{"problemName":"513.找树左下角的值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/513.找树左下角的值.json","problemData":{"id":"513","name":"513.找树左下角的值","url":"https://leetcode.cn/problems/find-bottom-left-tree-value","desc":"给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。","solutions":[{"date":"2021-07-21","time":88,"memory":43.2,"script":"typescript","desc":"层序遍历。","code":"function findBottomLeftValue(root: TreeNode): number {\n  const queue: TreeNode[] = [root];\n  let size = 1;\n  let ans = root.val;\n  while (queue.length !== 0) {\n    const node = queue.shift()!;\n    node.left && queue.push(node.left);\n    node.right && queue.push(node.right);\n    if (--size === 0 && queue.length !== 0) {\n      ans = queue[0].val;\n      size = queue.length;\n    }\n  }\n  return ans;\n}"},{"date":"2022-06-22","time":12,"memory":21.1,"script":"cpp","desc":"层序遍历。","code":"class Solution {\n   public:\n    int findBottomLeftValue(TreeNode* root) {\n        queue<TreeNode*> q;\n        q.push(root);\n        int ans = root->val, size = 1;\n        while (q.size()) {\n            TreeNode* node = q.front();\n            q.pop();\n            if (node->left) q.push(node->left);\n            if (node->right) q.push(node->right);\n            if (--size == 0) {\n                size = q.size();\n                if (q.size()) ans = q.front()->val;\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"514.自由之路.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/514.自由之路.json","problemData":{"id":"514","name":"514.自由之路","url":"https://leetcode.cn/problems/freedom-trail","desc":"给定一个字符串 ring ，表示刻在外环上的编码；给定另一个字符串 key ，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数。","solutions":[{"date":"2020-11-11","script":"javascript","time":140,"memory":45.82,"desc":"dp。","code":"const getIdx = (str, v) => str.codePointAt(v) - 'a'.codePointAt(0);\nvar findRotateSteps = function(ring, key) {\n    const n = ring.length, m = key.length;\n    const pos = new Array(26).fill(0).map(v => []);\n    for (let i = 0; i < n; ++i) {\n        pos[getIdx(ring, i)].push(i);\n    }\n    const dp = new Array(m).fill(0).map(v => new Array(n).fill(Number.MAX_SAFE_INTEGER));\n    for (const i of pos[getIdx(key, 0)]) {\n        dp[0][i] = Math.min(i, n - i) + 1;\n    }\n    for (let i = 1; i < m; ++i) {\n        for (const j of pos[getIdx(key, i)]) {\n            for (const k of pos[getIdx(key, i - 1)]) {\n                dp[i][j] = Math.min(dp[i][j], dp[i - 1][k] + Math.min(Math.abs(j - k), n - Math.abs(j - k)) + 1);\n            }\n        }\n    }\n    return dp[m - 1].reduce((pre, cur) => Math.min(pre, cur), Number.MAX_SAFE_INTEGER);\n};"},{"script":"python","time":108,"memory":17.4,"desc":"dfs。","code":"class Solution:\n    def findRotateSteps(self, ring: str, key: str) -> int:\n        arr = defaultdict(list)\n        for i in range(len(ring)):\n            arr[ring[i]].append(i)\n        @cache\n        def dfs(i1: int, i2: int) -> int:\n            if i2 == len(key): return 0\n            if ring[i1] == key[i2]: return dfs(i1, i2 + 1) + 1\n            return min(\n                dfs(next_i, i2 + 1) + min(abs(i1 - next_i), len(ring) - abs(i1 - next_i)) + 1\n                for next_i in arr[key[i2]]\n            )\n        return dfs(0, 0)","date":"2024-01-29"}],"tagList":["深度优先搜索","广度优先搜索","字符串","动态规划"],"level":"Hard"}},{"problemName":"515.在每个树行中找最大值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/515.在每个树行中找最大值.json","problemData":{"id":"515","name":"515.在每个树行中找最大值","url":"https://leetcode.cn/problems/find-largest-value-in-each-tree-row","desc":"给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。","solutions":[{"date":"2022-06-24","time":8,"memory":21.6,"script":"cpp","desc":"层序遍历。","code":"class Solution {\n   public:\n    vector<int> largestValues(TreeNode* root) {\n        vector<int> ans;\n        if (root == nullptr) return ans;\n        queue<TreeNode*> q;\n        q.push(root);\n        ans.push_back(root->val);\n        int size = 1, nmax = INT_MIN;\n        while (q.size()) {\n            TreeNode* node = q.front();\n            q.pop();\n            if (node->left) {\n                q.push(node->left);\n                nmax = max(nmax, node->left->val);\n            }\n            if (node->right) {\n                q.push(node->right);\n                nmax = max(nmax, node->right->val);\n            }\n            if (--size == 0) {\n                if (q.size()) ans.push_back(nmax);\n                nmax = INT_MIN;\n                size = q.size();\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"516.最长回文子序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/516.最长回文子序列.json","problemData":{"id":"516","name":"516.最长回文子序列","url":"https://leetcode.cn/problems/longest-palindromic-subsequence","desc":"给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。","solutions":[{"date":"2021-08-12","time":212,"memory":86,"script":"typescript","desc":"动态规划,dp[i][j]=以 i 结尾 j 开头的子序列的最大值。","code":"function longestPalindromeSubseq(s: string): number {\n  const n = s.length;\n  if (n === 1) return 1;\n  const dp = new Array(n).fill(0).map(_ => new Array(n).fill(0));\n  for (let i = n - 2; i >= 0; i--) {\n    dp[i][i] = 1;\n    const cl = s[i];\n    for (let j = i + 1; j < n; j++) {\n      const cr = s[j];\n      if (cl === cr) {\n        dp[i][j] = dp[i + 1][j - 1] + 2;\n      } else {\n        dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);\n      }\n    }\n  }\n  return dp[0][n - 1];\n}"}],"tagList":["字符串","动态规划"],"level":"Medium"}},{"problemName":"517.超级洗衣机.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/517.超级洗衣机.json","problemData":{"id":"517","name":"517.超级洗衣机","url":"https://leetcode.cn/problems/super-washing-machines","desc":"给定一个整数数组  machines 代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的 最少的操作步数 。如果不能使每台洗衣机中衣物的数量相等，则返回 -1 。","solutions":[{"date":"2021-09-29","time":76,"memory":40.1,"script":"typescript","desc":"贪心，统计每个洗衣机里衣服数与平均衣服数的差。","code":"function findMinMoves(machines: number[]): number {\n  const sum = machines.reduce((total, cur) => total + cur, 0);\n  const n = machines.length;\n  if (sum % n !== 0) return -1;\n  const avg = ~~(sum / n);\n  let ans = 0;\n  let num = 0;\n  for (let i = 0; i < n; i++) {\n    num += machines[i] - avg;\n    ans = Math.max(ans, Math.max(machines[i] - avg, Math.abs(num)));\n  }\n  return ans;\n}"}],"tagList":["贪心","数组"],"level":"Hard"}},{"problemName":"518.零钱兑换II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/518.零钱兑换II.json","problemData":{"id":"518","name":"518.零钱兑换II","url":"https://leetcode.cn/problems/coin-change-ii","desc":"给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。","solutions":[{"date":"2021-06-10","time":92,"memory":39.8,"script":"typescript","desc":"计算每种硬币的可能。","code":"function change(amount: number, coins: number[]): number {\n  const dp = new Array(amount + 1).fill(0);\n  dp[0] = 1;\n  for (const coin of coins) {\n    for (let i = 1; i <= amount; i++) {\n      if (i >= coin) {\n        dp[i] += dp[i - coin];\n      }\n    }\n  }\n  return dp[amount];\n}"},{"date":"2021-09-13","time":100,"memory":39.9,"script":"javascript","desc":"动态规划。","code":"function change(amount: number, coins: number[]): number {\n  coins.sort((a, b) => a - b);\n  const dp = new Array(amount + 1).fill(0);\n  dp[0] = 1;\n  for (const coin of coins) {\n    for (let i = 1; i <= amount; i++) {\n      if (i >= coin) dp[i] += dp[i - coin];\n    }\n  }\n  return dp[amount];\n}"},{"script":"python","time":81,"memory":16.5,"desc":"dp记录当前金额下的能兑换的方式数。","code":"class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n        for coin in coins:\n            for cur in range(coin, amount + 1):\n                dp[cur] += dp[cur - coin]\n        return dp[amount]","date":"2024-03-25"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"519.随机翻转矩阵.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/519.随机翻转矩阵.json","problemData":{"id":"913","name":"519.随机翻转矩阵","url":"https://leetcode.cn/problems/random-flip-matrix","desc":"给你一个 m x n 的二元矩阵 matrix ，且所有值被初始化为 0 。请你设计一个算法，随机选取一个满足  matrix[i][j] == 0 的下标  (i, j) ，并将它的值变为 1 。所有满足 matrix[i][j] == 0 的下标 (i, j) 被选取的概率应当均等。","solutions":[{"date":"2021-11-27","time":100,"memory":43.8,"script":"typescript","desc":"随机值，每次遍历到一个位置，把该位置与最后一个位置进行交换。","code":"class Solution {\n  map = new Map<number, number>();\n  total: number;\n  constructor(public m: number, public n: number) {\n    this.total = m * n;\n  }\n  flip(): number[] {\n    const num = this.random(0, --this.total);\n    const idx = this.map.get(num) ?? num;\n    this.map.set(num, this.map.get(this.total) ?? this.total);\n    return [Math.floor(idx / this.n), idx % this.n];\n  }\n  reset(): void {\n    this.map.clear();\n    this.total = this.m * this.n;\n  }\n  random(min: number, max: number): number {\n    return min + Math.floor(Math.random() * (max - min + 1));\n  }\n}"}],"tagList":["水塘抽样","哈希表","数学","随机化"],"level":"Medium"}},{"problemName":"520.检测大写字母.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/520.检测大写字母.json","problemData":{"id":"520","name":"520.检测大写字母","url":"https://leetcode.cn/problems/detect-capital","desc":"给定一个单词，你需要判断单词的大写使用是否正确。","solutions":[{"date":"2020-04-07","time":64,"memory":34.1,"script":"javascript","desc":"通过转换大小写进行判断。","code":"/**\n * @param {string} word\n * @return {boolean}\n */\nvar detectCapitalUse = function (word) {\n  if (word.toLowerCase() === word) return true;\n  if (word.toUpperCase() === word) return true;\n  if (\n    word[0].toUpperCase() === word[0] &&\n    word.substring(1, word.length).toLowerCase() === word.substring(1, word.length)\n  )\n    return true;\n  return false;\n};"},{"date":"2021-11-14","time":80,"memory":39.6,"script":"typescript","desc":"正则。","code":"function detectCapitalUse(word: string): boolean {\n  return /(^[A-Z]*$)|(^[a-z]*$)|(^[A-Z]{1}[a-z]*$)/g.test(word);\n}"},{"script":"python","time":31,"memory":16.41,"desc":"直接判断。","code":"class Solution:\n    def detectCapitalUse(self, word: str) -> bool:\n        return word.isupper() or word.islower() or len(word) > 1 and word[0].isupper() and word[1:].islower()","date":"2024-06-23"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"522.最长特殊序列II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/522.最长特殊序列II.json","problemData":{"id":"522","name":"522.最长特殊序列II","url":"https://leetcode.cn/problems/longest-uncommon-subsequence-ii","desc":"给定字符串列表 strs ，返回其中 最长的特殊序列 。如果最长特殊序列不存在，返回 -1 。","solutions":[{"date":"2022-06-27","time":4,"memory":8,"script":"cpp","desc":"对于每个字符串，查找是否有父串。","code":"class Solution {\n   public:\n    int findLUSlength(vector<string> &strs) {\n        int ans = -1, n = strs.size();\n        for (int i = 0; i < n; i++) {\n            string s1 = strs[i];\n            bool check = true;\n            for (int j = 0; j < n; j++) {\n                if (i != j && isSubStr(s1, strs[j])) {\n                    check = false;\n                    break;\n                }\n            }\n            if (check) ans = max(ans, (int)s1.size());\n        }\n        return ans;\n    }\n    bool isSubStr(const string &s1, const string &s2) {\n        int i1 = 0, i2 = 0, n1 = s1.size(), n2 = s2.size();\n        for (; i1 < n1 && i2 < n2; i2++)\n            if (s1[i1] == s2[i2]) i1++;\n        return i1 == n1;\n    }\n};"},{"script":"python","time":38,"memory":16.28,"desc":"枚举。","code":"class Solution:\n    def findLUSlength(self, strs: List[str]) -> int:\n        map = Counter(strs)\n        strs.sort(key = lambda s: -len(s))\n        for i in range(len(strs)):\n            s = strs[i]\n            if map[s] > 1: continue\n            need_continue = False\n            for j in range(i):\n                i1 = 0\n                for c in strs[j]:\n                    if s[i1] == c:\n                        i1 += 1\n                    if i1 == len(s):\n                        break\n                if i1 == len(s):\n                    need_continue = True\n                    break\n            if need_continue: continue\n            return len(s)\n        return -1","date":"2024-06-17"}],"tagList":["数组","哈希表","双指针","字符串","排序"],"level":"Medium"}},{"problemName":"523.连续的子数组和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/523.连续的子数组和.json","problemData":{"id":"523","name":"523.连续的子数组和","url":"https://leetcode.cn/problems/continuous-subarray-sum","desc":"给你一个整数数组 nums 和一个整数 k。如果存在一个整数 n ，令整数 x 符合 x = n \\* k ，则称 x 是 k 的一个倍数。","solutions":[{"date":"2021-06-02","time":156,"memory":53.9,"script":"typescript","desc":"当 prefixSums[q]−prefixSums[p] 为 kk 的倍数时，prefixSums[p] 和 prefixSums[q] 除以 k 的余数相同。","code":"function checkSubarraySum(nums: number[], k: number): boolean {\n  const len = nums.length;\n  if (len < 2 || k === 0) return false;\n  const map = new Map<number, number>([[0, -1]]);\n  let num = 0;\n  for (let i = 0; i < len; i++) {\n    num = (num + nums[i]) % k;\n    let prev = map.get(num);\n    if (prev !== undefined) {\n      if (i - prev >= 2) return true;\n    } else map.set(num, i);\n  }\n  return false;\n}"}],"tagList":["数组","哈希表","数学","前缀和"],"level":"Medium"}},{"problemName":"524.通过删除字母匹配到字典里最长单词.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/524.通过删除字母匹配到字典里最长单词.json","problemData":{"id":"524","name":"524.通过删除字母匹配到字典里最长单词","url":"https://leetcode.cn/problems/longest-word-in-dictionary-through-deleting","desc":"给你一个字符串 s 和一个字符串数组 dictionary 作为字典，找出并返回字典中最长的字符串，该字符串可以通过删除 s 中的某些字符得到。如果答案不止一个，返回长度最长且字典序最小的字符串。如果答案不存在，则返回空字符串。","solutions":[{"date":"2021-09-14","time":132,"memory":42.8,"script":"javascript","desc":"双指针。","code":"function findLongestWord(s: string, dictionary: string[]): string {\n        const n = dictionary.length;\n        const idxs = new Array(n).fill(0);\n        for (const c of s) {\n          for (let i = 0; i < n; i++) {\n            if (dictionary[i][idxs[i]] === c) idxs[i]++;\n          }\n        }\n        let ans!: string;\n        for (let i = 0; i < n; i++) {\n          if (dictionary[i].length === idxs[i]) {\n            if (!ans) ans = dictionary[i];\n            else ans = check(dictionary[i], ans);\n          }\n        }\n        return ans ?? '';\n        function check(str1: string, str2: string): string {\n          const n1 = str1.length;\n          const n2 = str2.length;\n          if (n1 > n2) return str1;\n          if (n1 < n2) return str2;\n          let idx = 0;\n          while (idx < n1) {\n            if (str1[idx] !== str2[idx])\n              return str1.codePointAt(idx)! > str2.codePointAt(idx)! ? str2 : str1;\n            idx++;\n          }\n          return str1;\n        }\n      }"}],"tagList":["数组","双指针","字符串","排序"],"level":"Medium"}},{"problemName":"525.连续数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/525.连续数组.json","problemData":{"id":"525","name":"525.连续数组","url":"https://leetcode.cn/problems/contiguous-array","desc":"给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。","solutions":[{"date":"2021-06-03","time":144,"memory":46.8,"script":"typescript","desc":"把 0 都置-1,利用前缀和判断和为 0 的值。","code":"function findMaxLength(nums: number[]): number {\n  const len = nums.length;\n  for (let i = 0; i < len; i++) if (nums[i] === 0) nums[i] = -1;\n  let sum = 0;\n  let ans = 0;\n  const map = new Map<number, number>([[0, -1]]);\n  for (let i = 0; i < len; i++) {\n    sum += nums[i];\n    let prev = map.get(sum);\n    if (prev !== undefined) ans = Math.max(ans, i - prev);\n    else map.set(sum, i);\n  }\n  return ans;\n}"},{"date":"2021-12-23","time":116,"memory":81.8,"script":"cpp","desc":"前缀和。","code":"class Solution {\n   public:\n    int findMaxLength(vector<int>& nums) {\n        int ans = 0, sum = 0;\n        unordered_map<int, int> mmap;\n        mmap[0] = -1;\n        for (int i = 0; i < nums.size(); i++) {\n            sum += nums[i] == 1 ? 1 : -1;\n            if (mmap.count(sum)) {\n                ans = max(ans, i - mmap[sum]);\n            } else {\n                mmap[sum] = i;\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","前缀和"],"level":"Medium"}},{"problemName":"526.优美的排列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/526.优美的排列.json","problemData":{"id":"526","name":"526.优美的排列","url":"https://leetcode.cn/problems/beautiful-arrangement","desc":"现在给定一个整数 N，请问可以构造多少个优美的排列？。","solutions":[{"date":"2021-08-16","time":396,"memory":43.6,"script":"typescript","desc":"深度遍历每个位置。","code":"function countArrangement(n: number): number {\n  let ans = 0;\n  dfs();\n  return ans;\n  function dfs(list: number[] = [], set = new Set<number>()) {\n    if (list.length === n) {\n      ans++;\n      return;\n    }\n    for (let i = 1; i <= n; i++) {\n      if (!set.has(i) && (i % (list.length + 1) === 0 || (list.length + 1) % i === 0)) {\n        set.add(i);\n        list.push(i);\n        dfs(list, set);\n        list.pop();\n        set.delete(i);\n      }\n    }\n  }\n}"},{"date":"2021-08-16","time":148,"memory":39.3,"script":"typescript","desc":"深度遍历每个位置,利用二进制去重。","code":"function countArrangement(n: number): number {\n  let ans = 0;\n  dfs();\n  return ans;\n  function dfs(list: number[] = [], mask = 0) {\n    if (list.length === n) {\n      ans++;\n      return;\n    }\n    for (let i = 1; i <= n; i++) {\n      if (\n        (mask & (1 << (i - 1))) === 0 &&\n        (i % (list.length + 1) === 0 || (list.length + 1) % i === 0)\n      ) {\n        mask |= 1 << (i - 1);\n        list.push(i);\n        dfs(list, mask);\n        list.pop();\n        mask &= ~(1 << (i - 1));\n      }\n    }\n  }\n}"}],"tagList":["位运算","数组","动态规划","回溯","状态压缩"],"level":"Medium"}},{"problemName":"528.按权重随机选择.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/528.按权重随机选择.json","problemData":{"id":"912","name":"528.按权重随机选择","url":"https://leetcode.cn/problems/random-pick-with-weight","desc":"给定一个正整数数组  w ，其中  w[i]  代表下标 i  的权重（下标从 0 开始），请写一个函数  pickIndex ，它可以随机地获取下标 i，选取下标 i  的概率与  w[i]  成正比。","solutions":[{"date":"2021-08-20","time":168,"memory":47.4,"script":"typescript","desc":"前缀和进行快速查找。","code":"class Solution {\n  sums: number[] = [0];\n  constructor(public w: number[]) {\n    for (const num of w) this.sums.push(this.sums[this.sums.length - 1] + num);\n  }\n  pickIndex(): number {\n    const random = this.random();\n    let l = 0;\n    let r = this.sums.length - 1;\n    while (l < r) {\n      const mid = (l + r) >> 1;\n      if (this.sums[mid] <= random) l = mid + 1;\n      else r = mid;\n    }\n    return l - 1;\n  }\n  random(min: number = 0, max: number = this.sums[this.sums.length - 1]): number {\n    return min + ~~(Math.random() * (max - min + 1));\n  }\n}"},{"date":"2021-08-30","time":240,"memory":47.1,"script":"typescript","desc":"利用前缀和随机取值。","code":"class Solution {\n  sums: number;\n  constructor(private w: number[]) {\n    this.sums = w.reduce((total, cur) => total + cur, 0);\n  }\n  pickIndex(): number {\n    let random = this.random();\n    for (let i = 0; i < this.w.length; i++) {\n      const w = this.w[i];\n      if (random <= w) return i;\n      random -= w;\n    }\n    return 0;\n  }\n  random(min: number = 1, max: number = this.sums): number {\n    return min + ~~(Math.random() * (max - min + 1));\n  }\n}"}],"tagList":["数组","数学","二分查找","前缀和","随机化"],"level":"Medium"}},{"problemName":"529.扫雷游戏.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/529.扫雷游戏.json","problemData":{"id":"529","name":"529.扫雷游戏","url":"https://leetcode.cn/problems/minesweeper","desc":"让我们一起来玩扫雷游戏！","solutions":[{"date":"2020-08-20","time":200,"memory":46,"script":"typescript","desc":"深度遍历。","code":"function updateBoard(board: string[][], click: number[]): string[][] {\n  const rowLen = board.length;\n  const colLen = board[0].length;\n  console.log(rowLen, colLen);\n  const set = new Set<string>();\n  const format = (row: number, col: number) => `${row}:${col}`;\n  dfs(click[0], click[1]);\n  return board;\n  function countMine(row: number, col: number): number {\n    let num = 0;\n    // top\n    if (row !== 0 && col !== 0 && isMine(row - 1, col - 1)) num++;\n    if (row !== 0 && isMine(row - 1, col)) num++;\n    if (row !== 0 && col !== colLen - 1 && isMine(row - 1, col + 1)) num++;\n    // mid\n    if (col !== 0 && isMine(row, col - 1)) num++;\n    if (col !== colLen - 1 && isMine(row, col + 1)) num++;\n    // bottom\n    if (row !== rowLen - 1 && col !== 0 && isMine(row + 1, col - 1)) num++;\n    if (row !== rowLen - 1 && isMine(row + 1, col)) num++;\n    if (row !== rowLen - 1 && col !== colLen - 1 && isMine(row + 1, col + 1)) num++;\n    return num;\n  }\n  function isMine(row: number, col: number): boolean {\n    return board[row][col] === 'M';\n  }\n  function dfs(row: number, col: number): void {\n    const formatName = format(row, col);\n    if (set.has(formatName)) return;\n    else set.add(formatName);\n    if (isMine(row, col)) {\n      board[row][col] = 'X';\n    } else if (countMine(row, col) > 0) {\n      board[row][col] = countMine(row, col) + '';\n    } else {\n      console.log(row, col);\n      board[row][col] = 'B';\n      // top\n      if (row !== 0 && col !== 0) dfs(row - 1, col - 1);\n      if (row !== 0) dfs(row - 1, col);\n      if (row !== 0 && col !== colLen - 1) dfs(row - 1, col + 1);\n      // mid\n      if (col !== 0) dfs(row, col - 1);\n      if (col !== colLen - 1) dfs(row, col + 1);\n      // bottom\n      if (row !== rowLen - 1 && col !== 0) dfs(row + 1, col - 1);\n      if (row !== rowLen - 1) dfs(row + 1, col);\n      if (row !== rowLen - 1 && col !== colLen - 1) dfs(row + 1, col + 1);\n    }\n  }\n}"}],"tagList":["深度优先搜索","广度优先搜索","数组","矩阵"],"level":"Medium"}},{"problemName":"530.二叉搜索树的最小绝对差.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/530.二叉搜索树的最小绝对差.json","problemData":{"id":"530","name":"530.二叉搜索树的最小绝对差","url":"https://leetcode.cn/problems/minimum-absolute-difference-in-bst","desc":"给定一个所有节点为非负值的二叉搜索树，求树中任意两节点的差的绝对值的最小值。","solutions":[{"date":"2020-02-23","time":2,"memory":40.5,"script":"java","desc":"中序遍历后判断数组前后值相减的最小值。","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n\tArrayList<Integer> list = new ArrayList<Integer>();\n\n    public int getMinimumDifference(TreeNode root) {\n\t\tinorder(root);\n\t\tint min = list.get(1)-list.get(0);\n\t\tfor(int i =0,len=list.size()-1;i<len;i++)\n\t\t\tmin=Math.min(list.get(i+1)-list.get(i), min);\n\t\treturn min;\n\t}\n\n\tpublic void inorder(TreeNode node) {\n\t\tif (node.left != null) {\n\t\t\tinorder(node.left);\n\t\t}\n\t\tlist.add(node.val);\n\t\tif (node.right != null) {\n\t\t\tinorder(node.right);\n\t\t}\n\t}\n}"},{"date":"2020-10-12","time":108,"memory":44.6,"script":"typescript","desc":"中序遍历排序后进行判断。","code":"function getMinimumDifference(root: TreeNode | null): number {\n  if (root === null) return 2147483647;\n  const queue: number[] = [];\n  inorder(root);\n  return queue.reduce(\n    (total, cur, i, arr) => (i === 0 ? total : Math.min(total, Math.abs(cur - arr[i - 1]))),\n    Infinity\n  );\n  function inorder(node: TreeNode | null): void {\n    if (node === null) return;\n    inorder(node.left);\n    queue.push(node.val);\n    inorder(node.right);\n  }\n}"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉搜索树","二叉树"],"level":"Easy"}},{"problemName":"532.数组中的k-diff数对.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/532.数组中的k-diff数对.json","problemData":{"id":"532","name":"532.数组中的k-diff数对","url":"https://leetcode.cn/problems/k-diff-pairs-in-an-array","desc":"给你一个整数数组 nums 和一个整数 k，请你在数组中找出 不同的 k-diff 数对，并返回不同的 k-diff 数对 的数目。","solutions":[{"date":"2022-06-16","time":16,"memory":13.9,"script":"cpp","desc":"排序后，针对于每个点查找差值为 k 的点的数量。","code":"class Solution {\n   public:\n    int findPairs(vector<int> &nums, int k) {\n        map<int, int> m;\n        for (auto &num : nums) m[num]++;\n        if (k == 0) return check0(m);\n        int ans = 0;\n        vector<int> list;\n        for (auto &item : m) list.push_back(item.first);\n        int n = list.size(), l1 = 0, l2 = 0;\n        for (int r = 0; r < n; r++) {\n            while (l2 < r && list[r] - list[l2] >= k) l2++;\n            while (l1 < l2 && list[r] - list[l1] > k) l1++;\n            ans += l2 - l1;\n        }\n        return ans;\n    }\n    int check0(map<int, int> &m) {\n        int ans = 0;\n        for (auto &item : m) {\n            if (item.second > 1) ans++;\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","双指针","二分查找","排序"],"level":"Medium"}},{"problemName":"535.TinyURL的加密与解密.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/535.TinyURL的加密与解密.json","problemData":{"id":"535","name":"535.TinyURL的加密与解密","url":"https://leetcode.cn/problems/encode-and-decode-tinyurl","desc":"TinyURL 是一种 URL 简化服务， 比如：当你输入一个 URL https://leetcode.com/problems/design-tinyurl  时，它将返回一个简化的 URL http://tinyurl.com/4e9iAk。","solutions":[{"date":"2021-07-24","time":88,"memory":39.5,"script":"typescript","desc":"随机生成哈希值。","code":"const random = () => (~~(Math.random() * 10000)).toString();\nconst map: Record<string, string> = {};\nfunction encode(longUrl: string): string {\n  let s = random();\n  while (map[s]) s = random();\n  map[s] = longUrl;\n  return s;\n}\nfunction decode(shortUrl: string): string {\n  return map[shortUrl];\n}"}],"tagList":["设计","哈希表","字符串","哈希函数"],"level":"Medium"}},{"problemName":"537.复数乘法.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/537.复数乘法.json","problemData":{"id":"537","name":"537.复数乘法","url":"https://leetcode.cn/problems/complex-number-multiplication","desc":"给你两个字符串表示的复数 num1 和 num2 ，请你遵循复数表示形式，返回表示它们乘积的字符串。","solutions":[{"date":"2022-02-25","time":0,"memory":5.7,"script":"cpp","desc":"模拟。","code":"class Solution {\n   public:\n    void analysis(string num, int& snum, int& fnum) {\n        int add = num.find(\"+\");\n        snum = atoi(num.substr(0, add).c_str());\n        fnum = atoi(num.substr(add + 1, num.size() - add - 1).c_str());\n    }\n    string complexNumberMultiply(string num1, string num2) {\n        int snum1, fnum1, snum2, fnum2;\n        analysis(num1, snum1, fnum1);\n        analysis(num2, snum2, fnum2);\n        ostringstream ostr;\n        ostr << snum1 * snum2 + fnum1 * fnum2 * -1 << \"+\"\n             << snum1 * fnum2 + snum2 * fnum1 << \"i\";\n        return ostr.str();\n    }\n};"}],"tagList":["数学","字符串","模拟"],"level":"Medium"}},{"problemName":"538.把二叉搜索树转换为累加树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/538.把二叉搜索树转换为累加树.json","problemData":{"id":"538","name":"538.把二叉搜索树转换为累加树","url":"https://leetcode.cn/problems/convert-bst-to-greater-tree","desc":"给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。","solutions":[{"date":"2020-09-21","time":244,"memory":47,"script":"typescript","desc":"中序遍历排序后利用 reduce 累加。","code":"function convertBST(root: TreeNode | null): TreeNode | null {\n  if (isNull(root)) return null;\n  const arr: number[] = [];\n  inorder(root);\n  toGreaterTree(root);\n  return root;\n  function isNull(node: TreeNode | null): node is null {\n    return node === null;\n  }\n  function toGreaterTree(node: TreeNode | null): void {\n    if (isNull(node)) return;\n    node.val = arr.reduce((total, cur) => total + (cur > node.val ? cur : 0), node.val);\n    toGreaterTree(node.left);\n    toGreaterTree(node.right);\n  }\n  function inorder(node: TreeNode | null): void {\n    if (isNull(node)) return;\n    inorder(node.left);\n    arr.push(node.val);\n    inorder(node.right);\n  }\n}"}],"tagList":["树","深度优先搜索","二叉搜索树","二叉树"],"level":"Medium"}},{"problemName":"539.最小时间差.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/539.最小时间差.json","problemData":{"id":"539","name":"539.最小时间差","url":"https://leetcode.cn/problems/minimum-time-difference","desc":"给定一个 24 小时制（小时:分钟 \"HH:MM\"）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。","solutions":[{"date":"2021-12-23","time":16,"memory":13.8,"script":"cpp","desc":"排序后遍历。","code":"class Solution {\n   public:\n    int toMin(string s) {\n        int hor = (s[0] - '0') * 10 + s[1] - '0';\n        int min = (s[3] - '0') * 10 + s[4] - '0';\n        return hor * 60 + min;\n    }\n    int findMinDifference(vector<string>& timePoints) {\n        vector<int> data;\n        for (int i = 0; i < timePoints.size(); i++) {\n            int min = toMin(timePoints[i]);\n            data.push_back(min);\n            data.push_back(24 * 60 + min);\n        }\n        sort(data.begin(), data.end());\n        int ans = INT_MAX;\n        for (int i = 1; i < data.size(); i++) {\n            ans = min(ans, data[i] - data[i - 1]);\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","数学","字符串","排序"],"level":"Medium"}},{"problemName":"540.有序数组中的单一元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/540.有序数组中的单一元素.json","problemData":{"id":"540","name":"540.有序数组中的单一元素","url":"https://leetcode.cn/problems/single-element-in-a-sorted-array","desc":"给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。请你找出并返回只出现一次的那个数。","solutions":[{"date":"2022-02-14","time":16,"memory":21.9,"script":"cpp","desc":"bs。","code":"class Solution {\n   public:\n    int singleNonDuplicate(vector<int>& nums) {\n        return bs(nums, 0, nums.size() - 1);\n    }\n    int bs(vector<int>& nums, int l, int r) {\n        int n = r - l + 1, m = (l + r) >> 1;\n        if (n == 1 || nums[l] != nums[l + 1]) return nums[l];\n        if (nums[r] != nums[r - 1]) return nums[r];\n        if (nums[m] != nums[m - 1] && nums[m] != nums[m + 1]) return nums[m];\n        if (nums[m] == nums[m - 1]) m--;\n        if ((m - l) & 1)\n            return bs(nums, l, m - 1);\n        else\n            return bs(nums, m + 2, r);\n    }\n};"},{"date":"2022-02-14","time":20,"memory":21.9,"script":"cpp","desc":"bs, 如果是偶数下标与后面的比，奇数下标与前面的比。","code":"class Solution {\n   public:\n    int singleNonDuplicate(vector<int>& nums) {\n        int l = 0, r = nums.size() - 1, m;\n        while (l < r) {\n            m = (l + r) >> 1;\n            if (nums[m] == nums[m ^ 1])\n                l = m + 1;\n            else\n                r = m;\n        }\n        return nums[l];\n    }\n};"}],"tagList":["数组","二分查找"],"level":"Medium"}},{"problemName":"541.反转字符串II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/541.反转字符串II.json","problemData":{"id":"541","name":"541.反转字符串II","url":"https://leetcode.cn/problems/reverse-string-ii","desc":"给定一个字符串和一个整数 k，你需要对从字符串开头算起的每个 2k 个字符的前 k 个字符进行反转。如果剩余少于 k 个字符，则将剩余的所有全部反转。如果有小于 2k 但大于或等于 k 个字符，则反转前 k 个字符，并将剩余的字符保持原样。","solutions":[{"date":"2020-04-07","time":120,"memory":37.3,"script":"javascript","desc":"解构翻转。","code":"/**\n * @param {string} s\n * @param {number} k\n * @return {string}\n */\nvar reverseStr = function (s, k) {\n  function reverse(s) {\n    return [...s].reverse().join('');\n  }\n  if (s.length < k) return reverse(s);\n  const reverseS = reverse(s.substr(0, k));\n  if (s.length <= 2 * k) {\n    return reverseS + s.substr(k);\n  }\n  return reverseS + s.substr(k, k) + reverseStr(s.substr(k * 2), k);\n};"},{"date":"2021-08-20","time":76,"memory":44.1,"script":"typescript","desc":"转为数组逐个翻转。","code":"function reverseStr(s: string, k: number): string {\n  const arr = s.split('');\n  for (let i = 0, n = s.length; i < n; i += 2 * k) reverse(i, Math.min(i + k - 1, n - 1));\n  return arr.join('');\n  function reverse(start: number, end: number) {\n    while (start < end) {\n      [arr[start], arr[end]] = [arr[end], arr[start]];\n      end--;\n      start++;\n    }\n  }\n}"}],"tagList":["双指针","字符串"],"level":"Easy"}},{"problemName":"542.01矩阵.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/542.01矩阵.json","problemData":{"id":"542","name":"542.01矩阵","url":"https://leetcode.cn/problems/01-matrix","desc":"给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。","solutions":[{"date":"2020-04-15","time":236,"memory":53.1,"script":"javascript","desc":"广度优先搜索，一层一层判断。","code":"/**\n * @param {number[][]} matrix\n * @return {number[][]}\n */\nvar updateMatrix = function (matrix) {\n  const res = [];\n  const queue = [];\n  for (let i = 0; i < matrix.length; i++) {\n    res.push(new Array(matrix[i].length));\n    for (let j = 0; j < matrix[i].length; j++) {\n      if (matrix[i][j] === 0) {\n        queue.push([i, j]);\n        res[i][j] = 0;\n      }\n    }\n  }\n  while (queue.length !== 0) {\n    const [i, j] = queue.shift();\n    if (i !== 0 && res[i - 1][j] === undefined) {\n      res[i - 1][j] = 1 + res[i][j];\n      queue.push([i - 1, j]);\n    }\n    if (j !== 0 && res[i][j - 1] === undefined) {\n      res[i][j - 1] = 1 + res[i][j];\n      queue.push([i, j - 1]);\n    }\n    if (i !== res.length - 1 && res[i + 1][j] === undefined) {\n      res[i + 1][j] = 1 + res[i][j];\n      queue.push([i + 1, j]);\n    }\n    if (j !== res[i].length - 1 && res[i][j + 1] === undefined) {\n      res[i][j + 1] = 1 + res[i][j];\n      queue.push([i, j + 1]);\n    }\n  }\n  return res;\n};"},{"date":"2021-07-25","time":324,"memory":52.8,"script":"typescript","desc":"bfs。","code":"function updateMatrix(mat: number[][]): number[][] {\n  const n = mat.length;\n  const m = mat[0].length;\n  const queue: [number, number, number][] = [];\n  for (let i = 0; i < n; i++) {\n    for (let j = 0; j < m; j++) {\n      if (mat[i][j] === 0) queue.push([i, j, 0]);\n    }\n  }\n  const format = (row: number, col: number) => `${row}::${col}`;\n  const set = new Set<string>(queue.map(([row, col]) => format(row, col)));\n  const add = (row: number, col: number, level: number) => {\n    const str = format(row, col);\n    if (set.has(str)) return;\n    set.add(str);\n    queue.push([row, col, level]);\n  };\n  while (queue.length) {\n    const [row, col, level] = queue.shift()!;\n    mat[row][col] = level;\n    if (row > 0) add(row - 1, col, level + 1);\n    if (row < n - 1) add(row + 1, col, level + 1);\n    if (col > 0) add(row, col - 1, level + 1);\n    if (col < m - 1) add(row, col + 1, level + 1);\n  }\n  return mat;\n}"}],"tagList":["广度优先搜索","数组","动态规划","矩阵"],"level":"Medium"}},{"problemName":"543.二叉树的直径.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/543.二叉树的直径.json","problemData":{"id":"543","name":"543.二叉树的直径","url":"https://leetcode.cn/problems/diameter-of-binary-tree","desc":"给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。","solutions":[{"date":"2022-03-15","time":16,"memory":19.7,"script":"cpp","desc":"dfs 统计左右子树的高度。","code":"class Solution {\n   public:\n    int h(TreeNode* node) {\n        if (!node) return 0;\n        return max(h(node->left), h(node->right)) + 1;\n    }\n    int diameterOfBinaryTree(TreeNode* root) {\n        if (!root) return 0;\n        return max(h(root->left) + h(root->right),\n                   max(diameterOfBinaryTree(root->left),\n                       diameterOfBinaryTree(root->right)));\n    }\n};"}],"tagList":["树","深度优先搜索","二叉树"],"level":"Easy"}},{"problemName":"547.省份数量.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/547.省份数量.json","problemData":{"id":"547","name":"547.省份数量","url":"https://leetcode.cn/problems/number-of-provinces","desc":"在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。返回矩阵中 省份 的数量。","solutions":[{"date":"2021-01-07","time":92,"memory":41.1,"script":"typescript","desc":"深度优先搜索。","code":"function findCircleNum(isConnected: number[][]): number {\n  const set = new Set<number>();\n  let ans = 0;\n  const len = isConnected.length;\n  const find = (index: number): void => {\n    for (let i = 0; i < len; i++) {\n      if (isConnected[i][index] === 1 && !set.has(i)) {\n        set.add(i);\n        find(i);\n      }\n    }\n  };\n  for (let i = 0; i < len; i++) {\n    if (!set.has(i)) {\n      ans++;\n      find(i);\n    }\n  }\n  return ans;\n}"},{"date":"2021-04-30","time":92,"memory":40.7,"script":"typescript","desc":"并查集。","code":"class UnionFind {\n  elements: number[];\n  constructor(public size: number) {\n    this.elements = new Array(size).fill(0).map((_, i) => i);\n  }\n  same(v1: number, v2: number): boolean {\n    return this.find(v1) === this.find(v2);\n  }\n  find(v: number): number {\n    return v === this.elements[v] ? v : (this.elements[v] = this.find(this.elements[v]));\n  }\n  union(v1: number, v2: number): void {\n    const e1 = this.find(v1);\n    const e2 = this.find(v2);\n    if (e1 !== e2) {\n      this.elements[e1] = e2;\n      this.size--;\n    }\n  }\n}\n\nfunction findCircleNum(isConnected: number[][]): number {\n  const len = isConnected.length;\n  const uf = new UnionFind(len);\n  for (let i = 0; i < len; i++) {\n    const connect = isConnected[i];\n    for (let j = 0; j < len; j++) {\n      connect[j] === 1 && uf.union(i, j);\n    }\n  }\n  return uf.size;\n}"},{"date":"2021-12-04","time":36,"memory":6.9,"script":"javascript","desc":"并查集。","code":"typedef struct unionfind\n{\n    int *father, len, size;\n} UnionFind;\nUnionFind *unionfind_create(int len)\n{\n    UnionFind *uf = (UnionFind *)malloc(sizeof(UnionFind));\n    uf->size = uf->len = len;\n    uf->father = (int *)malloc(sizeof(int) * len);\n    for (int i = 0; i < len; i++)\n        uf->father[i] = i;\n    return uf;\n}\nvoid unionfind_free(UnionFind *uf)\n{\n    free(uf->father);\n    free(uf);\n}\nint unionfind_find(UnionFind *uf, int data)\n{\n    return uf->father[data] = uf->father[data] == data ? data : unionfind_find(uf, uf->father[data]);\n}\nvoid unionfind_union(UnionFind *uf, int data1, int data2)\n{\n    int p1 = unionfind_find(uf, data1), p2 = unionfind_find(uf, data2);\n    if (p1 == p2) return ;\n    uf->size--;\n    uf->father[p1] = p2;\n}\nint findCircleNum(int** isConnected, int isConnectedSize, int* isConnectedColSize){\n    UnionFind *uf = unionfind_create(isConnectedSize);\n    for (int i = 0; i < isConnectedSize; i++) {\n        for (int j = 0; j < isConnectedSize; j++) {\n            if (isConnected[i][j]) unionfind_union(uf, i, j);\n        }\n    }\n    return uf->size;\n}"}],"tagList":["深度优先搜索","广度优先搜索","并查集","图"],"level":"Medium"}},{"problemName":"551.学生出勤记录I.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/551.学生出勤记录I.json","problemData":{"id":"551","name":"551.学生出勤记录I","url":"https://leetcode.cn/problems/student-attendance-record-i","desc":"如果学生可以获得出勤奖励，返回 true ；否则，返回 false 。","solutions":[{"date":"2021-08-17","time":72,"memory":39.4,"script":"typescript","desc":"遍历。","code":"function checkRecord(s: string): boolean {\n  let ac = 0;\n  let lc = 0;\n  for (const c of s) {\n    if (c === 'A') {\n      if (++ac >= 2) return false;\n      lc = 0;\n    } else if (c === 'L') {\n      if (++lc >= 3) return false;\n    } else {\n      lc = 0;\n    }\n  }\n  return true;\n}"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"552.学生出勤记录II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/552.学生出勤记录II.json","problemData":{"id":"552","name":"552.学生出勤记录II","url":"https://leetcode.cn/problems/student-attendance-record-ii","desc":"给你一个整数 n ，表示出勤记录的长度（次数）。请你返回记录长度为 n 时，可能获得出勤奖励的记录情况 数量 。","solutions":[{"date":"2021-08-18","time":2216,"memory":78.9,"script":"typescript","desc":"dp[i][j][k]=第 i 天的时候存在 j 个 A 和 k 个 L 的情况。","code":"function checkRecord(n: number): number {\n  const mod = 10 ** 9 + 7;\n  const dp = new Array(n + 1).fill(0).map(_ => new Array(2).fill(0).map(_ => new Array(3).fill(0)));\n  dp[0][0][0] = 1;\n  for (let i = 1; i <= n; i++) {\n    for (let j = 0; j < 2; j++) {\n      for (let k = 0; k < 3; k++) {\n        dp[i][j][0] = (dp[i][j][0] + dp[i - 1][j][k]) % mod;\n      }\n    }\n    for (let k = 0; k < 3; k++) {\n      dp[i][1][0] = (dp[i][1][0] + dp[i - 1][0][k]) % mod;\n    }\n    for (let j = 0; j < 2; j++) {\n      for (let k = 1; k < 3; k++) {\n        dp[i][j][k] = (dp[i][j][k] + dp[i - 1][j][k - 1]) % mod;\n      }\n    }\n  }\n  let ans = 0;\n  for (let j = 0; j < 2; j++) for (let k = 0; k < 3; k++) ans = (ans + dp[n][j][k]) % mod;\n  return ans;\n}"}],"tagList":["动态规划"],"level":"Hard"}},{"problemName":"553.最优除法.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/553.最优除法.json","problemData":{"id":"553","name":"553.最优除法","url":"https://leetcode.cn/problems/optimal-division","desc":"给定一组正整数，相邻的整数之间将会进行浮点除法操作。例如， [2,3,4] -> 2 / 3 / 4 。但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，才能得到最大的结果，并且返回相应的字符串格式的表达式。你的表达式不应该含有冗余的括号。","solutions":[{"date":"2022-02-27","time":0,"memory":7.7,"script":"cpp","desc":"使分母最小。","code":"class Solution {\n   public:\n    string optimalDivision(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 1) return to_string(nums[0]);\n        if (n == 2) return to_string(nums[0]) + \"/\" + to_string(nums[1]);\n        string ans = to_string(nums[0]) + \"/(\";\n        for (int i = 1; i < nums.size(); i++) {\n            ans += to_string(nums[i]);\n            if (i != nums.size() - 1) ans += \"/\";\n        }\n        ans += \")\";\n        return ans;\n    }\n};"}],"tagList":["数组","数学","动态规划"],"level":"Medium"}},{"problemName":"554.砖墙.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/554.砖墙.json","problemData":{"id":"554","name":"554.砖墙","url":"https://leetcode.cn/problems/brick-wall","desc":"你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。","solutions":[{"date":"2021-05-02","time":136,"memory":45.2,"script":"typescript","desc":"统计每个边界的空数。","code":"function leastBricks(wall: number[][]): number {\n  const rowLen = wall.length;\n  const size = wall[0].reduce((total, cur) => total + cur, 0);\n  if (wall.every(row => row.length === 1)) return rowLen;\n  const map: Record<number, number> = {};\n  for (const row of wall) {\n    let sum = -1;\n    for (const col of row) {\n      sum += col;\n      map[sum] = 1 + (map[sum] ?? 0);\n    }\n  }\n  Reflect.deleteProperty(map, size - 1);\n  return rowLen - Math.max(...Object.values(map));\n}"}],"tagList":["数组","哈希表"],"level":"Medium"}},{"problemName":"557.反转字符串中的单词III.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/557.反转字符串中的单词III.json","problemData":{"id":"557","name":"557.反转字符串中的单词III","url":"https://leetcode.cn/problems/reverse-words-in-a-string-iii","desc":"给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。","solutions":[{"date":"2020-04-07","time":104,"memory":43.2,"script":"javascript","desc":"通过解构成字符串进行转换。","code":"/**\n * @param {string} s\n * @return {string}\n */\nvar reverseWords = function (s) {\n  const words = s.split(' ');\n  for (let num in words) {\n    words[num] = [...words[num]].reverse().join('');\n  }\n  return words.join(' ');\n};"},{"date":"2020-08-30","time":112,"memory":44.5,"script":"typescript","desc":"分割后重新映射。","code":"function reverseWords(s: string): string {\n  return s\n    .split(' ')\n    .map(v => v.split('').reverse().join(''))\n    .join(' ');\n}"}],"tagList":["双指针","字符串"],"level":"Easy"}},{"problemName":"558.四叉树交集.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/558.四叉树交集.json","problemData":{"id":"773","name":"558.四叉树交集","url":"https://leetcode.cn/problems/logical-or-of-two-binary-grids-represented-as-quad-trees","desc":"请你返回一个表示 n \\* n 二进制矩阵的四叉树，它是 quadTree1 和 quadTree2 所表示的两个二进制矩阵进行 按位逻辑或运算 的结果。","solutions":[{"date":"2022-07-15","time":24,"memory":16.2,"script":"cpp","desc":"分治,如果一个叶子且 true,则与该节点相同,如果 false,则与另一个节点相同,否则递归。","code":"class Solution {\n   public:\n    Node *intersect(Node *quadTree1, Node *quadTree2) {\n        if (quadTree1->isLeaf) {\n            if (quadTree1->val)\n                return new Node(true, true);\n            else\n                return new Node(quadTree2->val, quadTree2->isLeaf,\n                                quadTree2->topLeft, quadTree2->topRight,\n                                quadTree2->bottomLeft, quadTree2->bottomRight);\n        }\n        if (quadTree2->isLeaf) {\n            if (quadTree2->val)\n                return new Node(true, true);\n            else\n                return new Node(true, false, quadTree1->topLeft,\n                                quadTree1->topRight, quadTree1->bottomLeft,\n                                quadTree1->bottomRight);\n        }\n        Node *tl = intersect(quadTree1->topLeft, quadTree2->topLeft),\n             *tr = intersect(quadTree1->topRight, quadTree2->topRight),\n             *bl = intersect(quadTree1->bottomLeft, quadTree2->bottomLeft),\n             *br = intersect(quadTree1->bottomRight, quadTree2->bottomRight);\n        if (tl->isLeaf && tr->isLeaf && bl->isLeaf && br->isLeaf &&\n            tl->val == tr->val && tl->val == bl->val && tl->val == br->val)\n            return new Node(tl->val, true);\n        else\n            return new Node(false, false, tl, tr, bl, br);\n    }\n};"}],"tagList":["树","分治"],"level":"Medium"}},{"problemName":"559.N叉树的最大深度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/559.N叉树的最大深度.json","problemData":{"id":"774","name":"559.N叉树的最大深度","url":"https://leetcode.cn/problems/maximum-depth-of-n-ary-tree","desc":"给定一个 N 叉树，找到其最大深度。最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。","solutions":[{"date":"2020-02-21","time":4,"memory":40.7,"script":"java","desc":"层序遍历。","code":"/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\nclass Solution {\n\tpublic int maxDepth(Node root) {\n\t\tif (root == null)\n\t\t\treturn 0;\n\t\tQueue<Node> queue = new LinkedList<Node>();\n\t\tint height = 0, size = 1;\n\t\tqueue.offer(root);\n\t\twhile (!queue.isEmpty()) {\n\t\t\tNode node = queue.poll();\n\t\t\tif (node.children != null)\n\t\t\t\tfor (int i = 0, len = node.children.size(); i < len; i++)\n\t\t\t\t\tqueue.offer(node.children.get(i));\n\t\t\tsize--;\n\t\t\tif (size == 0) {\n\t\t\t\theight++;\n\t\t\t\tsize = queue.size();\n\t\t\t}\n\t\t}\n\t\treturn height;\n\t}\n}"},{"date":"2021-11-21","time":108,"memory":48.4,"script":"typescript","desc":"dfs。","code":"function maxDepth(root: Node | null): number {\n  if (root === null) return 0;\n  return Math.max(...root.children.map(node => maxDepth(node)), 0) + 1;\n}"},{"date":"2021-11-21","time":4,"memory":6.9,"script":"c","desc":"dfs。","code":"int maxDepth(struct Node* root) {\n    if (!root) return 0;\n    int ans = 1;\n    for (int i = 0; i < root->numChildren; i++) {\n        int next_ans = maxDepth(root->children[i]) + 1;\n        ans = next_ans > ans ? next_ans : ans;\n    }\n    return ans;\n}"}],"tagList":["树","深度优先搜索","广度优先搜索"],"level":"Easy"}},{"problemName":"560.和为K的子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/560.和为K的子数组.json","problemData":{"id":"560","name":"560.和为K的子数组","url":"https://leetcode.cn/problems/subarray-sum-equals-k","desc":"给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。","solutions":[{"date":"2020-05-15","time":88,"memory":40.8,"script":"javascript","desc":"由于前 N 项和是前 N-1 项+第 N 项组成，前 N 项和-前 J 项和=K，即前 J 项和=前 N 项和-K。","code":"/**\n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar subarraySum = function (nums, k) {\n  const map = new Map().set(0, 1);\n  let sum = 0,\n    count = 0,\n    nowNum;\n  for (const num of nums) {\n    sum += num;\n    nowNum = sum - k;\n    if (map.has(nowNum)) count += map.get(nowNum);\n    if (map.has(sum)) map.set(sum, map.get(sum) + 1);\n    else map.set(sum, 1);\n  }\n  return count;\n};"},{"date":"2021-12-23","time":72,"memory":40.7,"script":"cpp","desc":"前缀和。","code":"class Solution {\n   public:\n    int subarraySum(vector<int>& nums, int k) {\n        unordered_map<int, int> mmap;\n        int sum = 0, ans = 0;\n        mmap[0] = 1;\n        for (auto& num : nums) {\n            sum += num;\n            if (mmap[sum - k]) ans += mmap[sum - k];\n            mmap[sum]++;\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","前缀和"],"level":"Medium"}},{"problemName":"561.数组拆分.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/561.数组拆分.json","problemData":{"id":"561","name":"561.数组拆分","url":"https://leetcode.cn/problems/array-partition","desc":"给定长度为  2n  的整数数组 nums ，你的任务是将这些数分成  n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从 1 到  n 的 min(ai, bi) 总和最大。返回该 最大总和 。","solutions":[{"date":"2021-02-16","time":180,"memory":46.1,"script":"typescript","desc":"贪心，排序后直接取下标为偶数的值。","code":"function arrayPairSum(nums: number[]): number {\n  return nums\n    .sort((a, b) => a - b)\n    .filter((_, i) => !(i & 1))\n    .reduce((total, cur) => total + cur, 0);\n}"}],"tagList":["贪心","数组","计数排序","排序"],"level":"Easy"}},{"problemName":"563.二叉树的坡度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/563.二叉树的坡度.json","problemData":{"id":"563","name":"563.二叉树的坡度","url":"https://leetcode.cn/problems/binary-tree-tilt","desc":"给定一个二叉树，计算 整个树 的坡度 。","solutions":[{"date":"2021-11-18","time":112,"memory":44.3,"script":"typescript","desc":"dfs。","code":"function findTilt(root: TreeNode | null): number {\n  return dfs(root).tilt;\n  function dfs(node: TreeNode | null): {\n    sum: number;\n    tilt: number;\n  } {\n    const ans = { sum: 0, tilt: 0, res: 0 };\n    if (node === null) return ans;\n    const left = dfs(node.left);\n    const right = dfs(node.right);\n    ans.tilt = Math.abs(left.sum - right.sum) + left.tilt + right.tilt;\n    ans.sum = node.val + left.sum + right.sum;\n    return ans;\n  }\n}"}],"tagList":["树","深度优先搜索","二叉树"],"level":"Easy"}},{"problemName":"564.寻找最近的回文数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/564.寻找最近的回文数.json","problemData":{"id":"564","name":"564.寻找最近的回文数","url":"https://leetcode.cn/problems/find-the-closest-palindrome","desc":"给定一个表示整数的字符串 n ，返回与它最近的回文整数（不包括自身）。如果不止一个，返回较小的那个。 “最近的”定义为两个整数差的绝对值最小。","solutions":[{"date":"2022-03-02","time":0,"memory":6.3,"script":"cpp","desc":"检测进位和退位的问题后，翻转前半部份。","code":"class Solution {\n   public:\n    string nearestPalindromic(string n) {\n        // 检测一位数\n        if (n.size() == 1) {\n            n[0] -= 1;\n            return n;\n        }\n        // 检测10000\n        if (n[0] == '1') {\n            int i = 1;\n            while (i < n.size() && n[i] == '0') i++;\n            if (i == n.size() || i == n.size() - 1 && n[i] == '1') {\n                string ans = \"\";\n                for (int i = 1; i < n.size(); i++) ans += '9';\n                return ans;\n            }\n        }\n        // 检测99999\n        if (n[0] == '9') {\n            int i = 1;\n            while (i < n.size() && n[i] == '9') i++;\n            if (i == n.size()) {\n                string ans = \"1\";\n                for (int i = 1; i < n.size(); i++) ans += \"0\";\n                ans += \"1\";\n                return ans;\n            }\n        }\n        // 检测其它\n        return common(n);\n    }\n    string common(const string &n) {\n        long long num = stoll(n);\n        vector<long long> list = getlist(n);\n        long long ans = -1, minus_num = INT_MAX;\n        for (int i = 0; i < list.size(); i++) {\n            int minus = abs(list[i] - num);\n            if (minus == 0) continue;\n            if (minus < minus_num || minus == minus_num && list[i] < ans) {\n                ans = list[i];\n                minus_num = minus;\n            }\n        }\n        return to_string(ans);\n    }\n    vector<long long> getlist(const string &n) {\n        if (n.size() & 1)\n            return getlist_odd(n);\n        else\n            return getlist_even(n);\n    }\n    vector<long long> getlist_odd(const string &n) {\n        vector<long long> ans;\n        long long high_num = 0;\n        for (int i = 0; i <= n.size() / 2; i++) {\n            high_num = high_num * 10 + n[i] - '0';\n        }\n        ans.push_back(getnum(high_num / 10, getlow(high_num / 10), n.size() / 2,\n                             high_num % 10));\n        ans.push_back(getnum((high_num + 1) / 10, getlow((high_num + 1) / 10),\n                             n.size() / 2, (high_num + 1) % 10));\n        ans.push_back(getnum((high_num - 1) / 10, getlow((high_num - 1) / 10),\n                             n.size() / 2, (high_num - 1) % 10));\n        return ans;\n    }\n    vector<long long> getlist_even(const string &n) {\n        vector<long long> ans;\n        long long high_num = 0;\n        for (int i = 0; i < n.size() / 2; i++) {\n            high_num = high_num * 10 + n[i] - '0';\n        }\n        ans.push_back(getnum(high_num, getlow(high_num), n.size() / 2, -1));\n        ans.push_back(\n            getnum(high_num + 1, getlow(high_num + 1), n.size() / 2, -1));\n        ans.push_back(\n            getnum(high_num - 1, getlow(high_num - 1), n.size() / 2, -1));\n        return ans;\n    }\n    long long getnum(const long long &high, const long long &low,\n                     const int size, const int mid) {\n        long long num = high;\n        num *= pow(10, size);\n        if (mid != -1) {\n            num *= 10;\n            num += mid * pow(10, size);\n        }\n        num += low;\n        return num;\n    }\n    long long getlow(const long long &num) {\n        string ans = to_string(num);\n        reverse(ans.begin(), ans.end());\n        return stoll(ans);\n    }\n};"}],"tagList":["数学","字符串"],"level":"Hard"}},{"problemName":"565.数组嵌套.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/565.数组嵌套.json","problemData":{"id":"565","name":"565.数组嵌套","url":"https://leetcode.cn/problems/array-nesting","desc":"索引从 0 开始长度为 N 的数组 A，包含 0 到 N - 1 的所有整数。找到最大的集合 S 并返回其大小。","solutions":[{"date":"2022-07-17","time":364,"memory":167.9,"script":"cpp","desc":"遍历，记录环大小。","code":"class Solution {\n   public:\n    int arrayNesting(vector<int> &nums) {\n        int ans = 0, n = nums.size();\n        vector<int> m(n, -1);\n        for (int i = 0; i < n; i++) {\n            if (m[i] != -1) continue;\n            unordered_set<int> s;\n            int res = dfs(nums, m, s, i);\n            ans = max(ans, res);\n            for (auto &idx : s) m[idx] = res;\n        }\n        return ans;\n    }\n    int dfs(vector<int> &nums, vector<int> &m, unordered_set<int> &s, int idx) {\n        if (m[idx] != -1) return m[idx];\n        if (s.count(idx)) return 0;\n        s.insert(idx);\n        return dfs(nums, m, s, nums[idx]) + 1;\n    }\n};"}],"tagList":["深度优先搜索","数组"],"level":"Medium"}},{"problemName":"566.重塑矩阵.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/566.重塑矩阵.json","problemData":{"id":"566","name":"566.重塑矩阵","url":"https://leetcode.cn/problems/reshape-the-matrix","desc":"给出一个由二维数组表示的矩阵，以及两个正整数 r 和 c，分别表示想要的重构的矩阵的行数和列数。重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。如果具有给定参数的 reshape 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。","solutions":[{"date":"2021-02-17","time":104,"memory":45.4,"script":"typescript","desc":"先计算总数，符合后直接拼接数组。","code":"function matrixReshape(nums: number[][], r: number, c: number): number[][] {\n  const sum = nums.length * nums[0].length;\n  if (sum !== r * c) return nums;\n  const arr = nums.reduce((totalArr, arr) => {\n    totalArr.push(...arr);\n    return totalArr;\n  }, [] as number[]);\n  const ans: number[][] = [];\n  for (let i = 0; i < r; i++) {\n    const temp: number[] = [];\n    for (let j = 0; j < c; j++) {\n      temp.push(arr[i * c + j]);\n    }\n    ans.push(temp);\n  }\n  return ans;\n}"}],"tagList":["数组","矩阵","模拟"],"level":"Easy"}},{"problemName":"567.字符串的排列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/567.字符串的排列.json","problemData":{"id":"567","name":"567.字符串的排列","url":"https://leetcode.cn/problems/permutation-in-string","desc":"给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。","solutions":[{"date":"2021-02-10","time":340,"memory":46.3,"script":"typescript","desc":"利用 map 储存遍历过的值。","code":"function checkInclusion(s1: string, s2: string): boolean {\n  const len1 = s1.length;\n  const getMap = (arr: string[]) =>\n    arr.reduce((total, cur) => {\n      total[cur] = (total[cur] ?? 0) + 1;\n      return total;\n    }, {} as Record<string, number>);\n  const charMap1 = getMap(s1.split(''));\n  const charMap2 = getMap(s2.substr(0, len1).split(''));\n  const check = () => Object.entries(charMap1).every(([k, v]) => charMap2[k] === v);\n  if (check()) return true;\n  for (let i = len1, len2 = s2.length; i < len2; i++) {\n    charMap2[s2[i - len1]]--;\n    charMap2[s2[i]] = (charMap2[s2[i]] ?? 0) + 1;\n    if (check()) return true;\n  }\n  return false;\n}"},{"date":"2021-02-10","time":304,"memory":46.3,"script":"typescript","desc":"增加 set 优化题解 1。","code":"function checkInclusion(s1: string, s2: string): boolean {\n  const len1 = s1.length;\n  const getMap = (arr: string[]) =>\n    arr.reduce((total, cur) => {\n      total[cur] = (total[cur] ?? 0) + 1;\n      return total;\n    }, {} as Record<string, number>);\n  const arr1 = s1.split('');\n  const map1 = getMap(arr1);\n  const set1 = new Set(arr1);\n  const map2 = getMap(s2.substr(0, len1).split(''));\n  const check = () => Object.entries(map1).every(([k, v]) => map2[k] === v);\n  if (check()) return true;\n  for (let i = len1, len2 = s2.length; i < len2; i++) {\n    const char = s2[i];\n    map2[s2[i - len1]]--;\n    map2[char] = (map2[char] ?? 0) + 1;\n    if (!set1.has(char)) continue;\n    if (check()) return true;\n  }\n  return false;\n}"}],"tagList":["哈希表","双指针","字符串","滑动窗口"],"level":"Medium"}},{"problemName":"572.另一棵树的子树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/572.另一棵树的子树.json","problemData":{"id":"572","name":"572.另一棵树的子树","url":"https://leetcode.cn/problems/subtree-of-another-tree","desc":"给定两个非空二叉树 s 和 t，检验  s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。","solutions":[{"date":"2020-05-07","time":84,"memory":41.5,"script":"javascript","desc":"先遍历获取所有值相等的节点，通过中序遍历判断是否每项值都相等","code":"/**\n * Definition for a binary tree node.\n * function TreeNode(val) {\n *     this.val = val;\n *     this.left = this.right = null;\n * }\n */\n/**\n * @param {TreeNode} s\n * @param {TreeNode} t\n * @return {boolean}\n */\nvar isSubtree = function (s, t) {\n  function searchNode(val) {\n    const queue = inorder(s);\n    const resArr = [];\n    for (const node of queue) {\n      if (node.val === val) resArr.push(node);\n    }\n    return resArr;\n  }\n  function inorder(node) {\n    const queue = [];\n    function _inorder(node) {\n      if (node.left !== null) _inorder(node.left);\n      queue.push(node);\n      if (node.right !== null) _inorder(node.right);\n    }\n    _inorder(node);\n    return queue;\n  }\n  function sameArrVal(arr1, arr2) {\n    const len1 = arr1.length;\n    if (len1 !== arr2.length) return false;\n    for (let i = 0; i < len1; i++) if (arr1[i].val !== arr2[i].val) return false;\n    return true;\n  }\n  const sameNodeArr = searchNode(t.val);\n  if (sameNodeArr.length === 0) return false;\n  const tArr = inorder(t);\n  for (const node of sameNodeArr) {\n    if (sameArrVal(inorder(node), tArr)) return true;\n  }\n  return false;\n};"},{"script":"python","time":58,"memory":16.51,"desc":"序列化。","code":"class Solution:\n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        def stringify(node: Optional[TreeNode]) -> str:\n            if not node: return ''\n            return f'[{node.val}, {stringify(node.left)}, {stringify(node.right)}]'\n        return stringify(subRoot) in stringify(root)","date":"2024-08-04"}],"tagList":["树","深度优先搜索","二叉树","字符串匹配","哈希函数"],"level":"Easy"}},{"problemName":"575.分糖果.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/575.分糖果.json","problemData":{"id":"575","name":"575.分糖果","url":"https://leetcode.cn/problems/distribute-candies","desc":"给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。","solutions":[{"date":"2021-11-01","time":128,"memory":50.9,"script":"typescript","desc":"贪心。","code":"function distributeCandies(candyType: number[]): number {\n  return Math.min(new Set<number>(candyType).size, candyType.length / 2);\n}"},{"script":"python","time":98,"memory":18.08,"desc":"判断最大糖果数量和最大糖果类型的最小值。","code":"class Solution:\n    def distributeCandies(self, candyType: List[int]) -> int:\n        return min(len(Counter(candyType).keys()),  len(candyType) // 2)","date":"2024-06-02"}],"tagList":["数组","哈希表"],"level":"Easy"}},{"problemName":"576.出界的路径数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/576.出界的路径数.json","problemData":{"id":"576","name":"576.出界的路径数","url":"https://leetcode.cn/problems/out-of-boundary-paths","desc":"给你五个整数 m、n、maxMove、startRow 以及 startColumn ，找出并返回可以将球移出边界的路径数量。","solutions":[{"date":"2021-08-15","time":120,"memory":43.6,"script":"typescript","desc":"dp[i][j][k]=第 i 步时，[j][k]坐标的最大数量。","code":"function findPaths(\n  m: number,\n  n: number,\n  maxMove: number,\n  startRow: number,\n  startColumn: number\n): number {\n  const mod = 10 ** 9 + 7;\n  const directions: [number, number][] = [\n    [0, 1],\n    [1, 0],\n    [-1, 0],\n    [0, -1],\n  ];\n  const dp = new Array(maxMove + 1)\n    .fill(0)\n    .map(_ => new Array(m).fill(0).map(_ => new Array(n).fill(0)));\n  dp[0][startRow][startColumn] = 1;\n  let ans = 0;\n  for (let i = 0; i < maxMove; i++) {\n    for (let j = 0; j < m; j++) {\n      for (let k = 0; k < n; k++) {\n        const cnt = dp[i][j][k];\n        if (cnt <= 0) continue;\n        for (const [moveRow, moveCol] of directions) {\n          const row = j + moveRow;\n          const col = k + moveCol;\n          if (row >= 0 && row < m && col >= 0 && col < n) {\n            dp[i + 1][row][col] = (dp[i + 1][row][col] + cnt) % mod;\n          } else {\n            ans = (ans + cnt) % mod;\n          }\n        }\n      }\n    }\n  }\n  return ans;\n}"}],"tagList":["动态规划"],"level":"Medium"}},{"problemName":"581.最短无序连续子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/581.最短无序连续子数组.json","problemData":{"id":"581","name":"581.最短无序连续子数组","url":"https://leetcode.cn/problems/shortest-unsorted-continuous-subarray","desc":"给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。请你找出符合题意的 最短 子数组，并输出它的长度。","solutions":[{"date":"2021-08-03","time":164,"memory":46.3,"script":"typescript","desc":"排序后比对每一位找出最先不同的下标。","code":"function findUnsortedSubarray(nums: number[]): number {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  let l = -1;\n  let r = -1;\n  for (let i = 0, n = nums.length; i < n; i++) {\n    if (sorted[i] !== nums[i] && l === -1) {\n      l = i;\n    }\n    if (sorted[n - 1 - i] !== nums[n - 1 - i] && r === -1) {\n      r = n - 1 - i;\n    }\n    if (l !== -1 && r !== -1) break;\n  }\n  return r === -1 ? 0 : r - l + 1;\n}"}],"tagList":["栈","贪心","数组","双指针","排序","单调栈"],"level":"Medium"}},{"problemName":"583.两个字符串的删除操作.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/583.两个字符串的删除操作.json","problemData":{"id":"583","name":"583.两个字符串的删除操作","url":"https://leetcode.cn/problems/delete-operation-for-two-strings","desc":"给你两个整数 a 和 b ，不使用 运算符 + 和 - ​​​​​​​，计算并返回两整数之和。","solutions":[{"date":"2021-09-26","time":76,"memory":39,"script":"typescript","desc":"不按照题目规则。","code":"function getSum(a: number, b: number): number {\n  return a + b;\n}"},{"date":"2021-09-26","time":76,"memory":39.1,"script":"typescript","desc":"利用 a&b<<1 计算出所有需要进位的位，利用异或求出两数相加后当前位所得到的结果。","code":"function getSum(a: number, b: number): number {\n  while (b != 0) {\n    const carry = (a & b) << 1;\n    a = a ^ b;\n    b = carry;\n  }\n  return a + b;\n}"}],"tagList":["字符串","动态规划"],"level":"Medium"}},{"problemName":"587.安装栅栏.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/587.安装栅栏.json","problemData":{"id":"587","name":"587.安装栅栏","url":"https://leetcode.cn/problems/erect-the-fence","desc":"在一个二维的花园中，有一些用 (x, y) 坐标表示的树。由于安装费用十分昂贵，你的任务是先用最短的绳子围起所有的树。只有当所有的树都被绳子包围时，花园才能围好栅栏。你需要找到正好位于栅栏边界上的树的坐标。","solutions":[{"date":"2022-04-23","time":32,"memory":19.3,"script":"cpp","desc":"andrew 凸包算法。","code":"class Solution {\n   public:\n    int cross(vector<int> &a, vector<int> &b, vector<int> &c) {\n        int x1 = a[0] - b[0], y1 = a[1] - b[1];\n        int x2 = c[0] - b[0], y2 = c[1] - b[1];\n        return x1 * y2 - x2 * y1;\n    }\n    vector<vector<int>> outerTrees(vector<vector<int>> &trees) {\n        int n = trees.size();\n        if (n <= 3) return trees;\n        sort(trees.begin(), trees.end(),\n             [&](vector<int> &a, vector<int> &b) -> bool {\n                 if (a[0] == b[0]) return a[1] < b[1];\n                 return a[0] < b[0];\n             });\n        vector<int> list, used(n, 0);\n        for (int i = 0; i < n; i++) {\n            while (list.size() > 1 &&\n                   cross(trees[list[list.size() - 2]],\n                         trees[list[list.size() - 1]], trees[i]) < 0) {\n                used[list.back()] = 0;\n                list.pop_back();\n            }\n            list.push_back(i);\n            used[i] = 1;\n        }\n        int size = list.size();\n        used[0] = 0;\n        for (int i = n - 2; i >= 0; i--) {\n            if (used[i]) continue;\n            while (list.size() > size &&\n                   cross(trees[list[list.size() - 2]],\n                         trees[list[list.size() - 1]], trees[i]) < 0) {\n                list.pop_back();\n            }\n            list.push_back(i);\n        }\n        list.pop_back();\n        vector<vector<int>> ans;\n        for (auto &idx : list) ans.emplace_back(trees[idx]);\n        return ans;\n    }\n};"}],"tagList":["几何","数组","数学"],"level":"Hard"}},{"problemName":"589.N叉树的前序遍历.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/589.N叉树的前序遍历.json","problemData":{"id":"775","name":"589.N叉树的前序遍历","url":"https://leetcode.cn/problems/n-ary-tree-preorder-traversal","desc":"给定一个 N 叉树，返回其节点值的前序遍历。","solutions":[{"date":"2020-02-21","time":1,"memory":41.2,"script":"java","desc":"遍历每个子节点再递归。","code":"/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\nclass Solution {\n\tLinkedList<Integer> list = new LinkedList<Integer>();\n    public List<Integer> preorder(Node root) {\n    \tif(root==null)return list;\n    \tinPreorder(root);\n\t\treturn list;\n    }\n    void inPreorder(Node node) {\n    \tlist.add(node.val);\n    \tfor(int i=0,len=node.children.size();i<len;i++) {\n    \t\tinPreorder(node.children.get(i));\n    \t}\n    }\n}"},{"date":"2022-03-10","time":16,"memory":11.3,"script":"cpp","desc":"dfs。","code":"class Solution {\n   public:\n    vector<int> preorder(Node* root) {\n        vector<int> ans;\n        if (root) dfs(ans, root);\n        return ans;\n    }\n    void dfs(vector<int>& ans, Node* node) {\n        ans.push_back(node->val);\n        for (auto& child : node->children) dfs(ans, child);\n    }\n};"},{"date":"2022-03-10","time":24,"memory":11.2,"script":"cpp","desc":"迭代。","code":"class Solution {\n    public:\n     vector<int> preorder(Node *root) {\n         vector<int> ans;\n         stack<Node *> s;\n         if (root) s.push(root);\n         while (s.size()) {\n             Node *node = s.top();\n             s.pop();\n             ans.push_back(node->val);\n             for (auto it = node->children.rbegin(); it != node->children.rend();\n                  it++)\n                 s.push(*it);\n         }\n         return ans;\n     }\n };"},{"script":"python","time":62,"memory":18.18,"desc":"dfs。","code":"class Solution:\n    def preorder(self, root: 'Node') -> List[int]:\n        if not root: return []\n        return [root.val] + reduce(lambda arr, cur: arr + cur, [self.preorder(child) for child in root.children], [])","date":"2024-02-18"}],"tagList":["栈","树","深度优先搜索"],"level":"Easy"}},{"problemName":"590.N叉树的后序遍历.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/590.N叉树的后序遍历.json","problemData":{"id":"776","name":"590.N叉树的后序遍历","url":"https://leetcode.cn/problems/n-ary-tree-postorder-traversal","desc":"给定一个 N 叉树，返回其节点值的后序遍历。","solutions":[{"date":"2020-02-21","time":1,"memory":41.7,"script":"java","desc":"遍历每个子节点再递归。","code":"/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\nclass Solution {\n\tLinkedList<Integer> list = new LinkedList<Integer>();\n    public List<Integer> postorder(Node root) {\n    \tinPostorder(root);\n        return list;\n    }\n    void inPostorder(Node node) {\n    \tif(node==null)return;\n    \tif(node.children!=null)\n    \tfor(int i=0,len=node.children.size();i<len;i++) {\n    \t\tinPostorder(node.children.get(i));\n    \t}\n\t\tlist.add(node.val);\n    }\n}"},{"date":"2022-03-12","time":16,"memory":11.3,"script":"cpp","desc":"dfs。","code":"class Solution {\n   public:\n    vector<int> postorder(Node *root) {\n        vector<int> ans;\n        if (root) dfs(ans, root);\n        return ans;\n    }\n    void dfs(vector<int> &ans, Node *&root) {\n        for (auto &child : root->children) dfs(ans, child);\n        ans.push_back(root->val);\n    }\n};"},{"date":"2022-03-12","time":20,"memory":12.1,"script":"cpp","desc":"迭代。","code":"class Solution {\n   public:\n    vector<int> postorder(Node *root) {\n        vector<int> ans;\n        stack<Node *> s;\n        unordered_set<Node *> sset;\n        if (root) s.push(root);\n        while (s.size()) {\n            Node *node = s.top();\n            s.pop();\n            if (sset.count(node)) {\n                ans.push_back(node->val);\n                continue;\n            }\n            sset.insert(node);\n            s.push(node);\n            for (auto it = node->children.rbegin(); it != node->children.rend();\n                 it++) {\n                s.push(*it);\n            }\n        }\n        return ans;\n    }\n};"},{"script":"python","time":53,"memory":18.12,"desc":"dfs。","code":"class Solution:\n    def postorder(self, root: 'Node') -> List[int]:\n        if not root: return []\n        return reduce(lambda arr, cur: arr + cur, [self.postorder(child) for child in root.children], []) + [root.val] ","date":"2024-02-19"}],"tagList":["栈","树","深度优先搜索"],"level":"Easy"}},{"problemName":"591.标签验证器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/591.标签验证器.json","problemData":{"id":"591","name":"591.标签验证器","url":"https://leetcode.cn/problems/tag-validator","desc":"给定一个表示代码片段的字符串，你需要实现一个验证器来解析这段代码，并返回它是否合法。","solutions":[{"date":"2022-05-02","time":0,"memory":6.5,"script":"cpp","desc":"栈存每一层，再遍历字符串。","code":"#ifdef DEBUG\n#define log(fmt, args...) \\\n    { printf(fmt, ##args); }\n#else\n#define log(fmt, args...)\n#endif\nclass Solution {\n   public:\n    int i = 0, n;\n    bool check = true;\n    stack<string> s;\n    string code;\n    bool isValid(string code) {\n        this->code = code;\n        n = code.size();\n        log(\"n = %d\\n\", n);\n        // 最外层一定要是tag\n        if (code[0] != '<' || code[n - 1] != '>') return false;\n        while (i < n) {\n            // 检测tag开始\n            if (code[i] == '<') {\n                // 检测CDATA\n                if (i + 1 < n && code[i + 1] == '!') {\n                    // CDATA一定要在tag里\n                    if (s.empty()) return false;\n                    analysisCDATATag();\n                    log(\"end analysisCDATATag : i = %d\\n\", i);\n                    if (!check) return false;\n                } else {\n                    // 检测tag\n                    analysisTag();\n                    log(\"end analysisTag : i = %d\\n\", i);\n                    // 如果栈空了，但检测没结束，就有问题\n                    if (!check || s.empty() && i != n) return false;\n                }\n            }\n            // 直接到下一个<\n            while (i < n && code[i] != '<') i++;\n        }\n        log(\"end check\");\n        // 最后看看是不是栈空\n        return s.empty();\n    }\n    void analysisTag() {\n        // 先拿到结尾下标\n        int end = i;\n        while (end < n && code[end] != '>') end++;\n        // 没结尾就不对了\n        if (end == n) {\n            check = false;\n            return;\n        }\n        // 看看是endTag还是startTag\n        if (i + 1 < n && code[i + 1] == '/') {\n            // endTag先过滤斜线\n            i += 1;\n            string tag = analysisCommonTag(end);\n            // 跳跃\n            i = end + 1;\n            // 如果tag解析不出来就不对了\n            if (tag != \"\") {\n                log(\"find end  tag : %s\\n\", tag.data());\n                // 如果endTag解析出来了但栈空或栈顶没匹配的也不对\n                if (s.empty() || s.top() != tag) check = false;\n                // 对了就出栈\n                else\n                    s.pop();\n                return;\n            } else\n                check = false;\n        } else {\n            // 解析startTag\n            string tag = analysisCommonTag(end);\n            i = end + 1;\n            if (tag != \"\") {\n                log(\"find start tag : %s\\n\", tag.data());\n                // 对了就入栈\n                s.push(tag);\n                return;\n            } else\n                check = false;\n        }\n    }\n    string analysisCommonTag(int end) {\n        string ans = \"\";\n        // 长度 [1, 9]\n        if (end == i + 1 || end - i - 1 > 9) return \"\";\n        // 都是大写字符\n        for (int start = i + 1; start < end; start++) {\n            if (!isupper(code[start])) return \"\";\n            ans += code[start];\n        }\n        return ans;\n    }\n    string startWith_cdata = \"<![CDATA[\";\n    string endWith_cdata = \"]]>\";\n    void analysisCDATATag() {\n        log(\"anasysisCDATATAG, i = %d\\n\", i);\n        // 先看看能不能匹配开始标记\n        int start = i, startMatchCnt = 0;\n        while (start < n && startMatchCnt != startWith_cdata.size()) {\n            if (code[start] == startWith_cdata[startMatchCnt])\n                startMatchCnt++;\n            else\n                break;\n            start++;\n        }\n        // 匹配不上就错了\n        if (start == n || startMatchCnt != startWith_cdata.size()) {\n            check = false;\n            return;\n        }\n        // 再看看能不能匹配结束标记\n        log(\"find start = %d\\n\", start);\n        int end = start, endMatchCnt = 0;\n        // 一直循环找]开头的进行尝试\n        while (true) {\n            endMatchCnt = 0;\n            while (end < n && code[end] != endWith_cdata[0]) end++;\n            while (end < n && endMatchCnt != endWith_cdata.size()) {\n                if (code[end] == endWith_cdata[endMatchCnt])\n                    endMatchCnt++;\n                else\n                    break;\n                end++;\n            }\n            log(\"end = %d\\n\", end);\n            if (end == n || endMatchCnt == endWith_cdata.size()) break;\n        }\n        // 匹配不上就错了\n        // 匹配上就跳跃了\n        if (end == n) {\n            check = false;\n        } else {\n            log(\"find cdata tag : start = %d, end = %d\\n\", start, end);\n            i = end;\n        }\n    }\n};"}],"tagList":["栈","字符串"],"level":"Hard"}},{"problemName":"592.分数加减运算.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/592.分数加减运算.json","problemData":{"id":"592","name":"592.分数加减运算","url":"https://leetcode.cn/problems/fraction-addition-and-subtraction","desc":"给定一个表示分数加减运算的字符串 expression ，你需要返回一个字符串形式的计算结果。 。","solutions":[{"date":"2022-07-27","time":0,"memory":5.9,"script":"cpp","desc":"解析字符串后通分约分。","code":"class Solution {\n   public:\n    typedef pair<int, int> node;\n    string fractionAddition(string expression) {\n        char op = '+';\n        node ans = make_pair(0, 1);\n        for (int i = 0; i < expression.size(); i++) {\n            int end = i;\n            string tmp = \"\";\n            while (end < expression.size() && !is_op(expression, end))\n                tmp += expression[end++];\n            i = end;\n            op_node(ans, to_node(tmp), op);\n            op = expression[i];\n        }\n        return to_string(ans.first) + \"/\" + to_string(ans.second);\n    }\n    bool is_op(string &expression, int idx) {\n        if (idx == 0 || idx == expression.size() - 1) return false;\n        if (expression[idx] != '+' && expression[idx] != '-') return false;\n        if (!isdigit(expression[idx - 1])) return false;\n        return true;\n    }\n    node to_node(string &str) {\n        node ans = make_pair(0, 0);\n        int i = 0, f = 1;\n        if (str[0] == '-') f = -1;\n        if (str[0] == '+' || str[0] == '-') i++;\n        while (str[i] != '/') ans.first = ans.first * 10 + str[i++] - '0';\n        i++;\n        while (i < str.size()) ans.second = ans.second * 10 + str[i++] - '0';\n        ans.first *= f;\n        return ans;\n    }\n    void op_node(node &node1, node node2, char op) {\n        format1(node1, node2);\n        if (op == '+')\n            node1.first += node2.first;\n        else\n            node1.first -= node2.first;\n        format2(node1);\n    }\n    int gcd(int a, int b) {\n        if (b == 0) return a;\n        return gcd(b, a % b);\n    }\n    int lcm(int a, int b) { return a * b / gcd(a, b); }\n    void format1(node &node1, node &node2) {\n        if (node1.second != node2.second) {\n            int num_lcm = lcm(node1.second, node2.second);\n            node1.first *= num_lcm / node1.second;\n            node2.first *= num_lcm / node2.second;\n            node1.second = node2.second = num_lcm;\n        }\n    }\n    void format2(node &node) {\n        int f = 1;\n        if (node.first < 0) {\n            f = -1;\n            node.first *= f;\n        }\n        int num_gcd = gcd(node.first, node.second);\n        if (num_gcd != 1) {\n            node.first /= num_gcd;\n            node.second /= num_gcd;\n        }\n        node.first *= f;\n    }\n};"},{"date":"2022-07-27","time":0,"memory":2,"script":"rust","desc":"同上。","code":"impl Solution {\n    pub fn fraction_addition(expression: String) -> String {\n        let expression: Vec<char> = expression.chars().collect();\n        let mut op = '+';\n        let mut ans = Node::new(0, 1);\n        let mut i = 0;\n        while i < expression.len() {\n            let mut end = i;\n            let mut tmp = String::new();\n            while end < expression.len() && !Solution::is_op(&expression, end) {\n                tmp.push(expression[end]);\n                end += 1;\n            }\n            i = end;\n            Solution::op_node(&mut ans, Solution::to_node(&tmp), op);\n            if i < expression.len() {\n                op = expression[i];\n            }\n            i += 1;\n        }\n        ans.to_string()\n    }\n    fn is_op(expression: &Vec<char>, idx: usize) -> bool {\n        if idx == 0 || idx == expression.len() - 1 {\n            false\n        } else if expression[idx] != '+' && expression[idx] != '-' {\n            false\n        } else if !expression[idx - 1].is_ascii_digit() {\n            false\n        } else {\n            true\n        }\n    }\n    fn to_node(string: &String) -> Node {\n        let string: Vec<char> = string.chars().collect();\n        let mut node = Node::new(0, 0);\n        let mut i = 0;\n        let mut f = 1;\n        if string[0] == '-' {\n            f = -1;\n        }\n        if string[0] == '+' || string[0] == '-' {\n            i += 1;\n        }\n        while string[i] != '/' {\n            node.first = node.first * 10 + (string[i] as i32 - '0' as i32);\n            i += 1;\n        }\n        i += 1;\n        while i < string.len() {\n            node.second = node.second * 10 + (string[i] as i32 - '0' as i32);\n            i += 1;\n        }\n        node.first *= f;\n        node\n    }\n    fn op_node(node1: &mut Node, node2: Node, op: char) {\n        let mut node2 = node2;\n        Solution::format1(node1, &mut node2);\n        if op == '+' {\n            node1.first += node2.first;\n        } else {\n            node1.first -= node2.first;\n        }\n        Solution::format2(node1);\n    }\n    fn format1(node1: &mut Node, node2: &mut Node) {\n        if node1.second != node2.second {\n            let lcm = Solution::lcm(node1.second, node2.second);\n            node1.first *= lcm / node1.second;\n            node2.first *= lcm / node2.second;\n            node1.second = lcm;\n            node2.second = lcm;\n        }\n    }\n    fn format2(node: &mut Node) {\n        let mut f = 1;\n        if node.first < 0 {\n            f = -1;\n            node.first *= f;\n        }\n        let gcd = Solution::gcd(node.first, node.second);\n        if gcd != 1 {\n            node.first /= gcd;\n            node.second /= gcd;\n        }\n        node.first *= f;\n    }\n    fn gcd(a: i32, b: i32) -> i32 {\n        if b == 0 {\n            a\n        } else {\n            Solution::gcd(b, a % b)\n        }\n    }\n    fn lcm(a: i32, b: i32) -> i32 {\n        a * b / Solution::gcd(a, b)\n    }\n}\n\nstruct Node {\n    first: i32,\n    second: i32,\n}\nimpl Node {\n    fn new(first: i32, second: i32) -> Self {\n        Self { first, second }\n    }\n    fn to_string(&self) -> String {\n        format!(\"{}/{}\", self.first, self.second)\n    }\n}"}],"tagList":["数学","字符串","模拟"],"level":"Medium"}},{"problemName":"593.有效的正方形.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/593.有效的正方形.json","problemData":{"id":"593","name":"593.有效的正方形","url":"https://leetcode.cn/problems/valid-square","desc":"给定 2D 空间中四个点的坐标 p1, p2, p3 和 p4，如果这四个点构成一个正方形，则返回 true 。","solutions":[{"date":"2022-07-29","time":0,"memory":2.1,"script":"rust","desc":"每条边都相等且任意三个角都能组成直角三角形。","code":"impl Solution {\n    pub fn valid_square(p1: Vec<i32>, p2: Vec<i32>, p3: Vec<i32>, p4: Vec<i32>) -> bool {\n        Solution::is_right_triangle(&p1, &p2, &p3)\n            && Solution::is_right_triangle(&p1, &p2, &p4)\n            && Solution::is_right_triangle(&p1, &p3, &p4)\n            && Solution::is_right_triangle(&p2, &p3, &p4)\n    }\n    fn is_right_triangle(p1: &Vec<i32>, p2: &Vec<i32>, p3: &Vec<i32>) -> bool {\n        let d1 = Solution::get_length(p1, p2);\n        let d2 = Solution::get_length(p1, p3);\n        let d3 = Solution::get_length(p3, p2);\n        d1 != 0\n            && d2 != 0\n            && d3 != 0\n            && (d1 + d2 == d3 && d1 == d2 || d1 + d3 == d2 && d1 == d3 || d2 + d3 == d1 && d2 == d3)\n    }\n    fn get_length(p1: &Vec<i32>, p2: &Vec<i32>) -> i32 {\n        (p1[0] - p2[0]).pow(2) + (p1[1] - p2[1]).pow(2)\n    }\n}"}],"tagList":["几何","数学"],"level":"Medium"}},{"problemName":"594.最长和谐子序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/594.最长和谐子序列.json","problemData":{"id":"594","name":"594.最长和谐子序列","url":"https://leetcode.cn/problems/longest-harmonious-subsequence","desc":"现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。","solutions":[{"date":"2021-11-20","time":120,"memory":48.6,"script":"typescript","desc":"哈希存储。","code":"function findLHS(nums: number[]): number {\n  const map = new Map<number, number>();\n  for (const num of nums) map.set(num, (map.get(num) ?? 0) + 1);\n  const list = Array.from(map.entries()).sort(([num1], [num2]) => num1 - num2);\n  let ans = 0;\n  for (let i = 0, l = list.length; i < l - 1; i++) {\n    const [num1, cnt1] = list[i];\n    const [num2, cnt2] = list[i + 1];\n    if (num2 !== num1 + 1) continue;\n    ans = Math.max(ans, cnt1 + cnt2);\n  }\n  return ans;\n}"},{"date":"2021-11-20","time":52,"memory":8.6,"script":"c","desc":"排序。","code":"int comp(int *num1, int *num2){\n    return *num1 - *num2;\n}\nint findLHS(int* nums, int numsSize){\n    qsort(nums, numsSize, sizeof(int), comp);\n    int ans = 0, left = 0, right = 0;\n    while(right < numsSize - 1){\n        while(right < numsSize - 1 && nums[right] == nums[left]) right++;\n        while(right < numsSize - 1 && nums[right] == nums[right + 1]) right++;\n        if(nums[left] == nums[right] - 1 && right - left + 1 > ans) ans = right - left + 1;\n        while(nums[left] != nums[right]) left++;\n    }\n    return ans;\n}"}],"tagList":["数组","哈希表","计数","排序","滑动窗口"],"level":"Easy"}},{"problemName":"598.区间加法II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/598.区间加法II.json","problemData":{"id":"598","name":"598.区间加法II","url":"https://leetcode.cn/problems/range-addition-ii","desc":"给定一个初始元素全部为 0，大小为 m\\*n 的矩阵 M 以及在 M 上的一系列更新操作。","solutions":[{"date":"2021-11-07","time":80,"memory":40.1,"script":"typescript","desc":"取最小值。","code":"function maxCount(m: number, n: number, ops: number[][]): number {\n  if (ops.length === 0) return m * n;\n  let minA = Infinity;\n  let minB = Infinity;\n  ops.forEach(([a, b]) => {\n    minA = Math.min(minA, a);\n    minB = Math.min(minB, b);\n  });\n  return minA * minB;\n}"}],"tagList":["数组","数学"],"level":"Easy"}},{"problemName":"600.不含连续1的非负整数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/501-600/600.不含连续1的非负整数.json","problemData":{"id":"600","name":"600.不含连续1的非负整数","url":"https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones","desc":"给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 连续的 1 的个数。","solutions":[{"date":"2021-09-11","time":84,"memory":39.8,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/non-negative-integers-without-consecutive-ones/solution/bu-han-lian-xu-1de-fei-fu-zheng-shu-by-l-9l86/)。","code":"function findIntegers(n: number): number {\n  const dp = new Array(31).fill(0);\n  dp[0] = dp[1] = 1;\n  for (let i = 2; i < 31; ++i) dp[i] = dp[i - 1] + dp[i - 2];\n  let pre = 0;\n  let res = 0;\n  for (let i = 29; i >= 0; --i) {\n    let val = 1 << i;\n    if ((n & val) !== 0) {\n      res += dp[i + 1];\n      if (pre === 1) break;\n      pre = 1;\n    } else pre = 0;\n    if (i === 0) res++;\n  }\n  return res;\n}"},{"script":"python","time":55,"memory":16.46,"desc":"数位dp。","code":"N = len(bin(10 ** 9)) - 2\narr = [0] * (N + 1)\narr[0] = arr[1] = 1\ntmp_sum = 1\nfor i in range(2, N + 1):\n    arr[i] = tmp_sum\n    tmp_sum += arr[i - 1]\n\nclass Solution:\n    def findIntegers(self, num: int) -> int:\n        if num == 0: return 1\n        n = len(bin(num)) - 2\n        res = sum(arr[:n])\n        next_num = num\n        if bin(next_num)[2:4] == '11':\n            next_num = (1 << (n - 1)) + (1 << (n - 2)) - 1\n        return sum(arr[:n]) + self.findIntegers(next_num - (1 << (n - 1)))","date":"2024-08-05"}],"tagList":["动态规划"],"level":"Hard"}}]},{"dirName":"601-700","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\601-700","problems":[{"problemName":"605.种花问题.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/605.种花问题.json","problemData":{"id":"605","name":"605.种花问题","url":"https://leetcode.cn/problems/can-place-flowers","desc":"假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。给你一个整数数组   flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数  n ，能否在不打破种植规则的情况下种入  n  朵花？能则返回 true ，不能则返回 false。","solutions":[{"date":"2021-01-02","time":96,"memory":41.2,"script":"typescript","desc":"计算每朵花之间的空格进行累加,与 n 比较。","code":"function canPlaceFlowers(flowerbed: number[], n: number): boolean {\n  const computeCount = (num: number) => (num < 1 ? 0 : ~~((num + 1) / 2));\n  let max = 0;\n  const len = flowerbed.length;\n  if (flowerbed.every(v => v === 0)) return computeCount(len) >= n;\n  const list: number[] = [];\n  flowerbed.forEach((v, i) => v && list.push(i));\n  for (let i = 0, l = list.length; i < l; i++) {\n    const index = list[i];\n    if (i === 0 && index > 1) max += computeCount(index - 1);\n    if (i === l - 1) max += computeCount(len - index - 2);\n    else max += computeCount(list[i + 1] - index - 3);\n  }\n  return max >= n;\n}"},{"date":"2023-09-29","script":"python","time":60,"memory":16.3,"desc":"同上。","code":"class Solution:\n    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:\n        prev = -1\n        for i in range(len(flowerbed)):\n            if flowerbed[i] == 0:\n                if prev + 1 == i and (i == len(flowerbed) - 1 or flowerbed[i + 1] == 0):\n                    n -= 1\n                else:\n                    prev = i\n        return n <= 0\n"}],"tagList":["贪心","数组"],"level":"Easy"}},{"problemName":"606.根据二叉树创建字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/606.根据二叉树创建字符串.json","problemData":{"id":"606","name":"606.根据二叉树创建字符串","url":"https://leetcode.cn/problems/construct-string-from-binary-tree","desc":"给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。","solutions":[{"date":"2022-03-15","time":32,"memory":64.2,"script":"cpp","desc":"遍历后组装。","code":"class Solution {\n   public:\n    string tree2str(TreeNode* root) {\n        if (!root) return \"\";\n        string l = \"(\" + tree2str(root->left) + \")\",\n               r = \"(\" + tree2str(root->right) + \")\";\n        return to_string(root->val) + (l == \"()\" && r == \"()\"   ? \"\"\n                                       : l != \"()\" && r == \"()\" ? l\n                                                                : l + r);\n    }\n};"}],"tagList":["树","深度优先搜索","字符串","二叉树"],"level":"Medium"}},{"problemName":"611.有效三角形的个数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/611.有效三角形的个数.json","problemData":{"id":"611","name":"611.有效三角形的个数","url":"https://leetcode.cn/problems/valid-triangle-number","desc":"给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。","solutions":[{"date":"2021-10-26","time":168,"memory":39.8,"script":"typescript","desc":"固定两边长度进行二分。","code":"function triangleNumber(nums: number[]): number {\n  const n = nums.length;\n  nums.sort((a, b) => a - b);\n  let ans = 0;\n  for (let i1 = 0; i1 < n - 1; i1++) {\n    const num1 = nums[i1];\n    for (let i2 = i1 + 1; i2 < n - 1; i2++) {\n      const num2 = nums[i2];\n      if (num1 + num2 > nums[n - 1]) {\n        ans += n - 1 - i2;\n        continue;\n      }\n      let l = i2 + 1;\n      let r = n - 1;\n      while (l < r) {\n        const mid = (l + r) >> 1;\n        if (num1 + num2 <= nums[mid]) r = mid;\n        else l = mid + 1;\n      }\n      ans += l - 1 - i2;\n    }\n  }\n  return ans;\n}"}],"tagList":["贪心","数组","双指针","二分查找","排序"],"level":"Medium"}},{"problemName":"617.合并二叉树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/617.合并二叉树.json","problemData":{"id":"617","name":"617.合并二叉树","url":"https://leetcode.cn/problems/merge-two-binary-trees","desc":"给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为  NULL 的节点将直接作为新二叉树的节点。","solutions":[{"date":"2020-09-23","time":168,"memory":45.5,"script":"typescript","desc":"递归。","code":"function mergeTrees(t1: TreeNode | null, t2: TreeNode | null): TreeNode | null {\n  return merge(t1, t2);\n  function merge(t1: TreeNode | null, t2: TreeNode | null): TreeNode | null {\n    if (t1 === null && t2 === null) return null;\n    if (t1 === null) return t2;\n    if (t2 === null) return t1;\n    const node = new TreeNode(t1.val + t2.val);\n    node.left = merge(t1.left, t2.left);\n    node.right = merge(t1.right, t2.right);\n    return node;\n  }\n}"},{"script":"cpp","time":36,"memory":30.85,"desc":"递归合并。","code":"class Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\n        if (!root1 && !root2) return nullptr;\n        else if (root1 && !root2) return root1;\n        else if (!root1 && root2) return root2;\n        else {\n            root1->val += root2->val;\n            root1->left = mergeTrees(root1->left, root2->left);\n            root1->right = mergeTrees(root1->right, root2->right);\n            return root1;\n        }\n    }\n};","date":"2023-08-14"},{"script":"python","time":64,"memory":16.15,"desc":"同上。","code":"class Solution:\n    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root1 and not root2:\n            return None\n        elif root1 and not root2:\n            return root1\n        elif not root1 and root2:\n            return root2\n        else:\n            root1.val += root2.val\n            root1.left = self.mergeTrees(root1.left, root2.left)\n            root1.right = self.mergeTrees(root1.right, root2.right)\n            return root1","date":"2023-08-14"},{"script":"rust","time":4,"memory":2.3,"desc":"同上。","code":"use std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn merge_trees(\n        root1: Option<Rc<RefCell<TreeNode>>>,\n        root2: Option<Rc<RefCell<TreeNode>>>,\n    ) -> Option<Rc<RefCell<TreeNode>>> {\n        match root1 {\n            None => root2,\n            Some(mut root1) => match root2 {\n                None => Some(root1),\n                Some(root2) => {\n                    {\n                        let mut root1_ref = root1.as_ref().borrow_mut();\n                        let mut root2_ref = root2.as_ref().borrow_mut();\n                        root1_ref.val += root2_ref.val;\n                        {\n                            let child1 = root1_ref.left.take();\n                            let child2 = root2_ref.left.take();\n                            root1_ref.left = Self::merge_trees(child1, child2);\n                        }\n                        {\n                            let child1 = root1_ref.right.take();\n                            let child2 = root2_ref.right.take();\n                            root1_ref.right = Self::merge_trees(child1, child2);\n                        }\n                    }\n                    Some(root1)\n                }\n            },\n        }\n    }\n}","date":"2023-08-14"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉树"],"level":"Easy"}},{"problemName":"621.任务调度器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/621.任务调度器.json","problemData":{"id":"621","name":"621.任务调度器","url":"https://leetcode.cn/problems/task-scheduler","desc":"给你一个用字符数组  tasks 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。然而，两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。你需要计算完成所有任务所需要的 最短时间 。","solutions":[{"date":"2020-12-06","time":108,"memory":42.9,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/task-scheduler/solution/ren-wu-diao-du-qi-by-leetcode-solution-ur9w/)。","code":"function leastInterval(tasks: string[], n: number): number {\n  const countCache: Record<string, number> = {};\n  for (const task of tasks) {\n    countCache[task] = 1 + (countCache[task] ?? 0);\n  }\n  const maxExec = Math.max(...Object.values(countCache));\n  const maxCount = Object.values(countCache).reduce(\n    (total, v) => total + (v === maxExec ? 1 : 0),\n    0\n  );\n  return Math.max((maxExec - 1) * (n + 1) + maxCount, tasks.length);\n}"}],"tagList":["贪心","数组","哈希表","计数","排序","堆（优先队列）"],"level":"Medium"}},{"problemName":"622.设计循环队列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/622.设计循环队列.json","problemData":{"id":"860","name":"622.设计循环队列","url":"https://leetcode.cn/problems/design-circular-queue","desc":"设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。","solutions":[{"date":"2021-03-14","time":172,"memory":45.1,"script":"typescript","desc":"利用 js 特性直接构建数组。","code":"function copyRandomList(head: Node | null): Node | null {\n  if (head === null) return null;\n  let p: Node | null = head;\n  while (p !== null) {\n    p.next = new Node(p.val, p.next, p.random);\n    p = p.next.next;\n  }\n  p = head.next;\n  while (p) {\n    if (p.random) p.random = p.random!.next;\n    p = p.next?.next ?? null;\n  }\n  const newHead: Node | null = head.next;\n  p = head;\n  while (p) {\n    const q: Node = p.next!;\n    p.next = q.next;\n    q.next = q.next?.next ?? null;\n    p = p.next;\n  }\n  return newHead;\n}"},{"date":"2021-03-14","time":152,"memory":45.4,"script":"typescript","desc":"创建头尾指针控制。","code":"class MyCircularQueue {\n  private arr: number[];\n  private head = 0;\n  private rear = 0;\n  private count = 0;\n  constructor(private k: number) {\n    this.arr = new Array(k);\n  }\n  enQueue(value: number): boolean {\n    if (this.isFull()) return false;\n    this.arr[this.rear] = value;\n    this.rear = (this.rear + 1) % this.k;\n    this.count++;\n    return true;\n  }\n  deQueue(): boolean {\n    if (this.isEmpty()) return false;\n    this.head = (this.head + 1) % this.k;\n    this.count--;\n    return true;\n  }\n  Front(): number {\n    if (this.isEmpty()) return -1;\n    return this.arr[this.head];\n  }\n  Rear(): number {\n    if (this.isEmpty()) return -1;\n    return this.arr[this.rear === 0 ? this.k - 1 : this.rear - 1];\n  }\n  isEmpty(): boolean {\n    return this.count === 0;\n  }\n  isFull(): boolean {\n    return this.count === this.k;\n  }\n}"},{"date":"2022-03-03","time":20,"memory":16.3,"script":"cpp","desc":"双指针。","code":"class MyCircularQueue {\n   public:\n    int head, tail, *list, n;\n    MyCircularQueue(int k) : head(0), tail(0), n(k + 1) {\n        list = ((int *)malloc(sizeof(int) * n));\n    }\n    ~MyCircularQueue() { free(list); }\n    bool enQueue(int value) {\n        if (isFull()) return 0;\n        list[tail] = value;\n        tail = (tail + 1) % n;\n        return 1;\n    }\n    bool deQueue() {\n        if (isEmpty()) return 0;\n        head = (head + 1) % n;\n        return 1;\n    }\n    int Front() {\n        if (isEmpty()) return -1;\n        return list[head];\n    }\n    int Rear() {\n        if (isEmpty()) return -1;\n        return list[tail == 0 ? n - 1 : tail - 1];\n    }\n    bool isEmpty() { return head == tail; }\n    bool isFull() { return (tail + 1) % n == head; }\n};"},{"date":"2022-08-02","time":4,"memory":2.3,"script":"rust","desc":"queue。","code":"struct MyCircularQueue {\n    list: Vec<i32>,\n    max: usize,\n    head: usize,\n    rear: usize,\n}\nimpl MyCircularQueue {\n    fn new(k: i32) -> Self {\n        let max = (k + 1) as usize;\n        let mut list = Vec::with_capacity(max);\n        for _ in 0..max {\n            list.push(0);\n        }\n        MyCircularQueue {\n            max,\n            list,\n            head: 0,\n            rear: 0,\n        }\n    }\n\n    fn en_queue(&mut self, value: i32) -> bool {\n        if self.is_full() {\n            false\n        } else {\n            self.list[self.rear] = value;\n            self.rear = (self.rear + 1) % self.max;\n            true\n        }\n    }\n\n    fn de_queue(&mut self) -> bool {\n        if self.is_empty() {\n            false\n        } else {\n            self.head = (self.head + 1) % self.max;\n            true\n        }\n    }\n\n    fn front(&self) -> i32 {\n        if self.is_empty() {\n            -1\n        } else {\n            *self.list.get(self.head).unwrap()\n        }\n    }\n\n    fn rear(&self) -> i32 {\n        if self.is_empty() {\n            -1\n        } else {\n            let rear = if self.rear == 0 {\n                self.max - 1\n            } else {\n                self.rear - 1\n            };\n            *self.list.get(rear).unwrap()\n        }\n    }\n\n    fn is_empty(&self) -> bool {\n        self.rear == self.head\n    }\n\n    fn is_full(&self) -> bool {\n        (self.rear + 1) % self.max == self.head\n    }\n}"}],"tagList":["设计","队列","数组","链表"],"level":"Medium"}},{"problemName":"623.在二叉树中增加一行.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/623.在二叉树中增加一行.json","problemData":{"id":"623","name":"623.在二叉树中增加一行","url":"https://leetcode.cn/problems/add-one-row-to-tree","desc":"给定一个二叉树的根 root 和两个整数 val 和 depth ，在给定的深度 depth 处添加一个值为 val 的节点行。","solutions":[{"date":"2022-08-05","time":20,"memory":24.4,"script":"cpp","desc":"排序后，从后往前取值。","code":"class Solution {\n   public:\n    TreeNode* addOneRow(TreeNode* root, int val, int depth) {\n        if (depth == 1) return new TreeNode(val, root, nullptr);\n        queue<TreeNode*> q;\n        q.push(root);\n        int size = 1, level = 1;\n        while (level < depth - 1) {\n            TreeNode* node = q.front();\n            q.pop();\n            if (node->left) q.push(node->left);\n            if (node->right) q.push(node->right);\n            if (--size == 0) {\n                level++;\n                size = q.size();\n            }\n        }\n        while (q.size()) {\n            TreeNode* node = q.front();\n            q.pop();\n            node->left = new TreeNode(val, node->left, nullptr);\n            node->right = new TreeNode(val, nullptr, node->right);\n        }\n        return root;\n    }\n};"},{"date":"2022-08-05","time":0,"memory":2.6,"script":"rust","desc":"层序遍历。","code":"use std::cell::RefCell;\nuse std::collections::VecDeque;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn add_one_row(\n        root: Option<Rc<RefCell<TreeNode>>>,\n        val: i32,\n        depth: i32,\n    ) -> Option<Rc<RefCell<TreeNode>>> {\n        if depth == 1 {\n            let mut new_root = TreeNode::new(val);\n            new_root.left = root;\n            Some(Rc::new(RefCell::new(new_root)))\n        } else {\n            let root = root.unwrap();\n            let mut q = VecDeque::<Rc<RefCell<TreeNode>>>::new();\n            q.push_back(root.clone());\n            let (mut size, mut level) = (1, 1);\n            while level < depth - 1 {\n                let node = q.pop_front();\n                let node = node.as_ref().unwrap().borrow();\n                if node.left.is_some() {\n                    q.push_back(node.left.as_ref().unwrap().clone());\n                }\n                if node.right.is_some() {\n                    q.push_back(node.right.as_ref().unwrap().clone());\n                }\n                size -= 1;\n                if size == 0 {\n                    level += 1;\n                    size = q.len();\n                }\n            }\n            while !q.is_empty() {\n                let node = q.pop_front();\n                let mut node = node.as_ref().unwrap().borrow_mut();\n                let left = node.left.clone();\n                let mut new_left = TreeNode::new(val);\n                new_left.left = left;\n                node.left = Some(Rc::new(RefCell::new(new_left)));\n                let right = node.right.clone();\n                let mut new_right = TreeNode::new(val);\n                new_right.right = right;\n                node.right = Some(Rc::new(RefCell::new(new_right)));\n            }\n            Some(root)\n        }\n    }\n}"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"628.三个数的最大乘积.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/628.三个数的最大乘积.json","problemData":{"id":"628","name":"628.三个数的最大乘积","url":"https://leetcode.cn/problems/maximum-product-of-three-numbers","desc":"给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。","solutions":[{"date":"2021-01-20","time":148,"memory":43,"script":"typescript","desc":"计算最大三个数，进行特殊值，有两个负数的比较。","code":"function maximumProduct(nums: number[]): number {\n  nums.sort((a, b) => a - b);\n  const len = nums.length;\n  const compute = (arr: number[]) => arr.reduce((total, cur) => total * cur, 1);\n  const maxNum = compute(nums.slice(-3));\n  return nums[0] < 0 && nums[1] < 0 && nums[len - 1] > 0\n    ? Math.max(compute([nums[0], nums[1], nums[len - 1]]), maxNum)\n    : maxNum;\n}"},{"date":"2021-01-20","time":152,"memory":43.2,"script":"typescript","desc":"优化题解 1。","code":"function maximumProduct(nums: number[]): number {\n  nums.sort((a, b) => a - b);\n  const len = nums.length;\n  return Math.max(nums[0] * nums[1] * nums[len - 1], nums[len - 1] * nums[len - 2] * nums[len - 3]);\n}"}],"tagList":["数组","数学","排序"],"level":"Easy"}},{"problemName":"629.K个逆序对数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/629.K个逆序对数组.json","problemData":{"id":"629","name":"629.K个逆序对数组","url":"https://leetcode.cn/problems/k-inverse-pairs-array","desc":"给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字，且恰好拥有 k 个逆序对的不同的数组的个数。","solutions":[{"date":"2021-11-11","time":5508,"memory":45.3,"script":"typescript","desc":"动态规划。","code":"function kInversePairs(n: number, k: number): number {\n  if (k === 0) return 1;\n  const MOD = 10 ** 9 + 7;\n  const dp: Map<number, number>[] = new Array(2).fill(0).map(_ => new Map());\n  dp[0].set(0, 1);\n  for (let i = 1; i < n; i++) {\n    const map = dp[i % 2];\n    map.clear();\n    for (const [num, cnt] of dp[(i - 1) % 2].entries()) {\n      for (let j = 0; j <= i; j++) {\n        if (num + j > k) break;\n        const cur = map.get(num + j) ?? 0;\n        map.set(num + j, (cur + cnt) % MOD);\n      }\n    }\n  }\n  return dp[(n - 1) % 2].get(k) ?? 0;\n}"}],"tagList":["动态规划"],"level":"Hard"}},{"problemName":"630.课程表III.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/630.课程表III.json","problemData":{"id":"630","name":"630.课程表III","url":"https://leetcode.cn/problems/course-schedule-iii","desc":"返回你最多可以修读的课程数目。","solutions":[{"date":"2021-12-14","time":180,"memory":47.4,"script":"typescript","desc":"按照结束时间排序后，每次取出值存入大根堆，维护当前需要的总时间 sum，当 sum 大于结束时间时，移除堆顶。","code":"class Heap<T = number> {\n  private arr: T[] = [];\n  get isEmpty() {\n    return this.size === 0;\n  }\n  get size() {\n    return this.arr.length;\n  }\n  get top() {\n    return this.arr[0];\n  }\n  constructor(private compare: (t1: T, t2: T) => number) {}\n  add(num: T): void {\n    this.arr.push(num);\n    this.shiftUp(this.size - 1);\n  }\n  remove(): T {\n    const num = this.arr.shift()!;\n    if (this.size) {\n      this.arr.unshift(this.arr.pop()!);\n      this.shiftDown(0);\n    }\n    return num;\n  }\n  private shiftUp(index: number): void {\n    if (index === 0) return;\n    const parentIndex = (index - 1) >> 1;\n    if (this.compare(this.arr[index], this.arr[parentIndex]) > 0) {\n      [this.arr[index], this.arr[parentIndex]] = [this.arr[parentIndex], this.arr[index]];\n      this.shiftUp(parentIndex);\n    }\n  }\n  private shiftDown(index: number): void {\n    let childrenIndex = index * 2 + 1;\n    if (childrenIndex > this.size - 1) return;\n    if (\n      childrenIndex + 1 <= this.size - 1 &&\n      this.compare(this.arr[childrenIndex + 1], this.arr[childrenIndex]) > 0\n    ) {\n      childrenIndex++;\n    }\n    if (this.compare(this.arr[childrenIndex], this.arr[index]) > 0) {\n      [this.arr[childrenIndex], this.arr[index]] = [this.arr[index], this.arr[childrenIndex]];\n      this.shiftDown(childrenIndex);\n    }\n  }\n  *[Symbol.iterator](): IterableIterator<T> {\n    for (const t of this.arr) {\n      yield t;\n    }\n  }\n}\nfunction scheduleCourse(courses: number[][]): number {\n  const heap = new Heap<number>((a, b) => a - b);\n  let sum = 0;\n  for (const [dur, last] of courses.sort((a, b) => a[1] - b[1])) {\n    sum += dur;\n    heap.add(dur);\n    if (sum > last) sum -= heap.remove();\n  }\n  return heap.size;\n}"},{"script":"cpp","time":256,"memory":53.61,"desc":"拓扑排序。","code":"class Solution {\npublic:\n    int scheduleCourse(vector<vector<int>>& courses) {\n        int sum = 0;\n        priority_queue<int> q;\n        sort(courses.begin(), courses.end(), [&](auto &a, auto &b) {\n            return a[1] < b[1];\n        });\n        for (auto &course : courses) {\n            sum += course[0];\n            q.push(course[0]);\n            if (sum > course[1]) {\n                sum -= q.top();\n                q.pop();\n            }\n        }\n        return q.size();\n    }\n};","date":"2023-09-11"},{"script":"python","time":124,"memory":19.54,"desc":"同上。","code":"class Solution:\n    def scheduleCourse(self, courses: List[List[int]]) -> int:\n        courses.sort(key=lambda o: o[1])\n        q = []\n        sum = 0\n        for [d, e] in courses:\n            sum += d\n            heappush(q, -d)\n            if sum > e:\n                sum -= -heappop(q)\n        return len(q)\n","date":"2023-09-11"},{"script":"rust","time":32,"memory":29.7,"desc":"同上。","code":"impl Solution {\n    pub fn schedule_course(mut courses: Vec<Vec<i32>>) -> i32 {\n        courses.sort_by_key(|o| o[1]);\n        let mut sum = 0;\n        let mut q = std::collections::BinaryHeap::<i32>::new();\n        for course in courses {\n            sum += course[0];\n            q.push(course[0]);\n            if sum > course[1] {\n                sum -= q.pop().unwrap();\n            }\n        }\n        q.len() as i32\n    }\n}","date":"2023-09-11"}],"tagList":["贪心","数组","排序","堆（优先队列）"],"level":"Hard"}},{"problemName":"633.平方数之和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/633.平方数之和.json","problemData":{"id":"633","name":"633.平方数之和","url":"https://leetcode.cn/problems/sum-of-square-numbers","desc":"给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。","solutions":[{"date":"2021-04-28","time":92,"memory":39.5,"script":"typescript","desc":"确定边界值进行逐个比较。","code":"function judgeSquareSum(c: number): boolean {\n  let num1 = 0;\n  let num2 = ~~Math.sqrt(c) + 1;\n  while (num1 <= num2) {\n    const sum = num1 ** 2 + num2 ** 2;\n    if (sum > c) num2--;\n    else if (sum < c) num1++;\n    else return true;\n  }\n  return false;\n}"}],"tagList":["数学","双指针","二分查找"],"level":"Medium"}},{"problemName":"636.函数的独占时间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/636.函数的独占时间.json","problemData":{"id":"636","name":"636.函数的独占时间","url":"https://leetcode.cn/problems/exclusive-time-of-functions","desc":"给出一个非抢占单线程 CPU 的 n 个函数运行日志，找到函数的独占时间。","solutions":[{"date":"2021-03-20","time":116,"memory":42.8,"script":"typescript","desc":"利用栈维护函数运行过程。","code":"function exclusiveTime(n: number, logs: string[]): number[] {\n  const ans = new Array(n).fill(0);\n  const stack: number[] = [];\n  for (let i = 0, l = logs.length, pre = 0; i < l; i++) {\n    const info = logs[i].split(':');\n    const id = Number(info[0]);\n    const tag = info[1];\n    const time = Number(info[2]);\n    if (tag === 'start') {\n      if (stack.length !== 0) ans[stack[stack.length - 1]] += time - pre;\n      pre = time;\n      stack.push(id);\n    } else {\n      ans[id] += time - pre + 1;\n      pre = time + 1;\n      stack.pop();\n    }\n  }\n  return ans;\n}"},{"date":"2022-08-07","time":12,"memory":13,"script":"cpp","desc":"stack。","code":"class Solution {\n  public:\n    typedef pair<int, int> node;\n    vector<int> exclusiveTime(int n, vector<string>& logs) {\n        vector<int> list(n, 0);\n        stack<node> s;\n        for (auto &item : logs) {\n            bool isStart;\n            int idx = 0, time = 0;\n            analysis(item, idx, isStart, time);\n            if (s.size()) {\n                if (isStart) {\n                    node top = s.top();\n                    list[top.first] += time - top.second;\n                    s.push(make_pair(idx, time));\n                } else {\n                    node top = s.top(); s.pop();\n                    list[top.first] += time - top.second + 1;\n                    if (s.size()) {\n                        top = s.top(); s.pop();\n                        top.second = time + 1;\n                        s.push(top);\n                    }\n                }\n            } else {\n                s.push(make_pair(idx, time));\n            }\n        }\n        return list;\n    }\n    void analysis(string &item, int &idx, bool &isStart, int &time) {\n        int i = 0;\n        for (; item[i] != ':'; i++) idx = idx * 10 + item[i] - '0';\n        i++;\n        string temp = \"\";\n        for (; item[i] != ':'; i++) temp += item[i];\n        isStart = temp == \"start\";\n        i++;\n        for (; i < item.size(); i++) time = time * 10 + item[i] - '0';\n    }\n};"}],"tagList":["栈","数组"],"level":"Medium"}},{"problemName":"637.二叉树的层平均值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/637.二叉树的层平均值.json","problemData":{"id":"637","name":"637.二叉树的层平均值","url":"https://leetcode.cn/problems/average-of-levels-in-binary-tree","desc":"给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。","solutions":[{"date":"2020-09-12","time":104,"memory":42.5,"script":"typescript","desc":"层序遍历。","code":"function averageOfLevels(root: TreeNode | null): number[] {\n  if (root === null) return [];\n  const queue: TreeNode[] = [root];\n  let size = 1;\n  const ans: number[] = [root.val];\n  while (queue.length !== 0) {\n    const node = queue.shift()!;\n    node.left && queue.push(node.left);\n    node.right && queue.push(node.right);\n    if (--size === 0 && queue.length !== 0) {\n      size = queue.length;\n      ans.push(queue.reduce((total, cur) => total + cur.val, 0) / size);\n    }\n  }\n  return ans;\n}"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉树"],"level":"Easy"}},{"problemName":"638.大礼包.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/638.大礼包.json","problemData":{"id":"638","name":"638.大礼包","url":"https://leetcode.cn/problems/shopping-offers","desc":"返回 确切 满足购物清单所需花费的最低价格，你可以充分利用大礼包的优惠活动。你不能购买超出购物清单指定数量的物品，即使那样会降低整体价格。任意大礼包可无限次购买。","solutions":[{"date":"2021-10-24","time":76,"memory":39.8,"script":"typescript","desc":"dfs。","code":"function shoppingOffers(price: number[], special: number[][], needs: number[]): number {\n  const n = price.length;\n  special = special\n    .filter(item => {\n      let sum = 0;\n      for (let i = 0; i < n; i++) sum += item[i] * price[i];\n      return sum > item[n];\n    })\n    .sort((a, b) => a[n] - b[n]);\n  let ans = Infinity;\n  dfs(needs);\n  return ans;\n  function dfs(needs: number[], cost = 0) {\n    if (needs.every(v => v === 0)) {\n      ans = Math.min(cost, ans);\n      return;\n    }\n    const list = special.filter((item: number[]) =>\n      item.every((v, i) => (i === n ? true : v <= needs[i]))\n    );\n    if (list.length === 0) {\n      dfs(\n        [0],\n        needs.reduce((total, v, i) => price[i] * v + total, cost)\n      );\n    } else {\n      list.forEach(item => {\n        dfs(\n          needs.map((v, i) => v - item[i]),\n          item[n] + cost\n        );\n      });\n    }\n  }\n}"}],"tagList":["位运算","记忆化搜索","数组","动态规划","回溯","状态压缩"],"level":"Medium"}},{"problemName":"639.解码方法II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/639.解码方法II.json","problemData":{"id":"639","name":"639.解码方法II","url":"https://leetcode.cn/problems/decode-ways-ii","desc":"给你一个字符串 s ，由数字和 '\\*' 字符组成，返回 解码 该字符串的方法 数目 。","solutions":[{"date":"2021-09-28","time":152,"memory":52.4,"script":"typescript","desc":"dfs。","code":"function pathSum(root: TreeNode | null, targetSum: number): number {\n  if (root === null) return 0;\n  let ans = 0;\n  dfs(root);\n  return ans;\n  function dfs(node: TreeNode | null, list: number[] = []) {\n    if (node === null) return;\n    const newList = list.map(v => v + node.val);\n    newList.push(node.val);\n    newList.forEach(v => {\n      if (v === targetSum) ans++;\n    });\n    dfs(node.left, newList);\n    dfs(node.right, newList);\n  }\n}"},{"date":"2021-09-28","time":88,"memory":42.6,"script":"typescript","desc":"dfs。","code":"function pathSum(root: TreeNode | null, targetSum: number): number {\n  if (root === null) return 0;\n  let ans = 0;\n  dfs(root);\n  return ans;\n  function dfs(node: TreeNode | null, list: number[] = []) {\n    if (node === null) return;\n    const val = node.val;\n    const len = list.length;\n    if (val === targetSum) ans++;\n    for (let i = 0; i < len; i++) {\n      list[i] += val;\n      if (list[i] === targetSum) ans++;\n    }\n    list.push(val);\n    dfs(node.left, list);\n    dfs(node.right, list);\n    list.pop();\n    for (let i = 0; i < len; i++) {\n      list[i] -= val;\n    }\n  }\n}"}],"tagList":["字符串","动态规划"],"level":"Hard"}},{"problemName":"640.求解方程.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/640.求解方程.json","problemData":{"id":"640","name":"640.求解方程","url":"https://leetcode.cn/problems/solve-the-equation","desc":"求解一个给定的方程，将 x 以字符串 \"x=#value\" 的形式返回。该方程仅包含 '+' ， '-' 操作，变量 x 和其对应系数。","solutions":[{"date":"2022-08-10","time":0,"memory":2,"script":"rust","desc":"拆分后解析。","code":"use std::collections::VecDeque;\nimpl Solution {\n    pub fn solve_equation(equation: String) -> String {\n        let (mut l, mut r) = (0, 0);\n        let equation = equation.split('=').collect::<Vec<&str>>();\n        Solution::analysis(&mut l, &mut r, Solution::format(equation[0]), 1);\n        Solution::analysis(&mut l, &mut r, Solution::format(equation[1]), -1);\n        if l == 0 && r == 0 {\n            String::from(\"Infinite solutions\")\n        } else if l == 0 {\n            String::from(\"No solution\")\n        } else {\n            format!(\"x={}\", r / l)\n        }\n    }\n    fn format(s: &str) -> String {\n        let mut ans = s.to_string().chars().collect::<VecDeque<char>>();\n        let front = ans.front().unwrap();\n        if *front != '+' && *front != '-' {\n            ans.push_front('+');\n        }\n        ans.push_front('0');\n        String::from_utf8(ans.iter().map(|c| *c as u8).collect::<Vec<u8>>()).unwrap()\n    }\n    fn analysis(l: &mut i32, r: &mut i32, s: String, flag: i32) {\n        let s = s.chars().collect::<Vec<char>>();\n        let mut i = 0;\n        while i < s.len() {\n            let mut num = String::new();\n            if i != 0 {\n                num.push(s[i - 1]);\n            }\n            while i < s.len() && s[i] != '+' && s[i] != '-' && s[i] != 'x' {\n                num.push(s[i]);\n                i += 1;\n            }\n            if i < s.len() && s[i] == 'x' {\n                if num.len() == 1 && (num.eq(\"+\") || num.eq(\"-\")) {\n                    num.push('1');\n                }\n                *l += flag * num.parse::<i32>().unwrap();\n                i += 1;\n            } else {\n                *r += -1 * flag * num.parse::<i32>().unwrap();\n            }\n            i += 1;\n        }\n    }\n}"}],"tagList":["数学","字符串","模拟"],"level":"Medium"}},{"problemName":"641.设计循环双端队列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/641.设计循环双端队列.json","problemData":{"id":"859","name":"641.设计循环双端队列","url":"https://leetcode.cn/problems/design-circular-deque","desc":"设计实现双端队列。","solutions":[{"date":"2021-03-14","time":160,"memory":46.1,"script":"typescript","desc":"根据题 622 完善。","code":"class MyCircularDeque {\n  private arr: number[];\n  private head = 0;\n  private rear = 0;\n  private count = 0;\n  constructor(private k: number) {\n    this.arr = new Array(k);\n  }\n  isEmpty(): boolean {\n    return this.count === 0;\n  }\n  isFull(): boolean {\n    return this.count === this.k;\n  }\n  insertFront(value: number): boolean {\n    if (this.isFull()) return false;\n    this.head = this.head === 0 ? this.k - 1 : this.head - 1;\n    this.arr[this.head] = value;\n    this.count++;\n    return true;\n  }\n  insertLast(value: number): boolean {\n    if (this.isFull()) return false;\n    this.arr[this.rear] = value;\n    this.rear = (this.rear + 1) % this.k;\n    this.count++;\n    return true;\n  }\n  deleteFront(): boolean {\n    if (this.isEmpty()) return false;\n    this.head = (this.head + 1) % this.k;\n    this.count--;\n    return true;\n  }\n  deleteLast(): boolean {\n    if (this.isEmpty()) return false;\n    this.rear = this.rear === 0 ? this.k - 1 : this.rear - 1;\n    this.count--;\n    return true;\n  }\n  getFront(): number {\n    if (this.isEmpty()) return -1;\n    return this.arr[this.head];\n  }\n\n  getRear(): number {\n    if (this.isEmpty()) return -1;\n    return this.arr[this.rear === 0 ? this.k - 1 : this.rear - 1];\n  }\n}"},{"date":"2022-03-03","time":20,"memory":16.5,"script":"cpp","desc":"双指针。","code":"class MyCircularDeque {\n   public:\n    int head, tail, *list, n;\n    MyCircularDeque(int k) : head(0), tail(0), n(k + 1) {\n        list = ((int *)malloc(sizeof(int) * n));\n    }\n    ~MyCircularDeque() { free(list); }\n\n    bool insertLast(int value) {\n        if (isFull()) return 0;\n        list[tail] = value;\n        tail = (tail + 1) % n;\n        return 1;\n    }\n    bool insertFront(int value) {\n        if (isFull()) return 0;\n        head = head == 0 ? n - 1 : head - 1;\n        list[head] = value;\n        return 1;\n    }\n    bool deleteLast() {\n        if (isEmpty()) return 0;\n        tail = tail == 0 ? n - 1 : tail - 1;\n        return 1;\n    }\n    bool deleteFront() {\n        if (isEmpty()) return 0;\n        head = (head + 1) % n;\n        return 1;\n    }\n    int getFront() {\n        if (isEmpty()) return -1;\n        return list[head];\n    }\n    int getRear() {\n        if (isEmpty()) return -1;\n        return list[tail == 0 ? n - 1 : tail - 1];\n    }\n    bool isEmpty() { return head == tail; }\n    bool isFull() { return (tail + 1) % n == head; }\n};"},{"date":"2022-08-15","time":4,"memory":2.5,"script":"rust","desc":"循环队列。","code":"struct MyCircularDeque {\n    list: Vec<i32>,\n    first: usize,\n    last: usize,\n    len: usize,\n}\nimpl MyCircularDeque {\n    fn new(k: i32) -> Self {\n        let len = (k + 1) as usize;\n        let mut list = Vec::with_capacity(len);\n        for _ in 0..len {\n            list.push(0);\n        }\n        MyCircularDeque {\n            list,\n            first: 0,\n            last: 0,\n            len,\n        }\n    }\n    fn insert_front(&mut self, value: i32) -> bool {\n        if self.is_full() {\n            false\n        } else {\n            self.first = self.get_prev(self.first);\n            self.list[self.first] = value;\n            true\n        }\n    }\n    fn insert_last(&mut self, value: i32) -> bool {\n        if self.is_full() {\n            false\n        } else {\n            self.list[self.last] = value;\n            self.last = self.get_next(self.last);\n            true\n        }\n    }\n    fn delete_front(&mut self) -> bool {\n        if self.is_empty() {\n            false\n        } else {\n            self.first = self.get_next(self.first);\n            true\n        }\n    }\n    fn delete_last(&mut self) -> bool {\n        if self.is_empty() {\n            false\n        } else {\n            self.last = self.get_prev(self.last);\n            true\n        }\n    }\n    fn get_front(&self) -> i32 {\n        if self.is_empty() {\n            -1\n        } else {\n            self.list[self.first]\n        }\n    }\n    fn get_rear(&self) -> i32 {\n        if self.is_empty() {\n            -1\n        } else {\n            self.list[self.get_prev(self.last)]\n        }\n    }\n    fn is_empty(&self) -> bool {\n        self.first == self.last\n    }\n    fn is_full(&self) -> bool {\n        self.get_next(self.last) == self.first\n    }\n    fn get_prev(&self, cur: usize) -> usize {\n        if cur == 0 {\n            self.len - 1\n        } else {\n            cur - 1\n        }\n    }\n    fn get_next(&self, cur: usize) -> usize {\n        (cur + 1) % self.len\n    }\n}"}],"tagList":["设计","队列","数组","链表"],"level":"Medium"}},{"problemName":"643.子数组最大平均数I.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/643.子数组最大平均数I.json","problemData":{"id":"643","name":"643.子数组最大平均数I","url":"https://leetcode.cn/problems/maximum-average-subarray-i","desc":"给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。","solutions":[{"date":"2021-02-04","time":116,"memory":49,"script":"typescript","desc":"使用一个数去储存已遍历过的值。","code":"function findMaxAverage(nums: number[], k: number): number {\n  let num = nums.slice(0, k).reduce((total, cur) => total + cur, 0);\n  let max = num;\n  for (let i = k, l = nums.length; i < l; i++) {\n    max = Math.max((num = num - nums[i - k] + nums[i]), max);\n  }\n  return max / k;\n}"}],"tagList":["数组","滑动窗口"],"level":"Easy"}},{"problemName":"646.最长数对链.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/646.最长数对链.json","problemData":{"id":"646","name":"646.最长数对链","url":"https://leetcode.cn/problems/maximum-length-of-pair-chain","desc":"给定一个数对集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。","solutions":[{"date":"2022-09-03","time":32,"memory":2.2,"script":"cpp","desc":"dp 记录当前点为结尾的最大链路。","code":"impl Solution {\n    pub fn find_longest_chain(pairs: Vec<Vec<i32>>) -> i32 {\n        let mut pairs = pairs;\n        pairs.sort_by(|a, b| {\n            if a[0] != b[0] {\n                a[0].cmp(&b[0])\n            } else {\n                a[1].cmp(&b[1])\n            }\n        });\n        let len = pairs.len();\n        let mut dp = vec![1; len];\n        let mut ans = 0;\n        for i in 0..len {\n            for j in 0..i {\n                if pairs[j][1] < pairs[i][0] {\n                    dp[i] = dp[i].max(dp[j] + 1)\n                }\n            }\n            ans = ans.max(dp[i]);\n        }\n        ans\n    }\n}"}],"tagList":["贪心","数组","动态规划","排序"],"level":"Medium"}},{"problemName":"647.回文子串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/647.回文子串.json","problemData":{"id":"647","name":"647.回文子串","url":"https://leetcode.cn/problems/palindromic-substrings","desc":"给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。","solutions":[{"date":"2020-08-19","time":88,"memory":37.5,"script":"typescript","desc":"遍历每个中心点,进行向外扩张判断。","code":"function countSubstrings(s: string): number {\n  const n = s.length;\n  let ans = 0;\n  for (let i = 0; i < 2 * n - 1; ++i) {\n    let l = ~~(i / 2);\n    let r = l + (i % 2);\n    while (l >= 0 && r < n && s[l] === s[r]) {\n      --l;\n      ++r;\n      ++ans;\n    }\n  }\n  return ans;\n}"}],"tagList":["双指针","字符串","动态规划"],"level":"Medium"}},{"problemName":"648.单词替换.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/648.单词替换.json","problemData":{"id":"648","name":"648.单词替换","url":"https://leetcode.cn/problems/replace-words","desc":"现在，给定一个由许多词根组成的词典 dictionary 和一个用空格分隔单词形成的句子 sentence。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。","solutions":[{"date":"2022-07-07","time":68,"memory":54.5,"script":"cpp","desc":"字典树。","code":"class TrieNode {\n   public:\n    TrieNode **children;\n    bool end;\n    TrieNode() {\n        children = (TrieNode **)malloc(sizeof(TrieNode *) * 26);\n        for (int i = 0; i < 26; i++) children[i] = nullptr;\n        end = false;\n    }\n    void insert(string str) {\n        TrieNode *node = this;\n        for (int i = 0; i < str.size(); i++) {\n            int idx = str[i] - 'a';\n            if (!node->children[idx]) node->children[idx] = new TrieNode();\n            node = node->children[idx];\n            if (i == str.size() - 1) node->end = true;\n        }\n    }\n    string find(string str) {\n        TrieNode *node = this;\n        string ans = \"\", tmp = \"\";\n        for (int i = 0; i < str.size(); i++) {\n            int idx = str[i] - 'a';\n            tmp += str[i];\n            if (!node->children[idx]) return ans;\n            node = node->children[idx];\n            if (node->end) return tmp;\n        }\n        return ans;\n    }\n};\nclass Solution {\n   public:\n    TrieNode *root = new TrieNode();\n    string replaceWords(vector<string> &dictionary, string sentence) {\n        vector<string> list;\n        string ans = \"\";\n        for (auto &str : dictionary) root->insert(str);\n        for (auto &str : split(sentence)) {\n            string res = root->find(str);\n            if (res == \"\")\n                list.push_back(str);\n            else\n                list.push_back(res);\n        }\n        for (int i = 0; i < list.size(); i++) {\n            if (i != 0) ans += \" \";\n            ans += list[i];\n        }\n        return ans;\n    }\n    vector<string> split(string &str) {\n        vector<string> ans;\n        string tmp = \"\";\n        for (auto &ch : str) {\n            if (ch == ' ') {\n                ans.push_back(tmp);\n                tmp = \"\";\n            } else\n                tmp += ch;\n        }\n        ans.push_back(tmp);\n        return ans;\n    }\n};"}],"tagList":["字典树","数组","哈希表","字符串"],"level":"Medium"}},{"problemName":"649.Dota2参议院.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/649.Dota2参议院.json","problemData":{"id":"649","name":"649.Dota2参议院","url":"https://leetcode.cn/problems/dota2-senate","desc":"给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。","solutions":[{"date":"2020-12-12","time":80,"memory":39.3,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/wiggle-subsequence/solution/bai-dong-xu-lie-by-leetcode-solution-yh2m/)。","code":"function predictPartyVictory(senate: string): string {\n  const l = senate.length;\n  const arr = new Array(l).fill(1);\n  const check = (c: string) => () => arr.every((v, i) => (senate[i] === c ? true : v === 0));\n  const checkR = check('R');\n  const checkD = check('D');\n  const setNext = (i: number, c: string) => {\n    for (let j = i + 1; j < l; j++) {\n      if (senate[j] === c && arr[j] === 1) {\n        arr[j] = 0;\n        return;\n      }\n    }\n    for (let j = 0; j < i; j++) {\n      if (senate[j] === c && arr[j] === 1) {\n        arr[j] = 0;\n        return;\n      }\n    }\n  };\n  while (true) {\n    for (let i = 0; i < l; i++) {\n      if (arr[i] === 0) continue;\n      if (senate[i] === 'R') {\n        if (checkR()) return 'Radiant';\n        setNext(i, 'D');\n      } else {\n        if (checkD()) return 'Dire';\n        setNext(i, 'R');\n      }\n    }\n  }\n  return '';\n}"}],"tagList":["贪心","队列","字符串"],"level":"Medium"}},{"problemName":"650.两个键的键盘.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/650.两个键的键盘.json","problemData":{"id":"650","name":"650.两个键的键盘","url":"https://leetcode.cn/problems/2-keys-keyboard","desc":"给你一个数字 n ，你需要使用最少的操作次数，在记事本上输出 恰好 n 个 'A' 。返回能够打印出 n 个 'A' 的最少操作次数。","solutions":[{"date":"2021-09-19","time":76,"memory":40,"script":"javascript","desc":"动态规划。","code":"function minSteps(n: number): number {\n  if (n === 1) return 0;\n  const dp = new Array(n + 1).fill(0);\n  for (let num = 2; num <= n; num++) {\n    if (num % 2 === 0) {\n      dp[num] = dp[num / 2] + 2;\n      continue;\n    }\n    for (let i = num - 1; i >= 2; i--) {\n      if (num % i === 0) {\n        dp[num] = dp[i] + num / i;\n        break;\n      }\n    }\n    if (dp[num] === 0) dp[num] = num;\n  }\n  return dp[n];\n}"}],"tagList":["数学","动态规划"],"level":"Medium"}},{"problemName":"652.寻找重复的子树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/652.寻找重复的子树.json","problemData":{"id":"652","name":"652.寻找重复的子树","url":"https://leetcode.cn/problems/find-duplicate-subtrees","desc":"给定一棵二叉树 root，返回所有重复的子树。","solutions":[{"date":"2022-09-05","time":52,"memory":53.7,"script":"cpp","desc":"map 存储相同节点·。","code":"class Solution {\npublic:\n    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {\n        unordered_map<string, vector<TreeNode*>> m;\n        dfs(m, root);\n        vector<TreeNode *> ans;\n        for (auto &item : m) {\n            if (item.second.size() > 1) {\n                ans.push_back(item.second[0]);\n            }\n        }\n        return ans;\n    }\n    string dfs(unordered_map<string, vector<TreeNode*>> &m, TreeNode *root) {\n        if (!root) return \"\";\n        string s = \"(\" + to_string(root->val) + \",[\" + dfs(m, root->left) + \"],[\" + dfs(m, root->right) + \"])\";\n        m[s].push_back(root);\n        return s;\n    }\n};"}],"tagList":["树","深度优先搜索","哈希表","二叉树"],"level":"Medium"}},{"problemName":"653.两数之和IV-输入二叉搜索树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/653.两数之和IV-输入二叉搜索树.json","problemData":{"id":"653","name":"653.两数之和IV-输入二叉搜索树","url":"https://leetcode.cn/problems/two-sum-iv-input-is-a-bst","desc":"给定一个二叉搜索树 root 和一个目标结果 k，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。","solutions":[{"date":"2021-08-20","time":168,"memory":46.8,"script":"typescript","desc":"层序遍历时判断每个值。","code":"function findTarget(root: TreeNode | null, k: number): boolean {\n  if (root === null) return false;\n  const set = new Set<number>();\n  const q = [root];\n  while (q.length) {\n    const node = q.shift()!;\n    if (set.has(node.val)) return true;\n    set.add(k - node.val);\n    node.left && q.push(node.left);\n    node.right && q.push(node.right);\n  }\n  return false;\n}"},{"date":"2022-03-21","time":36,"memory":37.7,"script":"cpp","desc":"dfs。","code":"class Solution {\n   public:\n    unordered_set<int> s;\n    bool findTarget(TreeNode *root, int k) {\n        if (!root) return false;\n        if (s.count(k - root->val)) return true;\n        s.insert(root->val);\n        return findTarget(root->left, k) || findTarget(root->right, k);\n    }\n};"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉搜索树","哈希表","双指针","二叉树"],"level":"Easy"}},{"problemName":"654.最大二叉树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/654.最大二叉树.json","problemData":{"id":"654","name":"654.最大二叉树","url":"https://leetcode.cn/problems/maximum-binary-tree","desc":"返回 nums 构建的 最大二叉树 。","solutions":[{"date":"2022-08-20","time":64,"memory":41.2,"script":"cpp","desc":"dfs。","code":"class Solution {\npublic:\n    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {\n        return _constructMaximumBinaryTree(nums, 0, nums.size());\n    }\n    TreeNode* _constructMaximumBinaryTree(vector<int>& nums, int l, int r) {\n        if (l >= r) return nullptr;\n        int max_num = INT_MIN, max_idx;\n        for (int i = l; i < r; i++) {\n            if (nums[i] > max_num) {\n                max_num = nums[i];\n                max_idx = i;\n            }\n        }\n        return new TreeNode(max_num, _constructMaximumBinaryTree(nums, l, max_idx), _constructMaximumBinaryTree(nums, max_idx + 1, r));\n    }\n};"}],"tagList":["栈","树","数组","分治","二叉树","单调栈"],"level":"Medium"}},{"problemName":"655.输出二叉树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/655.输出二叉树.json","problemData":{"id":"655","name":"655.输出二叉树","url":"https://leetcode.cn/problems/print-binary-tree","desc":"返回构造得到的矩阵 res 。","solutions":[{"date":"2022-08-22","time":0,"memory":2,"script":"rust","desc":"dfs。","code":"use std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn print_tree(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<String>> {\n        let height = Solution::get_height(root.as_ref()) - 1;\n        let n = 2_usize.pow(height as u32 + 1) - 1;\n        let mut ans = vec![vec![String::new(); n]; height + 1];\n        let root = root.unwrap();\n        Solution::dfs(root, &mut ans, height, 0, (n - 1) / 2);\n        ans\n    }\n    fn get_height(node: Option<&Rc<RefCell<TreeNode>>>) -> usize {\n        match node {\n            Some(node) => {\n                1 + Solution::get_height(node.borrow().left.as_ref())\n                    .max(Solution::get_height(node.borrow().right.as_ref()))\n            }\n            None => 0,\n        }\n    }\n    fn dfs(\n        node: Rc<RefCell<TreeNode>>,\n        data: &mut Vec<Vec<String>>,\n        height: usize,\n        r: usize,\n        c: usize,\n    ) {\n        data[r][c] = format!(\"{}\", node.borrow().val);\n        if node.borrow().left.is_some() {\n            Solution::dfs(\n                node.borrow().left.clone().unwrap(),\n                data,\n                height,\n                r + 1,\n                c - 2_usize.pow((height - r - 1) as u32),\n            )\n        }\n        if node.borrow().right.is_some() {\n            Solution::dfs(\n                node.borrow().right.clone().unwrap(),\n                data,\n                height,\n                r + 1,\n                c + 2_usize.pow((height - r - 1) as u32),\n            )\n        }\n    }\n}"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"657.机器人能否返回原点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/657.机器人能否返回原点.json","problemData":{"id":"657","name":"657.机器人能否返回原点","url":"https://leetcode.cn/problems/robot-return-to-origin","desc":"在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。","solutions":[{"date":"2020-08-28","time":88,"memory":38.8,"script":"typescript","desc":"先进行排序字符，初始化数据，计算机票数量，再深度遍历。","code":"function judgeCircle(moves: string): boolean {\n  let x = 0;\n  let y = 0;\n  const moveFn: Record<string, () => void> = {\n    U: () => (y += 1),\n    D: () => (y -= 1),\n    R: () => (x += 1),\n    L: () => (x -= 1),\n  };\n  for (const move of moves) moveFn[move]();\n  return x === 0 && y === 0;\n}"}],"tagList":["字符串","模拟"],"level":"Easy"}},{"problemName":"658.找到K个最接近的元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/658.找到K个最接近的元素.json","problemData":{"id":"658","name":"658.找到K个最接近的元素","url":"https://leetcode.cn/problems/find-k-closest-elements","desc":"给定一个 排序好 的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。","solutions":[{"date":"2022-08-25","time":16,"memory":2.2,"script":"rust","desc":"只要数的数量相同就可以匹配。","code":"use std::cmp::Ordering;\nuse std::collections::{BinaryHeap, VecDeque};\n#[derive(PartialEq, Eq, Debug)]\nstruct Item(i32, i32);\nimpl PartialOrd for Item {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        let ord = other.1.cmp(&self.1);\n        if ord == Ordering::Equal {\n            Some(other.0.cmp(&self.0))\n        } else {\n            Some(ord)\n        }\n    }\n}\nimpl Ord for Item {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.partial_cmp(other).unwrap()\n    }\n}\nimpl Solution {\n    pub fn find_closest_elements(arr: Vec<i32>, k: i32, x: i32) -> Vec<i32> {\n        let mut ans = VecDeque::<i32>::new();\n        let mut heap = BinaryHeap::<Item>::new();\n        for num in arr {\n            heap.push(Item(num, (num - x).abs()));\n        }\n        for _ in 0..k {\n            let num = heap.pop().unwrap().0;\n            if ans.len() == 0 || *ans.back().unwrap() <= num {\n                ans.push_back(num);\n            } else {\n                ans.push_front(num);\n            }\n        }\n        Vec::from(ans)\n    }\n}"}],"tagList":["数组","双指针","二分查找","排序","滑动窗口","堆（优先队列）"],"level":"Medium"}},{"problemName":"661.图片平滑器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/661.图片平滑器.json","problemData":{"id":"661","name":"661.图片平滑器","url":"https://leetcode.cn/problems/image-smoother","desc":"给你一个表示图像灰度的 m x n 整数矩阵 img ，返回对图像的每个单元格平滑处理后的图像 。","solutions":[{"date":"2022-03-16","time":44,"memory":21.1,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    constexpr static int dirs[8][2] = {{0, 1}, {0, -1}, {1, 0},  {-1, 0},\n                                       {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};\n    vector<vector<int>> imageSmoother(vector<vector<int>>& img) {\n        int n = img.size(), m = img[0].size();\n        vector<vector<int>> ans(n, vector<int>(m));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                int val = img[i][j], cnt = 1;\n                for (int k = 0; k < 8; k++) {\n                    int ni = i + dirs[k][0], nj = j + dirs[k][1];\n                    if (ni < 0 || ni == n || nj < 0 || nj == m) continue;\n                    val += img[ni][nj];\n                    cnt++;\n                }\n                ans[i][j] = val / cnt;\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","矩阵"],"level":"Easy"}},{"problemName":"664.奇怪的打印机.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/664.奇怪的打印机.json","problemData":{"id":"664","name":"664.奇怪的打印机","url":"https://leetcode.cn/problems/strange-printer","desc":"给你一个字符串 s ，你的任务是计算这个打印机打印它需要的最少打印次数。","solutions":[{"date":"2021-05-24","time":124,"memory":122.9,"script":"typescript","desc":"动态规划。","code":"function strangePrinter(s: string): number {\n  const len = s.length;\n  const dp: number[][] = new Array(len).fill(0).map(_ => new Array(len).fill(0));\n  for (let i = len - 1; i >= 0; i--) {\n    dp[i][i] = 1;\n    for (let j = i + 1; j < len; j++) {\n      if (s[i] === s[j]) dp[i][j] = dp[i][j - 1];\n      else {\n        let min = Infinity;\n        for (let k = i; k < j; k++) min = Math.min(dp[i][k] + dp[k + 1][j], min);\n        dp[i][j] = min;\n      }\n    }\n  }\n  return dp[0][len - 1];\n}"}],"tagList":["字符串","动态规划"],"level":"Hard"}},{"problemName":"665.非递减数列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/665.非递减数列.json","problemData":{"id":"665","name":"665.非递减数列","url":"https://leetcode.cn/problems/non-decreasing-array","desc":"给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。","solutions":[{"date":"2021-02-07","time":108,"memory":41.3,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/non-decreasing-array/solution/fei-di-jian-shu-lie-by-leetcode-solution-zdsm/)。","code":"function checkPossibility(nums: number[]): boolean {\n  const n = nums.length;\n  let f = false;\n  for (let i = 0; i < n - 1; i++) {\n    const num = nums[i];\n    const nextNum = nums[i + 1];\n    if (num > nextNum) {\n      if (f) return false;\n      f = true;\n      if (i > 0 && nextNum < nums[i - 1]) nums[i + 1] = num;\n    }\n  }\n  return true;\n}"}],"tagList":["数组"],"level":"Medium"}},{"problemName":"667.优美的排列II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/667.优美的排列II.json","problemData":{"id":"667","name":"667.优美的排列II","url":"https://leetcode.cn/problems/beautiful-arrangement-ii","desc":"给你两个整数 n 和 k ，请你构造一个答案列表 answer ，该列表应当包含从 1 到 n 的 n 个不同正整数。","solutions":[{"date":"2022-09-08","time":28,"memory":8.9,"script":"c","desc":"[1, k+1, 2, k, 3, k-1..]排列。","code":"int* constructArray(int n, int k, int* returnSize){\n    *returnSize = n;\n    int *ans = (int *)malloc(sizeof(int) * n);\n    if (k == 1) for (int i = 0; i < n; i++) ans[i] = i + 1;\n    else {\n        int l = 1, r = k + 1, idx = 0;\n        while (l < r) {\n            ans[idx++] = l++;\n            if (l != r) ans[idx++] = r--;\n        }\n        if (l == r) ans[id++] = l;\n        k += 2;\n        while (k <= n) ans[idx++] = k++;\n    }\n    return ans;\n}"}],"tagList":["数组","数学"],"level":"Medium"}},{"problemName":"669.修剪二叉搜索树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/669.修剪二叉搜索树.json","problemData":{"id":"669","name":"669.修剪二叉搜索树","url":"https://leetcode.cn/problems/trim-a-binary-search-tree","desc":"通过修剪二叉搜索树，使得所有节点的值在[low, high]中。","solutions":[{"date":"2022-09-10","time":12,"memory":16.7,"script":"cpp","desc":"dfs。","code":"class Solution {\npublic:\n    TreeNode* trimBST(TreeNode* root, int low, int high) {\n        if (!root) return nullptr;\n        root->left = trimBST(root->left, low, high);\n        root->right = trimBST(root->right, low, high);\n        if (root->val < low) root = root->right;\n        else if (root->val > high) root = root->left;\n        return root;\n    }\n};"}],"tagList":["树","深度优先搜索","二叉搜索树","二叉树"],"level":"Medium"}},{"problemName":"670.最大交换.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/670.最大交换.json","problemData":{"id":"670","name":"670.最大交换","url":"https://leetcode.cn/problems/maximum-swap","desc":"给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。","solutions":[{"date":"2022-09-13","time":0,"memory":5.7,"script":"cpp","desc":"寻找是否存在比当前值大的低位数。","code":"class Solution {\npublic:\n    int maximumSwap(int num) {\n        int list[10] = {0}, list_len = 0;\n        for (; num; num /= 10) list[list_len++] = num % 10;\n        for (int i = list_len - 1; i > 0; i--) {\n            int max_idx = i - 1;\n            for (int j = i - 1; j >= 0; j--) max_idx = list[max_idx] > list[j] ? max_idx : j;\n            if (list[max_idx] > list[i]) {\n                swap(list[max_idx], list[i]);\n                break;\n            }\n        }\n        int ans = 0;\n        for (int i = list_len - 1; i >= 0; i--) ans = ans * 10 + list[i];\n        return ans;\n    }\n};"},{"script":"python","time":42,"memory":16.49,"desc":"贪心。","code":"class Solution:\n    def maximumSwap(self, num: int) -> int:\n        arr = [[] for _ in range(10)]\n        lnum = list(int(c) for c in str(num))\n        for i in range(len(lnum)): arr[lnum[i]].append(i)\n        swap = False\n        for i in range(len(lnum)):\n            for num in range(9, -1, -1):\n                if lnum[i] >= num: break\n                while arr[num] and arr[num][-1] < i: arr[num].pop()\n                if arr[num]:\n                    lnum[i], lnum[arr[num][-1]] = lnum[arr[num][-1]], lnum[i]\n                    swap = True\n            if swap: break\n        return reduce(lambda sum, num: sum * 10 + num, lnum, 0)","date":"2024-01-22"}],"tagList":["贪心","数学"],"level":"Medium"}},{"problemName":"673.最长递增子序列的个数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/673.最长递增子序列的个数.json","problemData":{"id":"673","name":"673.最长递增子序列的个数","url":"https://leetcode.cn/problems/number-of-longest-increasing-subsequence","desc":"给定一个未排序的整数数组，找到最长递增子序列的个数。","solutions":[{"date":"2021-09-20","time":108,"memory":40.5,"script":"javascript","desc":"动态规划。","code":"function findNumberOfLIS(nums: number[]): number {\n  const n = nums.length;\n  const dp = new Array(n).fill(0).map(_ => ({ val: 1, cnt: 1 }));\n  let maxVal = 1;\n  let maxCnt = 0;\n  for (let i = 0; i < n; i++) {\n    const num = nums[i];\n    for (let j = 0; j < i; j++) {\n      if (nums[j] < num) {\n        const len = dp[j].val + 1;\n        if (dp[i].val < len) {\n          dp[i].val = len;\n          dp[i].cnt = dp[j].cnt;\n        } else if (dp[i].val === len) dp[i].cnt += dp[j].cnt;\n      }\n    }\n    if (maxVal < dp[i].val) {\n      maxVal = Math.max(maxVal, dp[i].val);\n      maxCnt = dp[i].cnt;\n    } else if (maxVal === dp[i].val) maxCnt += dp[i].cnt;\n  }\n  return maxCnt;\n}"}],"tagList":["树状数组","线段树","数组","动态规划"],"level":"Medium"}},{"problemName":"674.最长连续递增序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/674.最长连续递增序列.json","problemData":{"id":"674","name":"674.最长连续递增序列","url":"https://leetcode.cn/problems/longest-continuous-increasing-subsequence","desc":"给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。","solutions":[{"date":"2021-01-24","time":92,"memory":41.2,"script":"typescript","desc":"遍历一遍。","code":"function findLengthOfLCIS(nums: number[]): number {\n  const len = nums.length;\n  if (len === 0) return 0;\n  const dp = new Array(len).fill(1);\n  let max = 1;\n  for (let i = 1; i < len; i++)\n    nums[i] > nums[i - 1] && (max = Math.max(max, (dp[i] = dp[i - 1] + 1)));\n  return max;\n}"}],"tagList":["数组"],"level":"Easy"}},{"problemName":"675.为高尔夫比赛砍树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/675.为高尔夫比赛砍树.json","problemData":{"id":"675","name":"675.为高尔夫比赛砍树","url":"https://leetcode.cn/problems/cut-off-trees-for-golf-event","desc":"你将从 (0, 0) 点开始工作，返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回 -1 。","solutions":[{"date":"2022-05-23","time":760,"memory":97.5,"script":"cpp","desc":"bfs, 每次从当前值寻找下一个目标。","code":"int dirs[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nclass Solution {\n   public:\n    typedef pair<int, int> node;\n    int rowLen, colLen;\n    int cutOffTree(vector<vector<int>>& forest) {\n        rowLen = forest.size(), colLen = forest[0].size();\n        vector<int> list;\n        for (int row = 0; row < rowLen; row++) {\n            for (int col = 0; col < colLen; col++) {\n                if (forest[row][col] > 1) list.emplace_back(forest[row][col]);\n            }\n        }\n        sort(list.begin(), list.end(),\n             [&](int a, int b) -> bool { return a < b; });\n        int ans = 0;\n        node prev = make_pair(0, 0);\n        for (int i = 0; i < list.size(); i++) {\n            int step = findNext(forest, prev, list[i]);\n            if (step == -1) return -1;\n            ans += step;\n        }\n        return ans;\n    }\n    int findNext(vector<vector<int>>& forest, node& start, int target) {\n        int step = 0, size = 1;\n        queue<node> q;\n        vector<vector<bool>> used(rowLen, vector(colLen, false));\n        used[start.first][start.second] = true;\n        q.push(start);\n        while (q.size()) {\n            node item = q.front();\n            q.pop();\n            if (forest[item.first][item.second] == target) {\n                start.first = item.first;\n                start.second = item.second;\n                return step;\n            }\n            for (int i = 0; i < 4; i++) {\n                int nrow = item.first + dirs[i][0],\n                    ncol = item.second + dirs[i][1];\n                if (nrow < 0 || nrow == rowLen || ncol < 0 || ncol == colLen ||\n                    forest[nrow][ncol] == 0 || used[nrow][ncol])\n                    continue;\n                q.push(make_pair(nrow, ncol));\n                used[nrow][ncol] = true;\n            }\n            if (--size == 0) {\n                size = q.size();\n                step++;\n            }\n        }\n        return -1;\n    }\n};"}],"tagList":["广度优先搜索","数组","矩阵","堆（优先队列）"],"level":"Hard"}},{"problemName":"676.实现一个魔法字典.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/676.实现一个魔法字典.json","problemData":{"id":"676","name":"676.实现一个魔法字典","url":"https://leetcode.cn/problems/implement-magic-dictionary","desc":"设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于你构建的字典中。","solutions":[{"date":"2021-11-05","time":132,"memory":45.9,"script":"typescript","desc":"trie。","code":"const getIdx = (ch: string) => ch.codePointAt(0)! - 'a'.codePointAt(0)!;\nclass TrieNode {\n  end = false;\n  children: TrieNode[] = [];\n  constructor(public val: string) {}\n}\nclass Trie {\n  root = new TrieNode('');\n  insert(word: string): void {\n    let node = this.root;\n    for (const ch of word) {\n      const idx = getIdx(ch);\n      if (!node.children[idx]) node.children[idx] = new TrieNode(ch);\n      node = node.children[idx];\n    }\n    node.end = true;\n  }\n  search(word: string): boolean {\n    return this._search(word);\n  }\n  _search(word: string, node = this.root, idx = 0, err = 1): boolean {\n    if (idx === word.length) return node.end && err === 0;\n    const ch = word[idx];\n    const chIdx = getIdx(ch);\n    if (node.children[chIdx] && this._search(word, node.children[chIdx], idx + 1, err)) return true;\n    if (err === 0) return false;\n    for (const child of node.children) {\n      if (child === node.children[chIdx]) continue;\n      if (this._search(word, child, idx + 1, err - 1)) return true;\n    }\n    return false;\n  }\n}\n\nclass MagicDictionary {\n  trie = new Trie();\n  buildDict(dictionary: string[]): void {\n    dictionary.forEach(word => this.trie.insert(word));\n  }\n  search(searchWord: string): boolean {\n    return this.trie.search(searchWord);\n  }\n}"},{"date":"2022-07-11","time":712,"memory":101.6,"script":"cpp","desc":"trie, 对于每种可能出现 1 个替换，进行递归考虑。","code":"#define CHILD_SIZE 26\nclass TrieNode {\n   public:\n    int key;\n    bool end;\n    TrieNode **children;\n    TrieNode(int key) {\n        this->key = key;\n        this->end = false;\n        this->children = (TrieNode **)malloc(sizeof(TrieNode *) * CHILD_SIZE);\n        for (int i = 0; i < CHILD_SIZE; i++) children[i] = nullptr;\n    }\n};\nclass Trie {\n   public:\n    TrieNode *root;\n    Trie() { this->root = new TrieNode(0); }\n    void insert(string words) {\n        TrieNode *node = root;\n        for (auto &w : words) {\n            if (node->children[w - 'a'] == nullptr)\n                node->children[w - 'a'] = new TrieNode(w);\n            node = node->children[w - 'a'];\n        }\n        node->end = true;\n    }\n    bool search(string words) { return _search(words, 0, root, 0); }\n    bool _search(string &words, int idx, TrieNode *node, int replaceCnt) {\n        int w = words[idx];\n        if (idx == words.size() - 1) {\n            if (replaceCnt > 1)\n                return false;\n            else if (replaceCnt == 1)\n                return node->children[w - 'a'] != nullptr &&\n                       node->children[w - 'a']->end;\n            else {\n                for (int i = 0; i < CHILD_SIZE; i++) {\n                    if (node->children[i] == nullptr || w - 'a' == i) continue;\n                    if (node->children[i]->end) return true;\n                }\n            }\n            return false;\n        }\n        int nextw = words[idx + 1];\n        for (int i = 0; i < CHILD_SIZE; i++) {\n            if (node->children[i] == nullptr) continue;\n            if (w - 'a' == i &&\n                _search(words, idx + 1, node->children[i], replaceCnt))\n                return true;\n            if (w - 'a' != i &&\n                _search(words, idx + 1, node->children[i], replaceCnt + 1))\n                return true;\n        }\n        return false;\n    }\n};\n\nclass MagicDictionary {\n   public:\n    Trie *trie;\n    MagicDictionary() { trie = new Trie(); }\n    void buildDict(vector<string> dictionary) {\n        for (auto &words : dictionary) trie->insert(words);\n    }\n    bool search(string searchWord) { return trie->search(searchWord); }\n};"}],"tagList":["深度优先搜索","设计","字典树","哈希表","字符串"],"level":"Medium"}},{"problemName":"678.有效的括号字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/678.有效的括号字符串.json","problemData":{"id":"678","name":"678.有效的括号字符串","url":"https://leetcode.cn/problems/valid-parenthesis-string","desc":"给定一个只包含三种字符的字符串：（ ，） 和 \\*，写一个函数来检验这个字符串是否为有效字符串。","solutions":[{"date":"2021-09-17","time":80,"memory":39.5,"script":"typescript","desc":"分别统计左括号和\\*的下标，遍历到右括号时消除。","code":"function checkValidString(s: string): boolean {\n  const leftStack: number[] = [];\n  const starStack: number[] = [];\n  for (let i = 0; i < s.length; i++) {\n    const c = s[i];\n    if (c === '(') leftStack.push(i);\n    else if (c === '*') starStack.push(i);\n    else {\n      if (leftStack.length === 0 && starStack.length === 0) return false;\n      if (leftStack.length !== 0) leftStack.pop();\n      else starStack.pop();\n    }\n  }\n  while (leftStack.length !== 0 && starStack.length !== 0) {\n    const left = leftStack.pop()!;\n    const star = starStack.pop()!;\n    if (left > star) return false;\n  }\n  return leftStack.length === 0;\n}"},{"date":"2021-09-17","time":68,"memory":39.4,"script":"typescript","desc":"贪心，统计左括号可能的最大值和最小值。","code":"function checkValidString(s: string): boolean {\n  let min = 0;\n  let max = 0;\n  for (const c of s) {\n    if (c === '(') {\n      min++;\n      max++;\n    } else if (c === ')') {\n      min = Math.max(min - 1, 0);\n      max--;\n      if (max < 0) return false;\n    } else {\n      min = Math.max(min - 1, 0);\n      max++;\n    }\n  }\n  return min === 0;\n}"}],"tagList":["栈","贪心","字符串","动态规划"],"level":"Medium"}},{"problemName":"679.24点游戏.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/679.24点游戏.json","problemData":{"id":"679","name":"679.24点游戏","url":"https://leetcode.cn/problems/24-game","desc":"你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 \\*，/，+，-，(，) 的运算得到 24。","solutions":[{"date":"2020-08-22","time":1092,"memory":74.7,"script":"typescript","desc":"遍历所有可能创建模板,使用 eval 进行计算。","code":"function judgePoint24(nums: number[]): boolean {\n  const numLen = nums.length;\n  const op = ['+', '-', '*', '/'];\n  const opLen = op.length;\n  const set = new Set<number>();\n  const getTemplates = (\n    num1: number,\n    num2: number,\n    num3: number,\n    num4: number,\n    op1: string,\n    op2: string,\n    op3: string\n  ): string[] => {\n    return [\n      `(${num1}${op1}${num2})${op2}(${num3}${op3}${num4})`,\n      `${num1}${op1}(${num2}${op2}${num3}${op3}${num4})`,\n      `(${num1}${op1}${num2}${op2}${num3})${op3}${num4}`,\n      `${num1}${op1}${num2}${op2}(${num3}${op3}${num4})`,\n      `(${num1}${op1}${num2})${op2}${num3}${op3}${num4}`,\n      `${num1}${op1}${num2}${op2}${num3}${op3}${num4}`,\n    ];\n  };\n  for (let i1 = 0; i1 < numLen; i1++) {\n    const num1 = nums[i1];\n    set.add(i1);\n    for (let i2 = 0; i2 < numLen; i2++) {\n      const num2 = nums[i2];\n      if (set.has(i2)) continue;\n      set.add(i2);\n      for (let i3 = 0; i3 < numLen; i3++) {\n        const num3 = nums[i3];\n        if (set.has(i3)) continue;\n        set.add(i3);\n        for (let i4 = 0; i4 < numLen; i4++) {\n          const num4 = nums[i4];\n          if (set.has(i4)) continue;\n          for (let o1 = 0; o1 < opLen; o1++) {\n            const op1 = op[o1];\n            for (let o2 = 0; o2 < opLen; o2++) {\n              const op2 = op[o2];\n              for (let o3 = 0; o3 < opLen; o3++) {\n                const op3 = op[o3];\n                for (const template of getTemplates(num1, num2, num3, num4, op1, op2, op3)) {\n                  const comp = eval(template);\n                  if (comp > 24 - 6e-10 && comp < 24 + 6e-10) return true;\n                }\n              }\n            }\n          }\n        }\n        set.delete(i3);\n      }\n      set.delete(i2);\n    }\n    set.delete(i1);\n  }\n  return false;\n}"},{"date":"2020-08-22","time":108,"memory":43.4,"script":"typescript","desc":"回溯算法。","code":"function judgePoint24(nums: number[]): boolean {\n  if (nums.length === 1) return nums[0] > 24 - 6e-11 && nums[0] < 24 + 6e-10;\n  const len = nums.length;\n  const getCopyArr = () => [...nums];\n  for (let i = 0; i < len; i++) {\n    const num1 = nums[i];\n    for (let j = i + 1; j < len; j++) {\n      const num2 = nums[j];\n      const getArr = (num: number): number[] => {\n        const arr = getCopyArr();\n        arr.splice(j, 1);\n        arr.splice(i, 1);\n        arr.push(num);\n        return arr;\n      };\n      if (\n        judgePoint24(getArr(num1 + num2)) ||\n        judgePoint24(getArr(num1 * num2)) ||\n        judgePoint24(getArr(num1 - num2)) ||\n        judgePoint24(getArr(num2 - num1)) ||\n        judgePoint24(getArr(num1 / num2)) ||\n        judgePoint24(getArr(num2 / num1))\n      )\n        return true;\n    }\n  }\n  return false;\n}"}],"tagList":["数组","数学","回溯"],"level":"Hard"}},{"problemName":"680.验证回文串II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/680.验证回文串II.json","problemData":{"id":"680","name":"680.验证回文串II","url":"https://leetcode.cn/problems/valid-palindrome-ii","desc":"给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。","solutions":[{"date":"2020-02-23","time":116,"memory":42.8,"script":"javascript","desc":"从左右依次递进，遇到不匹配判断进一位是否相同，题目有个问题，发现输入 ac 返回 true。","code":"/**\n * @param {string} s\n * @return {boolean}\n */\nvar validPalindrome = function (s) {\n  let isDel = false;\n  function comp(start, endStart) {\n    if (endStart <= start) return true;\n    while (start < endStart) {\n      if (s[start] !== s[endStart]) {\n        if (isDel) return false;\n        isDel = true;\n        return comp(start + 1, endStart) || comp(start, endStart - 1);\n      }\n      start++;\n      endStart--;\n    }\n    return true;\n  }\n  return comp(0, s.length - 1);\n};"},{"date":"2022-02-18","time":48,"memory":19,"script":"cpp","desc":"双指针遍历。","code":"class Solution {\n   public:\n    bool check(string &s, int l, int r) {\n        while (l < r) {\n            if (s[l] != s[r]) return 0;\n            l++;\n            r--;\n        }\n        return 1;\n    }\n    bool validPalindrome(string s) {\n        int l = 0, r = s.size() - 1;\n        for (int l = 0, r = s.size() - 1; l < r; l++, r--) {\n            if (s[l] == s[r])\n                continue;\n            else\n                return check(s, l, r - 1) || check(s, l + 1, r);\n        }\n        return 1;\n    }\n};"}],"tagList":["贪心","双指针","字符串"],"level":"Easy"}},{"problemName":"682.棒球比赛.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/682.棒球比赛.json","problemData":{"id":"682","name":"682.棒球比赛","url":"https://leetcode.cn/problems/baseball-game","desc":"请你返回记录中所有得分的总和。","solutions":[{"date":"2021-03-19","time":80,"memory":39.9,"script":"typescript","desc":"dfs。","code":"class Solution {\n   public:\n    int calPoints(vector<string> &ops) {\n        vector<int> list;\n        for (auto &op : ops) {\n            int n = list.size();\n            if (op == \"+\") {\n                list.push_back(list[n - 1] + list[n - 2]);\n            } else if (op == \"D\") {\n                list.push_back(list[n - 1] * 2);\n            } else if (op == \"C\") {\n                list.pop_back();\n            } else {\n                list.push_back(stoi(op));\n            }\n        }\n        int ans = 0;\n        for (auto &num : list) ans += num;\n        return ans;\n    }\n};"},{"date":"2022-03-26","time":4,"memory":8.1,"script":"cpp","desc":"dfs。","code":"class Solution {\n   public:\n    int calPoints(vector<string> &ops) {\n        vector<int> list;\n        for (auto &op : ops) {\n            int n = list.size();\n            if (op == \"+\") {\n                list.push_back(list[n - 1] + list[n - 2]);\n            } else if (op == \"D\") {\n                list.push_back(list[n - 1] * 2);\n            } else if (op == \"C\") {\n                list.pop_back();\n            } else {\n                list.push_back(stoi(op));\n            }\n        }\n        int ans = 0;\n        for (auto &num : list) ans += num;\n        return ans;\n    }\n};"},{"script":"python","time":32,"memory":16.43,"desc":"枚举每一个块与另一个块是否位置产生交集。","code":"class Solution:\n    def calPoints(self, operations: List[str]) -> int:\n        s = []\n        for op in operations:\n            if op == '+':\n                s.append(s[-1] + s[-2])\n            elif op == 'D':\n                s.append(s[-1] * 2)\n            elif op == 'C':\n                s.pop()\n            else:\n                s.append(int(op))\n        return sum(s)","date":"2024-07-29"}],"tagList":["栈","数组","模拟"],"level":"Easy"}},{"problemName":"684.冗余连接.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/684.冗余连接.json","problemData":{"id":"684","name":"684.冗余连接","url":"https://leetcode.cn/problems/redundant-connection","desc":"输入一个图，该图由一个有着 N 个节点 (节点值不重复 1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在 1 到 N 中间，这条附加的边不属于树中已存在的边。返回一条可以删去的边，使得结果图是一个有着 N 个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u < v。","solutions":[{"date":"2021-01-13","time":96,"memory":45.3,"script":"typescript","desc":"利用 set 储存遍历结果。","code":"function findRedundantConnection(edges: number[][]): number[] {\n  const map = new Map<number, Set<number>>();\n  let ans: number[][] = [];\n  for (const edge of edges) {\n    const [num1, num2] = edge;\n    const set1 = map.get(num1);\n    const set2 = map.get(num2);\n    if (set1 && set2 && set1 !== set2) {\n      const set = new Set([...set1, ...set2]);\n      set.forEach(v => map.set(v, set));\n    } else if (!set1 && !set2) {\n      const set = new Set([num1, num2]);\n      map.set(num1, set);\n      map.set(num2, set);\n    } else if (!set1 && set2) {\n      set2.add(num1);\n      map.set(num1, set2);\n    } else if (set1 && !set2) {\n      set1.add(num2);\n      map.set(num2, set1);\n    } else {\n      ans.push(edge);\n    }\n  }\n  return ans.pop()!;\n}"},{"date":"2021-04-30","time":92,"memory":40.9,"script":"typescript","desc":"并查集。","code":"class UnionFind {\n  elements: number[];\n  constructor(public size: number) {\n    this.elements = new Array(size).fill(0).map((_, i) => i);\n  }\n  same(v1: number, v2: number): boolean {\n    return this.find(v1) === this.find(v2);\n  }\n  find(v: number): number {\n    return v === this.elements[v] ? v : (this.elements[v] = this.find(this.elements[v]));\n  }\n  union(v1: number, v2: number): void {\n    const e1 = this.find(v1);\n    const e2 = this.find(v2);\n    if (e1 !== e2) {\n      this.elements[e1] = e2;\n      this.size--;\n    }\n  }\n}\nfunction findRedundantConnection(edges: number[][]): number[] {\n  const uf = new UnionFind(edges.length);\n  for (const edge of edges) {\n    const [node1, node2] = edge;\n    if (uf.same(node1, node2)) return edge;\n    uf.union(node1, node2);\n  }\n  return [];\n}"}],"tagList":["深度优先搜索","广度优先搜索","并查集","图"],"level":"Medium"}},{"problemName":"685.冗余连接II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/685.冗余连接II.json","problemData":{"id":"685","name":"685.冗余连接II","url":"https://leetcode.cn/problems/redundant-connection-ii","desc":"在本问题中，有根树指满足以下条件的有向图。返回一条能删除的边，使得剩下的图是有 N 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。","solutions":[{"date":"2020-09-17","time":92,"memory":41.9,"script":"typescript","desc":"[参考连接](https://leetcode-cn.com/problems/redundant-connection-ii/solution/rong-yu-lian-jie-ii-by-leetcode-solution/)。","code":"class UnionFind {\n  ancestor: number[];\n  constructor(n: number) {\n    this.ancestor = new Array(n).fill(0).map((_, i) => i);\n  }\n  find(index: number): number {\n    return index === this.ancestor[index]\n      ? index\n      : (this.ancestor[index] = this.find(this.ancestor[index]));\n  }\n  union(u: number, v: number): void {\n    this.ancestor[this.find(u)] = this.find(v);\n  }\n}\nfunction findRedundantDirectedConnection(edges: number[][]): number[] {\n  const nodeCount = edges.length;\n  const uf = new UnionFind(nodeCount + 1);\n  const parent: number[] = new Array(nodeCount + 1).fill(0).map((_, i) => i);\n  let conflict = -1;\n  let cycle = -1;\n  for (let i = 0; i < nodeCount; i++) {\n    const [node1, node2] = edges[i];\n    if (parent[node2] !== node2) {\n      conflict = i;\n    } else {\n      parent[node2] = node1;\n      if (uf.find(node1) === uf.find(node2)) {\n        cycle = i;\n      } else {\n        uf.union(node1, node2);\n      }\n    }\n  }\n  if (conflict < 0) {\n    return [edges[cycle][0], edges[cycle][1]];\n  } else {\n    const [edge1, edge2] = edges[conflict];\n    return cycle >= 0 ? [parent[edge2], edge2] : [edge1, edge2];\n  }\n}"}],"tagList":["深度优先搜索","广度优先搜索","并查集","图"],"level":"Hard"}},{"problemName":"686.重复叠加字符串匹配.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/686.重复叠加字符串匹配.json","problemData":{"id":"686","name":"686.重复叠加字符串匹配","url":"https://leetcode.cn/problems/repeated-string-match","desc":"给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。","solutions":[{"date":"2021-12-22","time":72,"memory":39.5,"script":"cpp","desc":"判断最大重复次数是否满足 b。","code":"function repeatedStringMatch(a: string, b: string): number {\n          let cnt = Math.ceil(b.length / a.length);\n          if (a.repeat(cnt).includes(b)) return cnt;\n          if (a.repeat(cnt + 1).includes(b)) return cnt + 1;\n          return -1;\n        }"}],"tagList":["字符串","字符串匹配"],"level":"Medium"}},{"problemName":"687.最长同值路径.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/687.最长同值路径.json","problemData":{"id":"687","name":"687.最长同值路径","url":"https://leetcode.cn/problems/longest-univalue-path","desc":"给定一个二叉树的 root ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。","solutions":[{"date":"2022-09-02","time":84,"memory":49.9,"script":"cpp","desc":"递归,每次记录以根结点起的最长链路和子节点的最长内部链路。","code":"#define MAX(a, b) ((a) > (b) ? (a) : (b))\nint longestUnivaluePath(struct TreeNode *root){\n    if (!root) return 0;\n    int ans = 0;\n    _longestUnivaluePath(root, &ans);\n    return ans - 1;\n}\nint _longestUnivaluePath(struct TreeNode *root, int *ans) {\n    if (!root) return 0;\n    int cnt1 = 1, cnt2 = 1,\n        left = _longestUnivaluePath(root->left, ans),\n        right = _longestUnivaluePath(root->right, ans);\n    if (root->left && root->left->val == root->val) cnt1 = MAX(cnt1, 1 + left), cnt2 += left;\n    if (root->right && root->right->val == root->val) cnt1 = MAX(cnt1, 1 + right), cnt2 += right;\n    *ans = MAX(*ans, cnt1);\n    *ans = MAX(*ans, cnt2);\n    return cnt1;\n}"}],"tagList":["树","深度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"688.骑士在棋盘上的概率.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/688.骑士在棋盘上的概率.json","problemData":{"id":"688","name":"688.骑士在棋盘上的概率","url":"https://leetcode.cn/problems/knight-probability-in-chessboard","desc":"返回 骑士在棋盘停止移动后仍留在棋盘上的概率 。","solutions":[{"date":"2022-02-17","time":0,"memory":5.8,"script":"cpp","desc":"动态规划，统计每个点的概率。","code":"int dirs[8][2] = {{-1, -2}, {-1, 2}, {-2, -1}, {-2, 1},\n          {1, 2},   {1, -2}, {2, 1},   {2, -1}};\nclass Solution {\n  public:\n   double knightProbability(int n, int k, int row, int column) {\n       double table[2][n][n], ans = 0;\n       memset(table, 0, sizeof(double) * 2 * n * n);\n       table[0][row][column] = 1;\n       for (int i = 0; i < k; i++) {\n           int idx = i & 1, nidx = (i + 1) & 1;\n           memset(table[nidx], 0, sizeof(double) * n * n);\n           for (int row = 0; row < n; row++) {\n               for (int col = 0; col < n; col++) {\n                   if (table[idx][row][col] == 0) continue;\n                   for (int next = 0; next < 8; next++) {\n                       int nrow = row + dirs[next][0],\n                           ncol = col + dirs[next][1];\n                       if (nrow < 0 || nrow >= n || ncol < 0 || ncol >= n)\n                           continue;\n                       table[nidx][nrow][ncol] +=\n                           1.0 / 8 * table[idx][row][col];\n                   }\n               }\n           }\n       }\n       for (int row = 0; row < n; row++) {\n           for (int col = 0; col < n; col++) {\n               if (table[k & 1][row][col]) ans += table[k & 1][row][col];\n           }\n       }\n       return ans;\n   }\n};"}],"tagList":["动态规划"],"level":"Medium"}},{"problemName":"689.三个无重叠子数组的最大和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/689.三个无重叠子数组的最大和.json","problemData":{"id":"689","name":"689.三个无重叠子数组的最大和","url":"https://leetcode.cn/problems/maximum-sum-of-3-non-overlapping-subarrays","desc":"给你一个整数数组 nums 和一个整数 k ，找出三个长度为 k 、互不重叠、且 3 \\* k 项的和最大的子数组，并返回这三个子数组。","solutions":[{"date":"2021-12-08","time":80,"memory":42,"script":"typescript","desc":"滑动窗口，记录每次的最大值比较。","code":"function maxSumOfThreeSubarrays(nums: number[], k: number): number[] {\n  const n = nums.length;\n  let sum1 = 0,\n    max1 = 0,\n    idx1 = 0;\n  let sum2 = 0,\n    max2 = 0,\n    idx2 = 0,\n    idx2_1 = 0,\n    idx2_2 = 0;\n  let sum3 = 0,\n    max3 = 0,\n    idx3 = 0;\n  let idx = 0;\n  idx1 = idx;\n  for (let i = idx, end = idx + k; i < end; i++, idx++) max1 = sum1 += nums[i];\n  idx2_2 = idx2 = idx;\n  for (let i = idx, end = idx + k; i < end; i++, idx++) max2 = max1 + (sum2 += nums[i]);\n  idx3 = idx;\n  for (let i = idx, end = idx + k; i < end; i++, idx++) max3 = max2 + (sum3 += nums[i]);\n  const ans = [idx1, idx2, idx3];\n  for (; idx < n; idx++) {\n    sum1 = sum1 + nums[idx - 2 * k] - nums[idx - 3 * k];\n    sum2 = sum2 + nums[idx - 1 * k] - nums[idx - 2 * k];\n    sum3 = sum3 + nums[idx - 0 * k] - nums[idx - 1 * k];\n    if (max1 < sum1) {\n      max1 = sum1;\n      idx1 = idx - 3 * k + 1;\n    }\n    if (max2 < max1 + sum2) {\n      max2 = max1 + sum2;\n      idx2 = idx - 2 * k + 1;\n      idx2_1 = idx1;\n      idx2_2 = idx2;\n    }\n    if (max3 < max2 + sum3) {\n      max3 = max2 + sum3;\n      idx3 = idx - 1 * k + 1;\n      ans[0] = idx2_1;\n      ans[1] = idx2_2;\n      ans[2] = idx3;\n    }\n  }\n  return ans;\n}"},{"script":"python","time":100,"memory":24.2,"desc":"dp[i]表示以当前为最后一个数组时的最大值。","code":"class Solution:\n    def maxSumOfThreeSubarrays(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n\n        sums = [0]\n        for num in nums: sums.append(num + sums[-1])\n\n        dp1 = [(0, 0)] * (n + 1)\n        for i in range(0, n - k + 1):\n            if dp1[i][0] < sums[i + k] - sums[i]:\n                dp1[i + 1] = (sums[i + k] - sums[i], i)\n            else:\n                dp1[i + 1] = dp1[i]\n\n        dp2 = [(0, 0, 0)] * (n + 1)\n        for i in range(k, n - k + 1):\n            if dp2[i][0] < sums[i + k] - sums[i] + dp1[i - k + 1][0]:\n                dp2[i + 1] = (sums[i + k] - sums[i] + dp1[i - k + 1][0], dp1[i - k + 1][1], i)\n            else:\n                dp2[i + 1] = dp2[i]\n\n        dp3 = [(0, 0, 0, 0)] * (n + 1)\n        for i in range(k * 2, n - k + 1):\n            if dp3[i][0] < sums[i + k] - sums[i] + dp2[i - k + 1][0]:\n                dp3[i + 1] = (sums[i + k] - sums[i] + dp2[i - k + 1][0], dp2[i - k + 1][1], dp2[i - k + 1][2], i)\n            else:\n                dp3[i + 1] = dp3[i]\n\n        return dp3[n - k + 1][1:]","date":"2023-11-19"}],"tagList":["数组","动态规划"],"level":"Hard"}},{"problemName":"690.员工的重要性.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/690.员工的重要性.json","problemData":{"id":"690","name":"690.员工的重要性","url":"https://leetcode.cn/problems/employee-importance","desc":"现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。","solutions":[{"date":"2021-05-01","time":80,"memory":42.2,"script":"typescript","desc":"哈希表储存。","code":"function GetImportance(employees: Employee[], id: number): number {\n  const map = employees.reduce((map, emp) => {\n    map.set(emp.id, emp);\n    return map;\n  }, new Map<number, Employee>());\n  const find = (id: number): number => {\n    const emp = map.get(id)!;\n    return (\n      emp.importance + emp.subordinates.map(id => find(id)).reduce((total, cur) => total + cur, 0)\n    );\n  };\n  return find(id);\n}"}],"tagList":["树","深度优先搜索","广度优先搜索","数组","哈希表"],"level":"Medium"}},{"problemName":"692.前K个高频单词.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/692.前K个高频单词.json","problemData":{"id":"692","name":"692.前K个高频单词","url":"https://leetcode.cn/problems/top-k-frequent-words","desc":"给一非空的单词列表，返回前 k 个出现次数最多的单词。","solutions":[{"date":"2021-04-09","time":144,"memory":44.6,"script":"typescript","desc":"构建堆。","code":"class Heap<T> {\n  private arr: T[] = [];\n  get isEmpty() {\n    return this.size === 0;\n  }\n  get size() {\n    return this.arr.length;\n  }\n  get top() {\n    return this.arr[0];\n  }\n  constructor(private compare: (num1: T, num2: T) => number) {}\n  add(num: T): void {\n    this.arr.push(num);\n    this.shiftUp(this.size - 1);\n  }\n  remove(): T {\n    const num = this.arr.shift()!;\n    if (this.size) {\n      this.arr.unshift(this.arr.pop()!);\n      this.shiftDown(0);\n    }\n    return num;\n  }\n  private shiftUp(index: number): void {\n    if (index === 0) return;\n    const parentIndex = (index - 1) >> 1;\n    if (this.compare(this.arr[index], this.arr[parentIndex]) > 0) {\n      [this.arr[index], this.arr[parentIndex]] = [this.arr[parentIndex], this.arr[index]];\n      this.shiftUp(parentIndex);\n    }\n  }\n  private shiftDown(index: number): void {\n    let childrenIndex = index * 2 + 1;\n    if (childrenIndex > this.size - 1) return;\n    if (\n      childrenIndex + 1 <= this.size - 1 &&\n      this.compare(this.arr[childrenIndex + 1], this.arr[childrenIndex]) > 0\n    ) {\n      childrenIndex++;\n    }\n    if (this.compare(this.arr[childrenIndex], this.arr[index]) > 0) {\n      [this.arr[childrenIndex], this.arr[index]] = [this.arr[index], this.arr[childrenIndex]];\n      this.shiftDown(childrenIndex);\n    }\n  }\n}\nfunction topKFrequent(words: string[], k: number): string[] {\n  const map: Record<string, number> = {};\n  for (const word of words) map[word] = (map[word] ?? 0) + 1;\n  const strCheck = (str1: string, str2: string) => {\n    let i = 0;\n    while (str1[i] && str1[i] === str2[i]) i++;\n    if (str1[i] && !str2[i]) return -1;\n    else if (!str1[i] && str2[i]) return 1;\n    else return str2.codePointAt(i)! - str1.codePointAt(i)!;\n  };\n  const heap = new Heap<[string, number]>(([str1, v1], [str2, v2]) =>\n    v1 === v2 ? strCheck(str1, str2) : v1 - v2\n  );\n  Object.entries(map).forEach(v => heap.add(v));\n  const ans: string[] = [];\n  while (heap.size && k--) {\n    ans.push(heap.remove()[0]);\n  }\n  return ans;\n}"},{"date":"2021-05-20","time":132,"memory":44.3,"script":"typescript","desc":"利用堆去获取。","code":"class Heap<T = number> {\n  private arr: T[] = [];\n  get isEmpty() {\n    return this.size === 0;\n  }\n  get size() {\n    return this.arr.length;\n  }\n  get top() {\n    return this.arr[0];\n  }\n  constructor(private compare: (t1: T, t2: T) => number) {}\n  add(num: T): void {\n    this.arr.push(num);\n    this.shiftUp(this.size - 1);\n  }\n  remove(): T {\n    const num = this.arr.shift()!;\n    if (this.size) {\n      this.arr.unshift(this.arr.pop()!);\n      this.shiftDown(0);\n    }\n    return num;\n  }\n  private shiftUp(index: number): void {\n    if (index === 0) return;\n    const parentIndex = (index - 1) >> 1;\n    if (this.compare(this.arr[index], this.arr[parentIndex]) > 0) {\n      [this.arr[index], this.arr[parentIndex]] = [this.arr[parentIndex], this.arr[index]];\n      this.shiftUp(parentIndex);\n    }\n  }\n  private shiftDown(index: number): void {\n    let childrenIndex = index * 2 + 1;\n    if (childrenIndex > this.size - 1) return;\n    if (\n      childrenIndex + 1 <= this.size - 1 &&\n      this.compare(this.arr[childrenIndex + 1], this.arr[childrenIndex]) > 0\n    ) {\n      childrenIndex++;\n    }\n    if (this.compare(this.arr[childrenIndex], this.arr[index]) > 0) {\n      [this.arr[childrenIndex], this.arr[index]] = [this.arr[index], this.arr[childrenIndex]];\n      this.shiftDown(childrenIndex);\n    }\n  }\n  *[Symbol.iterator](): IterableIterator<T> {\n    for (const t of this.arr) {\n      yield t;\n    }\n  }\n}\nfunction topKFrequent(words: string[], k: number): string[] {\n  const map: Record<string, number> = {};\n  for (const word of words) map[word] = (map[word] ?? 0) + 1;\n  const chartToNumber = (char: string) => char.codePointAt(0)! - 'a'.codePointAt(0)!;\n  const heap = new Heap<[string, number]>(([k1, v1], [k2, v2]) => {\n    if (v1 !== v2) return v1 - v2;\n    let i1 = 0;\n    const end1 = k1.length;\n    let i2 = 0;\n    const end2 = k2.length;\n    for (; i1 < end1 && i2 < end2; i1++, i2++)\n      if (k1[i1] !== k2[i2]) return chartToNumber(k2[i2]) - chartToNumber(k1[i1]);\n    if (i1 === end1) return 1;\n    else if (i2 === end2) return -1;\n    else return 0;\n  });\n  for (const data of Object.entries(map)) heap.add(data);\n  const ans: string[] = [];\n  while (heap.size !== 0 && k--) ans.push(heap.remove()[0]);\n  return ans;\n}"}],"tagList":["字典树","哈希表","字符串","桶排序","计数","排序","堆（优先队列）"],"level":"Medium"}},{"problemName":"693.交替位二进制数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/693.交替位二进制数.json","problemData":{"id":"693","name":"693.交替位二进制数","url":"https://leetcode.cn/problems/binary-number-with-alternating-bits","desc":"给你一个表示图像灰度的 m x n 整数矩阵 img ，返回对图像的每个单元格平滑处理后的图像 。","solutions":[{"date":"2022-03-16","time":0,"memory":5.8,"script":"cpp","desc":"遍历每一位。","code":"class Solution {\n   public:\n    bool hasAlternatingBits(int n) {\n        bool check = (n & 1) == 0;\n        for (n >>= 1; n; n >>= 1, check = !check) {\n            if ((n & 1) == 0) {\n                if (check) return false;\n            } else {\n                if (!check) return false;\n            }\n        }\n        return true;\n    }\n};"},{"date":"2022-03-28","time":0,"memory":5.9,"script":"typescript","desc":"遍历。","code":"class Solution {\n   public:\n    bool hasAlternatingBits(int n) {\n        bool f = n & 1;\n        for (; n; f ^= 1, n >>= 1) {\n            if ((n & 1) != f) return false;\n        }\n        return true;\n    }\n};"}],"tagList":["位运算"],"level":"Easy"}},{"problemName":"696.计数二进制子串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/696.计数二进制子串.json","problemData":{"id":"696","name":"696.计数二进制子串","url":"https://leetcode.cn/problems/count-binary-substrings","desc":"给定一个字符串 s，计算具有相同数量 0 和 1 的非空(连续)子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是组合在一起的。","solutions":[{"date":"2020-08-10","time":96,"memory":44.5,"script":"typescript","desc":"遍历后获取每次 0 或 1 同时出现的次数。","code":"function countBinarySubstrings(s: string): number {\n  const arr: number[] = [];\n  let count = 0;\n  let prev = '';\n  for (const c of s) {\n    if (c !== prev) {\n      arr.push(count);\n      count = 1;\n    } else {\n      count++;\n    }\n    prev = c;\n  }\n  arr.push(count);\n  let ans = 0;\n  for (let i = 0, l = arr.length; i < l - 1; i++) {\n    const num1 = arr[i];\n    const num2 = arr[i + 1];\n    ans += Math.min(num1, num2);\n  }\n  return ans;\n}"}],"tagList":["双指针","字符串"],"level":"Easy"}},{"problemName":"697.数组的度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/697.数组的度.json","problemData":{"id":"697","name":"697.数组的度","url":"https://leetcode.cn/problems/degree-of-an-array","desc":"给定一个非空且只包含非负数的整数数组  nums，数组的度的定义是指数组里任一元素出现频数的最大值。你的任务是在 nums 中找到与  nums  拥有相同大小的度的最短连续子数组，返回其长度。","solutions":[{"date":"2021-02-20","time":208,"memory":45.3,"script":"typescript","desc":"读取到度后直接取头尾进行判断。","code":"function findShortestSubArray(nums: number[]): number {\n  const map = new Map<number, number>();\n  nums.forEach(num => map.set(num, 1 + (map.get(num) ?? 0)));\n  const degreeValue = Math.max(...map.values());\n  const degreeList = [];\n  for (const [k, v] of map) v === degreeValue && degreeList.push(k);\n  return Math.min(...degreeList.map(num => nums.lastIndexOf(num) - nums.indexOf(num) + 1));\n}"},{"date":"2021-02-20","time":104,"memory":46.3,"script":"typescript","desc":"优化题解 1。","code":"function findShortestSubArray(nums: number[]): number {\n  const indexMap = new Map<number, [number, number]>();\n  const computeIndex = (num: number) => {\n    const [start, end] = indexMap.get(num)!;\n    return end - start + 1;\n  };\n  const map = new Map<number, number>();\n  for (let i = 0, len = nums.length; i < len; i++) {\n    const num = nums[i];\n    map.set(num, 1 + (map.get(num) ?? 0));\n    const indexes = indexMap.get(num);\n    if (indexes) {\n      indexes[1] = i;\n    } else {\n      indexMap.set(num, [i, i]);\n    }\n  }\n  const degreeValue = Math.max(...map.values());\n  const degreeList = [];\n  for (const [k, v] of map) v === degreeValue && degreeList.push(k);\n  return Math.min(...degreeList.map(num => computeIndex(num)));\n}"},{"date":"2021-02-20","time":100,"memory":44.4,"script":"typescript","desc":"优化题解 1。","code":"function findShortestSubArray(nums: number[]): number {\n  const map: Record<number, [number, number, number]> = {};\n  nums.forEach((num, i) => {\n    const data = map[num];\n    if (data) {\n      data[0]++;\n      data[2] = i;\n    } else {\n      map[num] = [1, i, i];\n    }\n  });\n  const data = Object.values(map);\n  const degreeValue = Math.max(...data.map(([c]) => c));\n  return Math.min(\n    ...data.filter(([c]) => c === degreeValue).map(([, start, end]) => end - start + 1)\n  );\n}"}],"tagList":["数组","哈希表"],"level":"Easy"}},{"problemName":"698.划分为k个相等的子集.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/698.划分为k个相等的子集.json","problemData":{"id":"698","name":"698.划分为k个相等的子集","url":"https://leetcode.cn/problems/partition-to-k-equal-sum-subsets","desc":"给定一个整数数组 nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。","solutions":[{"date":"2022-09-20","time":4,"memory":9,"script":"cpp","desc":"构造 k 个桶进行回溯+剪枝。","code":"class Solution {\npublic:\n    bool canPartitionKSubsets(vector<int>& nums, int k) {\n        sort(nums.rbegin(), nums.rend());\n        int sum = accumulate(nums.begin(), nums.end(), 0);\n        if (sum % k != 0) return false; else sum /= k;\n        vector<int> list(k, 0);\n        return dfs(nums, list, sum, 0);\n    }\n    bool dfs(vector<int> &nums, vector<int> &list, int sum, int i) {\n        if (i == nums.size()) {\n            for (auto &item : list) if (item != sum) return false;\n            return true;\n        }\n        for (int j = 0; j < list.size(); j++) {\n            if (list[j] + nums[i] > sum || j && list[j - 1] == list[j]) continue;\n            list[j] += nums[i];\n            if (dfs(nums, list, sum, i + 1)) return true;\n            list[j] -= nums[i];\n        }\n        return false;\n    }\n};"}],"tagList":["位运算","记忆化搜索","数组","动态规划","回溯","状态压缩"],"level":"Medium"}},{"problemName":"699.掉落的方块.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/699.掉落的方块.json","problemData":{"id":"699","name":"699.掉落的方块","url":"https://leetcode.cn/problems/falling-squares","desc":"在每个方块掉落后，你必须记录目前所有已经落稳的 方块堆叠的最高高度 。返回一个整数数组 ans ，其中 ans[i] 表示在第 i 块方块掉落后堆叠的最高高度。","solutions":[{"script":"python","time":407,"memory":16.72,"desc":"枚举每一个块与另一个块是否位置产生交集。","code":"class Solution:\n    def fallingSquares(self, positions: List[List[int]]) -> List[int]:\n        n = len(positions)\n        harr = [0] * n\n        maxh = 0\n        res = []\n        for i in range(n):\n            l1, h1 = positions[i]\n            harr[i] = h1\n            for j in range(i):\n                l2, h2 = positions[j]\n                if l1 + h1 - 1 >= l2 and l2 + h2 - 1 >= l1:\n                    harr[i] = max(harr[i], harr[j] + h1)\n            maxh = max(maxh, harr[i])\n            res.append(maxh)\n        return res","date":"2024-07-28"}],"tagList":["线段树","数组","有序集合"],"level":"Hard"}},{"problemName":"700.二叉搜索树中的搜索.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/601-700/700.二叉搜索树中的搜索.json","problemData":{"id":"783","name":"700.二叉搜索树中的搜索","url":"https://leetcode.cn/problems/search-in-a-binary-search-tree","desc":"给定二叉搜索树（BST）的根节点和一个值。 你需要在 BST 中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。","solutions":[{"date":"2020-02-23","time":0,"memory":41.5,"script":"java","desc":"遍历判断，根据 bst 的原理进行二分搜索。","code":"class Solution {\n\tpublic TreeNode searchBST(TreeNode root, int val) {\n\t\tif (root == null)\n\t\t\treturn null;\n\t\tif (root.val == val)\n\t\t\treturn root;\n\t\twhile (root != null && root.val != val) {\n\t\t\tif (val > root.val)\n\t\t\t\troot = root.right;\n\t\t\telse if (val < root.val)\n\t\t\t\troot = root.left;\n\t\t}\n\t\treturn root;\n\t}\n}"},{"date":"2021-11-26","time":108,"memory":44.7,"script":"typescript","desc":"递归。","code":"function searchBST(root: TreeNode | null, val: number): TreeNode | null {\n  if (root === null) return null;\n  if (root.val === val) return root;\n  if (root.val > val) return searchBST(root.left, val);\n  else return searchBST(root.right, val);\n}"},{"date":"2021-11-26","time":28,"memory":14.9,"script":"c","desc":"递归。","code":"struct TreeNode* searchBST(struct TreeNode* root, int val){\n    if (!root) return NULL;\n    if (root->val == val) return root;\n    if (root->val > val) return searchBST(root->left, val);\n    else return searchBST(root->right, val);\n}"}],"tagList":["树","二叉搜索树","二叉树"],"level":"Easy"}}]},{"dirName":"701-800","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\701-800","problems":[{"problemName":"701.二叉搜索树中的插入操作.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/701.二叉搜索树中的插入操作.json","problemData":{"id":"784","name":"701.二叉搜索树中的插入操作","url":"https://leetcode.cn/problems/insert-into-a-binary-search-tree","desc":"给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 保证原始二叉搜索树中不存在新值。注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。","solutions":[{"date":"2020-02-23","time":0,"memory":41.8,"script":"java","desc":"二分查找，若判断小则查找左节点，大则查找右节点，如果 null 则赋值。","code":"class Solution {\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n    \tif(root==null)return new TreeNode(val);\n    \tTreeNode node = root;\n    \twhile(node.val!=val) {\n    \t\tif(val>node.val) {\n    \t\t\tif(node.right==null) {\n    \t\t\t\tnode.right=new TreeNode(val);\n    \t\t\t\tbreak;\n    \t\t\t}else {\n    \t\t\t\tnode=node.right;\n    \t\t\t}\n    \t\t}else if(val<node.val){\n    \t\t\tif(node.left==null) {\n    \t\t\t\tnode.left=new TreeNode(val);\n    \t\t\t\tbreak;\n    \t\t\t}else {\n    \t\t\t\tnode=node.left;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn root;\n    }\n}"},{"date":"2020-09-30","time":128,"memory":45.7,"script":"typescript","desc":"递归。","code":"function insertIntoBST(root: TreeNode | null, val: number): TreeNode | null {\n  if (root === null) return new TreeNode(val);\n  const v = root.val;\n  if (v > val) {\n    if (root.left === null) {\n      root.left = new TreeNode(val);\n    } else {\n      insertIntoBST(root.left, val);\n    }\n  } else {\n    if (root.right === null) {\n      root.right = new TreeNode(val);\n    } else {\n      insertIntoBST(root.right, val);\n    }\n  }\n  return root;\n}"}],"tagList":["树","二叉搜索树","二叉树"],"level":"Medium"}},{"problemName":"704.二分查找.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/704.二分查找.json","problemData":{"id":"792","name":"704.二分查找","url":"https://leetcode.cn/problems/binary-search","desc":"返回可以通过分割得到的平衡字符串的 最大数量 。","solutions":[{"date":"2021-09-07","time":64,"memory":39.7,"script":"typescript","desc":"遍历，判断 rl 相等时。","code":"function balancedStringSplit(s: string): number {\n  let r = 0;\n  let l = 0;\n  let ans = 0;\n  for (const c of s) {\n    if (c === 'R') r++;\n    if (c === 'L') l++;\n    if (r === l) {\n      ans++;\n      r = l = 0;\n    }\n  }\n  return ans;\n}"}],"tagList":["数组","二分查找"],"level":"Easy"}},{"problemName":"705.设计哈希集合.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/705.设计哈希集合.json","problemData":{"id":"816","name":"705.设计哈希集合","url":"https://leetcode.cn/problems/design-hashset","desc":"设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。","solutions":[{"date":"2021-07-24","time":176,"memory":54,"script":"typescript","desc":"哈希链表。","code":"class LNode {\n  constructor(\n    public key: number,\n    public value: number,\n    public prev: LNode | null = null,\n    public next: LNode | null = null\n  ) {}\n  remove() {\n    if (this.prev) this.prev.next = this.next;\n    if (this.next) this.next.prev = this.prev;\n  }\n}\nclass HashLinkedList {\n  private head = new LNode(0, 0);\n  private last: LNode = this.head;\n  private map = new Map<number, LNode>();\n  private count = 0;\n  constructor(private capacity: number) {}\n  get(key: number): number {\n    const node = this.map.get(key);\n    if (!node) return -1;\n    this.moveLast(node);\n    return node.value;\n  }\n  put(key: number, value: number): void {\n    let node = this.map.get(key);\n    if (!node) {\n      this.map.set(key, (node = new LNode(key, value, this.last)));\n      this.last.next = node;\n      this.last = node;\n      if (++this.count > this.capacity) {\n        const first = this.head.next!;\n        this.map.delete(first.key);\n        this.head.next = first.next!;\n        first.next!.prev = this.head;\n      }\n    } else {\n      node.value = value;\n      this.moveLast(node);\n    }\n  }\n  private moveLast(node: LNode) {\n    if (this.last === node) return;\n    node.remove();\n    node.prev = this.last;\n    this.last.next = node;\n    node.next = null;\n    this.last = node;\n  }\n}\nclass LRUCache {\n  private list: HashLinkedList;\n  constructor(capacity: number) {\n    this.list = new HashLinkedList(capacity);\n  }\n  get(key: number): number {\n    return this.list.get(key);\n  }\n  put(key: number, value: number): void {\n    this.list.put(key, value);\n  }\n}"},{"script":"python","time":94,"memory":22.09,"desc":"哈希存储。","code":"class MyHashSet:\n    def __init__(self):\n        self.set = set()\n    def add(self, key: int) -> None:\n        self.set.add(key)\n    def remove(self, key: int) -> None:\n        if self.contains(key):\n            self.set.remove(key)\n    def contains(self, key: int) -> bool:\n        return key in self.set","date":"2024-04-14"},{"script":"python","time":217,"memory":43.05,"desc":"利用bitmap存储。","code":"class BitMap:\n    def __init__(self, n: int):\n        self.size = 64\n        self.buckets = [0] * n\n    def add(self, key: int):\n        self.set(key // self.size, key % self.size, True)\n    def remove(self, key: int):\n        self.set(key // self.size, key % self.size, False)\n    def contains(self, key: int):\n        return self.get(key // self.size, key % self.size)\n    def set(self, bucket: int, loc: int, val: bool):\n        if val:\n            self.buckets[bucket] |= 1 << loc\n        else:\n            self.buckets[bucket] = self.buckets[bucket] & ~(1 << loc)\n    def get(self, bucket: int, loc: int):\n        return bool((self.buckets[bucket] >> loc) & 1)\n    \nclass MyHashSet:\n    def __init__(self):\n        self.bm = BitMap(10 ** 6 + 1)\n    def add(self, key: int) -> None:\n        self.bm.add(key)\n    def remove(self, key: int) -> None:\n        self.bm.remove(key)\n    def contains(self, key: int) -> bool:\n        return self.bm.contains(key)","date":"2024-04-14"}],"tagList":["设计","数组","哈希表","链表","哈希函数"],"level":"Easy"}},{"problemName":"706.设计哈希映射.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/706.设计哈希映射.json","problemData":{"id":"817","name":"706.设计哈希映射","url":"https://leetcode.cn/problems/design-hashmap","desc":"不使用任何内建的哈希表库设计一个哈希映射（HashMap）。","solutions":[{"date":"2021-07-24","time":204,"memory":48.8,"script":"typescript","desc":"利用链表解决哈希冲突。","code":"class LinkedListNode {\n  constructor(\n    public val: [number, number],\n    public prev: LinkedListNode | null = null,\n    public next: LinkedListNode | null = null\n  ) {}\n}\nclass LinkedList {\n  private head = new LinkedListNode([0, 0]);\n  private last: LinkedListNode | null = null;\n  private getNode(key: number): LinkedListNode | null {\n    let p: LinkedListNode = this.head;\n    while (p.next) {\n      if (p.next.val[0] === key) return p;\n      p = p.next;\n    }\n    return null;\n  }\n  contains(key: number): boolean {\n    return this.getNode(key) !== null;\n  }\n  put(key: number, value: number): void {\n    let node = this.getNode(key);\n    if (node !== null) {\n      node.next!.val[1] = value;\n      return;\n    }\n    node = new LinkedListNode([key, value]);\n    if (this.last === null) this.head.next = node;\n    else this.last.next = node;\n    this.last = node;\n  }\n  get(key: number): number {\n    const node = this.getNode(key);\n    if (node === null) return -1;\n    return node.next!.val[1];\n  }\n  remove(key: number): void {\n    const node = this.getNode(key);\n    if (node === null) return;\n    if (this.last === node.next) this.last = node;\n    node.next = node.next!.next;\n  }\n}\nconst SIZE = 1000;\nclass MyHashMap {\n  private list = new Array(SIZE).fill(0).map(_ => new LinkedList());\n  private hash(key: number) {\n    return key % SIZE;\n  }\n  put(key: number, value: number): void {\n    this.list[this.hash(key)].put(key, value);\n  }\n  get(key: number): number {\n    return this.list[this.hash(key)].get(key);\n  }\n  remove(key: number): void {\n    return this.list[this.hash(key)].remove(key);\n  }\n}"},{"script":"python","time":112,"memory":19.11,"desc":"map。","code":"class MyHashMap:\n    def __init__(self):\n        self.map = {}\n    def put(self, key: int, value: int) -> None:\n        self.map[key] = value\n    def get(self, key: int) -> int:\n        return self.map[key] if key in self.map else -1\n    def remove(self, key: int) -> None:\n        if key in self.map:\n            del self.map[key]\n","date":"2024-04-15"},{"script":"python","time":422,"memory":64.12,"desc":"利用双数组存键值对。","code":"class MyHashMap:\n    def __init__(self):\n        self.iarr = [False] * (10 ** 6 + 1)\n        self.varr = [-1] * (10 ** 6 + 1)\n    def put(self, key: int, value: int) -> None:\n        self.iarr[key] = True\n        self.varr[key] = value\n    def get(self, key: int) -> int:\n        return self.varr[key] if self.iarr[key] else -1\n    def remove(self, key: int) -> None:\n        self.iarr[key] = False","date":"2024-04-15"}],"tagList":["设计","数组","哈希表","链表","哈希函数"],"level":"Easy"}},{"problemName":"707.设计链表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/707.设计链表.json","problemData":{"id":"838","name":"707.设计链表","url":"https://leetcode.cn/problems/design-linked-list","desc":"设计链表的实现。","solutions":[{"date":"2022-09-23","time":36,"memory":19.2,"script":"cpp","desc":"构造链表。","code":"class Node {\npublic:\n    Node *next;\n    int val;\n    Node(int val): Node(val, nullptr) {}\n    Node(int val, Node *next): val(val), next(next) {}\n};\nclass MyLinkedList {\npublic:\n    int size;\n    Node *head, *tail;\n    MyLinkedList(): head(nullptr), tail(nullptr), size(0) {}\n    int get(int index) {\n        if (index < 0 || index >= size) return -1;\n        Node *p = head;\n        while (index--) p = p->next;\n        return p->val;\n    }\n    void addAtHead(int val) {\n        if (size == 0) return addFirst(val);\n        head = new Node(val, head);\n        size++;\n    }\n    void addAtTail(int val) {\n        if (size == 0) return addFirst(val);\n        Node *node = new Node(val);\n        tail->next = node;\n        tail = node;\n        size++;\n    }\n    void addAtIndex(int index, int val) {\n        if (index < 0 || index > size) return;\n        if (index == 0) return addAtHead(val);\n        if (index == size) return addAtTail(val);\n        Node *p = head;\n        while (--index) p = p->next;\n        Node *node = new Node(val, p->next);\n        p->next = node;\n        size++;\n    }\n    void deleteAtIndex(int index) {\n        if (index < 0 || index >= size) return;\n        if (size == 1) {\n            delete head;\n            head = tail = nullptr;\n        } else if (index == 0) {\n            Node *node = head;\n            head = head->next;\n            delete node;\n        } else {\n            bool isTail = index == size - 1;\n            Node *p = head;\n            while (--index) p = p->next;\n            Node *node = p->next;\n            p->next = node->next;\n            if (isTail) tail = p;\n            delete node;\n        }\n        size--;\n    }\n    void addFirst(int val){\n        head = tail = new Node(val);\n        size++;\n    }\n};"}],"tagList":["设计","链表"],"level":"Medium"}},{"problemName":"709.转换成小写字母.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/709.转换成小写字母.json","problemData":{"id":"742","name":"709.转换成小写字母","url":"https://leetcode.cn/problems/to-lower-case","desc":"实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。","solutions":[{"date":"2020-02-17","time":0,"memory":40.8,"script":"java","desc":"根据 asc 码如果是大写字母则改变成小写字母。","code":"class Solution {\n\tpublic String toLowerCase(String str) {\n\t\tfor (int i = 0, len = str.length(); i < len; i++) {\n\t\t\tchar c = str.charAt(i);\n\t\t\tif (c >= 65 && c <= 90) {\n\t\t\t\tchar newCh = (char) (c + 32);\n\t\t\t\tstr=str.replace(c, newCh);\n\t\t\t}\n\t\t}\n\t\treturn str;\n\t}\n}"},{"date":"2021-12-12","time":68,"memory":39.5,"script":"typescript","desc":"调用内置函数。","code":"function toLowerCase(s: string): string {\n  return s.toLowerCase();\n}"},{"date":"2021-12-12","time":776,"memory":39.4,"script":"typescript","desc":"转换 ascii。","code":"function toLowerCase(s: string): string {\n  let ans = '';\n  for (let i = 0, n = s.length; i < n; i++) {\n    const num = s.codePointAt(i)!;\n    if (num >= 65 && num <= 90) ans += String.fromCodePoint(num + 32);\n    else ans += s[i];\n  }\n  return ans;\n}"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"710.黑名单中的随机数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/710.黑名单中的随机数.json","problemData":{"id":"894","name":"710.黑名单中的随机数","url":"https://leetcode.cn/problems/random-pick-with-blacklist","desc":"给定一个整数 n 和一个 无重复 黑名单整数数组  blacklist 。设计一种算法，从 [0, n - 1] 范围内的任意整数中选取一个   未加入   黑名单  blacklist  的整数。任何在上述范围内且不在黑名单  blacklist  中的整数都应该有 同等的可能性 被返回。","solutions":[{"date":"2022-06-26","time":112,"memory":68.6,"script":"cpp","desc":"修改随机范围把范围内不可能取到的值映射出去。","code":"class Solution {\n   public:\n    int n;\n    unordered_map<int, int> m;\n    Solution(int n, vector<int> &blacklist) {\n        srand(time(0));\n        int size = blacklist.size(), nextN = n - size;\n        unordered_set<int> s;\n        for (auto &num : blacklist) {\n            if (num >= nextN) s.emplace(num);\n        }\n        int i = nextN;\n        for (auto &num : blacklist) {\n            if (num >= nextN) continue;\n            while (s.count(i)) i++;\n            m[num] = i++;\n        }\n        this->n = nextN;\n    }\n    int pick() {\n        int num = floor(random() % n);\n        return m.count(num) ? m[num] : num;\n    }\n};"}],"tagList":["数组","哈希表","数学","二分查找","排序","随机化"],"level":"Hard"}},{"problemName":"713.乘积小于K的子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/713.乘积小于K的子数组.json","problemData":{"id":"713","name":"713.乘积小于K的子数组","url":"https://leetcode.cn/problems/subarray-product-less-than-k","desc":"请找出该数组内乘积小于 k 的连续的子数组的个数。","solutions":[{"date":"2021-12-24","time":72,"memory":59.8,"script":"cpp","desc":"双指针。","code":"class Solution {\n   public:\n    int numSubarrayProductLessThanK(vector<int>& nums, int k) {\n        if (k == 0) return 0;\n        int n = nums.size(), l = 0, r = 0, num = 1, ans = 0;\n        while (l < n && r <= n) {\n            while (r < n && num < k) num *= nums[r++];\n            ans += r - l - (num >= k ? 1 : 0);\n            num /= nums[l++];\n        }\n        return max(ans, 0);\n    }\n};"},{"date":"2021-12-24","time":49,"memory":59.8,"script":"cpp","desc":"双指针。","code":"class Solution {\n   public:\n    int numSubarrayProductLessThanK(vector<int>& nums, int k) {\n        if (k == 0) return 0;\n        int ans = 0, num = 1, l = 0;\n        for (int r = 0; r < nums.size(); r++) {\n            num *= nums[r];\n            while (l <= r && num >= k) num /= nums[l++];\n            ans += r - l + 1;\n        }\n        return ans;\n    }\n};"},{"date":"2022-05-05","time":76,"memory":9.4,"script":"cpp","desc":"滑动窗口。","code":"int numSubarrayProductLessThanK(int *nums, int numsSize, int k) {\n    int l = 0, r = 0, sum = 1, ans = 0;\n    while (l < numsSize) {\n        while (r < numsSize && sum * nums[r] < k) sum *= nums[r++];\n        if (l == r) {\n            l++;\n            r++;\n        } else {\n            ans += r - l;\n            sum /= nums[l++];\n        }\n    }\n    return ans;\n}"}],"tagList":["数组","滑动窗口"],"level":"Medium"}},{"problemName":"714.买卖股票的最佳时机含手续费.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/714.买卖股票的最佳时机含手续费.json","problemData":{"id":"714","name":"714.买卖股票的最佳时机含手续费","url":"https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee","desc":"给定一个整数数组  prices，其中第  i  个元素代表了第  i  天的股票价格 ；非负整数  fee 代表了交易股票的手续费用。你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。返回获得利润的最大值。","solutions":[{"date":"2020-12-17","time":452,"memory":67.9,"script":"typescript","desc":"动态规划。","code":"function maxProfit(prices: number[], fee: number): number {\n  const len = prices.length;\n  /**\n   * 0 手上无股票\n   * 1 手上有股票\n   */\n  const dp: number[][] = new Array(len).fill(0).map(_ => new Array(2).fill(0));\n  dp[0] = [0, -prices[0]];\n  for (let i = 1; i < len; i++) {\n    dp[i] = [\n      Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee),\n      Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]),\n    ];\n  }\n  return dp[len - 1][0];\n}"},{"date":"2020-12-17","time":116,"memory":48.1,"script":"typescript","desc":"完善题解 1。","code":"function maxProfit(prices: number[], fee: number): number {\n  /**\n   * 0 手上无股票\n   * 1 手上有股票\n   */\n  let price0 = 0;\n  let price1 = -prices[0];\n  for (let i = 1, len = prices.length; i < len; i++) {\n    [price0, price1] = [\n      Math.max(price0, price1 + prices[i] - fee),\n      Math.max(price1, price0 - prices[i]),\n    ];\n  }\n  return price0;\n}\nconsole.log(maxProfit([9, 8, 7, 1, 2], 3));"},{"date":"2021-09-13","time":280,"memory":64.8,"script":"typescript","desc":"动态规划。","code":"function maxProfit(prices: number[], fee: number): number {\n  const n = prices.length;\n  const dp = new Array(n).fill(0).map(_ => new Array(2).fill(0));\n  dp[0][0] = -prices[0];\n  for (let i = 1; i < n; i++) {\n    dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);\n    dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);\n  }\n  return dp[n - 1][1];\n}"},{"date":"2021-09-13","time":108,"memory":47.6,"script":"typescript","desc":"动态规划优化。","code":"function maxProfit(prices: number[], fee: number): number {\n  const n = prices.length;\n  const dp = new Array(2).fill(0).map(_ => new Array(2).fill(0));\n  dp[0][0] = -prices[0];\n  for (let i = 1; i < n; i++) {\n    const idx = i % 2;\n    const preIdx = idx ^ 1;\n    dp[idx][0] = Math.max(dp[preIdx][0], dp[preIdx][1] - prices[i]);\n    dp[idx][1] = Math.max(dp[preIdx][1], dp[preIdx][0] + prices[i] - fee);\n  }\n  return dp[(n - 1) % 2][1];\n}"},{"script":"python","time":516,"memory":28.4,"desc":"同122题。","code":"class Solution:\n    def maxProfit(self, prices: List[int], fee: int) -> int:\n        n = len(prices)\n        # [i][0] i天买， [i][1] i天卖\n        dp = [[-inf for _ in range(2)] for _ in range(n)]\n        dp[0][0] = -prices[0]\n        dp[0][1] = 0\n        res = 0\n        num1 = 0\n        num2 = -prices[0]\n        for i in range(1, n):\n            dp[i][0] = max(dp[i][0], num1 - prices[i])\n            dp[i][1] = max(dp[i][1], num2 + prices[i] - fee)\n            res = max(res, dp[i][0], dp[i][1])\n            num1 = max(num1, dp[i][1])\n            num2 = max(num2, dp[i][0])\n        return res\n        \n        \n","date":"2023-10-06"}],"tagList":["贪心","数组","动态规划"],"level":"Medium"}},{"problemName":"715.Range模块.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/715.Range模块.json","problemData":{"id":"715","name":"715.Range模块","url":"https://leetcode.cn/problems/range-module","desc":"Range模块是跟踪数字范围的模块。设计一个数据结构来跟踪表示为 半开区间 的范围并查询它们。","solutions":[{"date":"2022-06-20","script":"cpp","time":200,"memory":66.95,"desc":"有序集合。","code":"class RangeModule {\npublic:\n    RangeModule() {}\n    \n    void addRange(int left, int right) {\n        auto it = intervals.upper_bound(left);\n        if (it != intervals.begin()) {\n            auto start = prev(it);\n            if (start->second >= right) {\n                return;\n            }\n            if (start->second >= left) {\n                left = start->first;\n                intervals.erase(start);\n            }\n        }\n        while (it != intervals.end() && it->first <= right) {\n            right = max(right, it->second);\n            it = intervals.erase(it);\n        }\n        intervals[left] = right;\n    }\n    \n    bool queryRange(int left, int right) {\n        auto it = intervals.upper_bound(left);\n        if (it == intervals.begin()) {\n            return false;\n        }\n        it = prev(it);\n        return right <= it->second;\n    }\n    \n    void removeRange(int left, int right) {\n        auto it = intervals.upper_bound(left);\n        if (it != intervals.begin()) {\n            auto start = prev(it);\n            if (start->second >= right) {\n                int ri = start->second;\n                if (start->first == left) {\n                    intervals.erase(start);\n                }\n                else {\n                    start->second = left;\n                }\n                if (right != ri) {\n                    intervals[right] = ri;\n                }\n                return;\n            }\n            else if (start->second > left) {\n                start->second = left;\n            }\n        }\n        while (it != intervals.end() && it->first < right) {\n            if (it->second <= right) {\n                it = intervals.erase(it);\n            }\n            else {\n                intervals[right] = it->second;\n                intervals.erase(it);\n                break;\n            }\n        }\n    }\n\nprivate:\n    map<int, int> intervals;\n};"},{"script":"python","time":480,"memory":20.4,"desc":"有序数组，每次合并数组。","code":"from sortedcontainers import SortedList\nclass RangeModule:\n    def __init__(self):\n        self.arr = SortedList([(-1, -1), (inf, inf)])\n\n    def addRange(self, left: int, right: int) -> None:\n        arr = self.arr\n        item = (left, right)\n        idx = arr.bisect_left(item)\n        if arr[idx - 1][1] >= left:\n            item = (arr[idx - 1][0], max(arr[idx - 1][1], item[1]))\n            arr.pop(idx - 1)\n            idx -= 1\n        while arr[idx][0] <= item[1]:\n            item = (item[0], max(arr[idx][1], item[1]))\n            arr.pop(idx)\n        arr.add(item)\n\n    def queryRange(self, left: int, right: int) -> bool:\n        arr = self.arr\n        idx = arr.bisect_right((left, inf))\n        return arr[idx - 1][0] <= left and arr[idx - 1][1] >= right\n\n    def removeRange(self, left: int, right: int) -> None:\n        arr = self.arr\n        idx = arr.bisect_left((left, right))\n        if arr[idx - 1][1] > left:\n            if arr[idx - 1][1] > right:\n                arr.add((right, arr[idx - 1][1]))\n            item = (arr[idx - 1][0], left)\n            arr.pop(idx - 1)\n            arr.add(item)\n        while arr[idx][1] <= right:\n            arr.pop(idx)\n        if arr[idx][0] <= right:\n            item = (right, arr[idx][1])\n            arr.pop(idx)\n            if item[0] != item[1]:\n                arr.add(item)","date":"2023-11-12"}],"tagList":["设计","线段树","有序集合"],"level":"Hard"}},{"problemName":"717.1比特与2比特字符.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/717.1比特与2比特字符.json","problemData":{"id":"717","name":"717.1比特与2比特字符","url":"https://leetcode.cn/problems/1-bit-and-2-bit-characters","desc":"给定一个以 0 结尾的二进制数组 bits ，如果最后一个字符必须是一位字符，则返回 true 。","solutions":[{"date":"2022-02-20","time":4,"memory":9.3,"script":"cpp","desc":"遍历， 判断最后的下标是否等于末尾。","code":"class Solution {\n   public:\n    bool isOneBitCharacter(vector<int>& bits) {\n        int idx = 0;\n        while (idx < bits.size() - 1) {\n            if (bits[idx] == 0)\n                idx += 1;\n            else\n                idx += 2;\n        }\n        return idx == bits.size() - 1;\n    }\n};"}],"tagList":["数组"],"level":"Easy"}},{"problemName":"718.最长重复子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/718.最长重复子数组.json","problemData":{"id":"718","name":"718.最长重复子数组","url":"https://leetcode.cn/problems/maximum-length-of-repeated-subarray","desc":"给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。","solutions":[{"date":"2020-07-01","time":272,"memory":93.5,"script":"typescript","desc":"dp[i][j]= A[i]===B[i] ? dp[i+1][j+1] + 1 : 0，倒序动态规划。","code":"function findLength(A: number[], B: number[]): number {\n  const aLen = A.length;\n  const bLen = B.length;\n  let max = 0;\n  const dp: number[][] = new Array(aLen + 1).fill(0).map(_ => new Array(bLen + 1).fill(0));\n  for (let i = aLen - 1; i >= 0; i--) {\n    for (let j = bLen - 1; j >= 0; j--) {\n      max = Math.max(max, (dp[i][j] = A[i] === B[j] ? dp[i + 1][j + 1] + 1 : 0));\n    }\n  }\n  return max;\n}"}],"tagList":["数组","二分查找","动态规划","滑动窗口","哈希函数","滚动哈希"],"level":"Medium"}},{"problemName":"719.找出第K小的数对距离.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/719.找出第K小的数对距离.json","problemData":{"id":"719","name":"719.找出第K小的数对距离","url":"https://leetcode.cn/problems/find-k-th-smallest-pair-distance","desc":"返回 所有数对距离中 第 k 小的数对距离。","solutions":[{"date":"2022-06-15","time":16,"memory":9.7,"script":"cpp","desc":"排序后，对于每一种差值，计算可能的数量。","code":"class Solution {\n   public:\n    int smallestDistancePair(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size(), l = 0, r = nums[n - 1] - nums[0], m;\n        while (l < r) {\n            m = (l + r) >> 1;\n            int cnt = 0;\n            for (int i = 0; i < n; i++) cnt += i - bs(nums, i, nums[i] - m);\n            if (cnt >= k)\n                r = m;\n            else\n                l = m + 1;\n        }\n        return l;\n    }\n    int bs(vector<int>& nums, int r, int target) {\n        int l = 0, m;\n        while (l < r) {\n            m = (l + r) >> 1;\n            if (nums[m] >= target)\n                r = m;\n            else\n                l = m + 1;\n        }\n        return l;\n    }\n};"}],"tagList":["数组","双指针","二分查找","排序"],"level":"Hard"}},{"problemName":"720.词典中最长的单词.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/720.词典中最长的单词.json","problemData":{"id":"720","name":"720.词典中最长的单词","url":"https://leetcode.cn/problems/longest-word-in-dictionary","desc":"给出一个字符串数组 words 组成的一本英语词典。返回 words 中最长的一个单词，该单词是由 words 词典中其他单词逐步添加一个字母组成。","solutions":[{"date":"2022-03-16","time":36,"memory":16.7,"script":"cpp","desc":"排序后遍历。","code":"bool comp(string &a, string &b) {\n    return a.size() == b.size() ? a < b : a.size() > b.size();\n}\nclass Solution {\n   public:\n    string longestWord(vector<string> &words) {\n        unordered_set<string> s;\n        for (auto &w : words) s.insert(w);\n        sort(words.begin(), words.end(), comp);\n        for (auto &w : words) {\n            if (find(s, w)) return w;\n        }\n        return \"\";\n    }\n    bool find(unordered_set<string> &s, string w) {\n        if (w == \"\") return true;\n        if (!s.count(w)) return false;\n        return find(s, w.substr(0, w.size() - 1));\n    }\n};"}],"tagList":["字典树","数组","哈希表","字符串","排序"],"level":"Medium"}},{"problemName":"721.账户合并.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/721.账户合并.json","problemData":{"id":"721","name":"721.账户合并","url":"https://leetcode.cn/problems/accounts-merge","desc":"给定一个列表 accounts，合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按字符 ASCII 顺序排列的邮箱地址。账户本身可以以任意顺序返回。","solutions":[{"date":"2021-05-01","time":272,"memory":53.2,"script":"typescript","desc":"并查集。","code":"class UnionFind {\n  elements: number[];\n  constructor(public size: number) {\n    this.elements = new Array(size).fill(0).map((_, i) => i);\n  }\n  same(v1: number, v2: number): boolean {\n    return this.find(v1) === this.find(v2);\n  }\n  find(v: number): number {\n    return v === this.elements[v] ? v : (this.elements[v] = this.find(this.elements[v]));\n  }\n  union(v1: number, v2: number): void {\n    const e1 = this.find(v1);\n    const e2 = this.find(v2);\n    if (e1 !== e2) {\n      this.elements[e1] = e2;\n      this.size--;\n    }\n  }\n}\nfunction accountsMerge(accounts: string[][]): string[][] {\n  const indexMap = new Map<string | number, number | string>();\n  const nameMap = new Map<string, string>();\n  let size = 0;\n  for (const [name, ...emails] of accounts)\n    emails.forEach(email => {\n      if (!indexMap.has(email)) {\n        indexMap.set(email, size);\n        indexMap.set(size, email);\n        size++;\n      }\n      nameMap.set(email, name);\n    });\n  const uf = new UnionFind(size);\n  for (const [, ...emails] of accounts) {\n    for (let i = 1, l = emails.length; i < l; i++) {\n      uf.union(indexMap.get(emails[i]) as number, indexMap.get(emails[i - 1]) as number);\n    }\n  }\n  const cache = new Map<number, number[]>();\n  for (let i = 0; i < size; i++) {\n    const index = uf.find(i);\n    let list = cache.get(index);\n    if (!list) cache.set(index, (list = []));\n    list.push(i);\n  }\n  const emailSort = (email1: string, email2: string): number => {\n    let i = 0;\n    const len = Math.min(email1.length, email2.length);\n    while (i < len) {\n      if (email1[i] === email2[i]) i++;\n      else return email1.codePointAt(i)! - email2.codePointAt(i)!;\n    }\n    return email1[i] === undefined ? -1 : 1;\n  };\n  const ans: string[][] = [];\n  for (const [k, v] of cache.entries()) {\n    ans.push([\n      nameMap.get(indexMap.get(k) as string) as string,\n      ...v.map(i => indexMap.get(i) as string).sort(emailSort),\n    ]);\n  }\n  return ans;\n}"},{"script":"python","time":1584,"memory":19.45,"desc":"并查集合并数据。","code":"class UnionFind:\n    def __init__(self, n) -> None:\n        self.n = n\n        self.data = [i for i in range(0, n)]\n        self.sizes = [1] * n\n        self.cnt = n\n    def size(self, v: int) -> int:\n        return self.sizes[self.find(v)]\n    def find(self, v: int) -> int:\n        if self.data[v] != v:\n            self.data[v] = self.find(self.data[v])\n        return self.data[v]\n    def uni(self, v1: int, v2: int):\n        p1 = self.find(v1)\n        p2 = self.find(v2)\n        if p1 != p2:\n            self.sizes[p1] += self.sizes[p2]\n            self.cnt -= self.sizes[p2]\n            self.data[p2] = p1\n    def same(self, v1: int, v2: int):\n        return self.find(v1) == self.find(v2)\n    def get_items(self) -> List[List[int]]:\n        map = defaultdict(list)\n        for i in range(self.n): map[self.find(i)].append(i)\n        return map.values()\nclass Solution:\n    def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:\n        n = len(accounts)\n        uf = UnionFind(n)\n        for i in range(n):\n            name1 = accounts[i][0]\n            emails1 = set(accounts[i][1:])\n            for j in range(i):\n                name2 = accounts[j][0]\n                emails2 = set(accounts[j][1:])\n                if name1 == name2 and not emails1.isdisjoint(emails2):\n                    uf.uni(i, j)\n        res = []\n        for arr in uf.get_items():\n            item = []\n            res.append(item)\n            item.append(accounts[arr[0]][0])\n            emails = []\n            for idx in arr: emails += accounts[idx][1:]\n            item += sorted(set(emails))\n        return res","date":"2024-07-15"}],"tagList":["深度优先搜索","广度优先搜索","并查集","数组","哈希表","字符串","排序"],"level":"Medium"}},{"problemName":"724.寻找数组的中心下标.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/724.寻找数组的中心下标.json","problemData":{"id":"724","name":"724.寻找数组的中心下标","url":"https://leetcode.cn/problems/find-pivot-index","desc":"给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。","solutions":[{"date":"2021-01-28","time":120,"memory":41.1,"script":"typescript","desc":"前缀和。","code":"function pivotIndex(nums: number[]): number {\n  const sum = nums.reduce((total, cur) => total + cur, 0);\n  const len = nums.length;\n  let l = 0;\n  for (let i = 0; i < len; i++) {\n    if (l === sum - l - nums[i]) return i;\n    l += nums[i];\n  }\n  return -1;\n}"},{"date":"2021-12-23","time":24,"memory":30.2,"script":"cpp","desc":"前缀和。","code":"class Solution {\n   public:\n    int pivotIndex(vector<int>& nums) {\n        int sum = 0;\n        for (auto& num : nums) sum += num;\n        int pre = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (sum - nums[i] == pre) return i;\n            pre += nums[i];\n            sum -= nums[i];\n        }\n        return -1;\n    }\n};"},{"script":"python","time":54,"memory":17.25,"desc":"遍历。","code":"class Solution:\n    def pivotIndex(self, nums: List[int]) -> int:\n        l = 0\n        r = sum(nums)\n        for i in range(len(nums)):\n            r -= nums[i]\n            if l == r: return i\n            l += nums[i]\n        return -1","date":"2024-07-08"}],"tagList":["数组","前缀和"],"level":"Easy"}},{"problemName":"725.分隔链表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/725.分隔链表.json","problemData":{"id":"725","name":"725.分隔链表","url":"https://leetcode.cn/problems/split-linked-list-in-parts","desc":"给你一个头结点为 head 的单链表和一个整数 k ，请你设计一个算法将链表分隔为 k 个连续的部分。","solutions":[{"date":"2021-09-22","time":88,"memory":40.6,"script":"javascript","desc":"储存到队列中进行筛选。","code":"function splitListToParts(head: ListNode | null, k: number): Array<ListNode | null> {\n  const list: ListNode[] = [];\n  let p: ListNode | null = head;\n  while (p) {\n    const next = p.next;\n    list.push(p);\n    p.next = null;\n    p = next;\n  }\n  const len = list.length;\n  const ans: Array<ListNode | null> = new Array(k).fill(null);\n  if (len <= k) {\n    for (let i = 0; i < len; i++) ans[i] = list[i];\n    return ans;\n  }\n  const cnt = ~~(len / k);\n  const last = (len % k) - 1;\n  let nodeIdx = 0;\n  for (let i = 0; i < k; i++) {\n    const node = (ans[i] = list[nodeIdx]);\n    const lastIdx = nodeIdx + cnt + (i <= last ? 1 : 0);\n    let p = node;\n    while (++nodeIdx < lastIdx) p = p.next = list[nodeIdx];\n  }\n  return ans;\n}"},{"date":"2021-09-22","time":76,"memory":40.2,"script":"javascript","desc":"循环两次。","code":"function splitListToParts(head: ListNode | null, k: number): Array<ListNode | null> {\n  let len = 0;\n  let p = head;\n  for (; p; p = p.next) len++;\n  const cnt = ~~(len / k);\n  const last = (len % k) - 1;\n  const ans: Array<ListNode | null> = [];\n  p = head;\n  let max = cnt + (ans.length <= last ? 1 : 0);\n  let idx = 0;\n  while (p) {\n    if (idx === 0) ans.push(p);\n    if (idx === max - 1) {\n      max = cnt + (ans.length <= last ? 1 : 0);\n      const next = p.next;\n      p.next = null;\n      p = next;\n      idx = 0;\n    } else {\n      p = p.next;\n      idx++;\n    }\n  }\n  while (ans.length < k) ans.push(null);\n  return ans;\n}"}],"tagList":["链表"],"level":"Medium"}},{"problemName":"726.原子的数量.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/726.原子的数量.json","problemData":{"id":"726","name":"726.原子的数量","url":"https://leetcode.cn/problems/number-of-atoms","desc":"给定一个化学式，输出所有原子的数量。格式为：第一个（按字典序）原子的名子，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。","solutions":[{"date":"2021-07-05","time":112,"memory":43,"script":"typescript","desc":"递归检索括号，逐个存入哈希表中。","code":"function countOfAtoms(formula: string): string {\n  const uperChar = /^[A-Z]$/;\n  const lowerChar = /^[a-z]$/;\n  const numChar = /^[0-9]$/;\n  const data = getRecord(formula);\n  return Object.entries(data)\n    .sort(([k1], [k2]) => {\n      const len1 = k1.length;\n      const len2 = k2.length;\n      let i = 0;\n      while (i < Math.min(len1, len2)) {\n        const code1 = k1.codePointAt(i)!;\n        const code2 = k2.codePointAt(i)!;\n        if (code1 !== code2) return code1 - code2;\n        else i++;\n      }\n      if (i === len1) return -1;\n      else if (i === len2) return 1;\n      else return 0;\n    })\n    .map(([k, v]) => k + (v === 1 ? '' : v))\n    .join('');\n  function getRecord(str: string): Record<string, number> {\n    const len = str.length;\n    const stack: string[] = [];\n    const map: Record<string, number> = {};\n    for (let i = 0; i < len; i++) {\n      let c = str[i];\n      if (uperChar.test(c)) {\n        stack.push(c);\n      } else if (lowerChar.test(c)) {\n        stack.push(stack.pop()! + c);\n      } else if (c === '(') {\n        let left = 1;\n        let tempStr = '';\n        while (true) {\n          if (str[i + 1] === '(') left++;\n          if (str[i + 1] === ')' && --left === 0) break;\n          tempStr += str[++i];\n        }\n        const internalRecord = getRecord(tempStr);\n        i++;\n        let numStr = '';\n        while (numChar.test(str[i + 1])) numStr += str[++i];\n        const num = +numStr;\n        Object.entries(internalRecord).forEach(([k, v]) => {\n          map[k] = (map[k] ?? 0) + v * (num === 0 ? 1 : num);\n        });\n      } else {\n        while (numChar.test(str[i + 1])) c = c + str[++i];\n        const num = +c;\n        const char = stack.pop()!;\n        map[char] = (map[char] ?? 0) + num;\n      }\n    }\n    while (stack.length !== 0) {\n      const c = stack.pop()!;\n      map[c] = (map[c] ?? 0) + 1;\n    }\n    return map;\n  }\n}"}],"tagList":["栈","哈希表","字符串","排序"],"level":"Hard"}},{"problemName":"728.自除数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/728.自除数.json","problemData":{"id":"728","name":"728.自除数","url":"https://leetcode.cn/problems/self-dividing-numbers","desc":"给定两个整数 left 和 right ，返回一个列表，列表的元素是范围 [left, right] 内所有的 自除数 。","solutions":[{"date":"2022-03-17","time":0,"memory":6.8,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    vector<int> selfDividingNumbers(int left, int right) {\n        vector<int> ans;\n        ans.reserve(1e4);\n        for (int num = left; num <= right; num++) check(ans, num);\n        return ans;\n    }\n    void check(vector<int> &ans, int num) {\n        int tmp = num;\n        for (; tmp; tmp /= 10) {\n            if (tmp % 10 == 0) return;\n            if (num % (tmp % 10) != 0) return;\n        }\n        ans.push_back(num);\n    }\n};"}],"tagList":["数学"],"level":"Easy"}},{"problemName":"729.我的日程安排表I.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/729.我的日程安排表I.json","problemData":{"id":"729","name":"729.我的日程安排表I","url":"https://leetcode.cn/problems/my-calendar-i","desc":"实现一个 MyCalendar 类来存放你的日程安排。如果要添加的日程安排不会造成 重复预订 ，则可以存储这个新的日程安排。","solutions":[{"date":"2022-07-05","time":188,"memory":50.3,"script":"typescript","desc":"构建 rbtree，每次通过 start、end 查找他最近的值然后进行比较。","code":"let NIL: RBNode<any>;\nclass RBNode<T> {\n  constructor(public key: T, public color = 0, public lchild = NIL, public rchild = NIL) {}\n  hasRedChild() {\n    return this.lchild.color === 0 || this.rchild.color === 0;\n  }\n}\nNIL = new RBNode(0, 1);\n\nclass RBTree<T extends Array<any>> {\n  root: RBNode<T> = NIL;\n  constructor(public compare: (v1: T, v2: T) => number) {}\n  print(node = this.root, init = true) {\n    if (node == NIL) return;\n    if (init) console.log('===[RBTree Print]===');\n    console.log(`${node.key}, (${node.lchild.key}, ${node.rchild.key})`);\n    this.print(node.lchild, false);\n    this.print(node.rchild, false);\n  }\n  rotateLeft(node: RBNode<T>) {\n    const newNode = node.rchild;\n    node.rchild = newNode.lchild;\n    newNode.lchild = node;\n    return newNode;\n  }\n  rotateRight(node: RBNode<T>) {\n    const newNode = node.lchild;\n    node.lchild = newNode.rchild;\n    newNode.rchild = node;\n    return newNode;\n  }\n  insert(key: T) {\n    this.root = this._insert(this.root, key);\n    this.root.color = 1;\n  }\n  _insert(node: RBNode<T>, key: T) {\n    if (node === NIL) return new RBNode(key);\n    const compare = this.compare(key, node.key);\n    if (compare === 0) {\n      node.key = key;\n      return node;\n    }\n    if (compare > 0) node.rchild = this._insert(node.rchild, key);\n    else node.lchild = this._insert(node.lchild, key);\n    return this._insertMaintain(node);\n  }\n  _insertMaintain(node: RBNode<T>) {\n    if (!node.hasRedChild()) return node;\n    if (\n      !(node.lchild.color === 0 && node.lchild.hasRedChild()) &&\n      !(node.rchild.color === 0 && node.rchild.hasRedChild())\n    )\n      return node;\n    if (node.lchild.color === 1) {\n      if (node.rchild.lchild.color === 0) node.rchild = this.rotateRight(node.rchild);\n      node = this.rotateLeft(node);\n    } else if (node.rchild.color === 1) {\n      if (node.lchild.rchild.color === 0) node.lchild = this.rotateLeft(node.lchild);\n      node = this.rotateRight(node);\n    }\n    node.color = 0;\n    node.lchild.color = node.rchild.color = 1;\n    return node;\n  }\n\n  remove(key: T) {\n    this.root = this._remove(this.root, key);\n    this.root.color = 1;\n  }\n  _remove(node: RBNode<T>, key: T) {\n    if (node == NIL) return node;\n    const compare = this.compare(key, node.key);\n    if (compare > 0) node.rchild = this._remove(node.rchild, key);\n    else if (compare < 0) node.lchild = this._remove(node.lchild, key);\n    else {\n      if (node.lchild === NIL || node.rchild === NIL) {\n        const tmp = node.lchild === NIL ? node.rchild : node.lchild;\n        tmp.color += node.color;\n        return tmp;\n      } else {\n        let tmp = node.lchild;\n        while (tmp.rchild !== NIL) tmp = tmp.rchild;\n        node.key = tmp.key;\n        node.lchild = this._remove(node.lchild, tmp.key);\n      }\n    }\n    return this._removeMaintain(node);\n  }\n  _removeMaintain(node: RBNode<T>) {\n    if (node.lchild.color !== 2 && node.rchild.color !== 2) return node;\n    if (node.hasRedChild()) {\n      let type = 0;\n      node.color = 0;\n      if (node.lchild.color === 0) node = this.rotateRight(node);\n      else (node = this.rotateLeft(node)), (type = 1);\n      node.color = 1;\n      if (type === 1) node.lchild = this._removeMaintain(node.lchild);\n      else node.rchild = this._removeMaintain(node.rchild);\n      return node;\n    }\n    if (\n      (node.lchild.color === 1 && !node.lchild.hasRedChild()) ||\n      (node.rchild.color === 1 && !node.rchild.hasRedChild())\n    ) {\n      node.color += 1;\n      node.lchild.color -= 1;\n      node.rchild.color -= 1;\n      return node;\n    }\n    if (node.lchild.color === 1) {\n      if (node.lchild.lchild.color !== 0) {\n        node.lchild.color = 0;\n        node.lchild = this.rotateLeft(node.lchild);\n        node.lchild.color = 1;\n      }\n      node.lchild.color = node.color;\n      node.rchild.color = 1;\n      node = this.rotateRight(node);\n    } else {\n      if (node.rchild.rchild.color !== 0) {\n        node.rchild.color = 0;\n        node.rchild = this.rotateRight(node.rchild);\n        node.rchild.color = 1;\n      }\n      node.rchild.color = node.color;\n      node.lchild.color = 1;\n      node = this.rotateLeft(node);\n    }\n    node.lchild.color = node.rchild.color = 1;\n    return node;\n  }\n  successor(node: RBNode<T>) {\n    let successor = NIL;\n    if (node.rchild) {\n      successor = node.rchild;\n      while (successor.lchild) successor = successor!.lchild;\n      return successor;\n    }\n    let tmp = this.root;\n    while (tmp) {\n      if (tmp.key > node.key) {\n        successor = tmp;\n        tmp = tmp.lchild;\n      } else {\n        tmp = tmp.rchild;\n      }\n    }\n    return tmp;\n  }\n  check([start, end]: T): boolean {\n    let node = this.root;\n    while (node !== NIL) {\n      if (node.key[0] >= end) node = node.lchild;\n      else if (node.key[1] <= start) node = node.rchild;\n      else break;\n    }\n    if (node === NIL) return true;\n    let tmp = node;\n    while (tmp !== NIL && tmp.key[1] >= start) {\n      const [tstart, tend] = tmp.key;\n      if (\n        (start > tstart && start < tend) ||\n        (end > tstart && end < tend) ||\n        (start <= tstart && end >= tend)\n      )\n        return false;\n      tmp = this.successor(tmp);\n    }\n    return true;\n  }\n}\nclass MyCalendar {\n  tree = new RBTree<number[]>((v1, v2) => v1[0] - v2[0]);\n  book(start: number, end: number): boolean {\n    const ans = this.tree.check([start, end]);\n    if (ans) this.tree.insert([start, end]);\n    return ans;\n  }\n}"}],"tagList":["设计","线段树","数组","二分查找","有序集合"],"level":"Medium"}},{"problemName":"731.我的日程安排表II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/731.我的日程安排表II.json","problemData":{"id":"731","name":"731.我的日程安排表II","url":"https://leetcode.cn/problems/my-calendar-ii","desc":"实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。","solutions":[{"date":"2022-07-19","time":28,"memory":2.7,"script":"rust","desc":"记录已经重叠的部分，每次遍历时判断新添加的是否和已重叠部分有冲突。","code":"struct MyCalendarTwo {\n    list: Vec<(i32, i32)>,\n    overlap: Vec<(i32, i32)>,\n}\nimpl MyCalendarTwo {\n    fn new() -> Self {\n        MyCalendarTwo {\n            list: Vec::new(),\n            overlap: Vec::new(),\n        }\n    }\n    fn book(&mut self, start: i32, end: i32) -> bool {\n        let block = (start, end);\n        for item in &self.overlap {\n            if self.is_overlap(&block, item) {\n                return false;\n            }\n        }\n        for item in &self.list {\n            if self.is_overlap(&block, item) {\n                self.overlap.push((block.0.max(item.0), block.1.min(item.1)));\n            }\n        }\n        self.list.push(block);\n        print!(\"{}\", block.0);\n        true\n    }\n    fn is_overlap(&self, v1: &(i32, i32), v2: &(i32, i32)) -> bool {\n        v1.0 < v2.1 && v1.1 > v2.0\n    }\n}"}],"tagList":["设计","线段树","数组","二分查找","有序集合","前缀和"],"level":"Medium"}},{"problemName":"735.小行星碰撞.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/735.小行星碰撞.json","problemData":{"id":"735","name":"735.小行星碰撞","url":"https://leetcode.cn/problems/asteroid-collision","desc":"找出碰撞后剩下的所有行星。","solutions":[{"date":"2022-07-13","time":16,"memory":17.3,"script":"cpp","desc":"栈。","code":"class Solution {\n   public:\n    vector<int> asteroidCollision(vector<int>& asteroids) {\n        int n = asteroids.size();\n        stack<int> s;\n        for (int i = 0; i < n; i++) {\n            int aster = asteroids[i];\n            bool hasAster = true;\n            while (s.size() && asteroids[s.top()] > 0 && aster < 0) {\n                int top = asteroids[s.top()];\n                if (abs(top) == abs(aster)) s.pop();\n                if (abs(top) >= abs(aster)) {\n                    hasAster = false;\n                    break;\n                } else\n                    s.pop();\n            }\n            if (hasAster) s.push(i);\n        }\n        vector<int> ans(s.size());\n        for (int i = s.size() - 1; i >= 0; i--)\n            ans[i] = asteroids[s.top()], s.pop();\n        return ans;\n    }\n};"}],"tagList":["栈","数组","模拟"],"level":"Medium"}},{"problemName":"736.Lisp语法解析.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/736.Lisp语法解析.json","problemData":{"id":"736","name":"736.Lisp语法解析","url":"https://leetcode.cn/problems/parse-lisp-expression","desc":"给你一个类似 Lisp 语句的字符串表达式 expression，求出其计算结果。","solutions":[{"date":"2022-07-06","time":32,"memory":26,"script":"cpp","desc":"递归比较，每次存储当前变量。","code":"class Solution {\n   public:\n    vector<unordered_map<string, int>> varStark;\n    int evaluate(string expression) {\n        if (expression[0] == '(')\n            expression = expression.substr(1, expression.size() - 2);\n        vector<string> list = toToken(expression);\n        return comp(list);\n    }\n    vector<string> toToken(string &expression) {\n        vector<string> list;\n        int i;\n        if (expression[0] == 'l') list.push_back(\"let\"), i = 4;\n        if (expression[0] == 'm') list.push_back(\"mult\"), i = 5;\n        if (expression[0] == 'a') list.push_back(\"add\"), i = 4;\n        while (i < expression.size()) {\n            int end = expression[i] == '(' ? findEndIdx1(expression, i)\n                                           : findEndIdx2(expression, i);\n            list.push_back(expression.substr(i, end - i));\n            i = end;\n            while (i < expression.size() && expression[i] == ' ' ||\n                   expression[i] == ')')\n                i++;\n        }\n        return list;\n    }\n    int comp(vector<string> &list) {\n        int ans;\n        if (list[0] == \"let\") ans = comp_let(list);\n        if (list[0] == \"add\") ans = comp_var(list[1]) + comp_var(list[2]);\n        if (list[0] == \"mult\") ans = comp_var(list[1]) * comp_var(list[2]);\n        return ans;\n    }\n    int comp_let(vector<string> &list) {\n        int n = list.size();\n        unordered_map<string, int> m;\n        for (int i = 1; i < n - 1; i += 2) {\n            int val;\n            varStark.push_back(m);\n            if (list[i + 1][0] == '(')\n                val = evaluate(list[i + 1]);\n            else\n                val = get_var(list[i + 1]);\n            varStark.pop_back();\n            m[list[i]] = val;\n        }\n        int val;\n        varStark.push_back(m);\n        if (list[n - 1][0] == '(') {\n            val = evaluate(list[n - 1]);\n        } else\n            val = get_var(list[n - 1]);\n        varStark.pop_back();\n        return val;\n    }\n    int comp_var(string &str) {\n        int val;\n        if (str[0] == '(')\n            val = evaluate(str);\n        else\n            val = get_var(str);\n        return val;\n    }\n    int get_var(string &str) {\n        for (int i = varStark.size() - 1; i >= 0; i--)\n            if (varStark[i].count(str)) return varStark[i][str];\n        return stoi(str);\n    }\n    int findEndIdx1(string &expression, int start) {\n        int end = start, deep = 0;\n        do {\n            if (expression[end] == '(')\n                deep++;\n            else if (expression[end] == ')')\n                deep--;\n            end++;\n        } while (deep > 0);\n        return end;\n    }\n    int findEndIdx2(string &expression, int start) {\n        int end = start;\n        while (end < expression.size() && expression[end] != ' ') end++;\n        return end;\n    }\n};"},{"date":"2022-07-06","time":32,"memory":26,"script":"cpp","desc":"递归比较，每次存储当前变量。","code":"class Solution {\n   public:\n    vector<unordered_map<string, int>> varStark;\n    int evaluate(string expression) {\n        if (expression[0] == '(')\n            expression = expression.substr(1, expression.size() - 2);\n        vector<string> list = toToken(expression);\n        return comp(list);\n    }\n    vector<string> toToken(string &expression) {\n        vector<string> list;\n        int i;\n        if (expression[0] == 'l') list.push_back(\"let\"), i = 4;\n        if (expression[0] == 'm') list.push_back(\"mult\"), i = 5;\n        if (expression[0] == 'a') list.push_back(\"add\"), i = 4;\n        while (i < expression.size()) {\n            int end = expression[i] == '(' ? findEndIdx1(expression, i)\n                                           : findEndIdx2(expression, i);\n            list.push_back(expression.substr(i, end - i));\n            i = end;\n            while (i < expression.size() && expression[i] == ' ' ||\n                   expression[i] == ')')\n                i++;\n        }\n        return list;\n    }\n    int comp(vector<string> &list) {\n        int ans;\n        if (list[0] == \"let\") ans = comp_let(list);\n        if (list[0] == \"add\") ans = comp_var(list[1]) + comp_var(list[2]);\n        if (list[0] == \"mult\") ans = comp_var(list[1]) * comp_var(list[2]);\n        return ans;\n    }\n    int comp_let(vector<string> &list) {\n        int n = list.size();\n        unordered_map<string, int> m;\n        for (int i = 1; i < n - 1; i += 2) {\n            int val;\n            varStark.push_back(m);\n            if (list[i + 1][0] == '(')\n                val = evaluate(list[i + 1]);\n            else\n                val = get_var(list[i + 1]);\n            varStark.pop_back();\n            m[list[i]] = val;\n        }\n        int val;\n        varStark.push_back(m);\n        if (list[n - 1][0] == '(') {\n            val = evaluate(list[n - 1]);\n        } else\n            val = get_var(list[n - 1]);\n        varStark.pop_back();\n        return val;\n    }\n    int comp_var(string &str) {\n        int val;\n        if (str[0] == '(')\n            val = evaluate(str);\n        else\n            val = get_var(str);\n        return val;\n    }\n    int get_var(string &str) {\n        for (int i = varStark.size() - 1; i >= 0; i--)\n            if (varStark[i].count(str)) return varStark[i][str];\n        return stoi(str);\n    }\n    int findEndIdx1(string &expression, int start) {\n        int end = start, deep = 0;\n        do {\n            if (expression[end] == '(')\n                deep++;\n            else if (expression[end] == ')')\n                deep--;\n            end++;\n        } while (deep > 0);\n        return end;\n    }\n    int findEndIdx2(string &expression, int start) {\n        int end = start;\n        while (end < expression.size() && expression[end] != ' ') end++;\n        return end;\n    }\n};"},{"date":"2022-07-06","time":32,"memory":26,"script":"cpp","desc":"递归比较，每次存储当前变量。","code":"class Solution {\n   public:\n    vector<unordered_map<string, int>> varStark;\n    int evaluate(string expression) {\n        if (expression[0] == '(')\n            expression = expression.substr(1, expression.size() - 2);\n        vector<string> list = toToken(expression);\n        return comp(list);\n    }\n    vector<string> toToken(string &expression) {\n        vector<string> list;\n        int i;\n        if (expression[0] == 'l') list.push_back(\"let\"), i = 4;\n        if (expression[0] == 'm') list.push_back(\"mult\"), i = 5;\n        if (expression[0] == 'a') list.push_back(\"add\"), i = 4;\n        while (i < expression.size()) {\n            int end = expression[i] == '(' ? findEndIdx1(expression, i)\n                                           : findEndIdx2(expression, i);\n            list.push_back(expression.substr(i, end - i));\n            i = end;\n            while (i < expression.size() && expression[i] == ' ' ||\n                   expression[i] == ')')\n                i++;\n        }\n        return list;\n    }\n    int comp(vector<string> &list) {\n        int ans;\n        if (list[0] == \"let\") ans = comp_let(list);\n        if (list[0] == \"add\") ans = comp_var(list[1]) + comp_var(list[2]);\n        if (list[0] == \"mult\") ans = comp_var(list[1]) * comp_var(list[2]);\n        return ans;\n    }\n    int comp_let(vector<string> &list) {\n        int n = list.size();\n        unordered_map<string, int> m;\n        for (int i = 1; i < n - 1; i += 2) {\n            int val;\n            varStark.push_back(m);\n            if (list[i + 1][0] == '(')\n                val = evaluate(list[i + 1]);\n            else\n                val = get_var(list[i + 1]);\n            varStark.pop_back();\n            m[list[i]] = val;\n        }\n        int val;\n        varStark.push_back(m);\n        if (list[n - 1][0] == '(') {\n            val = evaluate(list[n - 1]);\n        } else\n            val = get_var(list[n - 1]);\n        varStark.pop_back();\n        return val;\n    }\n    int comp_var(string &str) {\n        int val;\n        if (str[0] == '(')\n            val = evaluate(str);\n        else\n            val = get_var(str);\n        return val;\n    }\n    int get_var(string &str) {\n        for (int i = varStark.size() - 1; i >= 0; i--)\n            if (varStark[i].count(str)) return varStark[i][str];\n        return stoi(str);\n    }\n    int findEndIdx1(string &expression, int start) {\n        int end = start, deep = 0;\n        do {\n            if (expression[end] == '(')\n                deep++;\n            else if (expression[end] == ')')\n                deep--;\n            end++;\n        } while (deep > 0);\n        return end;\n    }\n    int findEndIdx2(string &expression, int start) {\n        int end = start;\n        while (end < expression.size() && expression[end] != ' ') end++;\n        return end;\n    }\n};"}],"tagList":["栈","递归","哈希表","字符串"],"level":"Hard"}},{"problemName":"738.单调递增的数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/738.单调递增的数字.json","problemData":{"id":"738","name":"738.单调递增的数字","url":"https://leetcode.cn/problems/monotone-increasing-digits","desc":"给定一个非负整数 N，找出小于或等于 N 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。","solutions":[{"date":"2020-12-15","time":88,"memory":39.7,"script":"typescript","desc":"检测到第一位非递增位，后续置 9。","code":"function monotoneIncreasingDigits(N: number): number {\n  const arr: number[] = N.toString()\n    .split('')\n    .map(v => +v);\n  const len = arr.length;\n  let i = 1;\n  while (i < len && arr[i - 1] <= arr[i]) i++;\n  if (i === len) return N;\n  while (i > 0 && arr[i - 1] > arr[i]) {\n    arr[i - 1]--;\n    i--;\n  }\n  for (i += 1; i < len; i++) {\n    arr[i] = 9;\n  }\n  return arr.reduce((total, cur) => total * 10 + cur, 0);\n}"}],"tagList":["贪心","数学"],"level":"Medium"}},{"problemName":"739.每日温度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/739.每日温度.json","problemData":{"id":"739","name":"739.每日温度","url":"https://leetcode.cn/problems/daily-temperatures","desc":"根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。","solutions":[{"date":"2020-06-11","time":1732,"memory":45.5,"script":"typescript","desc":"倒序遍历，相比起正序遍历的每次都遍历到重复值节约时间。","code":"function dailyTemperatures(T: number[]): number[] {\n  const len = T.length;\n  if (len === 0) return [];\n  let ans: number[] = [];\n  for (let i = len - 1; i >= 0; i--) {\n    if (i === len - 1) {\n      ans.unshift(0);\n      continue;\n    }\n    ans.unshift(find(T[i], i + 1));\n  }\n  return ans;\n  function find(num: number, index: number): number {\n    for (let i = index; i < len; i++) if (T[i] > num) return i - index + 1;\n    return 0;\n  }\n}"},{"date":"2020-06-11","time":196,"memory":50.3,"script":"typescript","desc":"维护单调栈，栈顶元素小于当前元素即赋值。","code":"function dailyTemperatures(T: number[]): number[] {\n  const stack: number[] = [];\n  const ans: number[] = [];\n  for (let i = 0, len = T.length; i < len; i++) {\n    while (stack.length !== 0 && T[stack.slice(-1)[0]] < T[i]) {\n      const index = stack.pop() as number;\n      ans[index] = i - index;\n    }\n    stack.push(i);\n  }\n  while (stack.length !== 0) ans[stack.pop() as number] = 0;\n  return ans;\n}"},{"date":"2021-07-19","time":240,"memory":60.6,"script":"typescript","desc":"单调递增栈。","code":"function dailyTemperatures(temperatures: number[]): number[] {\n  const stack: number[] = [];\n  const len = temperatures.length;\n  const ans: number[] = new Array(len).fill(0);\n  for (let i = 0; i < len; i++) {\n    const v = temperatures[i];\n    while (stack.length && temperatures[stack[stack.length - 1]] < v) {\n      const prev = stack.pop()!;\n      ans[prev] = i - prev;\n    }\n    stack.push(i);\n  }\n  return ans;\n}"}],"tagList":["栈","数组","单调栈"],"level":"Medium"}},{"problemName":"740.删除并获得点数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/740.删除并获得点数.json","problemData":{"id":"740","name":"740.删除并获得点数","url":"https://leetcode.cn/problems/delete-and-earn","desc":"开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。","solutions":[{"date":"2021-05-05","time":108,"memory":40.4,"script":"typescript","desc":"动态规划，计算包含前后值和不包含前后值得情况。","code":"function deleteAndEarn(nums: number[]): number {\n  const map = new Map<number, number>();\n  nums.forEach(num => map.set(num, (map.get(num) ?? 0) + 1));\n  const arr = [...map.keys()].sort((a, b) => a - b);\n  const len = arr.length;\n  const dp: number[][] = new Array(len).fill(0).map(_ => new Array(2).fill(0));\n  dp[0][0] = arr[0] * map.get(arr[0])!;\n  for (let i = 1; i < len; i++) {\n    const num = arr[i];\n    const maxPrev = Math.max(...dp[i - 1]);\n    dp[i][1] = maxPrev;\n    dp[i][0] = (map.has(num - 1) ? dp[i - 1][1] : maxPrev) + map.get(num)! * num;\n  }\n  return Math.max(...dp[len - 1]);\n}"}],"tagList":["数组","哈希表","动态规划"],"level":"Medium"}},{"problemName":"741.摘樱桃.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/741.摘樱桃.json","problemData":{"id":"741","name":"741.摘樱桃","url":"https://leetcode.cn/problems/cherry-pickup","desc":"你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃。","solutions":[{"date":"2022-07-11","time":84,"memory":34.2,"script":"cpp","desc":"问题转化为两个人从起点到终点路径中共有多少个樱桃,dp[i][j][k]表示总共 i 步的时候第一个人 x 在 j 第二个人 x 在 k,此时最大的樱桃数。","code":"class Solution {\n   public:\n    int cherryPickup(vector<vector<int>>& grid) {\n        int n = grid.size(), max_step = n * 2 - 1;\n        vector<vector<vector<int>>> dp(\n            max_step, vector<vector<int>>(n, vector<int>(n, INT_MIN)));\n        dp[0][0][0] = grid[0][0];\n        for (int step = 1; step < max_step; step++) {\n            int minCell = max(step - n + 1, 0), maxCell = min(n - 1, step);\n            for (\n                // x1最少走0格,如果step已经超过n,那x1最少也得n格\n                int x1 = minCell;\n                //  x1最多走到第n-1格\n                x1 <= maxCell; x1++) {\n                int y1 = step - x1;\n                if (grid[x1][y1] == -1) continue;\n                for (int x2 = minCell; x2 <= maxCell; x2++) {\n                    int y2 = step - x2;\n                    if (grid[x2][y2] == -1) continue;\n                    int cnt = dp[step - 1][x1][x2]; // 都向右走一步\n                    if (x1) cnt = max(cnt, dp[step - 1][x1 - 1][x2]); // x1向下走一步\n                    if (x2) cnt = max(cnt, dp[step - 1][x1][x2 - 1]); // x2向下走一步\n                    if (x1 && x2) cnt = max(cnt, dp[step - 1][x1 - 1][x2 - 1]); // 都向下走一步\n                    cnt += grid[x1][y1];\n                    if (x1 != x2) cnt += grid[x2][y2];\n                    dp[step][x1][x2] = cnt;\n                }\n            }\n        }\n        return max(0, dp[max_step - 1][n - 1][n - 1]);\n    }\n};"},{"script":"python","time":466,"memory":26.72,"desc":"dp[step][x1][x2]表示共走了step步后，第一个人往垂直方向走x1步，第二个人在垂直方向走x2步，此时能获得的最大樱桃数。","code":"class Solution:\n    def cherryPickup(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        MAX_STEP = (n - 1) * 2 + 1\n        dp = [[[-inf for _ in range(n + 1)] for _ in range(n + 1)] for _ in range(MAX_STEP)]\n        dp[0][0][0] = grid[0][0]\n        for step in range(1, MAX_STEP):\n            MAX_X = min(step, n - 1) + 1\n            for x1 in range(MAX_X):\n                y1 = step - x1\n                if y1 < n:\n                    for x2 in range(MAX_X):\n                        y2 = step - x2\n                        if y2 < n:\n                            if grid[x1][y1] != -1 and grid[x2][y2] != -1:\n                                dp[step][x1][x2] = max(\n                                    dp[step - 1][x1][x2],\n                                    dp[step - 1][x1 - 1][x2],\n                                    dp[step - 1][x1][x2 - 1],\n                                    dp[step - 1][x1 - 1][x2 - 1],\n                                )\n                                dp[step][x1][x2] += grid[x1][y1]\n                                if x1 != x2 or y1 != y2: dp[step][x1][x2] += grid[x2][y2]\n        res = 0\n        for item in dp[MAX_STEP - 1]:\n            res = max(res, max(item))\n        return res","date":"2024-05-07"}],"tagList":["数组","动态规划","矩阵"],"level":"Hard"}},{"problemName":"743.网络延迟时间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/743.网络延迟时间.json","problemData":{"id":"744","name":"743.网络延迟时间","url":"https://leetcode.cn/problems/network-delay-time","desc":"现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1。","solutions":[{"date":"2021-08-02","time":108,"memory":45.8,"script":"typescript","desc":"哈希储存，每次删减。","code":"class NetNode {\n  next: [NetNode, number][] = [];\n  constructor(public val: number) {}\n}\nfunction getMap(times: number[][]): Map<number, NetNode> {\n  const map = new Map<number, NetNode>();\n  for (const [start, end, time] of times) {\n    let startNode = map.get(start);\n    if (!startNode) map.set(start, (startNode = new NetNode(start)));\n    let endNode = map.get(end);\n    if (!endNode) map.set(end, (endNode = new NetNode(end)));\n    startNode.next.push([endNode, time]);\n  }\n  return map;\n}\nfunction networkDelayTime(times: number[][], n: number, k: number): number {\n  const map = getMap(times);\n  const init = map.get(k)!;\n  const q: [NetNode, number][] = [[init, 0]];\n  const set = new Set<NetNode>();\n  let ans = -1;\n  while (q.length) {\n    const nextQ: [NetNode, number][] = [];\n    let f = false;\n    while (q.length) {\n      const info = q.shift()!;\n      if (set.has(info[0])) continue;\n      f = true;\n      if (info[1] === 0) {\n        set.add(info[0]);\n        for (const [next, time] of info[0].next) {\n          if (time !== 0) set.has(next) || nextQ.push([next, time - 1]);\n          else q.push([next, time]);\n        }\n      } else {\n        info[1]--;\n        nextQ.push(info);\n      }\n    }\n    q.push(...nextQ);\n    if (f) ans++;\n  }\n  return set.size === n ? ans : -1;\n}"}],"tagList":["深度优先搜索","广度优先搜索","图","最短路","堆（优先队列）"],"level":"Medium"}},{"problemName":"744.寻找比目标字母大的最小字母.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/744.寻找比目标字母大的最小字母.json","problemData":{"id":"745","name":"744.寻找比目标字母大的最小字母","url":"https://leetcode.cn/problems/find-smallest-letter-greater-than-target","desc":"给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。","solutions":[{"date":"2022-03-18","time":20,"memory":15.4,"script":"cpp","desc":"遍历字母表。","code":"class Solution {\n   public:\n    char nextGreatestLetter(vector<char>& letters, char target) {\n        int list[26] = {0};\n        for (auto& ch : letters) {\n            list[ch - 'a'] = 1;\n        }\n        target -= 'a';\n        for (int i = (target + 1) % 26, cnt = 0; cnt < 26;\n             cnt++, i = (i + 1) % 26) {\n            if (list[i]) return i + 'a';\n        }\n        return 'a';\n    }\n};"},{"date":"2022-04-03","time":20,"memory":15.4,"script":"cpp","desc":"二分。","code":"class Solution {\n   public:\n    char nextGreatestLetter(vector<char>& letters, char target) {\n        int l = 0, r = letters.size(), m;\n        while (l < r) {\n            m = (l + r) >> 1;\n            if (letters[m] > target)\n                r = m;\n            else\n                l = m + 1;\n        }\n        return l == letters.size() ? letters[0] : letters[l];\n    }\n};"}],"tagList":["数组","二分查找"],"level":"Easy"}},{"problemName":"745.前缀和后缀搜索.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/745.前缀和后缀搜索.json","problemData":{"id":"746","name":"745.前缀和后缀搜索","url":"https://leetcode.cn/problems/prefix-and-suffix-search","desc":"设计一个包含一些单词的特殊词典，并能够通过前缀和后缀来检索单词。","solutions":[{"date":"2022-07-14","time":880,"memory":609.9,"script":"cpp","desc":"头尾插入,例如插入 app,即#app, p#app, pp#app, app#app,插入所有的可能性,然后从头开始找。","code":"#define CHILD_SIZE 27\nclass TrieNode {\n   public:\n    int key, idx;\n    bool end;\n    TrieNode **children;\n    TrieNode(int k) {\n        key = k;\n        idx = -1;\n        end = false;\n        children = (TrieNode **)malloc(sizeof(TrieNode *) * CHILD_SIZE);\n        for (int i = 0; i < CHILD_SIZE; i++) children[i] = nullptr;\n    }\n};\nclass Trie {\n   public:\n    TrieNode *root;\n    Trie() { root = new TrieNode(0); }\n    void insert(string str, int idx) {\n        TrieNode *node = root;\n        for (int i = 0; i < str.size(); i++) {\n            int idx = str[i] == '#' ? (CHILD_SIZE - 1) : str[i] - 'a';\n            if (node->children[idx] == nullptr)\n                node->children[idx] = new TrieNode(idx);\n            node = node->children[idx];\n        }\n        node->end = true;\n        node->idx = idx;\n    }\n    TrieNode *find(string str) {\n        TrieNode *node = root;\n        for (int i = 0; i < str.size(); i++) {\n            int idx = str[i] == '#' ? (CHILD_SIZE - 1) : str[i] - 'a';\n            if (node->children[idx] == nullptr) return nullptr;\n            node = node->children[idx];\n        }\n        return node;\n    }\n};\nclass WordFilter {\n   public:\n    Trie *t;\n    WordFilter(vector<string> &words) {\n        t = new Trie();\n        for (int i = 0; i < words.size(); i++) {\n            string w = words[i], insertw = \"#\" + w;\n            for (int j = w.size() - 1; j >= 0; j--) {\n                insertw = w[j] + insertw;\n                t->insert(insertw, i);\n            }\n        }\n    }\n    int f(string pref, string suff) {\n        TrieNode *n = t->find(suff + \"#\" + pref);\n        int ans = -1;\n        if (n == nullptr) return ans;\n        dfs(ans, n);\n        return ans;\n    }\n    void dfs(int &ans, TrieNode *n) {\n        if (n->end) ans = max(ans, n->idx);\n        for (int i = 0; i < CHILD_SIZE; i++) {\n            if (n->children[i] == nullptr) continue;\n            dfs(ans, n->children[i]);\n        }\n    }\n};"}],"tagList":["设计","字典树","数组","哈希表","字符串"],"level":"Hard"}},{"problemName":"746.使用最小花费爬楼梯.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/746.使用最小花费爬楼梯.json","problemData":{"id":"747","name":"746.使用最小花费爬楼梯","url":"https://leetcode.cn/problems/min-cost-climbing-stairs","desc":"给你数组的每个索引作为一个阶梯，第  i 个阶梯对应着一个非负数的体力花费值  cost[i](索引从0开始)。每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。您需要找到达到楼层顶部的最低花费。","solutions":[{"date":"2020-12-22","time":88,"memory":40.7,"script":"typescript","desc":"偶数列倒序插入。","code":"function zigzagLevelOrder(root: TreeNode | null): number[][] {\n  if (root === null) return [];\n  const ans: number[][] = [[root.val]];\n  let queue = [root];\n  let height = 0;\n  let size = 1;\n  while (queue.length !== 0) {\n    const node = queue.shift()!;\n    node.left && queue.push(node.left);\n    node.right && queue.push(node.right);\n    if (--size === 0) {\n      size = queue.length;\n      queue.length !== 0 &&\n        ans.push((++height & 1 ? queue.slice().reverse() : queue).map(node => node.val));\n    }\n  }\n  return ans;\n}"},{"date":"2021-09-03","time":80,"memory":39.9,"script":"typescript","desc":"动态规划。","code":"function minCostClimbingStairs(cost: number[]): number {\n  const n = cost.length;\n  const dp = new Array(n + 1);\n  dp[0] = cost[0];\n  dp[1] = cost[1];\n  for (let i = 2; i <= n; i++) dp[i] = (cost[i] ?? 0) + Math.min(dp[i - 1], dp[i - 2]);\n  return dp[n];\n}"},{"script":"python","time":48,"memory":16.2,"desc":"dp。","code":"class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        cost.append(0)\n        n = len(cost)\n        dp = [0] * n\n        dp[0] = cost[0]\n        dp[1] = cost[1]\n        for i in range(2, n):\n            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]\n        return dp[n - 1]","date":"2023-12-17"}],"tagList":["数组","动态规划"],"level":"Easy"}},{"problemName":"747.至少是其他数字两倍的最大数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/747.至少是其他数字两倍的最大数.json","problemData":{"id":"748","name":"747.至少是其他数字两倍的最大数","url":"https://leetcode.cn/problems/largest-number-at-least-twice-of-others","desc":"给你一个整数数组 nums ，其中总是存在 唯一的 一个最大整数 。请你找出数组中的最大元素并检查它是否 至少是数组中每个其他数字的两倍 。","solutions":[{"date":"2022-01-13","time":4,"memory":10.5,"script":"cpp","desc":"遍历两次，第一次记录最大值，第二次判断其他值的两倍是否超过最大值。","code":"class Solution {\n   public:\n    int dominantIndex(vector<int>& nums) {\n        int maxn = INT_MIN, maxi;\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] > maxn) {\n                maxn = nums[i];\n                maxi = i;\n            }\n        }\n        for (auto& num : nums) {\n            if (num != maxn && num * 2 > maxn) return -1;\n        }\n        return maxi;\n    }\n};"},{"date":"2022-01-13","time":8,"memory":10.7,"script":"cpp","desc":"排序。","code":"class Solution {\n   public:\n    int dominantIndex(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 1) return 0;\n        int arr[n];\n        for (int i = 0; i < n; i++) arr[i] = i;\n        sort(arr, arr + n,\n             [&](int i1, int i2) -> bool { return nums[i1] < nums[i2]; });\n        return nums[arr[n - 1]] >= nums[arr[n - 2]] * 2 ? arr[n - 1] : -1;\n    }\n};"}],"tagList":["数组","排序"],"level":"Easy"}},{"problemName":"748.最短补全词.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/748.最短补全词.json","problemData":{"id":"749","name":"748.最短补全词","url":"https://leetcode.cn/problems/shortest-completing-word","desc":"给你一个字符串 licensePlate 和一个字符串数组 words ，请你找出并返回 words 中的 最短补全词 。","solutions":[{"date":"2021-12-10","time":88,"memory":41.9,"script":"typescript","desc":"哈希。","code":"function shortestCompletingWord(licensePlate: string, words: string[]): string {\n  const reg_lowchar = /[a-z]/;\n  const map: Record<string, number> = {};\n  for (const ch of licensePlate.toLowerCase()) {\n    if (reg_lowchar.test(ch)) map[ch] = (map[ch] ?? 0) + 1;\n  }\n  return words\n    .filter(word => {\n      const wmap = { ...map };\n      for (const ch of word) {\n        if (wmap[ch]) wmap[ch]--;\n      }\n      return Object.values(wmap).every(v => v <= 0);\n    })\n    .sort((a, b) => a.length - b.length)[0];\n}"}],"tagList":["数组","哈希表","字符串"],"level":"Easy"}},{"problemName":"752.打开转盘锁.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/752.打开转盘锁.json","problemData":{"id":"753","name":"752.打开转盘锁","url":"https://leetcode.cn/problems/open-the-lock","desc":"字符串 target 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。","solutions":[{"date":"2021-06-26","time":776,"memory":56.8,"script":"typescript","desc":"广度优先搜索，储存后进行遍历。","code":"function openLock(deadends: string[], target: string): number {\n  const prevMap: Record<string, string> = {\n    0: '9',\n    1: '0',\n    2: '1',\n    3: '2',\n    4: '3',\n    5: '4',\n    6: '5',\n    7: '6',\n    8: '7',\n    9: '8',\n  };\n  const nextMap: Record<string, string> = {\n    0: '1',\n    1: '2',\n    2: '3',\n    3: '4',\n    4: '5',\n    5: '6',\n    6: '7',\n    7: '8',\n    8: '9',\n    9: '0',\n  };\n  const INIT_STR = '0000';\n  const set = new Set(deadends);\n  if (set.has(INIT_STR)) return -1;\n  if (target === INIT_STR) return 0;\n  const queue = [INIT_STR];\n  const map = new Map<string, number>([[INIT_STR, 0]]);\n  let ans = Infinity;\n  const updateQueue = (str: string, index: number, dict: Record<string, string>, step: number) => {\n    const replaceStr = str.substring(0, index) + dict[str[index]] + str.substring(index + 1);\n    if (replaceStr === target) {\n      ans = Math.min(ans, step + 1);\n      return;\n    }\n    if (!set.has(replaceStr)) {\n      map.has(replaceStr) || queue.push(replaceStr);\n      map.set(replaceStr, Math.min(map.get(replaceStr) ?? Infinity, step + 1));\n    }\n  };\n  while (queue.length !== 0) {\n    const str = queue.shift()!;\n    const step = map.get(str)!;\n    for (let i = 0; i < 4; i++) {\n      updateQueue(str, i, prevMap, step);\n      updateQueue(str, i, nextMap, step);\n    }\n  }\n  return ans === Infinity ? -1 : ans;\n}"},{"date":"2021-07-25","time":200,"memory":49.1,"script":"typescript","desc":"bfs。","code":"function openLock(deadends: string[], target: string): number {\n  const headendSet = new Set(deadends);\n  if (headendSet.has('0000')) return -1;\n  const queue: [string, number][] = [['0000', 0]];\n  const set = new Set<string>(['0000']);\n  const getNext = (num: number) => (num + 1) % 10;\n  const getPrev = (num: number) => (num === 0 ? 10 : num) - 1;\n  const add = (str: string, count) => {\n    if (set.has(str) || headendSet.has(str)) return;\n    set.add(str);\n    queue.push([str, count]);\n  };\n  while (queue.length) {\n    const [str, count] = queue.shift()!;\n    if (str === target) return count;\n    for (let i = 0; i < 4; i++) {\n      const num = str.codePointAt(i)! - '0'.codePointAt(0)!;\n      add(str.substr(0, i) + getNext(num) + str.substr(i + 1), count + 1);\n      add(str.substr(0, i) + getPrev(num) + str.substr(i + 1), count + 1);\n    }\n  }\n  return -1;\n}"}],"tagList":["广度优先搜索","数组","哈希表","字符串"],"level":"Medium"}},{"problemName":"753.破解保险箱.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/753.破解保险箱.json","problemData":{"id":"754","name":"753.破解保险箱","url":"https://leetcode.cn/problems/cracking-the-safe","desc":"请返回一个能打开保险箱的最短字符串。","solutions":[{"date":"2023-01-10","time":24,"memory":28.6,"script":"cpp","desc":"dfs。","code":"class Solution {\npublic:\n    int n, k, nmax;\n    string ans;\n    unordered_set<string> visit;\n    string crackSafe(int n, int k) {\n        this->n = n;\n        this->k = k;\n        this->ans = \"\";\n        for (int i = 0; i < n; i++) ans += \"0\";\n        nmax = pow(k, n);\n        visit.insert(ans);\n        dfs(ans);\n        return ans;\n    }\n    bool dfs(string cur) {\n        string prefix = cur.substr(cur.size() - n + 1, n - 1);\n        if (visit.size() == nmax) {\n            ans = cur;\n            return true;\n        }\n        for (int i = 0; i < k; i++) {\n            string next = prefix + to_string(i);\n            if (visit.count(next)) continue;\n            visit.insert(next);\n            if (dfs(cur + to_string(i))) return true;\n            visit.erase(next);\n        }\n        return false;\n    }\n};"},{"date":"2023-01-10","time":12,"memory":19.6,"script":"rust","desc":"同上。","code":"use std::collections::HashSet;\nimpl Solution {\n    pub fn crack_safe(n: i32, k: i32) -> String {\n        let mut visit = HashSet::<String>::new();\n        let mut cur = String::new();\n        for _ in 0..n {\n            cur.push('0');\n        }\n        visit.insert(cur.clone());\n        Solution::dfs(n, k, &mut visit, cur).1\n    }\n    fn dfs<'a>(n: i32, k: i32, visit: &mut HashSet<String>, cur: String) -> (bool, String) {\n        if visit.len() == k.pow(n as u32) as usize {\n            (true, cur)\n        } else {\n            let pre = &cur[(cur.len() as i32 - n + 1) as usize..cur.len()];\n            for i in 0..k {\n                let mut next = String::from(pre);\n                next.push(char::from(i as u8 + '0' as u8));\n                if visit.contains(&next) {\n                    continue;\n                }\n                visit.insert(next.clone());\n                let mut cur = cur.clone();\n                cur.push(char::from(i as u8 + '0' as u8));\n                let res = Solution::dfs(n, k, visit, cur);\n                if res.0 {\n                    return res;\n                }\n                visit.remove(&next);\n            }\n\n            (false, \"\".to_string())\n        }\n    }\n}"}],"tagList":["深度优先搜索","图","欧拉回路"],"level":"Hard"}},{"problemName":"757.设置交集大小至少为2.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/757.设置交集大小至少为2.json","problemData":{"id":"759","name":"757.设置交集大小至少为2","url":"https://leetcode.cn/problems/set-intersection-size-at-least-two","desc":"输出这个最小集合 S 的大小。","solutions":[{"date":"2022-07-22","time":212,"memory":55,"script":"cpp","desc":"贪心,排序后对于两个区间进行假定,如果无交集则说明集合数加二,如果包容则说明只需考虑最小区间。","code":"class Solution {\n   public:\n    int intersectionSizeTwo(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end(),\n             [&](vector<int> a, vector<int> b) -> bool {\n                 return a[0] == b[0] ? a[1] > b[1] : a[0] < b[0];\n             });\n        int n = intervals.size(), l = intervals[n - 1][0], r = l + 1, ans = 2;\n        for (int i = n - 2; i >= 0; i--) {\n            if (intervals[i][1] >= r)\n                continue;\n            else if (intervals[i][1] < l) {\n                ans += 2;\n                l = intervals[i][0];\n                r = l + 1;\n            } else {\n                r = l;\n                l = intervals[i][0];\n                ans++;\n            }\n        }\n        return ans;\n    }\n};"},{"date":"2022-07-22","time":4,"memory":2.3,"script":"rust","desc":"同上。","code":"impl Solution {\n    pub fn intersection_size_two(intervals: Vec<Vec<i32>>) -> i32 {\n        let mut intervals = intervals;\n        intervals.sort_by(|v1, v2| {\n            if v1[0] == v2[0] {\n                v2.cmp(v1)\n            } else {\n                v1.cmp(v2)\n            }\n        });\n        let n = intervals.len() as i32;\n        let mut l = intervals[(n - 1) as usize][0];\n        let mut r = l + 1;\n        let mut ans = 2;\n        let mut i = n - 2;\n        while i >= 0 {\n            if intervals[i as usize][1] >= r {\n                i -= 1;\n                continue;\n            } else if intervals[i as usize][1] < l {\n                l = intervals[i as usize][0];\n                r = l + 1;\n                ans += 2;\n            } else {\n                r = l;\n                l = intervals[i as usize][0];\n                ans += 1;\n            }\n            i -= 1;\n        }\n        ans\n    }\n}"}],"tagList":["贪心","数组","排序"],"level":"Hard"}},{"problemName":"761.特殊的二进制序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/761.特殊的二进制序列.json","problemData":{"id":"763","name":"761.特殊的二进制序列","url":"https://leetcode.cn/problems/special-binary-string","desc":"在任意次数的操作之后，交换后的字符串按照字典序排列的最大的结果是什么。","solutions":[{"date":"2022-08-08","time":0,"memory":2.1,"script":"rust","desc":"当作左括号和右括号的匹配。","code":"impl Solution {\n    pub fn make_largest_special(s: String) -> String {\n        let s = s.chars().collect::<Vec<char>>();\n        Solution::_make_largest_special(&s, 0, s.len())\n    }\n    fn _make_largest_special(s: &Vec<char>, l: usize, r: usize) -> String {\n        if l >= r - 1 {\n            return String::new();\n        }\n        let (mut i, mut cnt, mut left, mut substrs) = (l, 0, l, Vec::<String>::new());\n        while i < r {\n            if s[i] == '1' {\n                cnt += 1;\n            } else {\n                cnt -= 1;\n                if cnt == 0 {\n                    substrs.push(format!(\n                        \"1{}0\",\n                        Solution::_make_largest_special(s, left + 1, i)\n                    ));\n                    left = i + 1;\n                }\n            }\n            i += 1;\n        }\n        substrs.sort_by(|s1, s2| s2.cmp(s1));\n        substrs.join(\"\")\n    }\n}"}],"tagList":["递归","字符串"],"level":"Hard"}},{"problemName":"762.二进制表示中质数个计算置位.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/762.二进制表示中质数个计算置位.json","problemData":{"id":"767","name":"762.二进制表示中质数个计算置位","url":"https://leetcode.cn/problems/prime-number-of-set-bits-in-binary-representation","desc":"给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。","solutions":[{"date":"2022-03-18","time":48,"memory":6,"script":"cpp","desc":"存储质数表，遍历。","code":"unordered_set<int> s = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31};\nclass Solution {\n   public:\n    int countPrimeSetBits(int left, int right) {\n        int ans = 0;\n        for (int i = left; i <= right; i++) {\n            if (s.count(getc(i))) ans++;\n        }\n        return ans;\n    }\n    int getc(int num) {\n        int ans = 0;\n        for (; num; num >>= 1) {\n            if (num & 1) ans++;\n        }\n        return ans;\n    }\n};"},{"date":"2022-04-05","time":36,"memory":5.8,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    int countPrimeSetBits(int left, int right) {\n        int ans = 0;\n        for (int i = left; i <= right; i++) {\n            if (is_prime(cnt(i))) ans++;\n        }\n        return ans;\n    }\n    int cnt(int num) {\n        int ans = 0;\n        for (; num; num >>= 1) {\n            if ((num & 1) == 1) ans++;\n        }\n        return ans;\n    }\n    bool is_prime(int num) {\n        if (num == 0 || num == 1) return 0;\n        for (int i = 2; i < num; i++) {\n            if (num % i == 0) return 0;\n        }\n        return 1;\n    }\n};"}],"tagList":["位运算","数学"],"level":"Easy"}},{"problemName":"764.最大加号标志.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/764.最大加号标志.json","problemData":{"id":"769","name":"764.最大加号标志","url":"https://leetcode.cn/problems/largest-plus-sign","desc":"返回 grid 中包含 1 的最大的 轴对齐 加号标志的阶数 。如果未找到加号标志，则返回 0 。","solutions":[{"date":"2022-11-09","time":1844,"memory":235.8,"script":"cpp","desc":"遍历统计每个点最上下左右的 1。","code":"struct Node {\n    int top, bottom, left, right;\n    Node(): top(0), bottom(0), left(0), right(0) {}\n};\nclass Solution {\npublic:\n    unordered_map<int, unordered_map<int, bool>> m;\n    int n;\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& mines) {\n        this->n = n;\n        for (auto &item : mines) m[item[0]][item[1]] = true;\n        int ans = 0;\n        vector<vector<Node>> list(n, vector<Node>(n));\n        for (int i = 0; i < n; i++) load_row(list, i), load_col(list, i);\n        // cout << \"n = \" << n << endl;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (m[i][j]) continue;\n                // cout << \"=====\" << endl << \"i = \" << i << \", j = \" << j << endl;\n                Node &node = list[i][j];\n                int left = j - node.left,\n                    right = node.right - j,\n                    top = i - node.top,\n                    bottom = node.bottom - i;\n                ans = max(ans, min(min(left, right), min(top, bottom)) + 1);\n                // cout << \"node_top = \" << list[i][j].top\n                //      << \", node_bottom = \" << list[i][j].bottom\n                //      << \", node_left = \" << list[i][j].left\n                //      << \", node_right = \" << list[i][j].right\n                //      << endl\n                //      << \"top = \" << top\n                //      << \", bottom = \" << bottom\n                //      << \", left = \" << left\n                //      << \", right = \" << right\n                //      << endl\n                //      << \"ans = \" << ans\n                //      << endl;\n            }\n        }\n        return ans;\n    }\n    void load_row(vector<vector<Node>> &list, int row) {\n        int l = 0;\n        for (int i = 0; i < n; i++) {\n            if (!m[row][i]) {\n                list[row][i].left = l;\n            } else {\n                l = i + 1;\n            }\n        }\n        int r = n - 1;\n        for (int i = n - 1; i >= 0; i--) {\n            if (!m[row][i]) {\n                list[row][i].right = r;\n            } else {\n                r = i - 1;\n            }\n        }\n    }\n    void load_col(vector<vector<Node>> &list, int col) {\n        int t = 0;\n        for (int i = 0; i < n; i++) {\n            if (!m[i][col]) {\n                list[i][col].top = t;\n            } else {\n                t = i + 1;\n            }\n        }\n        int b = n - 1;\n        for (int i = n - 1; i >= 0; i--) {\n            if (!m[i][col]) {\n                list[i][col].bottom = b;\n            } else {\n                b = i - 1;\n            }\n        }\n    }\n};"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"765.情侣牵手.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/765.情侣牵手.json","problemData":{"id":"770","name":"765.情侣牵手","url":"https://leetcode.cn/problems/couples-holding-hands","desc":"N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 一次交换可选择任意两人，让他们站起来交换座位。","solutions":[{"date":"2021-02-14","time":84,"memory":40.2,"script":"typescript","desc":"储存所有值进行交换。","code":"function minSwapsCouples(row: number[]): number {\n  const map: Record<number, number> = {};\n  row.forEach((num, i) => (map[num] = i));\n  const swap = (num1: number, num2: number) => {\n    [row[map[num1]], row[map[num2]]] = [row[map[num2]], row[map[num1]]];\n    [map[num1], map[num2]] = [map[num2], map[num1]];\n  };\n  let ans = 0;\n  for (let i = 0, l = row.length - 1; i < l - 1; i += 2) {\n    const num = row[i];\n    const nextNum = row[i + 1];\n    const needNum = num & 1 ? num - 1 : num + 1;\n    if (nextNum !== needNum) {\n      ans++;\n      swap(needNum, nextNum);\n    }\n  }\n  return ans;\n}"},{"script":"python","time":48,"memory":15.68,"desc":"贪心的每次没有匹配上去重置。","code":"class Solution:\n    def minSwapsCouples(self, row: List[int]) -> int:\n        n = len(row)\n        map = {row[i]: i for i in range(n)}\n        ans = 0\n        for i in range(0, n, 2):\n            if row[i] ^ 1 != row[i + 1]:\n                map[row[i + 1]] = map[row[i] ^ 1]\n                row[map[row[i] ^ 1]], row[i + 1] = row[i + 1], row[map[row[i] ^ 1]]\n                ans += 1\n        return ans","date":"2023-11-11"}],"tagList":["贪心","深度优先搜索","广度优先搜索","并查集","图"],"level":"Hard"}},{"problemName":"766.托普利茨矩阵.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/766.托普利茨矩阵.json","problemData":{"id":"777","name":"766.托普利茨矩阵","url":"https://leetcode.cn/problems/toeplitz-matrix","desc":"给你一个 m x n 的矩阵 matrix 。如果这个矩阵是托普利茨矩阵，返回 true ；否则，返回 false 。","solutions":[{"date":"2021-02-22","time":96,"memory":40.8,"script":"typescript","desc":"从起始值开始比较遍历所有值。","code":"function isToeplitzMatrix(matrix: number[][]): boolean {\n  const rowLen = matrix.length;\n  const colLen = matrix[0].length;\n  const check = (row: number, col: number) => {\n    const num = matrix[row][col];\n    while (row < rowLen && col < colLen) {\n      if (num !== matrix[row++][col++]) return false;\n    }\n    return true;\n  };\n  for (let i = 0; i < colLen; i++) if (!check(0, i)) return false;\n  for (let i = 0; i < rowLen; i++) if (!check(i, 0)) return false;\n  return true;\n}"}],"tagList":["数组","矩阵"],"level":"Easy"}},{"problemName":"768.最多能完成排序的块II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/768.最多能完成排序的块II.json","problemData":{"id":"779","name":"768.最多能完成排序的块II","url":"https://leetcode.cn/problems/max-chunks-to-make-sorted-ii","desc":"我们最多能将数组分成多少块？。","solutions":[{"date":"2022-08-15","time":8,"memory":11.8,"script":"cpp","desc":"单调栈，每次意味着左边块中所有的元素都小于右边块，如果不满足则合并。","code":"class Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        vector<int> s;\n        for (auto &num : arr) {\n            if (s.empty() || s[s.size() - 1] <= num) {\n                s.push_back(num);\n            } else {\n                int num_max = s[s.size() - 1];\n                while (s.size() && s[s.size() - 1] > num) s.pop_back();\n                s.push_back(num_max);\n            }\n        }\n        return s.size();\n    }\n};"}],"tagList":["栈","贪心","数组","排序","单调栈"],"level":"Hard"}},{"problemName":"769.最多能完成排序的块.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/769.最多能完成排序的块.json","problemData":{"id":"780","name":"769.最多能完成排序的块","url":"https://leetcode.cn/problems/max-chunks-to-make-sorted","desc":"返回数组能分成的最多块数量。","solutions":[{"date":"2022-10-13","time":4,"memory":7,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    int maxChunksToSorted(vector<int>& arr) {\n        int n = arr.size(), nmax = arr[0], ans = 0;\n        for (int i = 0; i < n; i++) {\n            nmax = max(nmax, arr[i]);\n            if (nmax == i) ans++;\n        }\n        return ans;\n    }\n};"}],"tagList":["栈","贪心","数组","排序","单调栈"],"level":"Medium"}},{"problemName":"771.宝石与石头.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/771.宝石与石头.json","problemData":{"id":"782","name":"771.宝石与石头","url":"https://leetcode.cn/problems/jewels-and-stones","desc":"给定字符串 J 代表石头中宝石的类型，和字符串 S 代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。","solutions":[{"date":"2020-10-02","time":92,"memory":39.9,"script":"typescript","desc":"利用哈希储存值。","code":"function numJewelsInStones(J: string, S: string): number {\n  const cache: Record<string, number> = {};\n  const setCache = (c: string) => (cache[c] = cache[c] ? cache[c] + 1 : 1);\n  const getCache = (c: string) => (cache[c] ? cache[c] : 0);\n  for (const c of S) setCache(c);\n  let sum = 0;\n  for (const c of J) sum += getCache(c);\n  return sum;\n}"},{"script":"cpp","time":0,"memory":6.1,"desc":"遍历。","code":"class Solution {\npublic:\n    int numJewelsInStones(string jewels, string stones) {\n        bool list[200] = {0};\n        for (auto &o : jewels) list[o] = true;\n        int sum = 0;\n        for (auto &c : stones) {\n            if (list[c]) sum++;\n        }\n        return sum;\n    }\n};","date":"2023-07-24"},{"script":"python","time":36,"memory":16,"desc":"同上。","code":"class Solution:\n    def numJewelsInStones(self, jewels: str, stones: str) -> int:\n        s = set(jewels)\n        return sum(o in s for o in stones)","date":"2023-07-24"},{"script":"rust","time":0,"memory":1.9,"desc":"同上。","code":"impl Solution {\n    pub fn num_jewels_in_stones(jewels: String, stones: String) -> i32 {\n        let mut list = [false; 200];\n        for c in jewels.bytes() {\n            list[c as usize] = true;\n        }\n        stones\n            .bytes()\n            .into_iter()\n            .filter(|c| list[*c as usize])\n            .collect::<Vec<_>>()\n            .len() as i32\n    }\n}","date":"2023-07-24"}],"tagList":["哈希表","字符串"],"level":"Easy"}},{"problemName":"773.滑动谜题.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/773.滑动谜题.json","problemData":{"id":"787","name":"773.滑动谜题","url":"https://leetcode.cn/problems/sliding-puzzle","desc":"给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。","solutions":[{"date":"2021-06-26","time":192,"memory":50.8,"script":"typescript","desc":"广度悠闲搜索，计算每次移动后的最小步数。","code":"function slidingPuzzle(board: number[][]): number {\n  const ANS_STR = '123,450';\n  const stringify = (board: (number | string)[][]) => board.map(v => v.join('')).join(',');\n  if (stringify(board) === ANS_STR) return 0;\n  const parse = (boardStr: string) => boardStr.split(',').map(v => v.split(''));\n  const getZeroIndex = (index: number): [number, number] =>\n    index <= 2 ? [0, index] : [1, index - 4];\n  const queue: string[] = [stringify(board)];\n  const map = new Map<string, number>([[queue[0], 0]]);\n  let ans = Infinity;\n  const updateMap = (newStr: string, step: number) => {\n    if (newStr === ANS_STR) ans = Math.min(ans, step + 1);\n    else {\n      map.has(newStr) || queue.push(newStr);\n      map.set(newStr, Math.min(map.get(newStr) ?? Infinity, step + 1));\n    }\n  };\n  const swap = (board: string[][], row1: number, col1: number, row2: number, col2: number) => {\n    [board[row1][col1], board[row2][col2]] = [board[row2][col2], board[row1][col1]];\n  };\n  while (queue.length !== 0) {\n    const boardStr = queue.shift()!;\n    const step = map.get(boardStr)!;\n    const [row, col] = getZeroIndex(boardStr.indexOf('0'));\n    const board = parse(boardStr);\n    if (row === 0) {\n      swap(board, row, col, row + 1, col);\n      updateMap(stringify(board), step);\n      swap(board, row, col, row + 1, col);\n    }\n    if (row === 1) {\n      swap(board, row, col, row - 1, col);\n      updateMap(stringify(board), step);\n      swap(board, row, col, row - 1, col);\n    }\n    if (col > 0) {\n      swap(board, row, col, row, col - 1);\n      updateMap(stringify(board), step);\n      swap(board, row, col, row, col - 1);\n    }\n    if (col < 2) {\n      swap(board, row, col, row, col + 1);\n      updateMap(stringify(board), step);\n      swap(board, row, col, row, col + 1);\n    }\n  }\n  return ans === Infinity ? -1 : ans;\n}"}],"tagList":["广度优先搜索","数组","矩阵"],"level":"Hard"}},{"problemName":"779.第K个语法符号.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/779.第K个语法符号.json","problemData":{"id":"795","name":"779.第K个语法符号","url":"https://leetcode.cn/problems/k-th-symbol-in-grammar","desc":"给定行数 n 和序数 k，返回第 n 行中第 k 个字符。","solutions":[{"date":"2022-10-20","time":4,"memory":5.9,"script":"cpp","desc":"当前层前半段和上层一样，第三段和第二段相同，第一段和第四段相同。","code":"class Solution {\npublic:\n    int kthGrammar(int n, int k) {\n        if (n == 1) return 0;\n        else if (n == 2) return k == 1 ? 0 : 1;\n        int nmax = pow(2, n - 1), nextK = k;\n        if (k > nmax / 2 && k <= nmax / 4 * 3) nextK = k - nmax / 2 + nmax / 4;\n        else if (k > nmax / 4 * 3) nextK = k - nmax / 2 - nmax / 4;\n        return kthGrammar(n - 1, nextK);\n    }\n};"}],"tagList":["位运算","递归","数学"],"level":"Medium"}},{"problemName":"780.到达终点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/780.到达终点.json","problemData":{"id":"796","name":"780.到达终点","url":"https://leetcode.cn/problems/reaching-points","desc":"给定四个整数  sx , sy ，tx  和  ty，如果通过一系列的转换可以从起点  (sx, sy)  到达终点  (tx, ty)，则返回 true，否则返回  false。","solutions":[{"date":"2022-04-09","time":0,"memory":5.7,"script":"cpp","desc":"从目标节点减至初始节点的方法只有一种。","code":"class Solution {\n   public:\n    bool reachingPoints(int sx, int sy, int tx, int ty) {\n        while (tx > 0 && ty > 0) {\n            if (tx == sx && ty == sy) return true;\n            if (tx >= ty)\n                tx -= max((tx - sx) / ty, 1) * ty;\n            else\n                ty -= max((ty - sy) / tx, 1) * tx;\n        }\n        return false;\n    }\n};"}],"tagList":["数学"],"level":"Hard"}},{"problemName":"781.森林中的兔子.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/781.森林中的兔子.json","problemData":{"id":"797","name":"781.森林中的兔子","url":"https://leetcode.cn/problems/rabbits-in-forest","desc":"返回森林中兔子的最少数量。","solutions":[{"date":"2021-04-04","time":92,"memory":40.2,"script":"typescript","desc":"统计兔子说的数进行运算。","code":"function numRabbits(answers: number[]): number {\n  const map = new Map<number, number>();\n  for (const ans of answers) map.set(ans, (map.get(ans) ?? 0) + 1);\n  let ans = 0;\n  for (const [k, v] of map) {\n    if (k === 0) ans += v;\n    else if (k + 1 >= v) ans += k + 1;\n    else {\n      const count = ~~(v / (k + 1)) + +!!~~(v % (k + 1));\n      ans += count * (k + 1);\n    }\n  }\n  return ans;\n}"}],"tagList":["贪心","数组","哈希表","数学"],"level":"Medium"}},{"problemName":"783.二叉搜索树节点最小距离.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/783.二叉搜索树节点最小距离.json","problemData":{"id":"799","name":"783.二叉搜索树节点最小距离","url":"https://leetcode.cn/problems/minimum-distance-between-bst-nodes","desc":"给定一个二叉搜索树的根结点 root, 返回树中任意两节点的差的最小值。","solutions":[{"date":"2020-02-23","time":0,"memory":36.9,"script":"java","desc":"中序遍历排序后，获取相邻元素之间的差判断最小值。","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n\tArrayList<Integer> list = new ArrayList<Integer>();\n\tpublic int minDiffInBST(TreeNode root) {\n\t\tinorder(root);\n\t\tint min = list.get(1) - list.get(0);\n\t\tfor (int i = 0, len = list.size() - 1; i < len; i++)\n\t\t\tmin=Math.min(list.get(i + 1) - list.get(i), min);\n\t\treturn min;\n\t}\n\tpublic void inorder(TreeNode node) {\n\t\tif (node.left != null) {\n\t\t\tinorder(node.left);\n\t\t}\n\t\tlist.add(node.val);\n\t\tif (node.right != null) {\n\t\t\tinorder(node.right);\n\t\t}\n\t}\n}"},{"date":"2021-04-13","time":88,"memory":39.8,"script":"typescript","desc":"中序遍历。","code":"function minDiffInBST(root: TreeNode | null): number {\n  if (root === null) return 0;\n  const arr: number[] = [];\n  const inorder = (node: TreeNode | null) => {\n    if (node === null) return;\n    inorder(node.left);\n    arr.push(node.val);\n    inorder(node.right);\n  };\n  inorder(root);\n  let min = Infinity;\n  for (let i = 1, l = arr.length; i < l; i++) {\n    min = Math.min(min, arr[i] - arr[i - 1]);\n  }\n  return min;\n}"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉搜索树","二叉树"],"level":"Easy"}},{"problemName":"784.字母大小写全排列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/784.字母大小写全排列.json","problemData":{"id":"800","name":"784.字母大小写全排列","url":"https://leetcode.cn/problems/letter-case-permutation","desc":"返回 所有可能得到的字符串集合 。以 任意顺序 返回输出。","solutions":[{"date":"2022-10-30","time":4,"memory":9.8,"script":"cpp","desc":"模拟。","code":"class Solution {\npublic:\n    vector<string> letterCasePermutation(string s) {\n        vector<string> list;\n        dfs(list, s, 0, \"\");\n        return list;\n    }\n    void dfs(vector<string> &list, string &s, int idx, string &&cur) {\n        if (idx == s.size()) {\n            list.push_back(cur);\n            return;\n        }\n        dfs(list, s, idx + 1, cur + s[idx]);\n        if (s[idx] >= 'A' && s[idx] <= 'Z' || s[idx] >= 'a' && s[idx] <= 'z') {\n            dfs(list, s, idx + 1, cur + static_cast<char>(s[idx] ^ 0b100000));\n        }\n    }\n};"}],"tagList":["位运算","字符串","回溯"],"level":"Medium"}},{"problemName":"785.判断二分图.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/785.判断二分图.json","problemData":{"id":"801","name":"785.判断二分图","url":"https://leetcode.cn/problems/is-graph-bipartite","desc":"给定一个无向图 graph，当这个图为二分图时返回 true。","solutions":[{"date":"2020-07-16","time":84,"memory":38,"script":"typescript","desc":"遍历后采取红绿刷色。","code":"function isBipartite(graph: number[][]): boolean {\n  enum Color {\n    red,\n    green,\n    none,\n  }\n  const len = graph.length;\n  let valid = true;\n  const colors = new Array<Color>(len).fill(Color.none);\n  for (let i = 0; i < len && valid; i++) {\n    colors[i] === Color.none && dfs(i, Color.red);\n  }\n  return valid;\n  function dfs(node: number, color: Color): void {\n    colors[node] = color;\n    const newColor = color === Color.red ? Color.green : Color.red;\n    for (const neighbor of graph[node]) {\n      if (colors[neighbor] === Color.none) {\n        dfs(neighbor, newColor);\n        if (!valid) return;\n      } else if (colors[neighbor] !== newColor) {\n        valid = false;\n        return;\n      }\n    }\n  }\n}"}],"tagList":["深度优先搜索","广度优先搜索","并查集","图"],"level":"Medium"}},{"problemName":"786.第K个最小的质数分数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/786.第K个最小的质数分数.json","problemData":{"id":"802","name":"786.第K个最小的质数分数","url":"https://leetcode.cn/problems/k-th-smallest-prime-fraction","desc":"给你一个按递增顺序排序的数组 arr 和一个整数 k 。数组 arr 由 1 和若干 素数   组成，且其中所有整数互不相同。对于每对满足 0 < i < j < arr.length 的 i 和 j ，可以得到分数 arr[i] / arr[j] 。那么第  k  个最小的分数是多少呢? 。","solutions":[{"date":"2021-11-29","time":1804,"memory":95.9,"script":"typescript","desc":"排序。","code":"function kthSmallestPrimeFraction(arr: number[], k: number): number[] {\n  const n = arr.length;\n  const list: number[][] = [];\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      list.push([arr[i], arr[j]]);\n    }\n  }\n  list.sort(([num11, num12], [num21, num22]) => num11 / num12 - num21 / num22);\n  return list[k - 1];\n}"}],"tagList":["数组","双指针","二分查找","排序","堆（优先队列）"],"level":"Medium"}},{"problemName":"787.K站中转内最便宜的航班.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/787.K站中转内最便宜的航班.json","problemData":{"id":"803","name":"787.K站中转内最便宜的航班","url":"https://leetcode.cn/problems/cheapest-flights-within-k-stops","desc":"现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k  站中转的路线，使得从 src 到 dst 的 价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。","solutions":[{"date":"2021-08-24","time":128,"memory":44.6,"script":"typescript","desc":"动态规划，计算每天每个航班的最小值。","code":"function findCheapestPrice(\n  n: number,\n  flights: number[][],\n  src: number,\n  dst: number,\n  k: number\n): number {\n  const map = new Map<number, number[]>();\n  for (let i = 0; i < flights.length; i++) {\n    const [from] = flights[i];\n    let list = map.get(from);\n    if (!list) map.set(from, (list = []));\n    list.push(i);\n  }\n  const dp = new Array(k + 2).fill(0).map(_ => new Array(n).fill(Infinity));\n  dp[0][src] = 0;\n  let ans = Infinity;\n  for (let i = 1; i <= k + 1; i++) {\n    for (let j = 0; j < n; j++) {\n      if (dp[i - 1][j] === Infinity) continue;\n      const list = map.get(j);\n      if (!list) continue;\n      for (const flightIdx of list) {\n        const [, to, price] = flights[flightIdx];\n        dp[i][to] = Math.min(dp[i][to], dp[i - 1][j] + price);\n        if (to === dst) ans = Math.min(dp[i][to], ans);\n      }\n    }\n  }\n  return ans === Infinity ? -1 : ans;\n}"}],"tagList":["深度优先搜索","广度优先搜索","图","动态规划","最短路","堆（优先队列）"],"level":"Medium"}},{"problemName":"788.旋转数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/788.旋转数字.json","problemData":{"id":"804","name":"788.旋转数字","url":"https://leetcode.cn/problems/rotated-digits","desc":"现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？。","solutions":[{"date":"2022-09-25","time":4,"memory":6.8,"script":"cpp","desc":"动态规划，每次从前面状态推进。","code":"class Solution {\npublic:\n    // 0 -> 无法旋转\n    // 1 -> 旋转后是本身\n    // 2 -> 旋转后不是本身\n    int rotatedDigits(int n) {\n        vector<int> list(n + 1, 0);\n        int ans = 0;\n        for (int i = 1; i <= n; i++) {\n            if (i < 10) {\n                switch (i) {\n                    case 0:\n                    case 1:\n                    case 8: list[i] = 1; break;\n                    case 2:\n                    case 5:\n                    case 6:\n                    case 9: list[i] = 2; break;\n                    default: list[i] = 0; break;\n                }\n            } else {\n                int num1 = i / 10, num2 = i % 10;\n                if (list[num1] == 0 || num2 == 3 || num2 == 4 || num2 == 7) list[i] = 0;\n                else if (list[num1] == 1) list[i] = num2 == 0 || num2 == 1 || num2 == 8 ? 1 : 2;\n                else list[i] = 2;\n            }\n            if (list[i] == 2) ans++;\n        }\n        return ans;\n    }\n};"},{"date":"2022-09-25","time":4,"memory":5.8,"script":"cpp","desc":"动态规划，每次构造相同位数的数字。","code":"class Solution {\npublic:\n    int rotatedDigits(int n) {\n        int len = get_len(n), list[3] = {0}, ans = 0;\n        dfs(len, n, list, 0, 0, ans);\n        return ans;\n    }\n    void dfs(int len, int n, int (&list)[3], int num, int cnt, int &ans) {\n        if (num > n) return;\n        if (cnt == len) {\n            if (list[0] == 0 && list[2] > 0) ans++;\n            // cout << \"len = \" << len\n            //      << \", list = [\" << list[0] << \", \" << list[1] << \", \" << list[2]\n            //      << \"], num = \" << num << \", cnt = \" << cnt << \", ans = \" << ans << endl;\n            return;\n        }\n        for (int i = 0; i < 10; i++) {\n            list[get_tag(i)]++;\n            dfs(len, n, list, num * 10 + i, cnt + 1, ans);\n            list[get_tag(i)]--;\n        }\n    }\n    int get_len(int n) {\n        int ans = 0;\n        while (n) n /= 10, ans++;\n        return ans;\n    }\n    int get_tag(int n) {\n        switch (n) {\n            case 0:\n            case 1:\n            case 8: return 1;\n            case 2:\n            case 5:\n            case 6:\n            case 9: return 2;\n            default: return 0;\n        }\n    }\n};"},{"date":"2022-09-25","time":0,"memory":5.7,"script":"cpp","desc":"同上，优化非倒数。","code":"class Solution {\npublic:\n    int rotatedDigits(int n) {\n        int len = get_len(n), list[2] = {0}, ans = 0;\n        dfs(len, n, list, 0, 0, ans);\n        return ans;\n    }\n    void dfs(int len, int n, int (&list)[2], int num, int cnt, int &ans) {\n        if (num > n) return;\n        if (cnt == len) {\n            if (list[1] > 0) ans++;\n            return;\n        }\n        for (int i = 0; i < 10; i++) {\n            int tag = get_tag(i);\n            if (tag == -1) continue;\n            list[tag]++;\n            dfs(len, n, list, num * 10 + i, cnt + 1, ans);\n            list[tag]--;\n        }\n    }\n    int get_len(int n) {\n        int ans = 0;\n        while (n) n /= 10, ans++;\n        return ans;\n    }\n    int get_tag(int n) {\n        switch (n) {\n            case 0:\n            case 1:\n            case 8: return 0;\n            case 2:\n            case 5:\n            case 6:\n            case 9: return 1;\n            default: return -1;\n        }\n    }\n};"}],"tagList":["数学","动态规划"],"level":"Medium"}},{"problemName":"789.逃脱阻碍者.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/789.逃脱阻碍者.json","problemData":{"id":"805","name":"789.逃脱阻碍者","url":"https://leetcode.cn/problems/escape-the-ghosts","desc":"你在进行一个简化版的吃豆人游戏。 只有在你有可能成功逃脱时，输出 true ；否则，输出 false 。","solutions":[{"date":"2021-08-22","time":84,"memory":39.4,"script":"typescript","desc":"曼哈顿距离，只有阻碍者比起始点远才可到达。","code":"function escapeGhosts(ghosts: number[][], target: number[]): boolean {\n  const comp = (x: number, y: number): number => Math.abs(x - target[0]) + Math.abs(y - target[1]);\n  const distance = comp(0, 0);\n  for (const ghost of ghosts) {\n    if (comp(...(ghost as [number, number])) <= distance) return false;\n  }\n  return true;\n}"}],"tagList":["数组","数学"],"level":"Medium"}},{"problemName":"790.多米诺和托米诺平铺.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/790.多米诺和托米诺平铺.json","problemData":{"id":"806","name":"790.多米诺和托米诺平铺","url":"https://leetcode.cn/problems/domino-and-tromino-tiling","desc":"给定整数 n ，返回可以平铺 2 x n 的面板的方法的数量。","solutions":[{"date":"2022-11-12","time":0,"memory":5.7,"script":"cpp","desc":"dp。","code":"class Solution {\npublic:\n    const int mod = 1e9 + 7;\n    // j = 0 平整\n    // j = 1 上空\n    // j = 2 下空\n    int dp[1005][3] = {0};\n    int numTilings(int n) {\n        dp[1][0] = 1;\n        dp[2][0] = 2;\n        dp[2][1] = 1;\n        dp[2][2] = 1;\n        for (int i = 3; i <= n; i++) {\n            dp[i][0] = (dp[i][0] + dp[i - 1][0]) % mod;\n            dp[i][0] = (dp[i][0] + dp[i - 2][0]) % mod;\n            dp[i][0] = (dp[i][0] + dp[i - 1][1]) % mod;\n            dp[i][0] = (dp[i][0] + dp[i - 1][2]) % mod;\n            dp[i][1] = (dp[i][1] + dp[i - 2][0] + dp[i - 1][2]) % mod;\n            dp[i][2] = (dp[i][2] + dp[i - 2][0] + dp[i - 1][1]) % mod;\n        }\n        return dp[n][0];\n    }\n};"}],"tagList":["动态规划"],"level":"Medium"}},{"problemName":"791.自定义字符串排序.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/791.自定义字符串排序.json","problemData":{"id":"807","name":"791.自定义字符串排序","url":"https://leetcode.cn/problems/custom-sort-string","desc":"返回 满足这个性质的 s 的任意排列 。","solutions":[{"date":"2022-11-13","time":0,"memory":6.1,"script":"cpp","desc":"遍历后排序。","code":"class Solution {\npublic:\n    string customSortString(string order, string s) {\n        int list[26] = {0};\n        for (int i = 0; i < order.size(); i++) list[order[i] - 'a'] = i;\n        sort(s.begin(), s.end(), [&list](char &a, char &b){ return list[a - 'a'] < list[b - 'a']; });\n        return s;\n    }\n};"}],"tagList":["哈希表","字符串","排序"],"level":"Medium"}},{"problemName":"792.匹配子序列的单词数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/792.匹配子序列的单词数.json","problemData":{"id":"808","name":"792.匹配子序列的单词数","url":"https://leetcode.cn/problems/number-of-matching-subsequences","desc":"给定字符串 s 和字符串数组 words, 返回 words[i] 中是 s 的子序列的单词个数 。","solutions":[{"date":"2022-11-17","time":184,"memory":50.2,"script":"cpp","desc":"把 s 的每个坐标存入后，进行二分。","code":"class Solution {\npublic:\n    int numMatchingSubseq(string s, vector<string>& words) {\n        vector<vector<int>> list(26);\n        for (int i = 0; i < s.size(); i++) list[s[i] - 'a'].push_back(i);\n        int ans = 0;\n        for (auto &word : words) {\n            if (word.size() > s.size()) continue;\n            int p = -1;\n            bool f = true;\n            for (auto &c : word) {\n                auto &ilist = list[c - 'a'];\n                auto it = upper_bound(ilist.begin(), ilist.end(), p);\n                if (it == ilist.end()) {\n                    f = false;\n                    break;\n                }\n                if (!f) break;\n                p = *it;\n            }\n            if (f) ans++;\n        }\n        return ans;\n    }\n};"}],"tagList":["字典树","数组","哈希表","字符串","二分查找","动态规划","排序"],"level":"Medium"}},{"problemName":"793.阶乘函数后K个零.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/793.阶乘函数后K个零.json","problemData":{"id":"809","name":"793.阶乘函数后K个零","url":"https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function","desc":"给定 k，找出返回能满足 f(x) = k 的非负整数 x 的数量。","solutions":[{"date":"2022-08-28","time":0,"memory":5.8,"script":"cpp","desc":"层序遍历。","code":"class Solution {\npublic:\n    int preimageSizeFZF(int k) {\n        return help(k + 1) - help(k);\n    }\n    long long help(int k) {\n        long long l = 0, r = 5LL * k;\n        while (l < r) {\n            long long mid = (l + r) / 2;\n            if (get_cnt(mid) >= k) r = mid;\n            else l = mid + 1;\n        }\n        return l;\n    }\n    int get_cnt(int num) {\n        int cnt = 0;\n        while (num) {\n            cnt += num / 5;\n            num /= 5;\n        }\n        return cnt;\n    }\n};"}],"tagList":["数学","二分查找"],"level":"Hard"}},{"problemName":"794.有效的井字游戏.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/794.有效的井字游戏.json","problemData":{"id":"810","name":"794.有效的井字游戏","url":"https://leetcode.cn/problems/valid-tic-tac-toe-state","desc":"给你一个字符串数组 board 表示井字游戏的棋盘。当且仅当在井字游戏过程中，棋盘有可能达到 board 所显示的状态时，才返回 true 。","solutions":[{"date":"2021-12-09","time":76,"memory":39.3,"script":"typescript","desc":"检测数量是否相等或 x 多一个，检测是否不同时获胜，检测 x 获胜时，x 多一个，o 获胜时 o 与 x 数量相等。","code":"function validTicTacToe(board: string[]): boolean {\n  let cntO = 0,\n    cntX = 0,\n    checkO = check('O'),\n    checkX = check('X');\n  for (let i = 0; i < 3; i++) {\n    for (let j = 0; j < 3; j++) {\n      const ch = board[i][j];\n      if (ch === 'X') cntX++;\n      else if (ch === 'O') cntO++;\n    }\n  }\n  if (\n    (cntO !== cntX && cntO !== cntX - 1) ||\n    (checkO && checkX) ||\n    (checkO && cntO !== cntX) ||\n    (checkX && cntO !== cntX - 1)\n  )\n    return false;\n  return true;\n  function check(ch: string) {\n    return (\n      (board[0][0] === ch && board[0][1] === ch && board[0][2] === ch) ||\n      (board[1][0] === ch && board[1][1] === ch && board[1][2] === ch) ||\n      (board[2][0] === ch && board[1][2] === ch && board[2][2] === ch) ||\n      (board[0][0] === ch && board[1][0] === ch && board[2][0] === ch) ||\n      (board[0][1] === ch && board[1][1] === ch && board[2][1] === ch) ||\n      (board[0][2] === ch && board[1][2] === ch && board[2][2] === ch) ||\n      (board[0][0] === ch && board[1][1] === ch && board[2][2] === ch) ||\n      (board[0][2] === ch && board[1][1] === ch && board[2][0] === ch)\n    );\n  }\n}"}],"tagList":["数组","矩阵"],"level":"Medium"}},{"problemName":"795.区间子数组个数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/795.区间子数组个数.json","problemData":{"id":"811","name":"795.区间子数组个数","url":"https://leetcode.cn/problems/number-of-subarrays-with-bounded-maximum","desc":"给你一个整数数组 nums 和两个整数：left 及 right 。找出 nums 中连续、非空且其中最大元素在范围  [left, right] 内的子数组，并返回满足条件的子数组的个数。","solutions":[{"date":"2022-11-24","time":108,"memory":56.3,"script":"cpp","desc":"单调栈求出每个点最近比他大的左值和右值，判断当前点是最大值的情况。","code":"class Solution {\npublic:\n    int numSubarrayBoundedMax(vector<int>& nums, int left, int right) {\n        int n = nums.size(), ans = 0;\n        vector<int> llist(n, -1), rlist(n, n);\n        stack<int> s;\n        for (int i = 0; i < n; i++) {\n            while (s.size() && nums[s.top()] <= nums[i]) {\n                rlist[s.top()] = i;\n                s.pop();\n            }\n            llist[i] = s.empty() ? -1 : s.top();\n            s.push(i);\n        }\n        for (int i = 0; i < n; i++) {\n            if (nums[i] > right || nums[i] < left) continue;\n            int left = i - llist[i] - 1, right = rlist[i] - i;\n            ans += left + right + (left * (right - 1));\n        }\n        return ans;\n    }\n};"},{"date":"2022-11-24","time":48,"memory":51.1,"script":"cpp","desc":"一次遍历，统计出不包含>right 的值且最少包含一个>=left 的值的个数。","code":"class Solution {\npublic:\n    int numSubarrayBoundedMax(vector<int>& nums, int left, int right) {\n        int n = nums.size(), ans = 0, prev = -1, cur = -1;\n        for (int i = 0; i < n; i++) {\n            if (nums[i] <= right && nums[i] >= left) cur = i;\n            else if (nums[i] > right) prev = i, cur = -1;\n            if (cur != -1) ans += cur - prev;\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","双指针"],"level":"Medium"}},{"problemName":"796.旋转字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/796.旋转字符串.json","problemData":{"id":"812","name":"796.旋转字符串","url":"https://leetcode.cn/problems/rotate-string","desc":"给定两个字符串, s 和 goal。如果在若干次旋转操作之后，s 能变成 goal ，那么返回 true 。","solutions":[{"date":"2022-03-18","time":0,"memory":6.1,"script":"cpp","desc":"找到所有下标起始点进行遍历。","code":"class Solution {\n   public:\n    bool rotateString(string s, string goal) {\n        if (s.size() != goal.size()) return false;\n        vector<int> idxs = findidx(s, goal[0]);\n        for (auto &idx : idxs) {\n            if (check(s, goal, idx)) return true;\n        }\n        return false;\n    }\n    bool check(const string &s, const string &goal, const int &idx) {\n        int i1 = idx, i2 = 0, n = s.size();\n        while (i2 < n) {\n            if (s[i1] != goal[i2]) return false;\n            i1 = (i1 + 1) % s.size();\n            i2++;\n        }\n        return true;\n    }\n    vector<int> findidx(const string &s, const char &ch) {\n        vector<int> ans;\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == ch) ans.push_back(i);\n        }\n        return ans;\n    }\n};"},{"date":"2022-04-07","time":0,"memory":6,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    int n;\n    bool rotateString(string s, string goal) {\n        n = s.size();\n        vector<int> list;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == goal[0]) list.push_back(i);\n        }\n        for (auto &start : list) {\n            if (check(s, goal, start)) return true;\n        }\n        return false;\n    }\n    bool check(string &s, string &goal, int start) {\n        for (int i = 0; i < n; i++, start = (start + 1) % n) {\n            if (s[start] != goal[i]) return false;\n        }\n        return true;\n    }\n};"}],"tagList":["字符串","字符串匹配"],"level":"Easy"}},{"problemName":"797.所有可能的路径.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/797.所有可能的路径.json","problemData":{"id":"813","name":"797.所有可能的路径","url":"https://leetcode.cn/problems/all-paths-from-source-to-target","desc":"给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出。","solutions":[{"date":"2021-08-25","time":136,"memory":45.4,"script":"typescript","desc":"dfs。","code":"class GNode {\n  prev: GNode[] = [];\n  next: GNode[] = [];\n  constructor(public val: number) {}\n}\nfunction allPathsSourceTarget(graph: number[][]): number[][] {\n  const n = graph.length;\n  const list: GNode[] = new Array(n);\n  for (let i = 0; i < n; i++) {\n    let node = list[i];\n    if (!node) list[i] = node = new GNode(i);\n    const nextList = graph[i];\n    for (const next of nextList) {\n      let nextNode = list[next];\n      if (!nextNode) list[next] = nextNode = new GNode(next);\n      node.next.push(nextNode);\n      nextNode.prev.push(node);\n    }\n  }\n  const ans: number[][] = [];\n  dfs(list[0]);\n  return ans;\n  function dfs(node: GNode, list: GNode[] = []) {\n    list.push(node);\n    if (node.val === n - 1) ans.push(list.map(v => v.val));\n    if (node.next.length !== 0) node.next.forEach(v => dfs(v, list));\n    list.pop();\n  }\n}"},{"date":"2021-08-25","time":160,"memory":49,"script":"typescript","desc":"dfs。","code":"function allPathsSourceTarget(graph: number[][]): number[][] {\n  const n = graph.length;\n  const ans: number[][] = [];\n  dfs(0);\n  return ans;\n  function dfs(node: number, list: number[] = []) {\n    list.push(node);\n    if (node === n - 1) ans.push(list.slice());\n    graph[node].forEach(v => dfs(v, list));\n    list.pop();\n  }\n}"}],"tagList":["深度优先搜索","广度优先搜索","图","回溯"],"level":"Medium"}},{"problemName":"798.得分最高的最小轮调.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/798.得分最高的最小轮调.json","problemData":{"id":"814","name":"798.得分最高的最小轮调","url":"https://leetcode.cn/problems/smallest-rotation-with-highest-score","desc":"在所有可能的轮调中，返回我们所能得到的最高分数对应的轮调下标 k 。如果有多个答案，返回满足条件的最小的下标 k 。","solutions":[{"date":"2022-03-09","time":92,"memory":70.1,"script":"cpp","desc":"统计每个点可实现的 k 区间，利用差分加速。","code":"class Solution {\n   public:\n    int list[100001] = {0};\n    int bestRotation(vector<int>& nums) {\n        int n = nums.size();\n        for (int i = 0; i < n; i++) {\n            if (i >= nums[i]) {\n                list[0]++;\n                list[i - nums[i] + 1]--;\n            }\n            list[i + 1]++;\n            list[min(i + n - nums[i] + 1, n)]--;\n        }\n        int ans = 0, ansnum = 0, sum = 0;\n        for (int i = 1; i <= n; i++) {\n            sum += list[i];\n            if (sum > ansnum) {\n                ans = i;\n                ansnum = sum;\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","前缀和"],"level":"Hard"}},{"problemName":"799.香槟塔.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/701-800/799.香槟塔.json","problemData":{"id":"815","name":"799.香槟塔","url":"https://leetcode.cn/problems/champagne-tower","desc":"现在当倾倒了非负整数杯香槟后，返回第 i 行 j 个玻璃杯所盛放的香槟占玻璃杯容积的比例（ i 和 j 都从 0 开始）。","solutions":[{"date":"2022-11-20","time":12,"memory":13.7,"script":"cpp","desc":"模拟。","code":"class Solution {\npublic:\n    double champagneTower(int poured, int query_row, int query_glass) {\n        vector<vector<double>> dp(query_row + 1, vector<double>(query_row + 1, 0.0));\n        dp[0][0] = (double)poured;\n        for (int i = 1; i <= query_row; i++) {\n            if (dp[i - 1][0] > 1.0) dp[i][0] = dp[i][i] = (dp[i - 1][0] - 1) / 2;\n            for (int j = 1; j < i; j++) {\n                if (dp[i - 1][j - 1] > 1.0) dp[i][j] += (dp[i - 1][j - 1] - 1) / 2;\n                if (dp[i - 1][j] > 1.0) dp[i][j] += (dp[i - 1][j] - 1) / 2;\n            }\n        }\n        return min(1.0, dp[query_row][query_glass]);\n    }\n};"},{"date":"2022-11-20","time":16,"memory":13.7,"script":"cpp","desc":"模拟。","code":"class Solution {\npublic:\n    double champagneTower(int poured, int query_row, int query_glass) {\n        vector<vector<double>> dp(query_row + 1, vector<double>(query_row + 1, 0.0));\n        dp[0][0] = (double)poured;\n        for (int i = 0; i < query_row; i++) {\n            for (int j = 0; j <= i; j++) {\n                if (dp[i][j] <= 1.0) continue;\n                double val = (dp[i][j] - 1) / 2;\n                dp[i + 1][j] += val;\n                dp[i + 1][j + 1] += val;\n            }\n        }\n        return min(1.0, dp[query_row][query_glass]);\n    }\n};"}],"tagList":["动态规划"],"level":"Medium"}}]},{"dirName":"801-900","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\801-900","problems":[{"problemName":"801.使序列递增的最小交换次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/801.使序列递增的最小交换次数.json","problemData":{"id":"819","name":"801.使序列递增的最小交换次数","url":"https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing","desc":"返回 使 nums1 和 nums2 严格递增 所需操作的最小次数 。","solutions":[{"date":"2022-10-10","time":236,"memory":117.2,"script":"cpp","desc":"dp[i][0|1]表示 i 为结尾下标时，交换和不交换的最小交换次数。","code":"class Solution {\npublic:\n    int minSwap(vector<int>& nums1, vector<int>& nums2) {\n        int n = nums1.size();\n        vector<vector<int>> dp(n, vector<int>(2, n));\n        dp[0][0] = 0;\n        dp[0][1] = 1;\n        for (int i = 1; i < n; i++) {\n            if (nums1[i - 1] < nums1[i] && nums2[i - 1] < nums2[i]) {\n                dp[i][0] = min(dp[i][0], dp[i - 1][0]);\n                dp[i][1] = min(dp[i][1], dp[i - 1][1] + 1);\n            }\n            if (nums1[i - 1] < nums2[i] && nums2[i - 1] < nums1[i]) {\n                dp[i][0] = min(dp[i][0], dp[i - 1][1]);\n                dp[i][1] = min(dp[i][1], dp[i - 1][0] + 1);\n            }\n        }\n        return min(dp[n - 1][0], dp[n - 1][1]);\n    }\n};"}],"tagList":["数组","动态规划"],"level":"Hard"}},{"problemName":"802.找到最终的安全状态.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/802.找到最终的安全状态.json","problemData":{"id":"820","name":"802.找到最终的安全状态","url":"https://leetcode.cn/problems/find-eventual-safe-states","desc":"返回一个由图中所有安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。","solutions":[{"date":"2021-08-05","time":204,"memory":53.8,"script":"typescript","desc":"dfs。","code":"function eventualSafeNodes(graph: number[][]): number[] {\n  const n = graph.length;\n  const ans = new Map<number, boolean>();\n  const set = new Set<number>();\n  for (let i = 0; i < n; i++) dfs(i);\n  function dfs(idx: number) {\n    if (set.has(idx)) return false;\n    if (ans.has(idx)) return ans.get(idx);\n    if (graph[idx].length === 0) {\n      ans.set(idx, true);\n      return true;\n    }\n    set.add(idx);\n    let f = true;\n    for (const next of graph[idx]) {\n      if (!dfs(next)) {\n        f = false;\n        break;\n      }\n    }\n    set.delete(idx);\n    ans.set(idx, f);\n    return f;\n  }\n  return [...ans.entries()]\n    .filter(([, f]) => f)\n    .map(([val]) => val)\n    .sort((a, b) => a - b);\n}"}],"tagList":["深度优先搜索","广度优先搜索","图","拓扑排序"],"level":"Medium"}},{"problemName":"804.唯一摩尔斯密码词.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/804.唯一摩尔斯密码词.json","problemData":{"id":"822","name":"804.唯一摩尔斯密码词","url":"https://leetcode.cn/problems/unique-morse-code-words","desc":"对 words 中所有单词进行单词翻译，返回不同 单词翻译 的数量。","solutions":[{"date":"2022-03-19","time":0,"memory":8.2,"script":"cpp","desc":"哈希去重。","code":"const string l[26] = {\".-\",   \"-...\", \"-.-.\", \"-..\",  \".\",    \"..-.\", \"--.\",\n                      \"....\", \"..\",   \".---\", \"-.-\",  \".-..\", \"--\",   \"-.\",\n                      \"---\",  \".--.\", \"--.-\", \".-.\",  \"...\",  \"-\",    \"..-\",\n                      \"...-\", \".--\",  \"-..-\", \"-.--\", \"--..\"};\nclass Solution {\n   public:\n    string translate(const string &word) {\n        string ans = \"\";\n        for (auto &ch : word) ans += l[ch - 'a'];\n        return ans;\n    }\n    int uniqueMorseRepresentations(vector<string> &words) {\n        unordered_set<string> s;\n        for (auto &word : words) s.insert(translate(word));\n        return s.size();\n    }\n};"}],"tagList":["数组","哈希表","字符串"],"level":"Easy"}},{"problemName":"805.数组的均值分割.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/805.数组的均值分割.json","problemData":{"id":"823","name":"805.数组的均值分割","url":"https://leetcode.cn/problems/split-array-with-same-average","desc":"我们要将  nums  数组中的每个元素移动到  A  数组 或者  B  数组中，使得  A  数组和  B  数组不为空，并且  average(A) == average(B) 。","solutions":[{"date":"2022-11-14","time":148,"memory":18.1,"script":"cpp","desc":"折半搜索，利用二进制统计前半部分取 n 个数的 sum 存入 map，再统计后半部分取 n 个数，两者相加。","code":"class Solution {\npublic:\n    bool splitArraySameAverage(vector<int>& nums) {\n        int n = nums.size(), half = n / 2,\n            sum = accumulate(nums.begin(), nums.end(), 0);\n        unordered_map<int, unordered_set<int>> m;\n        for (int i = 0, len = 1 << half; i < len; i++) {\n            int total = 0, cnt = 0;\n            for (int j = 0; j < half; j++) {\n                if ((i & (1 << j)) == 0) continue;\n                total += nums[j];\n                cnt++;\n            }\n            m[cnt].insert(total);\n        }\n        for (int i = 0; i < (1 << (n - half)); i++) {\n            int total = 0, cnt = 0;\n            for (int j = half; j < n; j++) {\n                if ((i & 1 << (j - half)) == 0) continue;\n                total += nums[j];\n                cnt++;\n            }\n            // j : 左边拿几个数\n            for (int j = max(1, cnt); j < n - 1; j++) {\n                if (j * sum % n != 0) continue;\n                int prevCnt = j - cnt;\n                if (!m.count(prevCnt)) continue;\n                int leftTotal = j * sum / n;\n                int prevTotal = leftTotal - total;\n                if (!m[prevCnt].count(prevTotal)) continue;\n                return true;\n            }\n        }\n        return false;\n    }\n};"},{"date":"2022-11-14","time":176,"memory":51.3,"script":"cpp","desc":"同上。","code":"class Solution {\npublic:\n    bool splitArraySameAverage(vector<int>& nums) {\n        int n = nums.size(), half = n / 2,\n            sum = accumulate(nums.begin(), nums.end(), 0);\n        unordered_map<int, unordered_set<int>> m;\n        for (int i = 0, len = 1 << half; i < len; i++) {\n            int total = 0, cnt = 0;\n            for (int j = 0; j < half; j++) {\n                if ((i & (1 << j)) == 0) continue;\n                total += nums[j];\n                cnt++;\n            }\n            m[total].insert(cnt);\n        }\n        for (int i = 0; i < (1 << (n - half)); i++) {\n\n            int total = 0, cnt = 0;\n            for (int j = half; j < n; j++) {\n                if ((i & 1 << (j - half)) == 0) continue;\n                total += nums[j];\n                cnt++;\n            }\n            // j : 左边拿几个数\n            for (int j = max(1, cnt); j < n - 1; j++) {\n                if (j * sum % n != 0) continue;\n                int need = j * sum / n - total;\n                if (!m.count(need)) continue;\n                if (!m[need].count(j - cnt)) continue;\n                return true;\n            }\n        }\n        return false;\n    }\n}"}],"tagList":["位运算","数组","数学","动态规划","状态压缩"],"level":"Hard"}},{"problemName":"806.写字符串需要的行数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/806.写字符串需要的行数.json","problemData":{"id":"824","name":"806.写字符串需要的行数","url":"https://leetcode.cn/problems/number-of-lines-to-write-string","desc":"至少多少行能放下 S，以及最后一行使用的宽度是多少个单位？。","solutions":[{"date":"2022-03-19","time":0,"memory":6.6,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    vector<int> numberOfLines(vector<int>& widths, string s) {\n        int line = 1, surplus = 100;\n        for (auto& ch : s) {\n            int width = widths[ch - 'a'];\n            if (surplus < width) {\n                line++;\n                surplus = 100;\n            }\n            surplus -= width;\n        }\n        vector<int> ans = {line, 100 - surplus};\n        return ans;\n    }\n};"},{"date":"2022-04-12","time":0,"memory":6.8,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    vector<int> numberOfLines(vector<int>& widths, string s) {\n        int surplus = 100, line = 1;\n        for (auto &ch : s) {\n            int cnt = widths[ch - 'a'];\n            if (cnt > surplus) {\n                surplus = 100;\n                line++;\n            }\n            surplus -= cnt;\n        }\n        return {line, 100 - surplus};\n    }\n};"}],"tagList":["数组","字符串"],"level":"Easy"}},{"problemName":"807.保持城市天际线.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/807.保持城市天际线.json","problemData":{"id":"825","name":"807.保持城市天际线","url":"https://leetcode.cn/problems/max-increase-to-keep-city-skyline","desc":"在二维数组 grid 中，grid[i][j]代表位于某处的建筑物的高度。 我们被允许增加任何数量（不同建筑物的数量可能不同）的建筑物的高度。 高度 0 也被认为是建筑物。建筑物高度可以增加的最大总和是多少？。","solutions":[{"date":"2021-12-13","time":88,"memory":40.1,"script":"typescript","desc":"遍历后存储最大值数组。","code":"function maxIncreaseKeepingSkyline(grid: number[][]): number {\n  const n = grid.length;\n  const m = grid[0].length;\n  const vmax = new Array(m).fill(0);\n  const hmax = new Array(n).fill(0);\n  let ans = 0;\n  for (let row = 0; row < n; row++) {\n    let max = 0;\n    for (let col = 0; col < m; col++) {\n      max = Math.max(max, grid[row][col]);\n    }\n    hmax[row] = max;\n  }\n  for (let col = 0; col < m; col++) {\n    let max = 0;\n    for (let row = 0; row < n; row++) {\n      max = Math.max(max, grid[row][col]);\n    }\n    vmax[col] = max;\n  }\n  for (let row = 0; row < n; row++) {\n    for (let col = 0; col < m; col++) {\n      ans += Math.min(vmax[col] - grid[row][col], hmax[row] - grid[row][col]);\n    }\n  }\n  return ans;\n}"},{"script":"python","time":54,"memory":16.57,"desc":"遍历。","code":"class Solution:\n    def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:\n        n = len(grid)\n        rows = [0] * n\n        cols = [0] * n\n        for i in range(n):\n            for j in range(n):\n                rows[i] = max(rows[i], grid[i][j])\n                cols[j] = max(cols[j], grid[i][j])\n        return sum(min(rows[i], cols[j]) - grid[i][j] for i in range(n) for j in range(n))","date":"2024-07-14"}],"tagList":["贪心","数组","矩阵"],"level":"Medium"}},{"problemName":"808.分汤.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/808.分汤.json","problemData":{"id":"826","name":"808.分汤","url":"https://leetcode.cn/problems/soup-servings","desc":"有 A 和 B 两种类型 的汤。当两种类型的汤都分配完时，停止操作。","solutions":[{"date":"2022-11-21","time":4,"memory":6.2,"script":"cpp","desc":"当 i=0,j=0 时完成同时分配的概率/2=0.5，当 i>0,j=0 时概率 0，当 i=0,j>0 是完成 A 分配概率 1。","code":"class Solution {\npublic:\n    double soupServings(int n) {\n        n = ceil(1.0 * n / 25);\n        if (n > 179) return 1.0;\n        double dp[200][200] = {0};\n        dp[0][0] = 0.5;\n        for (int i = 1; i <= n; i++) dp[0][i] = 1.0;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                dp[i][j] = (\n                    dp[max(0, i - 4)][j] +\n                    dp[max(0, i - 3)][max(0, j - 1)] +\n                    dp[max(0, i - 2)][max(0, j - 2)] +\n                    dp[max(0, i - 1)][max(0, j - 3)]\n                ) / 4;\n            }\n        }\n        return dp[n][n];\n    }\n};"},{"date":"2022-11-21","time":4,"memory":9.3,"script":"cpp","desc":"同上，dfs 记忆化。","code":"class Solution {\npublic:\n    double soupServings(int n) {\n        n = ceil(1.0 * n / 25);\n        if (n > 179) return 1.0;\n        unordered_map<int, unordered_map<int, double>> m;\n        function<double(int, int)> dfs= [&m, &dfs](int a, int b) {\n            if (m.count(a) && m[a].count(b)) return m[a][b];\n            if (a <= 0 && b > 0) return m[a][b] = 1.0;\n            if (a <= 0 && b <= 0) return m[a][b] = 0.5;\n            if (a > 0 && b <= 0) return m[a][b] = 0.0;\n            return m[a][b] = (\n                dfs(a - 4, b) +\n                dfs(a - 3, b - 1) +\n                dfs(a - 2, b - 2) +\n                dfs(a - 1, b - 3)\n            ) / 4;\n        };\n        return dfs(n, n);\n    }\n};"}],"tagList":["数学","动态规划","概率与统计"],"level":"Medium"}},{"problemName":"809.情感丰富的文字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/809.情感丰富的文字.json","problemData":{"id":"827","name":"809.情感丰富的文字","url":"https://leetcode.cn/problems/expressive-words","desc":"输入一组查询单词，输出其中可扩张的单词数量。","solutions":[{"date":"2022-11-25","time":0,"memory":7.3,"script":"cpp","desc":"双指针遍历。","code":"class Solution {\npublic:\n    typedef pair<int, char> Node;\n    int expressiveWords(string s, vector<string>& words) {\n        vector<Node> list;\n        for (int i = 0; i < s.size(); i++) {\n            char c = s[i];\n            int cnt = 1;\n            while (i + 1 < s.size() && s[i + 1] == c) i++, cnt++;\n            list.push_back(make_pair(cnt, c));\n        }\n        int ans = 0;\n        for (auto &s : words) if (check(list, s)) ans++;\n        return ans;\n    }\n    bool check(vector<Node> &list, string &s) {\n        int cur = 0, i = 0;\n        for (; i < s.size() && cur < list.size(); i++, cur++) {\n            Node &node = list[cur];\n            char c = s[i];\n            int cnt = 1;\n            while (i + 1 < s.size() && s[i + 1] == c) i++, cnt++;\n            if (node.second != c ||\n                node.first < cnt ||\n                node.first == 2 && cnt == 1\n            ) return false;\n        }\n        return i == s.size() && cur == list.size();\n    }\n};"}],"tagList":["数组","双指针","字符串"],"level":"Medium"}},{"problemName":"810.黑板异或游戏.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/810.黑板异或游戏.json","problemData":{"id":"828","name":"810.黑板异或游戏","url":"https://leetcode.cn/problems/chalkboard-xor-game","desc":"假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 true。","solutions":[{"date":"2021-05-22","time":100,"memory":39.9,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/chalkboard-xor-game/solution/hei-ban-yi-huo-you-xi-by-leetcode-soluti-eb0c/)。","code":"function xorGame(nums: number[]): boolean {\n  return !(nums.length & 1) ? true : nums.reduce((total, cur) => total ^ cur, 0) === 0;\n}"}],"tagList":["位运算","脑筋急转弯","数组","数学","博弈"],"level":"Hard"}},{"problemName":"811.子域名访问计数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/811.子域名访问计数.json","problemData":{"id":"829","name":"811.子域名访问计数","url":"https://leetcode.cn/problems/subdomain-visit-count","desc":"给你一个 计数配对域名 组成的数组 cpdomains ，解析得到输入中每个子域名对应的 计数配对域名 ，并以数组形式返回。","solutions":[{"date":"2022-10-05","time":20,"memory":12.6,"script":"cpp","desc":"哈希存储。","code":"class Solution {\npublic:\n    vector<string> subdomainVisits(vector<string>& cpdomains) {\n        unordered_map<string, int> m;\n        for (auto &s : cpdomains) {\n            string data = \"\";\n            int cnt = 0;\n            analysisDomain(s, data, cnt);\n            for (auto &item : analysisData(data)) {\n                m[item] += cnt;\n            }\n        }\n        vector<string> ans;\n        for (auto &item : m) {\n            ans.push_back(to_string(item.second) + \" \" + item.first);\n        }\n        return ans;\n    }\n    void analysisDomain(string &s, string &data, int &cnt) {\n        bool isCnt = true;\n        for (int i = 0; i < s.size(); i++) {\n            if (s[i] == ' ') {\n                isCnt = false;\n            } else if (isCnt) {\n                cnt = cnt * 10 + s[i] - '0';\n            } else {\n                data += s[i];\n            }\n        }\n    }\n    vector<string> analysisData(string &data) {\n        vector<string> list;\n        list.push_back(data);\n        int n = data.size();\n        for (int i = 0; i < n; i++) {\n            if (data[i] == '.') {\n                list.push_back(data.substr(i + 1, n - i));\n            }\n        }\n        return list;\n    }\n};"}],"tagList":["数组","哈希表","字符串","计数"],"level":"Medium"}},{"problemName":"812.最大三角形面积.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/812.最大三角形面积.json","problemData":{"id":"830","name":"812.最大三角形面积","url":"https://leetcode.cn/problems/largest-triangle-area","desc":"给定包含多个点的集合，从其中取三个点组成三角形，返回能组成的最大三角形的面积。","solutions":[{"date":"2022-03-20","time":24,"memory":7.4,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    double largestTriangleArea(vector<vector<int>>& points) {\n        int n = points.size();\n        double ans = 0;\n        for (int i1 = 0; i1 < n; i1++) {\n            for (int i2 = i1 + 1; i2 < n; i2++) {\n                for (int i3 = i2 + 1; i3 < n; i3++) {\n                    if (check(points, i1, i2, i3)) continue;\n                    ans = max(ans, comp_area(points, i1, i2, i3));\n                }\n            }\n        }\n        return ans;\n    }\n    bool check(vector<vector<int>>& points, int i1, int i2, int i3) {\n        return points[i1][0] == points[i2][0] &&\n                   points[i1][0] == points[i3][0] ||\n               points[i1][1] == points[i2][1] && points[i1][1] == points[i3][1];\n    }\n    double comp_area(vector<vector<int>>& points, int i1, int i2, int i3) {\n        double line1 = comp_line(points, i1, i2),\n               line2 = comp_line(points, i1, i3),\n               line3 = comp_line(points, i2, i3),\n               p = (line1 + line2 + line3) / 2;\n        return sqrt(p * (p - line1) * (p - line2) * (p - line3));\n    }\n    double comp_line(vector<vector<int>>& points, int i1, int i2) {\n        double x = pow(points[i1][0] - points[i2][0], 2),\n               y = pow(points[i1][1] - points[i2][1], 2);\n        return sqrt(x + y);\n    }\n};"}],"tagList":["几何","数组","数学"],"level":"Easy"}},{"problemName":"813.最大平均值和的分组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/813.最大平均值和的分组.json","problemData":{"id":"831","name":"813.最大平均值和的分组","url":"https://leetcode.cn/problems/largest-sum-of-averages","desc":"给定数组 nums 和一个整数 k 。我们将给定的数组 nums 分成 最多 k 个相邻的非空子数组 。 分数 由每个子数组内的平均值的总和构成。","solutions":[{"date":"2022-11-28","time":12,"memory":7.7,"script":"cpp","desc":"dp[i][j] = 最多分成 i 组，只用到前 j 个字符串的最大平均值。","code":"class Solution {\npublic:\n    double largestSumOfAverages(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<vector<double>> dp(k + 1, vector<double>(n + 1, 0));\n        int sum = 0;\n        for (int i = 0; i < n; i++) {\n            sum += nums[i];\n            dp[1][i + 1] = 1.0 * sum / (i + 1);\n        }\n        double ans = dp[1][n];\n        for (int knum = 2; knum <= k; knum++) {\n            for (int i = knum; i <= n; i++) {\n                int sum = 0, cnt = 0;\n                for (int j = i; j >= knum; j--) {\n                    sum += nums[j - 1];\n                    cnt += 1;\n                    dp[knum][i] = max(dp[knum][i], dp[knum - 1][j - 1] + 1.0 * sum / cnt);\n                }\n            }\n            ans = max(ans, dp[knum][n]);\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","动态规划","前缀和"],"level":"Medium"}},{"problemName":"814.二叉树剪枝.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/814.二叉树剪枝.json","problemData":{"id":"832","name":"814.二叉树剪枝","url":"https://leetcode.cn/problems/binary-tree-pruning","desc":"返回移除了所有不包含 1 的子树的原二叉树。","solutions":[{"date":"2022-07-21","time":4,"memory":8.4,"script":"cpp","desc":"dfs。","code":"class Solution {\n   public:\n    TreeNode *pruneTree(TreeNode *root) {\n        bool check = false;\n        return _pruneTree(root, &check);\n    }\n    TreeNode *_pruneTree(TreeNode *root, bool *check) {\n        if (root == nullptr) {\n            *check = false;\n            return root;\n        }\n        bool checkl = false, checkr = false;\n        root->left = _pruneTree(root->left, &checkl);\n        root->right = _pruneTree(root->right, &checkr);\n        if (root->val || checkl || checkr) {\n            *check = true;\n            return root;\n        } else {\n            *check = false;\n            return nullptr;\n        }\n    }\n};"},{"date":"2022-07-21","time":0,"memory":2,"script":"rust","desc":"dfs。","code":"use std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn prune_tree(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {\n        let mut check = false;\n        let mut root = root;\n        Solution::_prune_tree(&mut root, &mut check);\n        root\n    }\n    fn _prune_tree(root: &mut Option<Rc<RefCell<TreeNode>>>, check: &mut bool) {\n        if root.is_none() {\n            *check = false;\n            return;\n        }\n        let mut check_l = false;\n        let mut check_r = false;\n        Solution::_prune_tree(&mut root.as_ref().unwrap().borrow_mut().left, &mut check_l);\n        Solution::_prune_tree(&mut root.as_ref().unwrap().borrow_mut().right, &mut check_r);\n        if root.as_ref().unwrap().borrow().val == 1 || check_l || check_r {\n            *check = true;\n        } else {\n            *root = None;\n        }\n    }\n}"},{"date":"2022-07-21","time":60,"memory":42.7,"script":"javascript","desc":"dfs。","code":"var pruneTree = function (root) {\n  return _pruneTree(root)[0];\n};\nfunction _pruneTree(root) {\n  if (!root) return [null, false];\n  const [left, checkl] = _pruneTree(root.left);\n  const [right, checkr] = _pruneTree(root.right);\n  root.left = left;\n  root.right = right;\n  if (checkl || checkr || root.val === 1) {\n    return [root, true];\n  } else {\n    return [null, false];\n  }\n}"},{"date":"2022-07-21","time":68,"memory":43.9,"script":"javascript","desc":"dfs。","code":"function pruneTree(root: TreeNode | null): TreeNode | null {\n  return _pruneTree(root)[0];\n}\nfunction _pruneTree(root: TreeNode | null): [TreeNode | null, boolean] {\n  if (!root) return [null, false];\n  const [left, checkl] = _pruneTree(root.left);\n  const [right, checkr] = _pruneTree(root.right);\n  root.left = left;\n  root.right = right;\n  if (checkl || checkr || root.val === 1) {\n    return [root, true];\n  } else {\n    return [null, false];\n  }\n}"}],"tagList":["树","深度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"815.公交路线.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/815.公交路线.json","problemData":{"id":"833","name":"815.公交路线","url":"https://leetcode.cn/problems/bus-routes","desc":"求出 最少乘坐的公交车数量 。如果不可能到达终点车站，返回 -1 。","solutions":[{"date":"2021-06-28","time":268,"memory":71.6,"script":"typescript","desc":"广度优先搜索，储存站点信息和公交换站信息。","code":"function numBusesToDestination(routes: number[][], source: number, target: number): number {\n  if (source === target) return 0;\n  const stationMap = new Map<number, Set<number>>();\n  for (let routeIndex = 0, routeLen = routes.length; routeIndex < routeLen; routeIndex++) {\n    const route = routes[routeIndex];\n    for (\n      let stationIndex = 0, stationLen = route.length;\n      stationIndex < stationLen;\n      stationIndex++\n    ) {\n      const station = route[stationIndex];\n      let set = stationMap.get(station);\n      if (!set) stationMap.set(station, (set = new Set()));\n      set.add(routeIndex);\n    }\n  }\n  const busMap = new Map<number, Set<number>>();\n  for (const busList of stationMap.values()) {\n    if (busList.size === 1) continue;\n    for (const bus of busList) {\n      let set = busMap.get(bus);\n      if (!set) busMap.set(bus, (set = new Set()));\n      for (const nextBus of busList) if (nextBus !== bus) set.add(nextBus);\n    }\n  }\n  const FIRST_BUS = stationMap.get(source)!;\n  const LAST_BUS = stationMap.get(target)!;\n  if (!FIRST_BUS || !LAST_BUS || FIRST_BUS.size === 0 || LAST_BUS.size === 0) return -1;\n  for (const bus of FIRST_BUS) if (LAST_BUS.has(bus)) return 1;\n  let ans = Infinity;\n  const stepMap = new Map<number, number>();\n  for (const bus of FIRST_BUS) stepMap.set(bus, 1);\n  const queue: number[] = [...FIRST_BUS];\n  while (queue.length !== 0) {\n    const bus = queue.shift()!;\n    const step = stepMap.get(bus)!;\n    if (LAST_BUS.has(bus)) {\n      ans = Math.min(ans, step);\n      continue;\n    }\n    const nextBusList = busMap.get(bus)!;\n    for (const nextBus of nextBusList ?? []) {\n      if (!stepMap.has(nextBus)) queue.push(nextBus);\n      stepMap.set(nextBus, Math.min(stepMap.get(nextBus) ?? Infinity, step + 1));\n    }\n  }\n  return ans === Infinity ? -1 : ans;\n}"}],"tagList":["广度优先搜索","数组","哈希表"],"level":"Hard"}},{"problemName":"816.模糊坐标.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/816.模糊坐标.json","problemData":{"id":"834","name":"816.模糊坐标","url":"https://leetcode.cn/problems/ambiguous-coordinates","desc":"返回所有可能的原始字符串到一个列表中。","solutions":[{"date":"2022-11-07","time":8,"memory":10,"script":"cpp","desc":"组合。","code":"class Solution {\npublic:\n    vector<string> ambiguousCoordinates(string s) {\n        vector<string> ans;\n        int n = s.size();\n        for (int i = 2; i < n - 1; i++) {\n            for (auto &l : comp(s.substr(1, i - 1))) {\n                for (auto &r: comp(s.substr(i, s.size() - 1 - i))) {\n                    ans.push_back(\"(\" + l + \", \" + r + \")\");\n                }\n            }\n        }\n        return ans;\n    }\n    vector<string> comp(string str) {\n        vector<string> list;\n        int f = check1(str);\n        if (f) list.push_back(str);\n        if (str.size() > 1) {\n            for (int i = 1; i < str.size(); i++) {\n                string next = str.substr(0, i) + \".\" + str.substr(i);\n                int f = check2(next, i);\n                if (f) list.push_back(next);\n            }\n        }\n        return list;\n    }\n    bool check1(string &str) {\n        if (str[0] == '0' && str.size() != 1) return false;\n        return true;\n    }\n    bool check2(string &str, int idx) {\n        // 开头不能是0，除非只有0\n        if (str[0] == '0' && idx != 1) return false;\n        // 结尾不能是0\n        if (str.back() == '0') return false;\n        // 小数不能全0\n        int f = true;\n        for (int i = idx + 1; i < str.size(); i++) {\n            if (str[i] != '0') {\n                f = false;\n                break;\n            }\n        }\n        if (f) return false;\n        return true;\n    }\n};"}],"tagList":["字符串","回溯","枚举"],"level":"Medium"}},{"problemName":"817.链表组件.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/817.链表组件.json","problemData":{"id":"835","name":"817.链表组件","url":"https://leetcode.cn/problems/linked-list-components","desc":"返回列表 nums 中组件的个数。","solutions":[{"date":"2022-10-12","time":24,"memory":20.8,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    int numComponents(ListNode* head, vector<int>& nums) {\n        unordered_set<int> s(nums.begin(), nums.end());\n        ListNode *p = head;\n        while (p && !s.count(p->val)) p = p->next;\n        int ans = 0;\n        while (p) {\n            while (p && s.count(p->val)) p = p->next;\n            ans++;\n            while (p && !s.count(p->val)) p = p->next;\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","链表"],"level":"Medium"}},{"problemName":"819.最常见的单词.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/819.最常见的单词.json","problemData":{"id":"837","name":"819.最常见的单词","url":"https://leetcode.cn/problems/most-common-word","desc":"给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。","solutions":[{"date":"2022-03-20","time":4,"memory":7.4,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    string mostCommonWord(string paragraph, vector<string>& banned) {\n        unordered_map<string, int> m;\n        unordered_set<string> s;\n        for (auto& ban : banned) s.insert(ban);\n        string ans = \"\";\n        int maxlen = 0, n = paragraph.size();\n        for (int i = 0; i < n; i++) {\n            while (i < n && !isalpha(paragraph[i])) i++;\n            if (i == n) break;\n            string tmp = \"\";\n            while (i < n && isalpha(paragraph[i]))\n                tmp += tolower(paragraph[i++]);\n            if (s.count(tmp)) continue;\n            m[tmp]++;\n            if (m[tmp] > maxlen) {\n                ans = tmp;\n                maxlen = m[tmp];\n            }\n        }\n        return ans;\n    }\n};"},{"date":"2022-04-17","time":4,"memory":7.6,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    string mostCommonWord(string paragraph, vector<string>& banned) {\n        int n = paragraph.size();\n        string ans = \"\";\n        unordered_map<string, int> m;\n        unordered_set<string> s;\n        for (auto& str : banned) s.insert(str);\n        for (int i = 0; i < n; i++) {\n            while (i < n && !isalpha(paragraph[i])) i++;\n            if (i == n) break;\n            int end = i;\n            string next = \"\";\n            do {\n                next += tolower(paragraph[end++]);\n            } while (end < n && isalpha(paragraph[end]));\n            if (!s.count(next) && m[ans] < ++m[next]) ans = next;\n            i = end;\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","字符串","计数"],"level":"Easy"}},{"problemName":"821.字符的最短距离.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/821.字符的最短距离.json","problemData":{"id":"841","name":"821.字符的最短距离","url":"https://leetcode.cn/problems/shortest-distance-to-a-character","desc":"给你一个字符串 s 和一个字符 c ，且 c 是 s 中出现过的字符。返回一个整数数组 answer ，其中 answer.length == s.length 且 answer[i] 是 s 中从下标 i 到离它 最近 的字符 c 的 距离 。","solutions":[{"date":"2022-03-20","time":4,"memory":6.7,"script":"cpp","desc":"bfs。","code":"class Solution {\n   public:\n    vector<int> shortestToChar(string s, char c) {\n        unordered_set<string> sset;\n        int n = s.size();\n        vector<int> ans(n, -1);\n        queue<int> q;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == c) {\n                q.push(i);\n                ans[i] = 0;\n            }\n        }\n        int level = 1, size = q.size();\n        while (q.size()) {\n            int idx = q.front();\n            q.pop();\n            if (idx < n - 1 && ans[idx + 1] == -1) {\n                q.push(idx + 1);\n                ans[idx + 1] = level;\n            }\n            if (idx > 0 && ans[idx - 1] == -1) {\n                q.push(idx - 1);\n                ans[idx - 1] = level;\n            }\n            if (--size == 0) {\n                size = q.size();\n                level++;\n            }\n        }\n        return ans;\n    }\n};"},{"date":"2022-04-19","time":4,"memory":6.6,"script":"cpp","desc":"bfs。","code":"class Solution {\n   public:\n    vector<int> shortestToChar(string s, char c) {\n        int n = s.size();\n        vector<int> check(n, -1);\n        queue<pair<int, int>> q;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == c) {\n                q.push(make_pair(i, 0));\n                check[i] = 0;\n            }\n        }\n        while (q.size()) {\n            pair<int, int> item = q.front();\n            q.pop();\n            int row = item.first, cnt = item.second;\n            if (row < n - 1 && check[row + 1] == -1) {\n                q.push(make_pair(row + 1, cnt + 1));\n                check[row + 1] = cnt + 1;\n            }\n            if (row > 0 && check[row - 1] == -1) {\n                q.push(make_pair(row - 1, cnt + 1));\n                check[row - 1] = cnt + 1;\n            }\n        }\n        return check;\n    }\n};"}],"tagList":["数组","双指针","字符串"],"level":"Easy"}},{"problemName":"822.翻转卡片游戏.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/822.翻转卡片游戏.json","problemData":{"id":"842","name":"822.翻转卡片游戏","url":"https://leetcode.cn/problems/card-flipping-game","desc":"哪个数是这些想要的数字中最小的数（找到这些数中的最小值）呢？如果没有一个数字符合要求的，输出 0。","solutions":[{"script":"cpp","time":40,"memory":24.54,"desc":"哈希存储。","code":"class Solution {\npublic:\n    int flipgame(vector<int>& fronts, vector<int>& backs) {\n        int n = fronts.size(), res = INT_MAX;\n        unordered_map<int, vector<int>> mf, mb;\n        for (int i = 0; i < n; i++) {\n            mf[fronts[i]].push_back(i);\n            mb[backs[i]].push_back(i);\n        }\n        auto check = [&](unordered_map<int, vector<int>> &m, vector<int> &l, int val) -> bool {\n            for (auto &idx : m[val]) {\n                if (l[idx] == val) return false;\n            }\n            return true;\n        };\n        for (int i = 0; i < n; i++) {\n            if (!mf.count(fronts[i]) && !mb.count(fronts[i]) || check(mf, backs, fronts[i]) || check(mb, fronts, fronts[i])) {\n                res = min(res, fronts[i]);\n            }\n            if (!mf.count(backs[i]) && !mb.count(backs[i]) || check(mf, backs, backs[i]) || check(mb, fronts, backs[i])) {\n                res = min(res, backs[i]);\n            }\n        }\n        return res == INT_MAX ? 0 : res;\n    }\n};","date":"2023-08-02"},{"script":"cpp","time":20,"memory":18.66,"desc":"哈希存储。","code":"class Solution {\npublic:\n    int flipgame(vector<int>& fronts, vector<int>& backs) {\n        int n = fronts.size(), res = 3000;\n        unordered_set<int> s;\n        for (int i = 0; i < n; i++) {\n            if (fronts[i] == backs[i]) s.insert(fronts[i]);\n        }\n        for (int i = 0; i < n; i++) {\n            if (!s.count(fronts[i])) res = min(res, fronts[i]);\n            if (!s.count(backs[i])) res = min(res, backs[i]);\n        }\n        return res % 3000;\n    }\n};","date":"2023-08-02"},{"script":"python","time":52,"memory":15.72,"desc":"同上。","code":"class Solution:\n    def flipgame(self, fronts: List[int], backs: List[int]) -> int:\n        n = len(fronts)\n        res = 3000\n        s = set()\n        for i in range(n):\n            if fronts[i] == backs[i]:\n                s.add(fronts[i])\n        for i in range(n):\n            if not fronts[i] in s:\n                res = min(res, fronts[i])\n            if not backs[i] in s:\n                res = min(res, backs[i])\n        return res % 3000","date":"2023-08-02"},{"script":"rust","time":4,"memory":1.96,"desc":"同上。","code":"impl Solution {\n    pub fn flipgame(fronts: Vec<i32>, backs: Vec<i32>) -> i32 {\n        let n = fronts.len();\n        let mut s = std::collections::HashSet::<i32>::new();\n        let mut res = 3000;\n        for i in 0..n {\n            if fronts[i] == backs[i] {\n                s.insert(fronts[i]);\n            }\n        }\n        for i in 0..n {\n            if !s.contains(&fronts[i]) {\n                res = res.min(fronts[i]);\n            }\n            if !s.contains(&backs[i]) {\n                res = res.min(backs[i]);\n            }\n        }\n        res % 3000\n    }\n}","date":"2023-08-02"}],"tagList":["数组","哈希表"],"level":"Medium"}},{"problemName":"823.带因子的二叉树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/823.带因子的二叉树.json","problemData":{"id":"843","name":"823.带因子的二叉树","url":"https://leetcode.cn/problems/binary-trees-with-factors","desc":"给出一个含有不重复整数元素的数组 arr ，每个整数 arr[i] 均大于 1。用这些整数来构建二叉树，每个整数可以使用任意次数。其中：每个非叶结点的值应等于它的两个子结点的值的乘积。满足条件的二叉树一共有多少个？。","solutions":[{"script":"python","time":312,"memory":16.79,"desc":"dfs。","code":"class Solution:\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\n        MOD = 1000000007\n        arr.sort()\n        s = set()\n        for num in arr:\n            s.add(num)\n        @cache\n        def dfs(root: int) -> int:\n            res = 1\n            for num in arr:\n                if num >= root: break\n                if root % num != 0: continue\n                if root // num not in s: continue\n                res = (res + dfs(num) * dfs(root // num) % MOD) % MOD\n            return res\n        return sum(dfs(num) for num in arr) % MOD","date":"2023-08-29"},{"script":"cpp","time":52,"memory":8.66,"desc":"遍历。","code":"class Solution {\npublic:\n    int numFactoredBinaryTrees(vector<int>& arr) {\n        int MOD = 1e9 + 7, n = arr.size(), res = 1;\n        sort(arr.begin(), arr.end());\n        unordered_map<int, int> m;\n        for (int i = 0; i < n; i++) m[arr[i]] = i;\n        vector<long long> list(n, 1);\n        for (int i = 1; i < n; i++) {\n            for (int j = i - 1; j >= 0; j--) {\n                if (arr[i] % arr[j] == 0 && m.count(arr[i] / arr[j])) {\n                    list[i] = (list[i] + list[j] * list[m[arr[i] / arr[j]]] % MOD) % MOD;\n                }\n            }\n            res = (res + list[i]) % MOD;\n        }\n        return res;\n    }\n};","date":"2023-08-29"},{"script":"python","time":384,"memory":15.91,"desc":"同上。","code":"class Solution:\n    def numFactoredBinaryTrees(self, arr: List[int]) -> int:\n        MOD = 1000000007\n        n = len(arr)\n        res = 1\n        arr.sort()\n        m = {}\n        for i in range(n):\n            m[arr[i]] = i\n        list = [1 for _ in range(n)]\n        for i in range(1, n):\n            for j in range(i-1, -1, -1):\n                if arr[i] % arr[j] == 0 and arr[i] // arr[j] in m:\n                    list[i] = (list[i] + list[j] *\n                                list[m[arr[i] / arr[j]]] % MOD) % MOD\n            res = (res + list[i]) % MOD\n        return res","date":"2023-08-29"},{"script":"rust","time":20,"memory":2,"desc":"同上。","code":"impl Solution {\n    pub fn num_factored_binary_trees(mut arr: Vec<i32>) -> i32 {\n        const MOD: i64 = 1000000007;\n        let n = arr.len();\n        let mut res = 1;\n        arr.sort();\n        let mut m = std::collections::HashMap::<i32, usize>::new();\n        for (i, num) in arr.iter().enumerate() {\n            m.insert(*num, i);\n        }\n        let mut list = vec![1i64; n];\n        for i in 1..n {\n            for j in (0..i).rev() {\n                if arr[i] % arr[j] == 0 && m.contains_key(&(arr[i] / arr[j])) {\n                    let idx = m.get(&(arr[i] / arr[j])).unwrap();\n                    list[i] = (list[i] + list[j] * list[*idx] % MOD) % MOD;\n                }\n            }\n            res = (res + list[i]) % MOD;\n        }\n        res as i32\n    }\n}","date":"2023-08-29"}],"tagList":["数组","哈希表","动态规划","排序"],"level":"Medium"}},{"problemName":"824.山羊拉丁文.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/824.山羊拉丁文.json","problemData":{"id":"851","name":"824.山羊拉丁文","url":"https://leetcode.cn/problems/goat-latin","desc":"返回将 S 转换为山羊拉丁文后的句子。","solutions":[{"date":"2022-03-21","time":0,"memory":6.2,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    string toGoatLatin(string sentence) {\n        istringstream iss(sentence);\n        string tmp, ans = \"\";\n        int cnt = 1;\n        while (getline(iss, tmp, ' ')) {\n            char firstch = tolower(tmp[0]);\n            if (firstch == 'a' || firstch == 'e' || firstch == 'i' ||\n                firstch == 'o' || firstch == 'u')\n                tmp += \"ma\";\n            else\n                tmp = tmp.substr(1, tmp.size() - 1) + tmp[0] + \"ma\";\n            for (int i = 0; i < cnt; i++) tmp += \"a\";\n            if (ans != \"\") ans += \" \";\n            ans += tmp;\n            cnt++;\n        }\n        return ans;\n    }\n};"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"825.适龄的朋友.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/825.适龄的朋友.json","problemData":{"id":"852","name":"825.适龄的朋友","url":"https://leetcode.cn/problems/friends-of-appropriate-ages","desc":"在社交媒体网站上有 n 个用户。返回在该社交媒体网站上产生的好友请求总数。","solutions":[{"date":"2021-12-27","time":1320,"memory":36.5,"script":"cpp","desc":"排序后双指针移动。","code":"class Solution {\n   public:\n    int numFriendRequests(vector<int>& ages) {\n        sort(ages.begin(), ages.end());\n        int n = ages.size(), ans = 0;\n        for (int l = 0, r = 0; r < n; r++) {\n            while (l < r && ages[l] <= ages[r] / 2.0 + 7) l++;\n            ans += r - l;\n            if (ages[r] / 2.0 + 7 < ages[r]) {\n                int tmp = r;\n                while (tmp + 1 < n && ages[tmp + 1] == ages[tmp]) {\n                    ans++;\n                    tmp++;\n                }\n            }\n        }\n        return ans;\n    }\n};"},{"date":"2021-12-27","time":108,"memory":36.2,"script":"cpp","desc":"二分查找最小值和最大值。","code":"class Solution {\n   public:\n    int bs(vector<int>& ages, double num) {\n        int l = 0, r = ages.size(), m;\n        while (l < r) {\n            m = (l + r) / 2;\n            if (ages[m] > num)\n                r = m;\n            else\n                l = m + 1;\n        }\n        return l;\n    }\n    int numFriendRequests(vector<int>& ages) {\n        sort(ages.begin(), ages.end());\n        int n = ages.size(), ans = 0;\n        for (int i = 0; i < n; i++) {\n            double min = ages[i] / 2.0 + 7, max = ages[i];\n            if (min > max) continue;\n            int imin = bs(ages, min), imax = bs(ages, max);\n            if (imin < imax) ans += imax - imin - 1;\n        }\n        return ans;\n    }\n};"},{"date":"2021-12-27","time":56,"memory":36.3,"script":"cpp","desc":"双指针移动。","code":"class Solution {\n   public:\n    int numFriendRequests(vector<int>& ages) {\n        sort(ages.begin(), ages.end());\n        int n = ages.size(), l = 0, r = 0, ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (ages[i] * 0.5 + 7 > ages[i]) continue;\n            while (r + 1 < n && ages[r + 1] <=ages[i]) r++;\n            while (l < r && ages[l] <= ages[i] * 0.5 + 7) l++;\n            ans += r - l;\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","双指针","二分查找","排序"],"level":"Medium"}},{"problemName":"826.安排工作以达到最大收益.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/826.安排工作以达到最大收益.json","problemData":{"id":"853","name":"826.安排工作以达到最大收益","url":"https://leetcode.cn/problems/most-profit-assigning-work","desc":"返回 在把工人分配到工作岗位后，我们所能获得的最大利润 。","solutions":[{"script":"python","time":75,"memory":18.77,"desc":"排序后获取当前难度下最大的收益。","code":"class Solution:\n    def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:\n        diff_list = sorted([i for i in range(len(difficulty))], key = lambda i: -difficulty[i])\n        res = 0\n        cur_profit = 0\n        for i in sorted([i for i in range(len(worker))], key = lambda i: worker[i]):\n            while diff_list and difficulty[diff_list[-1]] <= worker[i]:\n                cur_profit = max(cur_profit, profit[diff_list.pop()])\n            res += cur_profit\n        return res","date":"2024-05-17"}],"tagList":["贪心","数组","双指针","二分查找","排序"],"level":"Medium"}},{"problemName":"827.最大人工岛.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/827.最大人工岛.json","problemData":{"id":"854","name":"827.最大人工岛","url":"https://leetcode.cn/problems/making-a-large-island","desc":"给你一个大小为 n x n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。返回执行此操作后，grid 中最大的岛屿面积是多少？。","solutions":[{"date":"2022-09-18","time":620,"memory":167.5,"script":"cpp","desc":"uf 记录所有岛，对每个 0 位置进行尝试合并。","code":"class UnionFind{\npublic:\n    int n;\n    vector<int> list;\n    UnionFind(int n){\n        this->n = n;\n        list = vector<int>(n);\n        for (int i = 0; i < n; i++) list[i] = i;\n    }\n    int find(int e) {\n        if (list[e] == e) return e;\n        return list[e] = find(list[e]);\n    }\n    void uni(int e1, int e2) {\n        int p1 = find(e1), p2 = find(e2);\n        if (p1 != p2) list[p1] = p2;\n    }\n};\nint dirs[4][2] = {\n    {0, 1}, {0, -1},\n    {-1, 0}, {1, 0}\n};\ntypedef pair<int, int> node;\nclass Solution {\npublic:\n    int n;\n    int largestIsland(vector<vector<int>>& grid) {\n        n = grid.size();\n        vector<node> list0;\n        UnionFind uf(n * n);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                int idx = toIdx(i, j);\n                if (grid[i][j] == 0) {\n                    uf.list[idx] = -1;\n                    list0.push_back(make_pair(i, j));\n                } else {\n                    for (int k = 0; k < 4; k++) {\n                        int x = i + dirs[k][0], y = j + dirs[k][1];\n                        if (x < 0 || x == n || y < 0 || y == n || grid[x][y] == 0) continue;\n                        uf.uni(idx, toIdx(x, y));\n                    }\n                }\n            }\n        }\n        unordered_map<int, int> m;\n        int ans = 0;\n        for (int i = 0; i < uf.n; i++) if (uf.list[i] != -1) ans = max(ans, ++m[uf.find(i)]);\n        for (auto &item : list0) {\n            unordered_set<int> s;\n            for (int i = 0; i < 4; i++) {\n                int x = item.first + dirs[i][0], y = item.second + dirs[i][1];\n                if (x < 0 || x == n || y < 0 || y == n || grid[x][y] == 0) continue;\n                s.insert(uf.find(toIdx(x, y)));\n            }\n            int sum = 1;\n            for (auto &p : s) sum += m[p];\n            ans = max(ans, sum);\n        }\n        return ans;\n    }\n    int toIdx(int x, int y) {\n        return x * n + y;\n    }\n};"}],"tagList":["深度优先搜索","广度优先搜索","并查集","数组","矩阵"],"level":"Hard"}},{"problemName":"828.统计子串中的唯一字符.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/828.统计子串中的唯一字符.json","problemData":{"id":"855","name":"828.统计子串中的唯一字符","url":"https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string","desc":"给你一个字符串 s ，我们需要返回 countUniqueChars(t) 的总和，其中 t 是 s 的子字符串。","solutions":[{"date":"2022-09-06","time":52,"memory":36,"script":"cpp","desc":"记录每个字符出现的下标，统计每个字符只出现一次的子串。","code":"class Solution {\npublic:\n    int uniqueLetterString(string s) {\n        unordered_map<char, vector<int>> m;\n        for (int i = 0; i < s.size(); i++) m[s[i]].push_back(i);\n        int ans = 0;\n        for (auto &item : m) {\n            vector<int> list = item.second;\n            list.insert(list.begin(), -1);\n            list.push_back(s.size());\n            for (int i = 1; i < list.size() - 1; i++) ans += (list[i] - list[i - 1]) * (list[i + 1] - list[i]);\n        }\n        return ans;\n    }\n};"},{"script":"python","time":272,"memory":20.83,"desc":"按字符归类所有下标，记录当前字符下标仅出现一次的频率。","code":"class Solution:\n    def uniqueLetterString(self, s: str) -> int:\n        n = len(s)\n        ans = 0\n        clist = [[-1] for _ in range(26)]\n        for i in range(n): clist[ord(s[i]) - ord('A')].append(i)\n        for arr in clist:\n            arr.append(n)\n            for j in range(1, len(arr) - 1):\n                ans += (arr[j] - arr[j - 1]) * (arr[j + 1] - arr[j])\n        return ans","date":"2023-11-26"}],"tagList":["哈希表","字符串","动态规划"],"level":"Hard"}},{"problemName":"830.较大分组的位置.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/830.较大分组的位置.json","problemData":{"id":"857","name":"830.较大分组的位置","url":"https://leetcode.cn/problems/positions-of-large-groups","desc":"在一个由小写字母构成的字符串 s 中，包含由一些连续的相同字符所构成的分组。找到每一个 较大分组 的区间，按起始位置下标递增顺序排序后，返回结果。","solutions":[{"date":"2021-01-05","time":100,"memory":42.1,"script":"typescript","desc":"遍历后对每一项进行判断是否符合条件。","code":"function largeGroupPositions(s: string): number[][] {\n  const len = s.length;\n  const ans: number[][] = [];\n  const comp = (index: number): number => {\n    const c = s[index];\n    let count = 1;\n    let i = index + 1;\n    for (; i < len; i++)\n      if (s[i] === c) count++;\n      else break;\n    if (count < 3) return index;\n    const nextI = index + count - 1;\n    ans.push([index, nextI]);\n    return nextI;\n  };\n  for (let i = 0; i < len; i++) i = comp(i);\n  return ans;\n}"},{"date":"2021-01-05","time":136,"memory":42.5,"script":"typescript","desc":"从后往前遍历。","code":"function largeGroupPositions(s: string): number[][] {\n  const len = s.length;\n  const ans: number[][] = [];\n  let startI = len - 1;\n  for (let i = startI - 1; i >= 0; i--) {\n    if (i === 0 && s[i] === s[startI]) {\n      startI - i + 1 >= 3 && ans.unshift([i, startI]);\n    } else if (s[i] !== s[startI]) {\n      startI - i >= 3 && ans.unshift([i + 1, startI]);\n      startI = i;\n    }\n  }\n  return ans;\n}"}],"tagList":["字符串"],"level":"Easy"}},{"problemName":"831.隐藏个人信息.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/831.隐藏个人信息.json","problemData":{"id":"858","name":"831.隐藏个人信息","url":"https://leetcode.cn/problems/masking-personal-information","desc":"给你一条个人信息字符串 s ，可能表示一个 邮箱地址 ，也可能表示一串 电话号码 。返回按如下规则 隐藏 个人信息后的结果。","solutions":[{"script":"cpp","time":0,"memory":6,"desc":"模拟。","code":"class Solution {\npublic:\n    string maskPII(string s) {\n        if (isEmail(s)) return formatEmail(s);\n        return formatPhone(s);\n    }\n    bool isEmail(string &s) {\n        return s.find('@') != string::npos;\n    }\n    string formatEmail(string &s) {\n        string res = \"\";\n        res += tolower(s[0]);\n        res += \"*****\";\n        int i = 0;\n        while (s[i + 1] != '@') i++;\n        while (i < s.size()) res += tolower(s[i++]);\n        return res;\n    }\n    string formatPhone(string &s) {\n        string formats = \"\", res = \"\";\n        for (auto &c : s) \n            if (isdigit(c)) formats += c;\n        switch(formats.size() - 10) {\n            case 1: res += \"+*-\"; break;\n            case 2: res += \"+**-\"; break;\n            case 3: res += \"+***-\"; break;\n        }\n        res += \"***-***-\" + formats.substr(formats.size() - 4, 4);\n        return res;\n    }\n};","date":"2023-04-01"},{"script":"python","time":44,"memory":15,"desc":"同上。","code":"class Solution:\n    def maskPII(self, s: str) -> str:\n        def isEmail(s: str):\n            return s.find('@') != -1\n\n        def formatEmail(s: str):\n            res = \"\"\n            res += s[0].lower() + '*****'\n            i = 0\n            while s[i+1] != '@':\n                i += 1\n            while i < len(s):\n                res += s[i].lower()\n                i += 1\n            return res\n\n        def formatPhone(s: str):\n            formats, res = \"\", \"\"\n            for c in s:\n                if c.isdigit():\n                    formats += c\n            pre = len(formats) - 10\n            if pre == 1:\n                res += \"+*-\"\n            elif pre == 2:\n                res += \"+**-\"\n            elif pre == 3:\n                res += \"+***-\"\n            res += \"***-***-\" + formats[-4:]\n            return res\n\n        return formatEmail(s) if isEmail(s) else formatPhone(s)","date":"2023-04-01"},{"script":"rust","time":0,"memory":2.3,"desc":"同上。","code":"impl Solution {\n    pub fn mask_pii(s: String) -> String {\n        let s = s.chars().collect::<Vec<char>>();\n        fn format_email(s: &Vec<char>) -> String {\n            let mut res = String::new();\n            res.push_str(&s[0].to_lowercase().to_string());\n            res.push_str(\"*****\");\n            let mut i = 0;\n            while s[i + 1] != '@' {\n                i += 1;\n            }\n            while i < s.len() {\n                res.push_str(&s[i].to_lowercase().to_string());\n                i += 1;\n            }\n            res\n        }\n\n        fn format_phone(s: &Vec<char>) -> String {\n            let mut formats = vec![];\n            for c in s {\n                if c.is_numeric() {\n                    formats.push(*c);\n                }\n            }\n            let mut res = String::new();\n            match formats.len() - 10 {\n                1 => res.push_str(\"+*-\"),\n                2 => res.push_str(\"+**-\"),\n                3 => res.push_str(\"+***-\"),\n                _ => {}\n            }\n            res.push_str(\"***-***-\");\n            res.push_str(\n                &String::from_utf8(\n                    formats[formats.len() - 4..]\n                        .iter()\n                        .map(|v| *v as u8)\n                        .collect::<Vec<u8>>(),\n                )\n                .unwrap(),\n            );\n            res\n        }\n        if s.contains(&'@') {\n            format_email(&s)\n        } else {\n            format_phone(&s)\n        }\n    }\n}","date":"2023-04-01"}],"tagList":["字符串"],"level":"Medium"}},{"problemName":"832.翻转图像.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/832.翻转图像.json","problemData":{"id":"861","name":"832.翻转图像","url":"https://leetcode.cn/problems/flipping-an-image","desc":"给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。","solutions":[{"date":"2021-02-24","time":92,"memory":40.5,"script":"typescript","desc":"双循环直接翻转去反。","code":"function flipAndInvertImage(A: number[][]): number[][] {\n  const colLen = A[0].length;\n  for (let row = 0, rowLen = A.length; row < rowLen; row++)\n    for (let col = 0, colMidLen = (colLen - 1) / 2; col <= colMidLen; col++)\n      [A[row][col], A[row][colLen - col - 1]] = [A[row][colLen - col - 1] ^ 1, A[row][col] ^ 1];\n  return A;\n}"}],"tagList":["位运算","数组","双指针","矩阵","模拟"],"level":"Easy"}},{"problemName":"833.字符串中的查找与替换.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/833.字符串中的查找与替换.json","problemData":{"id":"862","name":"833.字符串中的查找与替换","url":"https://leetcode.cn/problems/find-and-replace-in-string","desc":"在对 s 执行所有替换操作后返回 结果字符串 。","solutions":[{"script":"cpp","time":8,"memory":13.16,"desc":"从后往前遍历。","code":"class Solution {\npublic:\n    string findReplaceString(string s, vector<int>& indices, vector<string>& sources, vector<string>& targets) {\n        int n = indices.size();\n        vector<int> idxs;\n        for (int i = 0; i < n; i++) idxs.push_back(i);\n        sort(idxs.begin(), idxs.end(), [&](auto &i1, auto &i2) {\n            return indices[i2] < indices[i1];\n        });\n        auto check = [&](int &start, string &source) {\n            for (int i = 0; i < source.size(); i++) {\n                if (start + i >= s.size() || source[i] != s[start + i]) return false;\n            }\n            return true;\n        };\n        for (int idx = 0; idx < n; idx++) {\n            int i = idxs[idx];\n            if (check(indices[i], sources[i])) {\n                s = s.substr(0, indices[i]) + targets[i] + s.substr(indices[i] + sources[i].size());\n            }\n        }\n        return s;\n    }\n};","date":"2023-08-15"},{"script":"python","time":44,"memory":16.1,"desc":"同上。","code":"class Solution:\n    def findReplaceString(self, s: str, indices: List[int], sources: List[str], targets: List[str]) -> str:\n        n = len(indices)\n        idxs = [i for i in range(n)]\n        idxs.sort(key=lambda i: indices[i], reverse=True)\n        for idx in range(n):\n            i = idxs[idx]\n            if s[indices[i]:indices[i]+len(sources[i])] == sources[i]:\n                s = s[0:indices[i]] + targets[i] +                     s[indices[i]+len(sources[i]):]\n                print(s)\n        return s","date":"2023-08-15"},{"script":"rust","time":0,"memory":2.1,"desc":"同上。","code":"impl Solution {\n    pub fn find_replace_string(\n        mut s: String,\n        indices: Vec<i32>,\n        sources: Vec<String>,\n        targets: Vec<String>,\n    ) -> String {\n        let indices = indices.into_iter().map(|i| i as usize).collect::<Vec<_>>();\n        let n = indices.len();\n        let mut idxs = (0..n).collect::<Vec<_>>();\n        idxs.sort_by_key(|i| indices[*i]);\n        idxs.reverse();\n        for i in idxs {\n            if indices[i] + sources[i].len() <= s.len() && s[indices[i]..indices[i] + sources[i].len()] == sources[i] {\n                let mut ns = String::new();\n                ns.push_str(&s[0..indices[i]]);\n                ns.push_str(&targets[i]);\n                ns.push_str(&s[indices[i] + sources[i].len()..]);\n                s = ns;\n            }\n        }\n        s\n    }\n}","date":"2023-08-15"}],"tagList":["数组","哈希表","字符串","排序"],"level":"Medium"}},{"problemName":"834.树中距离之和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/834.树中距离之和.json","problemData":{"id":"863","name":"834.树中距离之和","url":"https://leetcode.cn/problems/sum-of-distances-in-tree","desc":"给定一个无向、连通的树。树中有 n 个标记为 0...n-1 的节点以及 n-1 条边 。给定整数 n 和数组 edges ， edges[i] = [ai, bi]表示树中的节点 ai 和 bi 之间有一条边。返回长度为 n 的数组 answer ，其中 answer[i] 是树中第 i 个节点与所有其他节点之间的距离之和。","solutions":[{"date":"2020-10-06","script":"javascript","time":224,"memory":54.2,"desc":"dfs。","code":"/**\n* @param {number} N\n* @param {number[][]} edges\n* @return {number[]}\n*/\nlet ans, sz, dp, graph;\nconst dfs = (u, f) => {\n    sz[u] = 1;\n    dp[u] = 0;\n    for (const v of graph[u]) {\n        if (v === f) {\n            continue;\n        }\n        dfs(v, u);\n        dp[u] += dp[v] + sz[v];\n        sz[u] += sz[v];\n    }\n}\nconst dfs2 = (u, f) => {\n    ans[u] = dp[u];\n    for (const v of graph[u]) {\n        if (v === f) {\n            continue;\n        }\n        const pu = dp[u], pv = dp[v];\n        const su = sz[u], sv = sz[v];\n\n        dp[u] -= dp[v] + sz[v];\n        sz[u] -= sz[v];\n        dp[v] += dp[u] + sz[u];\n        sz[v] += sz[u];\n\n        dfs2(v, u);\n\n        dp[u] = pu, dp[v] = pv;\n        sz[u] = su, sz[v] = sv;\n    }\n}\nvar sumOfDistancesInTree = function(N, edges) {\n    ans = new Array(N).fill(0);\n    sz = new Array(N).fill(0);\n    dp = new Array(N).fill(0);\n    graph = new Array(N).fill(0).map(v => []);\n    for (const [u, v] of edges) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n    dfs(0, -1);\n    dfs2(0, -1);\n    return ans;\n};"},{"script":"cpp","time":232,"memory":106.4,"desc":"dfs。","code":"#define X first\n#define Y second\n#define pii pair<int, int>\nclass Solution {\npublic:\n    vector<int> sumOfDistancesInTree(int n, vector<vector<int>>& edges) {\n        vector<int> res(n, 0);\n        vector<vector<int>> nodes(n);\n        for (auto &edge : edges) {\n            nodes[edge[0]].push_back(edge[1]);\n            nodes[edge[1]].push_back(edge[0]);\n        }\n        // X 总共有几个， Y 总路径和\n        vector<pii> cache(n);\n        function<pii(int, int)> find = [&](int cur, int p) -> pii {\n            if (nodes[cur].size() == 1 && nodes[cur][0] == p) return cache[cur] = make_pair(1, 1);\n            pii ans = make_pair(1, 1);\n            for (auto &child : nodes[cur]) {\n                if (child != p) {\n                    auto res = find(child, cur);\n                    ans.X += res.X;\n                    ans.Y += res.X + res.Y;\n                }\n            }\n            cache[cur] = ans;\n            return ans;\n        };\n        find(0, -1);\n        function<void(int, int, int)> dfs = [&](int cur, int p, int sum) {\n            res[cur] = sum + cache[cur].Y - cache[cur].X;\n            for (auto &child : nodes[cur]) {\n                if (child != p) dfs(child, cur, res[cur] - cache[child].Y + n - cache[child].X);\n            }\n        };\n        dfs(0, -1, 0);\n        return res;\n    }\n};","date":"2023-07-16"},{"script":"python","time":404,"memory":69.3,"desc":"同上。","code":"class Solution:\n    def sumOfDistancesInTree(self, n: int, edges: List[List[int]]) -> List[int]:\n        res = [0 for _ in range(n)]\n        nodes = [[] for _ in range(n)]\n        for edge in edges:\n            nodes[edge[0]].append(edge[1])\n            nodes[edge[1]].append(edge[0])\n        cache = [[] for _ in range(n)]\n\n        def find(cur: int, p: int) -> List[int]:\n            ans = [1, 1]\n            if len(nodes[cur]) == 1 and nodes[cur][0] == p:\n                cache[cur] = ans\n            else:\n                for child in nodes[cur]:\n                    if child != p:\n                        res = find(child, cur)\n                        ans[0] += res[0]\n                        ans[1] += res[0] + res[1]\n                cache[cur] = ans\n            return ans\n\n        find(0, -1)\n        \n        def dfs(cur: int, p: int, sum: int):\n            res[cur] = sum + cache[cur][1] - cache[cur][0]\n            for child in nodes[cur]:\n                if child != p:\n                    dfs(child, cur, res[cur] - cache[child]\n                        [1] + n - cache[child][0])\n        dfs(0, -1, 0)\n        return res","date":"2023-07-16"},{"script":"rust","time":48,"memory":8.8,"desc":"同上。","code":"fn find(nodes: &Vec<Vec<usize>>, cache: &mut Vec<(i32, i32)>, cur: usize, p: usize) -> (i32, i32) {\n    let mut ans: (i32, i32) = (1, 1);\n    if !(nodes[cur].len() == 1 && nodes[cur][0] == p) {\n        for child in &nodes[cur] {\n            if *child != p {\n                let res = find(nodes, cache, *child, cur);\n                ans.0 += res.0;\n                ans.1 += res.0 + res.1;\n            }\n        }\n    }\n    cache[cur] = ans;\n    ans\n}\nfn dfs(\n    res: &mut Vec<i32>,\n    nodes: &Vec<Vec<usize>>,\n    cache: &Vec<(i32, i32)>,\n    n: usize,\n    cur: usize,\n    p: usize,\n    sum: i32,\n) {\n    res[cur] = sum + cache[cur].1 - cache[cur].0;\n    for child in &nodes[cur] {\n        if *child != p {\n            dfs(\n                res,\n                nodes,\n                cache,\n                n,\n                *child,\n                cur,\n                res[cur] - cache[*child].1 + (n as i32) - cache[*child].0,\n            );\n        }\n    }\n}\nimpl Solution {\n    pub fn sum_of_distances_in_tree(n: i32, edges: Vec<Vec<i32>>) -> Vec<i32> {\n        let n = n as usize;\n        let mut res = vec![0; n];\n        let mut nodes = vec![vec![]; n];\n        for edge in edges {\n            nodes[edge[0] as usize].push(edge[1] as usize);\n            nodes[edge[1] as usize].push(edge[0] as usize);\n        }\n        let mut cache = vec![(0, 0); n];\n        find(&nodes, &mut cache, 0, usize::MAX);\n        dfs(&mut res, &nodes, &cache, n, 0, usize::MAX, 0);\n        res\n    }\n}","date":"2023-07-16"}],"tagList":["树","深度优先搜索","图","动态规划"],"level":"Hard"}},{"problemName":"836.矩形重叠.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/836.矩形重叠.json","problemData":{"id":"866","name":"836.矩形重叠","url":"https://leetcode.cn/problems/rectangle-overlap","desc":"给出两个矩形 rec1 和 rec2 。如果它们重叠，返回 true；否则，返回 false 。","solutions":[{"date":"2022-03-21","time":0,"memory":7.6,"script":"cpp","desc":"统计所有不可能重叠的情况。","code":"class Solution {\n   public:\n    bool isRectangleOverlap(vector<int>& rec1, vector<int>& rec2) {\n        int x1_1 = rec1[0], y1_1 = rec1[1], x1_2 = rec1[2], y1_2 = rec1[3];\n        int x2_1 = rec2[0], y2_1 = rec2[1], x2_2 = rec2[2], y2_2 = rec2[3];\n        if (x1_2 <= x2_1 || x2_2 <= x1_1 || y1_2 <= y2_1 || y2_2 <= y1_1)\n            return false;\n        return true;\n    }\n};"}],"tagList":["几何","数学"],"level":"Easy"}},{"problemName":"837.新21点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/837.新21点.json","problemData":{"id":"867","name":"837.新21点","url":"https://leetcode.cn/problems/new-21-game","desc":"爱丽丝参与一个大致基于纸牌游戏 “21 点” 规则的游戏，描述如下：爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N 的概率是多少？","solutions":[{"date":"2020-06-03","time":1396,"memory":38.1,"script":"typescript","desc":"dp[x]=积分为 x 时的概率，dp[x]=sum(dp[x+1]+dp[x+2]...+dp[x+W])/W。","code":"function new21Game(N: number, K: number, W: number): number {\n  const arr = new Array(K + W).fill(0);\n  const min = Math.min(N, K + W - 1);\n  for (let i = K; i <= min; i++) arr[i] = 1;\n  for (let i = K - 1; i >= 0; i--) {\n    let s = 0;\n    for (let j = i, sum = i + W; j <= sum; j++) s += arr[j];\n    arr[i] = s / W;\n  }\n  return arr[0];\n}"},{"date":"2020-06-03","time":220,"memory":41.6,"script":"typescript","desc":"优化题解 1。","code":"function new21Game(N: number, K: number, W: number): number {\n  const dp = new Array(W).fill(0);\n  let sum = 0;\n  for (let i = K; i <= N && i <= K + W - 1; i++) {\n    dp[i - K] = 1;\n    sum++;\n  }\n  for (let i = K - 1; i >= 0; i--) {\n    dp.unshift(sum / W);\n    sum += dp[0] - dp.pop();\n  }\n  return dp[0];\n}"},{"date":"2020-06-03","time":264,"memory":41.8,"script":"typescript","desc":"优化题解 2。","code":"function new21Game(N: number, K: number, W: number): number {\n  const dp = new Array(W).fill(0);\n  const min = Math.min(N, K + W - 1);\n  let sum = -1;\n  while (sum + K <= min) dp[sum++] = 1;\n  for (let i = K - 1; i >= 0; i--) {\n    dp.unshift(sum / W);\n    sum += dp[0] - dp.pop();\n  }\n  return dp[0];\n}"}],"tagList":["数学","动态规划","滑动窗口","概率与统计"],"level":"Medium"}},{"problemName":"838.推多米诺.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/838.推多米诺.json","problemData":{"id":"868","name":"838.推多米诺","url":"https://leetcode.cn/problems/push-dominoes","desc":"返回表示最终状态的字符串。","solutions":[{"date":"2022-02-21","time":80,"memory":15.3,"script":"cpp","desc":"dp, 统计每秒钟的状态进行推导。","code":"class Solution {\n   public:\n    string pushDominoes(string dominoes) {\n        int n = dominoes.size(), change, cnt = 0;\n        string dp[2];\n        dp[0] = dominoes;\n        do {\n            change = 0;\n            int idx = cnt & 1, nidx = (cnt + 1) & 1;\n            dp[nidx] = dp[idx];\n            for (int i = 0; i < n; i++) {\n                if (dp[idx][i] == '.') {\n                    if (i > 0 && dp[idx][i - 1] == 'R' && i < n - 1 &&\n                        dp[idx][i + 1] == 'L')\n                        dp[idx][i] = '.';\n                    else if (i > 0 && dp[idx][i - 1] == 'R') {\n                        change = 1;\n                        dp[nidx][i] = 'R';\n                    } else if (i < n - 1 && dp[idx][i + 1] == 'L') {\n                        change = 1;\n                        dp[nidx][i] = 'L';\n                    } else if (i > 0 && dp[idx][i - 1] == '.' ||\n                               i < n - 1 && dp[idx][i + 1] == '.')\n                        dp[idx][i] = '.';\n                }\n            }\n            cnt++;\n        } while (change);\n        return dp[cnt & 1];\n    }\n};"}],"tagList":["双指针","字符串","动态规划"],"level":"Medium"}},{"problemName":"839.相似字符串组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/839.相似字符串组.json","problemData":{"id":"869","name":"839.相似字符串组","url":"https://leetcode.cn/problems/similar-string-groups","desc":"如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。给你一个字符串列表 strs。列表中的每个字符串都是 strs 中其它所有字符串的一个字母异位词。请问 strs 中有多少个相似字符串组？。","solutions":[{"date":"2021-02-01","time":108,"memory":43.2,"script":"typescript","desc":"利用并查集整合组。","code":"class UnionFind {\n  elements: number[];\n  constructor(public size: number) {\n    this.elements = new Array(size).fill(0).map((_, i) => i);\n  }\n  same(v1: number, v2: number): boolean {\n    return this.find(v1) === this.find(v2);\n  }\n  find(v: number): number {\n    return v === this.elements[v] ? v : (this.elements[v] = this.find(this.elements[v]));\n  }\n  union(v1: number, v2: number): void {\n    const e1 = this.find(v1);\n    const e2 = this.find(v2);\n    if (e1 !== e2) {\n      this.elements[e1] = e2;\n      this.size--;\n    }\n  }\n}\nfunction numSimilarGroups(strs: string[]): number {\n  const len = strs.length;\n  const charLen = strs[0].length;\n  const check = (str1: string, str2: string) => {\n    let num = 0;\n    for (let i = 0; i < charLen; i++) {\n      if (str1[i] !== str2[i] && ++num > 2) return false;\n    }\n    return true;\n  };\n  const uf = new UnionFind(len);\n  for (let i = 0; i < len - 1; i++) {\n    for (let j = i + 1; j < len; j++) {\n      const str1 = strs[i];\n      const str2 = strs[j];\n      if (check(str1, str2)) {\n        uf.union(i, j);\n      }\n    }\n  }\n  return uf.size;\n}"}],"tagList":["深度优先搜索","广度优先搜索","并查集","数组","哈希表","字符串"],"level":"Hard"}},{"problemName":"841.钥匙和房间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/841.钥匙和房间.json","problemData":{"id":"871","name":"841.钥匙和房间","url":"https://leetcode.cn/problems/keys-and-rooms","desc":"有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，...，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。最初，除 0 号房间外的其余所有房间都被锁住。你可以自由地在房间之间来回走动。如果能进入每个房间返回 true，否则返回 false。","solutions":[{"date":"2020-08-31","time":88,"memory":39.4,"script":"typescript","desc":"深度优先搜索。","code":"function canVisitAllRooms(rooms: number[][]): boolean {\n  const N = rooms.length;\n  const visitedRooms = new Set<number>();\n  visit(0);\n  return N === visitedRooms.size;\n  function visit(room: number) {\n    if (visitedRooms.has(room)) return;\n    visitedRooms.add(room);\n    for (const nextRoom of rooms[room]) {\n      visit(nextRoom);\n    }\n  }\n}"}],"tagList":["深度优先搜索","广度优先搜索","图"],"level":"Medium"}},{"problemName":"842.将数组拆分成斐波那契序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/842.将数组拆分成斐波那契序列.json","problemData":{"id":"872","name":"842.将数组拆分成斐波那契序列","url":"https://leetcode.cn/problems/split-array-into-fibonacci-sequence","desc":"给定一个数字字符串 S，比如 S = \"123456579\"，我们可以将它分成斐波那契式的序列 [123, 456, 579]。","solutions":[{"date":"2020-12-08","time":104,"memory":40.8,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/solution/jiang-shu-zu-chai-fen-cheng-fei-bo-na-qi-ts6c/)。","code":"function splitIntoFibonacci(S: string): number[] {\n  const list = [];\n  const maxNum = Math.pow(2, 31) - 1;\n  const len = S.length;\n  const numS = S.split('').map(v => +v);\n  (function backtrack(index = 0, sum = 0, prev = 0) {\n    if (index === len) return list.length >= 3;\n    let curLong = 0;\n    for (let i = index; i < len; i++) {\n      if (i > index && numS[index] === 0) break;\n      curLong = curLong * 10 + numS[i];\n      if (curLong > maxNum) break;\n      if (list.length >= 2) {\n        if (curLong < sum) continue;\n        else if (curLong > sum) break;\n      }\n      list.push(curLong);\n      if (backtrack(i + 1, prev + curLong, curLong)) return true;\n      list.pop();\n    }\n    return false;\n  })();\n  return list;\n}"}],"tagList":["字符串","回溯"],"level":"Medium"}},{"problemName":"844.比较含退格的字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/844.比较含退格的字符串.json","problemData":{"id":"874","name":"844.比较含退格的字符串","url":"https://leetcode.cn/problems/backspace-string-compare","desc":"给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。","solutions":[{"date":"2020-10-19","time":92,"memory":40.2,"script":"typescript","desc":"利用正则去掉退格。","code":"function backspaceCompare(S: string, T: string): boolean {\n  return replace(S) === replace(T);\n  function replace(str: string): string {\n    const reg = /[a-z]#/g;\n    let arr: RegExpMatchArray | null;\n    while ((arr = str.match(reg)) !== null) {\n      arr.forEach(v => (str = str.replace(v, '')));\n      arr = str.match(reg);\n      // console.log(str);\n    }\n    while (str.startsWith('#')) str = str.substr(1);\n    // console.log(str);\n    return str;\n  }\n}"},{"date":"2021-03-19","time":84,"memory":39.7,"script":"typescript","desc":"栈维护。","code":"function backspaceCompare(S: string, T: string): boolean {\n  function compStr(str: string): string {\n    const stack: string[] = [];\n    for (let i = 0, l = str.length; i < l; i++) {\n      const c = str[i];\n      if (c === '#') {\n        if (stack.length === 0) continue;\n        else stack.pop();\n      } else {\n        stack.push(c);\n      }\n    }\n    return stack.join('');\n  }\n  return compStr(S) === compStr(T);\n}"}],"tagList":["栈","双指针","字符串","模拟"],"level":"Easy"}},{"problemName":"845.数组中的最长山脉.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/845.数组中的最长山脉.json","problemData":{"id":"875","name":"845.数组中的最长山脉","url":"https://leetcode.cn/problems/longest-mountain-in-array","desc":"给出一个整数数组 A，返回最长 “山脉” 的长度。","solutions":[{"date":"2020-10-25","time":104,"memory":42.6,"script":"typescript","desc":"遍历获取所有山顶，再计算每个山脉的高度。","code":"function longestMountain(A: number[]): number {\n  const len = A.length;\n  const tops: number[] = [];\n  findTop();\n  let ans = 0;\n  console.log(tops);\n  if (tops.length === 0) return ans; // 没有顶峰\n  for (const top of tops) {\n    ans = Math.max(ans, findLength(top));\n  }\n  return ans;\n  function findLength(top: number): number {\n    let ans = 1;\n    for (let i = top - 1; i >= 0; i--) {\n      if (A[i] >= A[i + 1]) break;\n      ans++;\n    }\n    for (let i = top + 1; i < len; i++) {\n      if (A[i] >= A[i - 1]) break;\n      ans++;\n    }\n    return ans;\n  }\n  function findTop() {\n    for (let i = 1; i < len - 1; i++) {\n      const num = A[i];\n      if (num > A[i + 1] && num > A[i - 1]) tops.push(i);\n    }\n  }\n}"}],"tagList":["数组","双指针","动态规划","枚举"],"level":"Medium"}},{"problemName":"846.一手顺子.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/846.一手顺子.json","problemData":{"id":"876","name":"846.一手顺子","url":"https://leetcode.cn/problems/hand-of-straights","desc":"给你一个整数数组 hand 其中 hand[i] 是写在第 i 张牌，和一个整数 groupSize 。如果她可能重新排列这些牌，返回 true ；否则，返回 false 。","solutions":[{"date":"2021-12-30","time":32,"memory":19.9,"script":"cpp","desc":"遍历后标记使用过的值。","code":"class Solution {\n   public:\n    bool isNStraightHand(vector<int>& hand, int groupSize) {\n        int n = hand.size(), ans = 0, *check = (int*)calloc(n, sizeof(int)),\n            *nums = (int*)calloc(groupSize, sizeof(int));\n        sort(hand.begin(), hand.end());\n        for (int i = 0; i < n; i++) {\n            if (check[i]) continue;\n            int len = 0, pre = hand[i];\n            nums[len++] = i;\n            for (int j = i + 1; j < n && len < groupSize && hand[j] <= pre + 1;\n                 j++) {\n                if (check[j] || pre == hand[j]) continue;\n                pre = hand[j];\n                nums[len++] = j;\n            }\n            if (len < groupSize) continue;\n            ans++;\n            for (int j = 0; j < groupSize; j++) check[nums[j]] = 1;\n        }\n        return ans * groupSize == n;\n    }\n};"}],"tagList":["贪心","数组","哈希表","排序"],"level":"Medium"}},{"problemName":"847.访问所有节点的最短路径.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/847.访问所有节点的最短路径.json","problemData":{"id":"877","name":"847.访问所有节点的最短路径","url":"https://leetcode.cn/problems/shortest-path-visiting-all-nodes","desc":"返回能够访问所有节点的最短路径的长度。","solutions":[{"date":"2021-08-06","time":120,"memory":45,"script":"typescript","desc":"bfs,利用 set 做重复值过滤。","code":"function shortestPathLength(graph: number[][]): number {\n  const n = graph.length;\n  const queue: [number, number, number][] = [];\n  const seen = new Array(n).fill(0).map(_ => new Set<number>());\n  for (let i = 0; i < n; i++) {\n    queue.push([i, 1 << i, 0]);\n    seen[i].add(1 << i);\n  }\n  let ans = Infinity;\n  while (queue.length) {\n    const data = queue.shift()!;\n    const [idx, mask, step] = data;\n    if (mask === (1 << n) - 1) {\n      ans = step;\n      break;\n    }\n    for (const next of graph[idx]) {\n      const newMask = mask | (1 << next);\n      if (seen[next].has(newMask)) continue;\n      queue.push([next, newMask, step + 1]);\n      seen[next].add(newMask);\n    }\n  }\n  return ans;\n}"}],"tagList":["位运算","广度优先搜索","图","动态规划","状态压缩"],"level":"Hard"}},{"problemName":"849.到最近的人的最大距离.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/849.到最近的人的最大距离.json","problemData":{"id":"879","name":"849.到最近的人的最大距离","url":"https://leetcode.cn/problems/maximize-distance-to-closest-person","desc":"返回他到离他最近的人的最大距离。","solutions":[{"script":"cpp","time":16,"memory":16.14,"desc":"遍历时记录前一个1。","code":"class Solution {\npublic:\n    int maxDistToClosest(vector<int>& seats) {\n        int prev = -1, idx = 0, res = INT_MIN;\n        while (idx < seats.size()) {\n            if (seats[idx] == 1) {\n                if (prev == -1) res = max(res, idx);\n                else res = max(res, (idx - prev) / 2);\n                prev = idx;\n            }\n            idx += 1;\n        }\n        res = max(res, (int)seats.size() - 1 - prev);\n        return res;\n    }\n};","date":"2023-08-22"},{"script":"python","time":52,"memory":16.38,"desc":"同上。","code":"class Solution:\n    def maxDistToClosest(self, seats: List[int]) -> int:\n        prev = -1\n        idx = 0\n        res = -inf\n        while idx < len(seats):\n            if seats[idx] == 1:\n                if prev == -1:\n                    res = max(res, idx)\n                else:\n                    res = max(res, (idx - prev) // 2)\n                prev = idx\n            idx += 1\n        res = max(res, len(seats) - 1 - prev)\n        return res","date":"2023-08-22"},{"script":"rust","time":0,"memory":2.15,"desc":"同上。","code":"impl Solution {\n    pub fn max_dist_to_closest(seats: Vec<i32>) -> i32 {\n        let mut prev = -1;\n        let mut idx = 0;\n        let mut res = i32::MIN;\n        while idx < seats.len() {\n            if seats[idx] == 1 {\n                let idx = idx as i32;\n                res = res.max(if prev == -1 { idx } else { (idx - prev) / 2 });\n                prev = idx;\n            }\n            idx += 1;\n        }\n        res = res.max(seats.len() as i32 - 1 - prev);\n        res\n    }\n}","date":"2023-08-22"}],"tagList":["数组"],"level":"Medium"}},{"problemName":"851.喧闹和富有.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/851.喧闹和富有.json","problemData":{"id":"881","name":"851.喧闹和富有","url":"https://leetcode.cn/problems/loud-and-rich","desc":"现在，返回一个整数数组 answer 作为答案，其中  answer[x] = y  的前提是，在所有拥有的钱肯定不少于  person x  的人中，person y  是最安静的人（也就是安静值  quiet[y]  最小的人）。","solutions":[{"date":"2021-12-15","time":216,"memory":49.3,"script":"typescript","desc":"拓扑排序后向下遍历。","code":"class Person {\n  parent: Person = this;\n  children: Person[] = [];\n  constructor(public idx: number, public quiet: number) {}\n}\nfunction dfs(list: Set<Person>, persons: Person[], ans: number[]) {\n  if (list.size === 0) return;\n  const children = new Set<Person>();\n  for (const person of list) {\n    ans[person.idx] = person.parent.idx;\n    for (const child of person.children) {\n      children.add(child);\n      if (child.parent.quiet > person.parent.quiet) child.parent = person.parent;\n    }\n  }\n  dfs(children, persons, ans);\n}\nfunction loudAndRich(richer: number[][], quiet: number[]): number[] {\n  const persons = quiet.map((v, i) => new Person(i, v));\n  const starts = new Set(persons);\n  for (const [i1, i2] of richer) {\n    const p1 = persons[i1];\n    const p2 = persons[i2];\n    p1.children.push(p2);\n    starts.delete(p2);\n  }\n  const ans: number[] = new Array(quiet.length).fill(Infinity);\n  dfs(starts, persons, ans);\n  return ans;\n}"}],"tagList":["深度优先搜索","图","拓扑排序","数组"],"level":"Medium"}},{"problemName":"852.山脉数组的峰顶索引.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/852.山脉数组的峰顶索引.json","problemData":{"id":"882","name":"852.山脉数组的峰顶索引","url":"https://leetcode.cn/problems/peak-index-in-a-mountain-array","desc":"给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] < arr[1] < ... arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1] 的下标 i 。","solutions":[{"date":"2021-06-15","time":84,"memory":40.1,"script":"typescript","desc":"搜索最大值。","code":"function peakIndexInMountainArray(arr: number[]): number {\n  for (let i = 1, l = arr.length; i < l - 1; i++) {\n    if (arr[i - 1] < arr[i] && arr[i + 1] < arr[i]) return i;\n  }\n  return 0;\n}"},{"date":"2021-06-15","time":84,"memory":40.1,"script":"typescript","desc":"二分查找。","code":"function peakIndexInMountainArray(arr: number[]): number {\n  const len = arr.length;\n  let left = 1;\n  let right = len - 2;\n  let ans = 0;\n  while (left <= right) {\n    const mid = ~~((left + right) >> 1);\n    if (arr[mid] > arr[mid + 1]) {\n      ans = mid;\n      right = mid - 1;\n    } else {\n      left = mid + 1;\n    }\n  }\n  return ans;\n}"}],"tagList":["数组","二分查找"],"level":"Medium"}},{"problemName":"855.考场就座.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/855.考场就座.json","problemData":{"id":"885","name":"855.考场就座","url":"https://leetcode.cn/problems/exam-room","desc":"当学生进入考场后，他必须坐在能够使他与离他最近的人之间的距离达到最大化的座位上。如果有多个这样的座位，他会坐在编号最小的座位上。","solutions":[{"date":"2022-12-30","time":612,"memory":19.8,"script":"cpp","desc":"遍历。","code":"class ExamRoom {\npublic:\n    int n;\n    set<int> s;\n    ExamRoom(int n): n(n) {}\n    int seat() {\n        if (s.size() == 0) { s.insert(0); return 0; }\n        auto it = s.begin(), prev = it;\n        int ans = 0, val = 0;\n        if (*it != 0) {\n            ans = 0;\n            val = *it;\n        }\n        for (it++; it != s.end(); prev = it++) {\n            int mid = (*it + *prev) / 2;\n            if (mid - *prev > val) {\n                ans = mid;\n                val = mid - *prev;\n            }\n        }\n        if (*s.rbegin() != n - 1 && n - *s.rbegin() - 1 > val) {\n            ans = n - 1;\n            val = n - *s.rbegin() - 1;\n        }\n        s.insert(ans);\n        return ans;\n    }\n    void leave(int p) {\n        s.erase(p);\n    }\n};"}],"tagList":["设计","有序集合","堆（优先队列）"],"level":"Medium"}},{"problemName":"856.括号的分数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/856.括号的分数.json","problemData":{"id":"886","name":"856.括号的分数","url":"https://leetcode.cn/problems/score-of-parentheses","desc":"给定一个平衡括号字符串  S，按下述规则计算该字符串的分数：() 得 1 分。AB 得  A + B  分，其中 A 和 B 是平衡括号字符串。(A) 得  2 \\* A  分，其中 A 是平衡括号字符串。","solutions":[{"date":"2020-02-16","time":4,"memory":41.3,"script":"java","desc":"左括号压栈，右括号时判断当前括号里是否含有\\*，含有则出栈并把个数\\*2，最后算\\*的个数。","code":"class Solution {\n    public int scoreOfParentheses(String S) {\n        Stack<Character> stack = new Stack<Character>();\n\t\tint len = S.length();\n\t\tint sum = 0, tem = 0;\n\t\tfor (int i = 0; i < len; i++) {\n//\t\t\tSystem.out.println(stack + \",sum:\" + sum + \",tem:\" + tem);\n\t\t\tchar c = S.charAt(i);\n\t\t\tif (c == '(') {\n\t\t\t\tstack.push(c);\n\t\t\t} else {\n\t\t\t\tchar d = stack.pop();\n\t\t\t\tif (d == '(') {\n\t\t\t\t\tstack.push('*');\n\t\t\t\t}\n\t\t\t\tif (d == '*') {\n\t\t\t\t\ttem++;\n\t\t\t\t\twhile (stack.pop() == '*') {\n\t\t\t\t\t\ttem++;\n\t\t\t\t\t}\n\t\t\t\t\ttem *= 2;\n//\t\t\t\t\tSystem.out.println(stack);\n//\t\t\t\t\tSystem.out.println(tem);\n\t\t\t\t\twhile (tem != 0) {\n\t\t\t\t\t\tstack.push('*');\n\t\t\t\t\t\ttem--;\n\t\t\t\t\t}\n//\t\t\t\t\tSystem.out.println(stack);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t\twhile (!stack.isEmpty()) {\n\t\t\tstack.pop();\n\t\t\tsum++;\n\t\t}\n\t\treturn sum;\n    }\n}"},{"date":"2022-10-09","time":0,"memory":5.9,"script":"cpp","desc":"栈。","code":"class Solution {\npublic:\n    int scoreOfParentheses(string s) {\n        vector<int> st;\n        for (auto &c : s) {\n            if (c == '(') {\n                st.push_back(-1);\n            } else if (st.back() == -1) {\n                st.pop_back();\n                st.push_back(1);\n            } else {\n                int num = 0;\n                while (st.back() != -1) {\n                    num += st.back();\n                    st.pop_back();\n                }\n                st.pop_back();\n                st.push_back(num * 2);\n            }\n        }\n        return accumulate(st.begin(), st.end(), 0);\n    }\n};"}],"tagList":["栈","字符串"],"level":"Medium"}},{"problemName":"857.雇佣K名工人的最低成本.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/857.雇佣K名工人的最低成本.json","problemData":{"id":"887","name":"857.雇佣K名工人的最低成本","url":"https://leetcode.cn/problems/minimum-cost-to-hire-k-workers","desc":"给定整数 k ，返回 组成满足上述条件的付费群体所需的最小金额 。","solutions":[{"date":"2022-09-11","time":140,"memory":49.8,"script":"typescript","desc":"在工人数相同的情况下，对应 1 质量的完成，所有工人应该支付最高平均价格。","code":"class Heap<T = number> {\n  private arr: T[] = [];\n  get isEmpty() {\n    return this.size === 0;\n  }\n  get size() {\n    return this.arr.length;\n  }\n  get top() {\n    return this.arr[0];\n  }\n  constructor(private compare: (t1: T, t2: T) => number) {}\n  add(num: T): void {\n    this.arr.push(num);\n    this.shiftUp(this.size - 1);\n  }\n  remove(): T {\n    const num = this.arr.shift()!;\n    if (this.size) {\n      this.arr.unshift(this.arr.pop()!);\n      this.shiftDown(0);\n    }\n    return num;\n  }\n  private shiftUp(index: number): void {\n    if (index === 0) return;\n    const parentIndex = (index - 1) >> 1;\n    if (this.compare(this.arr[index], this.arr[parentIndex]) > 0) {\n      [this.arr[index], this.arr[parentIndex]] = [this.arr[parentIndex], this.arr[index]];\n      this.shiftUp(parentIndex);\n    }\n  }\n  private shiftDown(index: number): void {\n    let childrenIndex = index * 2 + 1;\n    if (childrenIndex > this.size - 1) return;\n    if (\n      childrenIndex + 1 <= this.size - 1 &&\n      this.compare(this.arr[childrenIndex + 1], this.arr[childrenIndex]) > 0\n    ) {\n      childrenIndex++;\n    }\n    if (this.compare(this.arr[childrenIndex], this.arr[index]) > 0) {\n      [this.arr[childrenIndex], this.arr[index]] = [this.arr[index], this.arr[childrenIndex]];\n      this.shiftDown(childrenIndex);\n    }\n  }\n  *[Symbol.iterator](): IterableIterator<T> {\n    for (const t of this.arr) {\n      yield t;\n    }\n  }\n}\nfunction mincostToHireWorkers(quality: number[], wage: number[], k: number): number {\n  const len = quality.length;\n  const arr = new Array(len)\n    .fill(0)\n    .map((_, i) => i)\n    .sort((i1, i2) => wage[i1] / quality[i1] - wage[i2] / quality[i2]);\n  const heap = new Heap<number>((t1, t2) => t1 - t2);\n  let i = 0;\n  let sum = 0;\n  let ans = Infinity;\n  for (; i < k - 1; i++) {\n    sum += quality[arr[i]];\n    heap.add(quality[arr[i]]);\n  }\n  for (; i < len; i++) {\n    sum += quality[arr[i]];\n    heap.add(quality[arr[i]]);\n    ans = Math.min(ans, (wage[arr[i]] / quality[arr[i]]) * sum);\n    sum -= heap.remove();\n  }\n  return ans;\n}"}],"tagList":["贪心","数组","排序","堆（优先队列）"],"level":"Hard"}},{"problemName":"859.亲密字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/859.亲密字符串.json","problemData":{"id":"889","name":"859.亲密字符串","url":"https://leetcode.cn/problems/buddy-strings","desc":"给定两个由小写字母构成的字符串 A 和 B ，只要我们可以通过交换 A 中的两个字母得到与 B 相等的结果，就返回 true ；否则返回 false 。","solutions":[{"date":"2021-03-14","time":92,"memory":40.5,"script":"typescript","desc":"取三段进行比较。","code":"function buddyStrings(a: string, b: string): boolean {\n  const len = a.length;\n  if (len !== b.length) return false;\n  if (a === b) return new Set([...a]).size !== len;\n  let i = 0;\n  while (i < len && a[i] === b[i]) i++;\n  let j = i + 1;\n  while (j < len && a[j] === b[j]) j++;\n  if (j === len) return false;\n  if (a[i] !== b[j] || a[j] !== b[i]) return false;\n  return (\n    a.substring(0, i) === b.substring(0, i) &&\n    a.substring(i + 1, j) === b.substring(i + 1, j) &&\n    a.substring(j + 1) === b.substring(j + 1)\n  );\n}"},{"date":"2021-03-14","time":100,"memory":40.6,"script":"typescript","desc":"优化题解 1,直接判断最后一段。","code":"function buddyStrings(a: string, b: string): boolean {\n  const len = a.length;\n  if (len !== b.length) return false;\n  if (a === b) return new Set([...a]).size !== len;\n  let i = 0;\n  while (i < len && a[i] === b[i]) i++;\n  let j = i + 1;\n  while (j < len && a[j] === b[j]) j++;\n  if (j === len) return false;\n  if (a[i] !== b[j] || a[j] !== b[i]) return false;\n  while (++j < len) if (a[j] !== b[j]) return false;\n  return true;\n}"},{"date":"2021-11-23","time":80,"memory":40.9,"script":"typescript","desc":"校验字符错位个数。","code":"function buddyStrings(s: string, goal: string): boolean {\n  const getmap = (str: string) =>\n    str.split('').reduce<Record<string, number>>((map, ch) => {\n      map[ch] = (map[ch] ?? 0) + 1;\n      return map;\n    }, {});\n  const map1 = getmap(s);\n  const map2 = getmap(goal);\n  if (Object.entries(map1).some(([k, v]) => map2[k] !== v)) return false;\n  let cnt = 0;\n  const len = s.length;\n  for (let i = 0; i < len; i++) {\n    if (s[i] !== goal[i]) cnt++;\n  }\n  if (cnt === 0) return Object.values(map1).some(v => v >= 2);\n  if (cnt !== 2) return false;\n  return true;\n}"},{"date":"2021-11-23","time":0,"memory":5.6,"script":"c","desc":"校验字符错位个数。","code":"bool buddyStrings(char * s, char * goal){\n    if (strlen(s) != strlen(goal)) return false;\n    int map1[26] = {0}, map2[26] = {0}, len = strlen(s), has_repeat = 0;\n    for (int i = 0; i < len; i++) {\n        map1[s[i] - 'a']++;\n        map2[goal[i] - 'a']++;\n    }\n    for (int i = 0; i < 26; i++) {\n        if (map1[i] != map2[i]) return false;\n        if (map1[i] >= 2) has_repeat = 1;\n    }\n    int cnt = 0;\n    for (int i = 0; i < len; i++) {\n        if (s[i] != goal[i]) {\n            if (++cnt > 2) return false;\n        }\n    }\n    if (cnt == 0) return has_repeat == 1;\n    return true;\n}"}],"tagList":["哈希表","字符串"],"level":"Easy"}},{"problemName":"860.柠檬水找零.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/860.柠檬水找零.json","problemData":{"id":"890","name":"860.柠檬水找零","url":"https://leetcode.cn/problems/lemonade-change","desc":"在柠檬水摊上，每一杯柠檬水的售价为 5 美元。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。","solutions":[{"date":"2020-12-10","time":96,"memory":40.8,"script":"typescript","desc":"贪心，20 时尽可能返回 10+5。","code":"function lemonadeChange(bills: number[]): boolean {\n  let five = 0;\n  let ten = 0;\n  for (const bill of bills) {\n    if (bill === 5) {\n      five++;\n    } else if (bill === 10) {\n      five--;\n      ten++;\n    } else if (ten > 0) {\n      ten--;\n      five--;\n    } else {\n      five -= 3;\n    }\n    if (five < 0) return false;\n  }\n  return true;\n}"},{"script":"cpp","time":88,"memory":81.4,"desc":"遍历。","code":"class Solution {\npublic:\n    bool lemonadeChange(vector<int>& bills) {\n        int coins[2] = {0};\n        for (auto &bill : bills) {\n            switch (bill) {\n                case 5: \n                    coins[0] += 1; \n                    break;\n                case 10: \n                    if (coins[0] >= 1) {\n                        coins[0]--;\n                    } else {\n                        return false;\n                    }\n                    coins[1] += 1;\n                    break;\n                case 20:\n                    if (coins[0] >= 1 && coins[1] >= 1) {\n                        coins[0] -= 1;\n                        coins[1] -= 1;\n                    } else if (coins[0] >= 3) {\n                        coins[0] -= 3;\n                    } else {\n                        return false;\n                    }\n            }\n        }\n        return true;\n    }\n};","date":"2023-07-22"}],"tagList":["贪心","数组"],"level":"Easy"}},{"problemName":"861.翻转矩阵后的得分.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/861.翻转矩阵后的得分.json","problemData":{"id":"891","name":"861.翻转矩阵后的得分","url":"https://leetcode.cn/problems/score-after-flipping-matrix","desc":"有一个二维矩阵  A 其中每个元素的值为  0  或  1 。移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。返回尽可能高的分数。","solutions":[{"date":"2020-12-07","time":96,"memory":40.2,"script":"typescript","desc":"贪心，计算首列为 1 后，后面 1 尽可能多。","code":"function matrixScore(A: number[][]): number {\n  const reverse = (num: number) => (num ? 0 : 1);\n  const rowLen = A.length;\n  const colLen = A[0].length;\n  for (const row of A) {\n    if (!row[0]) {\n      for (let i = 0, l = colLen; i < l; i++) {\n        row[i] = reverse(row[i]);\n      }\n    }\n  }\n  for (let i = 1, l = colLen; i < l; i++) {\n    let c = 0;\n    for (let j = 0; j < rowLen; j++) {\n      if (A[j][i]) {\n        cpp;\n      }\n    }\n    if (c < rowLen / 2) {\n      for (let j = 0; j < rowLen; j++) {\n        A[j][i] = reverse(A[j][i]);\n      }\n    }\n  }\n  return A.reduce((total, cur) => total + parseInt(cur.join(''), 2), 0);\n}"}],"tagList":["贪心","位运算","数组","矩阵"],"level":"Medium"}},{"problemName":"862.和至少为K的最短子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/862.和至少为K的最短子数组.json","problemData":{"id":"892","name":"862.和至少为K的最短子数组","url":"https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k","desc":"返回 A 的最短的非空连续子数组的长度，该子数组的和至少为 K 。","solutions":[{"date":"2021-07-21","time":6080,"memory":50.3,"script":"typescript","desc":"单调递增队列。","code":"function shortestSubarray(nums: number[], k: number): number {\n  const n = nums.length;\n  const queue: number[] = [];\n  const sums = [0];\n  let sum = 0;\n  nums.forEach(num => sums.push((sum += num)));\n  let ans = Infinity;\n  for (let i = 0; i <= n; i++) {\n    const sum = sums[i];\n    while (queue.length && sums[queue[queue.length - 1]] > sum) queue.pop();\n    for (const prevIndex of queue) {\n      if (sum - sums[prevIndex] >= k) {\n        ans = Math.min(ans, i - prevIndex);\n      } else break;\n    }\n    queue.push(i);\n  }\n  return ans === Infinity ? -1 : ans;\n}"},{"date":"2021-07-21","time":2896,"memory":50.3,"script":"typescript","desc":"优化题解 1。","code":"function shortestSubarray(nums: number[], k: number): number {\n  const n = nums.length;\n  const queue: number[] = [];\n  const sums = [0];\n  let sum = 0;\n  nums.forEach(num => sums.push((sum += num)));\n  let ans = Infinity;\n  for (let i = 0; i <= n; i++) {\n    const sum = sums[i];\n    let p = -1;\n    while (queue.length && sum - sums[queue[0]] >= k) p = queue.shift()!;\n    if (p !== -1) ans = Math.min(ans, i - p);\n    while (queue.length && sums[queue[queue.length - 1]] > sum) queue.pop();\n    queue.push(i);\n  }\n  return ans === Infinity ? -1 : ans;\n}"},{"date":"2022-10-26","time":204,"memory":102.3,"script":"cpp","desc":"前缀和+单调递增队列，遍历到一个值时，可以快速知道前面的前缀和。","code":"class Solution {\npublic:\n    int shortestSubarray(vector<int>& nums, int k) {\n        int n = nums.size(), ans = 0x7fffffff;\n        vector<long long> sums(1 + n, 0);\n        for (int i = 0; i < n; i++) sums[i + 1] = sums[i] + nums[i];\n        deque<int> q;\n        q.push_back(0);\n        for (int i = 0; i < n; i++) {\n            int idx = -1;\n            while (q.size() && sums[i + 1] - sums[q.front()] >= k) idx = q.front(), q.pop_front();\n            if (idx != -1) ans = min(ans, i + 1 - idx);\n            while (q.size() && sums[q.back()] > sums[i + 1]) q.pop_back();\n            q.push_back(i + 1);\n        }\n        return ans == 0x7fffffff ? -1 : ans;\n    }\n};"}],"tagList":["队列","数组","二分查找","前缀和","滑动窗口","单调队列","堆（优先队列）"],"level":"Hard"}},{"problemName":"863.二叉树中所有距离为K的结点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/863.二叉树中所有距离为K的结点.json","problemData":{"id":"893","name":"863.二叉树中所有距离为K的结点","url":"https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree","desc":"给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。","solutions":[{"date":"2021-07-25","time":88,"memory":39.9,"script":"typescript","desc":"向上寻找，向下寻找。","code":"function distanceK(root: TreeNode | null, target: TreeNode | null, k: number): number[] {\n  const ans: number[] = [];\n  find();\n  return ans;\n  function find(node: TreeNode | null = root): number {\n    if (node === null) return -1;\n    if (node === target) {\n      dfs(node);\n      return k - 1;\n    }\n    let step = find(node.left);\n    if (step !== -1) {\n      if (step === 0) {\n        ans.push(node.val);\n        return -1;\n      } else {\n        dfs(node.right, step - 1);\n        return step - 1;\n      }\n    }\n    step = find(node.right);\n    if (step !== -1) {\n      if (step === 0) {\n        ans.push(node.val);\n        return -1;\n      } else {\n        dfs(node.left, step - 1);\n        return step - 1;\n      }\n    }\n    return -1;\n  }\n  function dfs(node: TreeNode | null, level = k): void {\n    if (node === null) return;\n    if (level === 0) {\n      ans.push(node.val);\n    } else {\n      dfs(node.left, level - 1);\n      dfs(node.right, level - 1);\n    }\n  }\n}"},{"date":"2021-07-28","time":88,"memory":40.1,"script":"typescript","desc":"递归。","code":"function distanceK(root: TreeNode | null, target: TreeNode | null, k: number): number[] {\n  const ans: number[] = [];\n  find(root);\n  return ans;\n  function find(node: TreeNode | null): number {\n    if (node === null) return -1;\n    if (node === target) {\n      dfs(node, k);\n      return k - 1;\n    }\n    let distance = find(node.left);\n    if (distance !== -1) {\n      if (distance === 0) ans.push(node.val);\n      else {\n        dfs(node.right, distance - 1);\n        return distance - 1;\n      }\n      return -1;\n    }\n    distance = find(node.right);\n    if (distance !== -1) {\n      if (distance === 0) ans.push(node.val);\n      else {\n        dfs(node.left, distance - 1);\n        return distance - 1;\n      }\n    }\n    return -1;\n  }\n  function dfs(node: TreeNode | null, k: number): void {\n    if (node === null) return;\n    if (k === 0) {\n      ans.push(node.val);\n    } else {\n      dfs(node.left, k - 1);\n      dfs(node.right, k - 1);\n    }\n  }\n}"}],"tagList":["树","深度优先搜索","广度优先搜索","哈希表","二叉树"],"level":"Medium"}},{"problemName":"864.获取所有钥匙的最短路径.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/864.获取所有钥匙的最短路径.json","problemData":{"id":"895","name":"864.获取所有钥匙的最短路径","url":"https://leetcode.cn/problems/shortest-path-to-get-all-keys","desc":"返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。","solutions":[{"date":"2022-11-10","time":16,"memory":9.9,"script":"cpp","desc":"bfs，通过 mask 记录当前拿到的钥匙数。","code":"const int dirs[4][2] = {\n    {0, 1}, {0, -1},\n    {1, 0}, {-1, 0}\n};\nstruct Node {\n    int x, y, mask;\n    Node(int x, int y, int mask = 0): x(x), y(y), mask(mask){}\n};\nclass Solution {\npublic:\n    int shortestPathAllKeys(vector<string>& grid) {\n        int n = grid.size(), m = grid[0].size(), sx = -1, sy = -1, mmap[35][35][70] = {0}, MAX_MASK = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == '@') sx = i, sy = j;\n                else if (islower(grid[i][j])) MAX_MASK |= (1 << grid[i][j] - 'a');\n            }\n        }\n        int size = 1, step = 0;\n        queue<Node> q;\n        q.push(Node(sx, sy));\n        mmap[sx][sy][0] = 1;\n        while (!q.empty()) {\n            Node node = q.front();\n            // cout << \"===\" << endl\n            //      << \"step = \" << step\n            //      << \", x = \" << node.x\n            //      << \", y = \" << node.y\n            //      << \", mask = \" << node.mask\n            //      << endl;\n            if (node.mask == MAX_MASK) return step;\n            q.pop();\n            for (int i = 0; i < 4; i++) {\n                int nx = node.x + dirs[i][0], ny = node.y + dirs[i][1];\n                if (nx < 0 || nx == n || ny < 0 || ny == m) continue;\n                char c = grid[nx][ny];\n                if (c == '#') continue;\n                if (isupper(c) && (node.mask & (1 << c - 'A')) == 0) continue;\n                Node next(nx, ny, node.mask);\n                if (islower(c)) next.mask |= 1 << c - 'a';\n                if (mmap[next.x][next.y][next.mask]) continue;\n                mmap[next.x][next.y][next.mask] = 1;\n                q.push(next);\n            }\n            if (--size == 0) {\n                size = q.size();\n                step++;\n            }\n        }\n        return -1;\n    }\n};"}],"tagList":["位运算","广度优先搜索","数组","矩阵"],"level":"Hard"}},{"problemName":"865.具有所有最深节点的最小子树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/865.具有所有最深节点的最小子树.json","problemData":{"id":"896","name":"865.具有所有最深节点的最小子树","url":"https://leetcode.cn/problems/smallest-subtree-with-all-the-deepest-nodes","desc":"给定一个根为 root 的二叉树，每个节点的深度是 该节点到根的最短距离 。返回包含原始树中所有 最深节点 的 最小子树 。","solutions":[{"script":"cpp","time":8,"memory":13.76,"desc":"dfs。","code":"class Solution {\npublic:\n    TreeNode* subtreeWithAllDeepest(TreeNode* root) {\n        function<pair<int, TreeNode*>(TreeNode*, int)> dfs = [&](TreeNode *node, int level) -> pair<int, TreeNode*> {\n            pair<int, TreeNode*> res = make_pair(level, node);\n            if (node->left) {\n                res = dfs(node->left, level + 1);\n            }\n            if (node->right) {\n                auto rres = dfs(node->right, level + 1);\n                if (rres.first > res.first) res = rres;\n                else if (rres.first == res.first) res.second = node;\n            }\n            return res;\n        };\n        return dfs(root, 0).second;\n    }\n};","date":"2023-09-06"}],"tagList":["树","深度优先搜索","广度优先搜索","哈希表","二叉树"],"level":"Medium"}},{"problemName":"867.转置矩阵.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/867.转置矩阵.json","problemData":{"id":"898","name":"867.转置矩阵","url":"https://leetcode.cn/problems/transpose-matrix","desc":"给你一个二维整数数组 matrix， 返回 matrix 的 转置矩阵 。","solutions":[{"date":"2021-02-25","time":100,"memory":41.1,"script":"typescript","desc":"双循环纵向取值。","code":"function transpose(matrix: number[][]): number[][] {\n  const ans: number[][] = [];\n  for (let i = 0, colLen = matrix[0].length; i < colLen; i++) {\n    const arr: number[] = [];\n    for (let j = 0, rowLen = matrix.length; j < rowLen; j++) arr.push(matrix[j][i]);\n    ans.push(arr);\n  }\n  return ans;\n}"},{"date":"2021-02-25","time":96,"memory":40.2,"script":"typescript","desc":"读取数组长度进行纵向映射。","code":"function transpose(matrix: number[][]): number[][] {\n  return matrix[0].map((_, i) => matrix.map(arr => arr[i]));\n}"}],"tagList":["数组","矩阵","模拟"],"level":"Easy"}},{"problemName":"868.二进制间距.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/868.二进制间距.json","problemData":{"id":"899","name":"868.二进制间距","url":"https://leetcode.cn/problems/binary-gap","desc":"给定一个正整数 n，找到并返回 n 的二进制表示中两个 相邻 1 之间的 最长距离 。如果不存在两个相邻的 1，返回 0 。","solutions":[{"date":"2022-03-22","time":0,"memory":5.9,"script":"cpp","desc":"找 1，统计中间 0 的个数。","code":"class Solution {\n   public:\n    int binaryGap(int n) {\n        if (n == 0) return 0;\n        int start = 0, ans = 0;\n        while (start < 32 && (n & 1 << start) == 0) start++;\n        for (int i = start + 1, prev = start; i < 32; i++) {\n            // 统计存在11的情况\n            if ((n & 1 << i) != 0) {\n                if (i == prev + 1) {\n                    ans = 1;\n                    break;\n                }\n                prev = i;\n            }\n        }\n        while (start < 32) {\n            // 找1\n            while (start < 32 && (n & 1 << start) != 0) start++;\n            if (start == 32) break;\n            int cnt = 0;\n            // 找0\n            while (start < 32 && (n & 1 << start) == 0) start++, cnt++;\n            if (start == 32) break;\n            ans = max(ans, cnt + 1);\n        }\n        return ans;\n    }\n};"},{"date":"2022-03-22","time":0,"memory":5.8,"script":"cpp","desc":"一次遍历，找当前 1 前面的 1。","code":"class Solution {\n   public:\n    int binaryGap(int n) {\n        int ans = 0, prev = -1;\n        for (int i = 0; i < 32; i++) {\n            if ((n & 1 << i) == 0) continue;\n            if (prev != -1) ans = max(ans, i - prev);\n            prev = i;\n        }\n        return ans;\n    }\n};"},{"date":"2022-04-24","time":0,"memory":5.3,"script":"cpp","desc":"遍历。","code":"int binaryGap(int n) {\n    int prev = -1, ans = 0;\n    for (int i = 0; n; i++, n >>= 1) {\n        int bit = n & 1;\n        if (bit == 0) continue;\n        if (prev != -1) ans = fmax(ans, i - prev);\n        prev = i;\n    }\n    return ans;\n}"}],"tagList":["位运算"],"level":"Easy"}},{"problemName":"869.重新排序得到2的幂.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/869.重新排序得到2的幂.json","problemData":{"id":"900","name":"869.重新排序得到2的幂","url":"https://leetcode.cn/problems/reordered-power-of-2","desc":"给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。","solutions":[{"date":"2021-10-28","time":2416,"memory":61.5,"script":"typescript","desc":"dfs。","code":"function reorderedPowerOf2(n: number): boolean {\n  const chars = n.toString().split('');\n  const len = chars.length;\n  const list: number[] = [];\n  const set = new Set<number>();\n  dfs();\n  return list.some(num => (num & (num - 1)) === 0);\n  function dfs(num = 0) {\n    if (set.size === len) {\n      list.push(num);\n      return;\n    }\n    for (let i = 0; i < len; i++) {\n      if (set.has(i)) continue;\n      const ch = chars[i];\n      if (num === 0 && ch === '0') continue;\n      set.add(i);\n      dfs(num * 10 + ch.codePointAt(0)! - '0'.codePointAt(0)!);\n      set.delete(i);\n    }\n  }\n}"}],"tagList":["哈希表","数学","计数","枚举","排序"],"level":"Medium"}},{"problemName":"870.优势洗牌.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/870.优势洗牌.json","problemData":{"id":"901","name":"870.优势洗牌","url":"https://leetcode.cn/problems/advantage-shuffle","desc":"返回 nums1 的任意排列，使其相对于 nums2 的优势最大化。","solutions":[{"date":"2022-10-08","time":164,"memory":58.3,"script":"cpp","desc":"排序下标数组后，从大往小判断。","code":"class Solution {\npublic:\n    vector<int> advantageCount(vector<int>& nums1, vector<int>& nums2) {\n        int n = nums1.size();\n        vector<int> ans(n), inums1(n), inums2(n);\n        for (int i = 0; i < n; i++) inums1[i] = inums2[i] = i;\n        sort(inums1.begin(), inums1.end(), [&](int i1, int i2){ return nums1[i1] < nums1[i2]; });\n        sort(inums2.begin(), inums2.end(), [&](int i1, int i2){ return nums2[i1] < nums2[i2]; });\n        int e1 = n - 1, s1 = 0, i2 = n - 1;\n        while (e1 >= s1) {\n            if (nums1[inums1[e1]] > nums2[inums2[i2]]) ans[inums2[i2]] = nums1[inums1[e1--]];\n            else ans[inums2[i2]] = nums1[inums1[s1++]];\n            i2--;\n        }\n        return ans;\n    }\n};"}],"tagList":["贪心","数组","双指针","排序"],"level":"Medium"}},{"problemName":"873.最长的斐波那契子序列的长度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/873.最长的斐波那契子序列的长度.json","problemData":{"id":"905","name":"873.最长的斐波那契子序列的长度","url":"https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence","desc":"给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。","solutions":[{"date":"2022-07-11","time":480,"memory":11.6,"script":"cpp","desc":"哈希存储后遍历每条最长链路。","code":"class Solution {\n   public:\n    int lenLongestFibSubseq(vector<int> &arr) {\n        unordered_set<int> s;\n        for (auto &num : arr) s.insert(num);\n        int ans = 0;\n        for (int i = 0; i < arr.size(); i++) {\n            for (int j = 0; j < i; j++) {\n                ans = max(ans, check(s, arr[j], arr[i]) + 2);\n            }\n        }\n        return ans < 3 ? 0 : ans;\n    }\n    int check(unordered_set<int> &s, int num1, int num2) {\n        if (s.count(num1 + num2)) return 1 + check(s, num2, num1 + num2);\n        return 0;\n    }\n};"}],"tagList":["数组","哈希表","动态规划"],"level":"Medium"}},{"problemName":"874.模拟行走机器人.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/874.模拟行走机器人.json","problemData":{"id":"906","name":"874.模拟行走机器人","url":"https://leetcode.cn/problems/walking-robot-simulation","desc":"返回从原点到机器人所有经过的路径点（坐标为整数）的最大欧式距离的平方。","solutions":[{"script":"cpp","time":100,"memory":47.7,"desc":"模拟。","code":"#define X first\n#define Y second\n#define pii pair<int, int>\nvector<vector<int>> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\nclass Solution {\npublic:\n    int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {\n        unordered_map<int, unordered_map<int, bool>> m;\n        for (auto &item : obstacles) m[item[0]][item[1]] = true;\n        int d = 0, res = 0;\n        pii cur = make_pair(0, 0);\n        for (auto &cmd : commands) {\n            if (cmd == -1) d = (d + 1) % 4;\n            else if (cmd == -2) d = (d - 1 + 4) % 4;\n            else while (cmd--) {\n                if (m.count(cur.X + dirs[d][0]) && m[cur.X + dirs[d][0]].count(cur.Y + dirs[d][1])) break;\n                cur.X += dirs[d][0];\n                cur.Y += dirs[d][1];\n                res = max(res, (int)(pow(cur.X, 2) + pow(cur.Y, 2)));\n            }\n        }\n        return res;\n    }\n};","date":"2023-07-19"}],"tagList":["数组","哈希表","模拟"],"level":"Medium"}},{"problemName":"875.爱吃香蕉的珂珂.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/875.爱吃香蕉的珂珂.json","problemData":{"id":"907","name":"875.爱吃香蕉的珂珂","url":"https://leetcode.cn/problems/koko-eating-bananas","desc":"返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。","solutions":[{"date":"2022-06-08","time":0,"memory":9.9,"script":"typescript","desc":"算斜率是否相等。","code":"class Solution {\n   public:\n    bool isBoomerang(vector<vector<int>>& points) {\n        int x1 = points[0][0], y1 = points[0][1], x2 = points[1][0],\n            y2 = points[1][1], x3 = points[2][0], y3 = points[2][1];\n        return (y2 - y1) * (x3 - x1) != (y3 - y1) * (x2 - x1);\n    }\n};"}],"tagList":["数组","二分查找"],"level":"Medium"}},{"problemName":"876.链表的中间结点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/876.链表的中间结点.json","problemData":{"id":"908","name":"876.链表的中间结点","url":"https://leetcode.cn/problems/middle-of-the-linked-list","desc":"给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。","solutions":[{"date":"2020-02-13","time":0,"memory":39.8,"script":"java","desc":"使用快慢指针，若快指针到达 null 则满指针到达中间。","code":"class Solution {\n    public ListNode middleNode(ListNode head) {\n        if(head.next==null||head==null) {\n\t\t\treturn head;\n\t\t}\n\t\tif(head.next.next==null) {\n\t\t\treturn head.next;\n\t\t}\n\t\tListNode slowListNode=head;\n\t\tListNode fastListNode=head.next;\n\t\twhile(fastListNode!=null&&fastListNode.next!=null) {\n\t\t\tslowListNode=slowListNode.next;\n\t\t\tfastListNode=fastListNode.next.next;\n\t\t}\n\t\tif(fastListNode==null) {\n\t\t\treturn slowListNode;\n\t\t}else {\n\t\t\treturn slowListNode.next;\n\t\t}\n    }\n}"}],"tagList":["链表","双指针"],"level":"Easy"}},{"problemName":"877.石子游戏.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/877.石子游戏.json","problemData":{"id":"909","name":"877.石子游戏","url":"https://leetcode.cn/problems/stone-game","desc":"亚历克斯和李用几堆石子在做游戏。假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。","solutions":[{"date":"2021-06-16","time":104,"memory":44.8,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/stone-game/solution/shi-zi-you-xi-by-leetcode-solution/)。","code":"function stoneGame(piles: number[]): boolean {\n  const len = piles.length;\n  const dp = new Array(len).fill(0).map(_ => new Array(len));\n  for (let i = 0; i < len; i++) dp[i][i] = piles[i];\n  for (let i = len - 2; i >= 0; i--) {\n    for (let j = i + 1; j < len; j++) {\n      dp[i][j] = Math.max(piles[i] - dp[i + 1][j], piles[j] - dp[i][j - 1]);\n    }\n  }\n  return dp[0][len - 1] > 0;\n}"},{"date":"2021-06-16","time":84,"memory":39.2,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/stone-game/solution/shi-zi-you-xi-by-leetcode-solution/)。","code":"function stoneGame(piles: number[]): boolean {\n  return true;\n}"}],"tagList":["数组","数学","动态规划","博弈"],"level":"Medium"}},{"problemName":"878.第N个神奇数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/878.第N个神奇数字.json","problemData":{"id":"910","name":"878.第N个神奇数字","url":"https://leetcode.cn/problems/nth-magical-number","desc":"如果正整数可以被 A 或 B 整除，那么它是神奇的。","solutions":[{"date":"2021-12-11","time":76,"memory":39.3,"script":"typescript","desc":"求 1~n\\*min(a,b)中每一个数字，包括前面有的神奇数数量，用二分归为。","code":"function gcd(a: bigint, b: bigint) {\n  return b ? gcd(b, a % b) : a;\n}\nfunction lcm(a: bigint, b: bigint) {\n  return (a * b) / gcd(a, b);\n}\nfunction f(x: bigint, a: bigint, b: bigint) {\n  return x / a + x / b - x / lcm(a, b);\n}\nfunction nthMagicalNumber(n: number, a: number, b: number): number {\n  let l = 1n;\n  let r = BigInt(n * Math.min(a, b));\n  const biga = BigInt(a);\n  const bigb = BigInt(b);\n  while (l < r) {\n    const mid = (l + r) / 2n;\n    const num = f(mid, biga, bigb);\n    if (num >= n) r = mid;\n    else l = mid + 1n;\n  }\n  return Number(l % BigInt(10 ** 9 + 7));\n}"},{"date":"2022-11-22","time":4,"memory":5.7,"script":"cpp","desc":"二分，判断当前数是第几个数 = n / a + n / b - n / lcm。","code":"class Solution {\npublic:\n    const int mod = 1e9 + 7;\n    int gcd(int a, int b) {\n        if (b > a) return gcd(b, a);\n        if (b == 0) return a;\n        return gcd(b, a % b);\n    }\n    int lcm(int a, int b) {\n        return a * b / gcd(a, b);\n    }\n    int nthMagicalNumber(int n, int a, int b) {\n        long long l = min(a, b), r = n * l, m, nlcm = lcm(a, b);\n        while (l < r) {\n            m = (l + r) >> 1;\n            int num = m / a + m / b - m / nlcm;\n            if (num >= n) r = m;\n            else l = m + 1;\n        }\n        return l % mod;\n    }\n};"}],"tagList":["数学","二分查找"],"level":"Hard"}},{"problemName":"879.盈利计划.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/879.盈利计划.json","problemData":{"id":"911","name":"879.盈利计划","url":"https://leetcode.cn/problems/profitable-schemes","desc":"集团里有 n 名员工，他们可以完成各种各样的工作创造利润。有多少种计划可以选择？因为答案很大，所以 返回结果模 10^9 + 7 的值。","solutions":[{"date":"2021-06-09","time":320,"memory":76.8,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/profitable-schemes/solution/ying-li-ji-hua-by-leetcode-solution-3t8o/)。","code":"function profitableSchemes(\n  n: number,\n  minProfit: number,\n  group: number[],\n  profit: number[]\n): number {\n  const MOD = 1e9 + 7;\n  const len = group.length;\n  const dp = new Array(len + 1)\n    .fill(0)\n    .map(_ => new Array(n + 1).fill(0).map(_ => new Array(minProfit + 1).fill(0)));\n  dp[0][0][0] = 1;\n  for (let i = 1; i <= len; i++) {\n    const member = group[i - 1];\n    const earn = profit[i - 1];\n    for (let j = 0; j <= n; j++) {\n      for (let k = 0; k <= minProfit; k++) {\n        if (j < member) {\n          dp[i][j][k] = dp[i - 1][j][k];\n        } else {\n          dp[i][j][k] = (dp[i - 1][j][k] + dp[i - 1][j - member][Math.max(0, k - earn)]) % MOD;\n        }\n      }\n    }\n  }\n  let ans = 0;\n  for (let i = 0; i <= n; i++) ans = (ans + dp[len][i][minProfit]) % MOD;\n  return ans;\n}"}],"tagList":["数组","动态规划"],"level":"Hard"}},{"problemName":"881.救生艇.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/881.救生艇.json","problemData":{"id":"917","name":"881.救生艇","url":"https://leetcode.cn/problems/boats-to-save-people","desc":"返回载到每一个人所需的最小船数。","solutions":[{"date":"2021-08-26","time":176,"memory":45.6,"script":"typescript","desc":"贪心，双指针从两边向中间计算。","code":"function numRescueBoats(people: number[], limit: number): number {\n  people.sort((a, b) => a - b);\n  let ans = 0;\n  let l = 0;\n  let r = people.length - 1;\n  while (l <= r) {\n    if (people[r] + people[l] <= limit) l++;\n    r--;\n    ans++;\n  }\n  return ans;\n}"},{"script":"python","time":84,"memory":22.12,"desc":"贪心使每条船上尽可能多。","code":"class Solution:\n    def numRescueBoats(self, people: List[int], limit: int) -> int:\n        people.sort()\n        l = 0\n        r = len(people) - 1\n        res = 0\n        while l <= r:\n            if people[l] + people[r] <= limit: l += 1\n            res += 1\n            r -= 1\n        return res","date":"2024-06-10"}],"tagList":["贪心","数组","双指针","排序"],"level":"Medium"}},{"problemName":"882.细分图中的可到达节点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/882.细分图中的可到达节点.json","problemData":{"id":"918","name":"882.细分图中的可到达节点","url":"https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph","desc":"返回中枢整数 x 。如果不存在中枢整数，则返回 -1 。题目保证对于给定的输入，至多存在一个中枢整数。","solutions":[{"date":"2022-11-27","time":0,"memory":5.8,"script":"cpp","desc":"遍历对每个值尝试。","code":"# define X first\n# define Y second\n# define lb(x) ((x) & (-x))\n# define mem(a,b) memset(a,b,sizeof(a))\n# define debug freopen(\"r.txt\",\"r\",stdin)\n# define pi pair<int,int>\nusing namespace std;\ntypedef long long ll;\n\nclass Solution {\npublic:\n    int pivotInteger(int n) {\n        int sum = (1 + n) * n / 2;\n        int prev_sum = 0;\n        for (int i = 1; i <=n ; i++) {\n            int next_sum = sum - prev_sum;\n            prev_sum += i;\n            if (prev_sum == next_sum) return i;\n        }\n        return -1;\n    }\n};"}],"tagList":["图","最短路","堆（优先队列）"],"level":"Hard"}},{"problemName":"883.三维形体投影面积.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/883.三维形体投影面积.json","problemData":{"id":"919","name":"883.三维形体投影面积","url":"https://leetcode.cn/problems/projection-area-of-3d-shapes","desc":"返回 所有三个投影的总面积 。","solutions":[{"date":"2022-03-22","time":8,"memory":9.1,"script":"cpp","desc":"统计每个投影面积的大小。","code":"class Solution {\n   public:\n    int projectionArea(vector<vector<int>>& grid) {\n        int n = grid.size(), x = 0, y = 0, z = 0;\n        // z\n        for (int row = 0; row < n; row++) {\n            for (int col = 0; col < n; col++) {\n                if (grid[row][col] != 0) z++;\n            }\n        }\n        // y\n        for (int row = 0; row < n; row++) {\n            int h = 0;\n            for (int col = 0; col < n; col++) {\n                h = max(h, grid[row][col]);\n            }\n            y += h;\n        }\n        // x\n        for (int col = 0; col < n; col++) {\n            int h = 0;\n            for (int row = 0; row < n; row++) {\n                h = max(h, grid[row][col]);\n            }\n            x += h;\n        }\n        return x + y + z;\n    }\n};"}],"tagList":["几何","数组","数学","矩阵"],"level":"Easy"}},{"problemName":"884.两句话中的不常见单词.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/884.两句话中的不常见单词.json","problemData":{"id":"920","name":"884.两句话中的不常见单词","url":"https://leetcode.cn/problems/uncommon-words-from-two-sentences","desc":"给你两个 句子 s1 和 s2 ，返回所有 不常用单词 的列表。返回列表中单词可以按 任意顺序 组织。","solutions":[{"date":"2022-01-30","time":4,"memory":6.5,"script":"cpp","desc":"分割字符串后遍历。","code":"class Solution {\n   public:\n    vector<string> uncommonFromSentences(string s1, string s2) {\n        vector<string> ans;\n        unordered_map<string, int> m;\n        istringstream iss1(s1), iss2(s2);\n        string buffer;\n        while (getline(iss1, buffer, ' ')) m[buffer]++;\n        while (getline(iss2, buffer, ' ')) m[buffer]++;\n        for (auto &data : m)\n            if (data.second == 1) ans.push_back(data.first);\n        return ans;\n    }\n};"}],"tagList":["哈希表","字符串"],"level":"Easy"}},{"problemName":"886.可能的二分法.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/886.可能的二分法.json","problemData":{"id":"922","name":"886.可能的二分法","url":"https://leetcode.cn/problems/possible-bipartition","desc":"给定整数 n  和数组 dislikes ，其中  dislikes[i] = [ai, bi] ，表示不允许将编号为 ai  和   bi 的人归入同一组。当可以用这种方法将所有人分进两组时，返回 true；否则返回 false。","solutions":[{"date":"2022-10-16","time":220,"memory":62.7,"script":"cpp","desc":"并查集，把所有人的对立连成一块，并不可能和当前值在同一个集。","code":"struct UnionFind {\n    vector<int> list;\n    UnionFind(int n): list(vector<int>(n)) {\n        for (int i = 0; i < n; i++) list[i] = i;\n    }\n    int find(int v) {\n        return list[v] == v ? v : list[v] = find(list[v]);\n    }\n    void uni(int v1, int v2) {\n        int p1 = find(v1), p2 = find(v2);\n        if (p1 == p2) return;\n        list[p1] = p2;\n    }\n    bool same(int v1, int v2) {\n        return find(v1) == find(v2);\n    }\n};\nclass Solution {\npublic:\n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        UnionFind uf(n + 1);\n        vector<vector<int>> list(n + 1);\n        for (auto &item : dislikes) {\n            list[item[0]].push_back(item[1]);\n            list[item[1]].push_back(item[0]);\n        }\n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < list[i].size(); j++) {\n                uf.uni(list[i][0], list[i][j]);\n                if (uf.same(i, list[i][j])) return false;\n            }\n        }\n        return true;\n    }\n};"}],"tagList":["深度优先搜索","广度优先搜索","并查集","图"],"level":"Medium"}},{"problemName":"888.公平的糖果交换.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/888.公平的糖果交换.json","problemData":{"id":"924","name":"888.公平的糖果交换","url":"https://leetcode.cn/problems/fair-candy-swap","desc":"爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 根糖果棒的大小，B[j] 是鲍勃拥有的第 j 根糖果棒的大小。返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。","solutions":[{"date":"2021-02-01","time":132,"memory":49.2,"script":"typescript","desc":"利用 set 进行比较存在值。","code":"function fairCandySwap(A: number[], B: number[]): number[] {\n  const num =\n    (A.reduce((total, cur) => total + cur, 0) - B.reduce((total, cur) => total + cur, 0)) / 2;\n  const set = new Set(A);\n  for (const y of B) {\n    const x = y + num;\n    if (set.has(x)) return [x, y];\n  }\n  return [];\n}"}],"tagList":["数组","哈希表","二分查找","排序"],"level":"Easy"}},{"problemName":"889.根据前序和后序遍历构造二叉树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/889.根据前序和后序遍历构造二叉树.json","problemData":{"id":"925","name":"889.根据前序和后序遍历构造二叉树","url":"https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal","desc":"返回与给定的前序和后序遍历匹配的任何二叉树。","solutions":[{"date":"2020-02-22","time":3,"memory":39.4,"script":"java","desc":"通过前序的左节点头部和后序的左节点头部进行匹配获取左节点的最大下标，再通过分割数组进行递归遍历新左节点和右节点。","code":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode constructFromPrePost(int[] pre, int[] post) {\n    \tint len = pre.length;\n    \tif(len==0)return null;\n    \tTreeNode node = new TreeNode(pre[0]);\n    \tif(len==1)return node;\n    \tint L=0;\n    \tfor(int i=0;i<len;i++)\n    \t\tif(post[i]==pre[1])\n    \t\t\tL=i+1;\n    \tnode.left=constructFromPrePost(Arrays.copyOfRange(pre, 1, L+1), Arrays.copyOfRange(post, 0, L));\n    \tnode.right=constructFromPrePost(Arrays.copyOfRange(pre, L+1, len), Arrays.copyOfRange(post, L,len-1));\n    \treturn node;\n    }\n}"},{"script":"python","time":42,"memory":16.39,"desc":"dfs。","code":"class Solution:\n    def constructFromPrePost(self, preorder: List[int], postorder: List[int]) -> Optional[TreeNode]:\n        if not preorder: return None\n        l = set()\n        r = set()\n        for i in range(len(preorder) - 1):\n            l.add(preorder[i + 1])\n            r.add(postorder[i])\n            if l == r: break\n        cnt = len(l)\n        return TreeNode(\n            preorder[0],\n            self.constructFromPrePost(preorder[1:cnt + 1], postorder[:cnt]),\n            self.constructFromPrePost(preorder[cnt + 1:], postorder[cnt:-1])\n        )","date":"2024-02-23"}],"tagList":["树","数组","哈希表","分治","二叉树"],"level":"Medium"}},{"problemName":"890.查找和替换模式.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/890.查找和替换模式.json","problemData":{"id":"926","name":"890.查找和替换模式","url":"https://leetcode.cn/problems/find-and-replace-pattern","desc":"返回 words 中与给定模式匹配的单词列表。","solutions":[{"date":"2022-06-12","time":4,"memory":7.6,"script":"cpp","desc":"遍历比较。","code":"class Solution {\n   public:\n    int n;\n    vector<string> findAndReplacePattern(vector<string> &words,\n                                         string pattern) {\n        vector<string> ans;\n        n = pattern.size();\n        for (auto &word : words) {\n            if (check(pattern, word)) ans.push_back(word);\n        }\n        return ans;\n    }\n    bool check(string &pattern, string &word) {\n        char list[26] = {0};\n        bool check[26] = {0};\n        for (int i = 0; i < n; i++) {\n            char wc = word[i], pc = pattern[i];\n            if (list[pc - 'a'] && list[pc - 'a'] != wc) return false;\n            if (list[pc - 'a'] == '\\0' && check[wc - 'a']) return false;\n            check[wc - 'a'] = true;\n            list[pc - 'a'] = wc;\n        }\n        return true;\n    }\n};"}],"tagList":["数组","哈希表","字符串"],"level":"Medium"}},{"problemName":"891.子序列宽度之和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/891.子序列宽度之和.json","problemData":{"id":"927","name":"891.子序列宽度之和","url":"https://leetcode.cn/problems/sum-of-subsequence-widths","desc":"给你一个整数数组 nums ，返回 nums 的所有非空 子序列 的 宽度之和 。","solutions":[{"date":"2022-11-18","time":224,"memory":52.5,"script":"cpp","desc":"因为子序列是选取某几个元素组成所以和顺序无关，先排序然后比较对于每一个元素，有几次做最大值有几次做最小值。","code":"class Solution {\npublic:\n    typedef long long ll;\n    const ll mod = 1e9 + 7;\n    int sumSubseqWidths(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        ll ans = 0, n = nums.size();\n        for (ll i = 0; i < n; i++) ans = (ans + (toCount(i + 1) - toCount(n - i)) * nums[i]) % mod;\n        return ans;\n    }\n    ll toCount(ll num) {\n        return quick_pow(2, num - 1);\n    }\n    ll quick_pow(ll a, ll b) {\n        ll ans = 1, tmp = a;\n        for (; b; b >>= 1) {\n            if (b & 1) ans = (ans * tmp) % mod;\n            tmp = (tmp * tmp) % mod;\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","数学","排序"],"level":"Hard"}},{"problemName":"892.三维形体的表面积.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/892.三维形体的表面积.json","problemData":{"id":"928","name":"892.三维形体的表面积","url":"https://leetcode.cn/problems/surface-area-of-3d-shapes","desc":"请你返回最终这些形体的总表面积。","solutions":[{"date":"2022-03-22","time":4,"memory":9,"script":"cpp","desc":"对每一块的四边进行统计。","code":"int dirs[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\nclass Solution {\n   public:\n    int surfaceArea(vector<vector<int>>& grid) {\n        int n = grid.size(), ans = 0;\n        for (int row = 0; row < n; row++) {\n            for (int col = 0; col < n; col++) {\n                int cnt = grid[row][col];\n                if (cnt == 0) continue;\n                ans += 2;\n                for (int i = 0; i < 4; i++) {\n                    int nrow = row + dirs[i][0], ncol = col + dirs[i][1];\n                    if (nrow < 0 || nrow >= n || ncol < 0 || ncol >= n) {\n                        ans += cnt;\n                        continue;\n                    }\n                    int ncnt = grid[nrow][ncol];\n                    if (ncnt < cnt) ans += cnt - ncnt;\n                }\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["几何","数组","数学","矩阵"],"level":"Easy"}},{"problemName":"894.所有可能的真二叉树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/894.所有可能的真二叉树.json","problemData":{"id":"930","name":"894.所有可能的真二叉树","url":"https://leetcode.cn/problems/all-possible-full-binary-trees","desc":"给你一个整数 n ，请你找出所有可能含 n 个节点的 真二叉树 ，并以列表形式返回。","solutions":[{"script":"python","time":63,"memory":20.82,"desc":"dfs。","code":"class Solution:\n    @cache\n    def allPossibleFBT(self, n: int) -> List[Optional[TreeNode]]:\n        return [\n            TreeNode(0, lnode, rnode) \n            for cnt in range(1, n - 1)\n            for lnode in self.allPossibleFBT(cnt) \n            for rnode in self.allPossibleFBT(n - 1 - cnt)\n        ] if n != 1 else [TreeNode(0)]","date":"2024-04-02"}],"tagList":["树","递归","记忆化搜索","动态规划","二叉树"],"level":"Medium"}},{"problemName":"895.最大频率栈.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/895.最大频率栈.json","problemData":{"id":"931","name":"895.最大频率栈","url":"https://leetcode.cn/problems/maximum-frequency-stack","desc":"设计一个类似堆栈的数据结构，将元素推入堆栈，并从堆栈中弹出出现频率最高的元素。","solutions":[{"date":"2022-11-30","time":236,"memory":123,"script":"cpp","desc":"heap。","code":"class Node {\npublic:\n    int val, cnt, idx;\n    stack<int> time;\n    Node(int val, int cnt): val(val), cnt(cnt), idx(0) {}\n    string toString() {\n        stringstream ss;\n        ss << \"Node: \"\n           << \"val = \" << val\n           << \", cnt = \" << cnt\n           << \", idx = \" << idx\n           << \", time = \" << (time.empty() ? -1 : time.top())\n           ;\n        return ss.str();\n    }\n};\nclass Heap {\npublic:\n    int time;\n    unordered_map<int, Node*> m;\n    vector<Node*> data;\n    Heap(): time(0) {}\n    void push(int val) {\n        Node *node = nullptr;\n        if (m.count(val)) {\n            node = m[val];\n            node->cnt++;\n            node->time.push(time++);\n            // cout << \"push -> \" << node->toString() << endl;\n            shiftUp(node->idx);\n        } else {\n            node = m[val] = new Node(val, 1);\n            node->time.push(time++);\n            push(node);\n        }\n        // print();\n    }\n    void push(Node *node) {\n        node->idx = data.size();\n        // cout << \"push -> \" << node->toString() << endl;\n        data.push_back(node);\n        shiftUp(node->idx);\n    }\n    int pop() {\n        // cout << \"pop -> \" << data[0]->toString() << endl;\n        int val = data[0]->val;\n        if (data.size() == 1 && data[0]->cnt == 1) data.clear();\n        else {\n            Node *node = data[0], *last = data.back();\n            data.pop_back();\n            last->idx = 0;\n            data[0] = last;\n            // cout << \"==\" << node->toString() << endl;\n            shiftDown(0);\n            if (node->cnt > 1) {\n                node->time.pop();\n                node->cnt--;\n                push(node);\n            } else {\n                // cout << \"in\" << endl;\n                m.erase(node->val);\n                delete node;\n                // cout << \"inend\" << endl;\n            };\n        }\n        // print();\n        return val;\n    }\n    void shiftUp(int idx) {\n        // cout << \"shiftup : \" << idx << endl;\n        if (idx == 0) return;\n        int p = (idx - 1) / 2;\n        Node *cnode = data[idx], *pnode = data[p];\n        if (cnode->cnt > pnode->cnt || cnode->cnt == pnode->cnt && cnode->time.top() > pnode->time.top()) {\n            swap(cnode->idx, pnode->idx);\n            swap(data[idx], data[p]);\n            shiftUp(p);\n        }\n    }\n    void shiftDown(int idx) {\n        // cout << \"shiftdown : \" << idx << endl;\n        int child = idx * 2 + 1;\n        if (child >= data.size()) return;\n        if (child + 1 < data.size() &&\n            (data[child]->cnt < data[child + 1]->cnt ||\n             data[child]->cnt == data[child + 1]->cnt && data[child]->time.top() < data[child + 1]->time.top())\n        ) child++;\n        Node *cnode = data[child], *pnode = data[idx];\n        if (pnode->cnt < cnode->cnt || pnode->cnt == cnode->cnt && pnode->time.top() < cnode->time.top()) {\n            swap(cnode->idx, pnode->idx);\n            swap(data[child], data[idx]);\n            shiftDown(child);\n        }\n    }\n    void print() {\n        cout << \"=======PRINT========\" << endl;\n        for (int i = 0; i < data.size(); i++) {\n            cout << \"idx = \" << i\n                 << \", child = \" << (i * 2 + 1) << \", \" << (i * 2 + 2)\n                 << \", \" << data[i]->toString()\n                 << endl;\n        }\n    }\n};\nclass FreqStack {\npublic:\n    Heap heap;\n    FreqStack() {}\n    void push(int val) {\n        heap.push(val);\n    }\n    int pop() {\n        return heap.pop();\n    }\n};"},{"date":"2022-11-30","time":188,"memory":97.7,"script":"cpp","desc":"记录所有的值的次数，利用 map 对每种次数压栈处理。","code":"class FreqStack {\npublic:\n    unordered_map<int, stack<int>> mstack;\n    unordered_map<int, int> mfreq;\n    int maxFreq = 0;\n    FreqStack() {}\n    void push(int val) {\n        int freq = ++mfreq[val];\n        mstack[freq].push(val);\n        maxFreq = max(maxFreq, freq);\n    }\n    int pop() {\n        int val = mstack[maxFreq].top();\n        mfreq[val]--;\n        mstack[maxFreq].pop();\n        if (mstack[maxFreq].size() == 0) maxFreq--;\n        return val;\n    }\n};"}],"tagList":["栈","设计","哈希表","有序集合"],"level":"Hard"}},{"problemName":"896.单调数列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/896.单调数列.json","problemData":{"id":"932","name":"896.单调数列","url":"https://leetcode.cn/problems/monotonic-array","desc":"如果数组是单调递增或单调递减的，那么它是单调的。","solutions":[{"date":"2021-02-28","time":104,"memory":44.1,"script":"typescript","desc":"分别判断单调性。","code":"function isMonotonic(A: number[]): boolean {\n  const len = A.length - 1;\n  let f = true;\n  for (let i = 0; i < len; i++) {\n    if (A[i] > A[i + 1]) {\n      f = false;\n      break;\n    }\n  }\n  if (f) return true;\n  for (let i = 0; i < len; i++) {\n    if (A[i] < A[i + 1]) {\n      return false;\n    }\n  }\n  return true;\n}"}],"tagList":["数组"],"level":"Easy"}},{"problemName":"897.递增顺序搜索树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/897.递增顺序搜索树.json","problemData":{"id":"933","name":"897.递增顺序搜索树","url":"https://leetcode.cn/problems/increasing-order-search-tree","desc":"给你一棵二叉搜索树，请你 按中序遍历 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。","solutions":[{"date":"2021-04-25","time":88,"memory":39.7,"script":"typescript","desc":"递归遍历每个点。","code":"function increasingBST(root: TreeNode | null): TreeNode | null {\n  function increasing(node: TreeNode): [TreeNode, TreeNode] {\n    if (!root.left && !root.right) return [root, root];\n    let first = node;\n    let last = node;\n    if (node.left !== null) {\n      const data = increasing(node.left);\n      first = data[0];\n      data[1].right = node;\n      node.left = null;\n    }\n    if (node.right !== null) {\n      const data = increasing(node.right);\n      last.right = data[0];\n      last = data[1];\n    }\n    return [first, last];\n  }\n  return increasing(root)[0];\n}"},{"date":"2021-04-25","time":132,"memory":40.2,"script":"typescript","desc":"先中序遍历后逐个赋值。","code":"function increasingBST(root: TreeNode | null): TreeNode | null {\n  if (root === null) return null;\n  const queue: TreeNode[] = [];\n  inorder(root);\n  for (let i = 0, l = queue.length - 1; i < l; i++) {\n    const node = queue[i];\n    node.left = null;\n    node.right = queue[i + 1];\n  }\n  const last = queue[queue.length - 1];\n  last.right = last.left = null;\n  return queue[0];\n  function inorder(node: TreeNode | null): void {\n    if (node === null) return;\n    inorder(node.left);\n    queue.push(node);\n    inorder(node.right);\n  }\n}"}],"tagList":["栈","树","深度优先搜索","二叉搜索树","二叉树"],"level":"Easy"}},{"problemName":"899.有序队列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/801-900/899.有序队列.json","problemData":{"id":"935","name":"899.有序队列","url":"https://leetcode.cn/problems/orderly-queue","desc":"给定一个字符串 s 和一个整数 k 。你可以从 s 的前 k 个字母中选择一个，并把它加到字符串的末尾。 。","solutions":[{"date":"2022-08-03","time":0,"memory":2.3,"script":"rust","desc":"如果 k 大于 1，说明可以任意调换顺序，如果 k 等于 1 说明只能把头部放入尾部。","code":"use std::cmp::Ordering;\nuse std::collections::VecDeque;\nimpl Solution {\n    pub fn orderly_queue(s: String, k: i32) -> String {\n        if k == 1 {\n            let mut s = s.chars().collect::<VecDeque<char>>();\n            let mut ans = s.clone();\n            let mut temp = s.clone();\n            for i in 0..s.len() {\n                temp.pop_front();\n                temp.push_back(s[i]);\n                if ans.cmp(&temp) == Ordering::Greater {\n                    ans = temp.clone();\n                }\n            }\n            ans.into_iter().collect()\n        } else {\n            let mut s = s.chars().collect::<Vec<char>>();\n            s.sort();\n            s.into_iter().collect()\n        }\n    }\n}"}],"tagList":["数学","字符串","排序"],"level":"Hard"}}]},{"dirName":"901-1000","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\901-1000","problems":[{"problemName":"1000.合并石头的最低成本.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/1000.合并石头的最低成本.json","problemData":{"id":"1042","name":"1000.合并石头的最低成本","url":"https://leetcode.cn/problems/minimum-cost-to-merge-stones","desc":"有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。","solutions":[{"script":"cpp","time":28,"memory":24.1,"desc":"区间dp。","code":"class Solution {\npublic:\n    int mergeStones(vector<int>& stones, int k) {\n        int n = stones.size(), dp[n][n][k + 1];\n        if ((n - k) % (k - 1) != 0) return -1;\n        memset(dp, -1, sizeof(dp));\n        vector<int> sums(1, 0);\n        for (auto &s : stones) sums.push_back(sums.back() + s);\n        function<int(int, int, int)> dfs = [&](int start, int end, int p) -> int {\n            if (start == end) return 0;\n            if (dp[start][end][p] != -1) return dp[start][end][p];\n            if (p == 1) return dp[start][end][p] = start == end ? 0 : sums[end + 1] - sums[start] + dfs(start, end, k);\n            int res = INT_MAX;\n            for (int m = start; m < end; m += k - 1) {\n                res = min(res, dfs(start, m, 1) + dfs(m + 1, end, p - 1));\n            }\n            return dp[start][end][p] = res == INT_MAX ? -1 : res;\n        };\n        return dfs(0, n - 1, 1);\n    }\n};","date":"2023-04-04"},{"script":"cpp","time":0,"memory":7.7,"desc":"区间dp。","code":"class Solution {\npublic:\n    int mergeStones(vector<int>& stones, int k) {\n        int n = stones.size(), dp[n][n];\n        if ((n - k) % (k - 1) != 0) return -1;\n        memset(dp, -1, sizeof(dp));\n        vector<int> sums(1, 0);\n        for (auto &s : stones) sums.push_back(sums.back() + s);\n        function<int(int, int)> dfs = [&](int start, int end) -> int {\n            if (start == end) return 0;\n            if (dp[start][end] != -1) return dp[start][end];\n            int res = INT_MAX;\n            for (int m = start; m < end; m += k - 1) {\n                res = min(res, dfs(start, m) + dfs(m + 1, end));\n            }\n            if ((end - start) % (k - 1) == 0) res += sums[end + 1] - sums[start];\n            return dp[start][end] = res;\n        };\n        return dfs(0, n - 1);\n    }\n};","date":"2023-04-04"},{"script":"python","time":44,"memory":15.5,"desc":"同上。","code":"class Solution:\n    def mergeStones(self, stones: List[int], k: int) -> int:\n        n = len(stones)\n        if (n - k) % (k - 1) != 0:\n            return -1\n        dp = [[-1] * n for _ in range(n)]\n        sums = [0]\n        for s in stones:\n            sums.append(sums[-1] + s)\n\n        @cache\n        def dfs(start: int, end: int) -> int:\n            if start == end:\n                return 0\n            res = 0x7fffffff\n            for m in range(start, end, k-1):\n                res = min(res, dfs(start, m) + dfs(m + 1, end))\n            if (end - start) % (k - 1) == 0:\n                res += sums[end + 1] - sums[start]\n            return res\n        return dfs(0, n-1)","date":"2023-04-04"},{"script":"rust","time":0,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn merge_stones(stones: Vec<i32>, k: i32) -> i32 {\n        let n = stones.len();\n        let k = k as usize;\n        if (n - k) % (k - 1) != 0 {\n            return -1;\n        }\n        let mut dp = vec![vec![-1; n]; n];\n        let mut sums = vec![-1];\n        for s in stones {\n            sums.push(*sums.last().unwrap() + s);\n        }\n\n        fn dfs(dp: &mut Vec<Vec<i32>>, sums: &Vec<i32>, k: usize, start: usize, end: usize) -> i32 {\n            if start == end {\n                0\n            } else if dp[start][end] != -1 {\n                dp[start][end]\n            } else {\n                let mut res = i32::MAX;\n                let mut m = start;\n                while m < end {\n                    res = res.min(dfs(dp, sums, k, start, m) + dfs(dp, sums, k, m + 1, end));\n                    m += k - 1;\n                }\n                if (end - start) % (k - 1) == 0 {\n                    res += sums[end + 1] - sums[start];\n                }\n                dp[start][end] = res;\n                res\n            }\n        }\n        return dfs(&mut dp, &sums, k, 0, n - 1);\n    }\n}","date":"2023-04-04"}],"tagList":["数组","动态规划","前缀和"],"level":"Hard"}},{"problemName":"901.股票价格跨度.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/901.股票价格跨度.json","problemData":{"id":"937","name":"901.股票价格跨度","url":"https://leetcode.cn/problems/online-stock-span","desc":"编写一个 StockSpanner 类，它收集某些股票的每日报价，并返回该股票当日价格的跨度。","solutions":[{"date":"2021-07-19","time":372,"memory":48.4,"script":"typescript","desc":"单调递减栈，寻找前一个比当前值大的值。","code":"class StockSpanner {\n  private arr: number[] = [];\n  private stack: number[] = [];\n  next(price: number): number {\n    const i = this.arr.length;\n    this.arr.push(price);\n    while (this.stack.length && price >= this.arr[this.stack[this.stack.length - 1]])\n      this.stack.pop()!;\n    const ans = i - (this.stack[this.stack.length - 1] ?? -1);\n    this.stack.push(i);\n    return ans;\n  }\n}"},{"date":"2022-10-21","time":196,"memory":84.1,"script":"cpp","desc":"单调栈，存储比自己大的最近节点。","code":"class StockSpanner {\npublic:\n    stack<int> s;\n    vector<int> list;\n    StockSpanner() {\n        list.push_back(0x7fffffff);\n        s.push(0);\n    }\n    int next(int price) {\n        while (list[s.top()] <= price) s.pop();\n        int res = list.size() - s.top();\n        s.push(list.size());\n        list.push_back(price);\n        return res;\n    }\n};"},{"script":"cpp","time":240,"memory":80.53,"desc":"单调栈。","code":"class StockSpanner {\npublic:\n    int idx;\n    vector<pair<int, int>> arr;\n    StockSpanner(): idx(0), arr(vector<pair<int, int>>()) {}\n    int next(int price) {\n        while (arr.size() && arr.back().second <= price) arr.pop_back();\n        idx += 1;\n        int res = idx - (arr.size() ? arr.back().first : 0);\n        arr.push_back(make_pair(idx, price));\n        return res;\n    }\n};","date":"2023-10-07"},{"script":"python","time":356,"memory":20.68,"desc":"同上。","code":"class StockSpanner:\n\n    def __init__(self):\n        self.idx = 0\n        self.arr = []\n\n    def next(self, price: int) -> int:\n        while self.arr and self.arr[-1][1] <= price:\n            self.arr.pop()\n        self.idx += 1\n        res = self.idx - (self.arr[-1][0] if self.arr else 0)\n        self.arr.append((self.idx, price))\n        return res\n","date":"2023-10-07"},{"script":"rust","time":28,"memory":6.27,"desc":"同上。","code":"struct StockSpanner {\n    idx: usize,\n    arr: Vec<(usize, i32)>,\n}\n\nimpl StockSpanner {\n    fn new() -> Self {\n        Self {\n            idx: 0,\n            arr: vec![],\n        }\n    }\n\n    fn next(&mut self, price: i32) -> i32 {\n        while !self.arr.is_empty() && self.arr.last().unwrap().1 <= price {\n            self.arr.pop();\n        }\n        self.idx += 1;\n        let res = self.idx\n            - (if self.arr.is_empty() {\n                0\n            } else {\n                self.arr.last().unwrap().0\n            });\n        self.arr.push((self.idx, price));\n        res as i32\n    }\n}","date":"2023-10-07"}],"tagList":["栈","设计","数据流","单调栈"],"level":"Medium"}},{"problemName":"902.最大为N的数字组合.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/902.最大为N的数字组合.json","problemData":{"id":"938","name":"902.最大为N的数字组合","url":"https://leetcode.cn/problems/numbers-at-most-n-given-digit-set","desc":"返回 可以生成的小于或等于给定整数 n 的正整数的个数 。","solutions":[{"date":"2022-10-18","time":0,"memory":8,"script":"cpp","desc":"先统计少一位数的情况，再对于位数相同的情况进行遍历。","code":"class Solution {\npublic:\n    int getCnt(int n, int &first, int &firstNum) {\n        int ans = 0;\n        for (; n; n /= 10) {\n            ans++;\n            if (n < 10) first *= n, firstNum = n;\n            else first *= 10;\n        }\n        return ans;\n    }\n    int atMostNGivenDigitSet(vector<string>& digits, int n, bool empty = true) {\n        if (n == 0) return 0;\n        if (n < 10) {\n            int idx = digits.size() - 1;\n            while (idx >= 0 && digits[idx][0] - '0' > n) idx--;\n            return idx + 1;\n        }\n        int firstNum, first = 1, cnt = getCnt(n, first, firstNum), sum = 0, ans = 0;\n        for (int i = 1; i < cnt; i++) sum += pow(digits.size(), i);\n        int idx = digits.size() - 1;\n        string s = to_string(n);\n        while (idx >= 0 && digits[idx][0] - '0' > firstNum) idx--;\n        if (idx < 0) return empty ? sum : 0;\n        if (digits[idx][0] - '0' == firstNum) {\n            int _first = 0, _firstNum = 0;\n            if (getCnt(n - first, _first, _firstNum) == cnt - 1) ans += atMostNGivenDigitSet(digits, n - first, false);\n            idx--;\n        }\n        ans += (idx + 1) * pow(digits.size(), cnt - 1);\n        return empty ? ans + sum : ans;\n    }\n};"}],"tagList":["数组","数学","字符串","二分查找","动态规划"],"level":"Hard"}},{"problemName":"904.水果成篮.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/904.水果成篮.json","problemData":{"id":"940","name":"904.水果成篮","url":"https://leetcode.cn/problems/fruit-into-baskets","desc":"给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。","solutions":[{"date":"2022-10-17","time":204,"memory":69.4,"script":"cpp","desc":"滑动窗口，每次记录窗口中小于 3 元素时的最大可能。","code":"class Solution {\npublic:\n    int totalFruit(vector<int>& fruits) {\n        unordered_map<int, int> m;\n        int ans = 0, l = 0, r = 0, n = fruits.size();\n        while (r < n) {\n            m[fruits[r]]++;\n            if (m.size() == 3) {\n                do {\n                    m[fruits[l]]--;\n                    if (m[fruits[l]] == 0) m.erase(fruits[l]);\n                    l++;\n                } while (l < n && m.size() == 3);\n            }\n            ans = max(ans, r - l + 1);\n            r++;\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","滑动窗口"],"level":"Medium"}},{"problemName":"905.按奇偶排序数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/905.按奇偶排序数组.json","problemData":{"id":"941","name":"905.按奇偶排序数组","url":"https://leetcode.cn/problems/sort-array-by-parity","desc":"给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。","solutions":[{"date":"2022-03-23","time":56,"memory":15.8,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    vector<int> sortArrayByParity(vector<int>& nums) {\n        vector<int> ans;\n        ans.reserve(nums.size());\n        for (auto& num : nums) {\n            if (num & 1)\n                ans.push_back(num);\n            else\n                ans.insert(ans.begin(), num);\n        }\n        return ans;\n    }\n};"},{"date":"2022-04-28","time":4,"memory":4.6,"script":"go","desc":"双指针。","code":"func sortArrayByParity(nums []int) []int {\n    var i1, i2 = 0, len(nums) - 1\n    for i1 < i2 {\n        for i1 < i2 && nums[i1]&1 == 0 {\n            i1 += 1\n        }\n        for i1 < i2 && nums[i2]&1 == 1 {\n            i2 -= 1\n        }\n        nums[i1], nums[i2] = nums[i2], nums[i1]\n    }\n    return nums\n}"}],"tagList":["数组","双指针","排序"],"level":"Easy"}},{"problemName":"907.子数组的最小值之和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/907.子数组的最小值之和.json","problemData":{"id":"943","name":"907.子数组的最小值之和","url":"https://leetcode.cn/problems/sum-of-subarray-minimums","desc":"给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。","solutions":[{"date":"2022-10-28","time":104,"memory":41.3,"script":"cpp","desc":"单调栈，统计每个点第一个左边大的数，和第二个右边大的数，统计左边数量+右边数量+左右交叉数量。","code":"class Solution {\npublic:\n    const int mod = 1e9 + 7;\n    int sumSubarrayMins(vector<int>& arr) {\n        int n = arr.size();\n        long long ans = 0;\n        vector<int> l(n, -1), r(n, n);\n        stack<int> s;\n        for (int i = 0; i < n; i++) {\n            while (s.size() && arr[s.top()] > arr[i]) r[s.top()] = i, s.pop();\n            if (s.size()) l[i] = s.top();\n            s.push(i);\n        }\n        for (int i = 0; i < n; i++) {\n            int left = i - l[i] - 1, right = r[i] - i - 1;\n            ans = (ans +(static_cast<long long>(left) + right + left * right + 1) * arr[i]) % mod;\n        }\n        return ans;\n    }\n};"},{"script":"python","time":140,"memory":20.25,"desc":"单调栈，找出当前点为最小值时的区间。","code":"class Solution:\n    def sumSubarrayMins(self, arr: List[int]) -> int:\n        n = len(arr)\n        prev = [-1] * n\n        next = [n] * n\n        s = []\n        ans = 0\n        for i in range(n):\n            while s and arr[s[-1]] >= arr[i]:\n                next[s[-1]] = i\n                s.pop()\n            if s: prev[i] = s[-1]\n            s.append(i)\n        return sum((next[i] - i) * (i - prev[i]) * arr[i] for i in range(n)) % (10** 9 + 7)","date":"2023-11-27"}],"tagList":["栈","数组","动态规划","单调栈"],"level":"Medium"}},{"problemName":"908.最小差值I.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/908.最小差值I.json","problemData":{"id":"944","name":"908.最小差值I","url":"https://leetcode.cn/problems/smallest-range-i","desc":"在对 nums 中的每个索引最多应用一次上述操作后，返回 nums 的最低 分数 。","solutions":[{"date":"2022-03-23","time":20,"memory":15.1,"script":"cpp","desc":"排序后获得最大最小值进行比较。","code":"class Solution {\n   public:\n    int smallestRangeI(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size(), nmin = nums[0], nmax = nums[n - 1],\n            mid = (nmax + nmin) / 2;\n        if (mid - k > nmin)\n            nmin += k;\n        else\n            nmin = mid;\n        if (mid + k < nmax)\n            nmax -= k;\n        else\n            nmax = mid;\n        return nmax - nmin;\n    }\n};"},{"date":"2022-04-30","time":12,"memory":5.9,"script":"go","desc":"查看最大最小值。","code":"func smallestRangeI(nums []int, k int) int {\n  n := len(nums)\n  if n == 1 {\n    return 0\n  }\n  var (\n    min = nums[0]\n    max = nums[0]\n  )\n  for _, val := range nums {\n    if min > val {\n      min = val\n    }\n    if max < val {\n      max = val\n    }\n  }\n  mid := (min + max) >> 1\n  if mid-min <= k {\n    min = mid\n  } else {\n    min += k\n  }\n  if max-mid <= k {\n    max = mid\n  } else {\n    max -= k\n  }\n  return max - min\n}"}],"tagList":["数组","数学"],"level":"Easy"}},{"problemName":"909.蛇梯棋.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/909.蛇梯棋.json","problemData":{"id":"945","name":"909.蛇梯棋","url":"https://leetcode.cn/problems/snakes-and-ladders","desc":"N x N 的棋盘 board 上，按从 1 到 N*N 的数字给方格编号，编号 从左下角开始，每一行交替方向。返回达到方格 N*N 所需的最少移动次数，如果不可能，则返回 -1。","solutions":[{"date":"2021-06-27","time":116,"memory":45.5,"script":"typescript","desc":"广度优先搜索，储存后进行遍历。","code":"function snakesAndLadders(board: number[][]): number {\n  const N = board.length;\n  const toBlock = (row: number, col: number) => {\n    if ((N & 1) === 0) {\n      return N * (N - 1 - row) + ((row & 1) === 0 ? N - col : col + 1);\n    } else {\n      return N * (N - 1 - row) + ((row & 1) === 0 ? col + 1 : N - col);\n    }\n  };\n  const toBoard = (block: number): [number, number] => {\n    const row = N - 1 - ~~((block - 1) / N);\n    let col!: number;\n    if ((N & 1) === 0) {\n      col = (row & 1) === 0 ? N - 1 - ((block - 1) % N) : (block - 1) % N;\n    } else {\n      col = (row & 1) === 0 ? (block - 1) % N : N - 1 - ((block - 1) % N);\n    }\n    return [row, col];\n  };\n  const ANS_NUM = N ** 2;\n  const map = new Map<number, number>([[1, 0]]);\n  let ans = Infinity;\n  const queue: [number, number][] = [[N - 1, 0]];\n  while (queue.length !== 0) {\n    const [row, col] = queue.shift()!;\n    const block = toBlock(row, col);\n    const step = map.get(block)!;\n    if (ANS_NUM - block <= 6) {\n      ans = Math.min(ans, step + 1);\n      continue;\n    }\n    for (let i = 1; i <= 6; i++) {\n      let nextBlock = block + i;\n      let nextBoard = toBoard(nextBlock);\n      const [nextRow, nextCol] = nextBoard;\n      if (board[nextRow][nextCol] !== -1) {\n        nextBlock = board[nextRow][nextCol];\n        nextBoard = toBoard(nextBlock);\n      }\n      if (nextBlock === ANS_NUM) {\n        ans = Math.min(ans, step + 1);\n        continue;\n      }\n      if (!map.has(nextBlock)) queue.push(nextBoard);\n      map.set(nextBlock, Math.min(map.get(nextBlock) ?? Infinity, step + 1));\n    }\n  }\n  return ans === Infinity ? -1 : ans;\n}"}],"tagList":["广度优先搜索","数组","矩阵"],"level":"Medium"}},{"problemName":"911.在线选举.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/911.在线选举.json","problemData":{"id":"947","name":"911.在线选举","url":"https://leetcode.cn/problems/online-election","desc":"给你两个整数数组 persons 和 times 。在选举中，第  i  张票是在时刻为  times[i]  时投给候选人 persons[i]  的。对于发生在时刻 t 的每个查询，需要找出在  t 时刻在选举中领先的候选人的编号。","solutions":[{"date":"2021-12-11","time":292,"memory":51.5,"script":"typescript","desc":"初始化时记录每个时刻的获胜人数，遍历用二分。","code":"class TopVotedCandidate {\n  arr: number[] = [];\n  constructor(persons: number[], private times: number[]) {\n    const n = persons.length;\n    const temp = new Array(n).fill(0);\n    let max = 0;\n    for (const person of persons) {\n      if (++temp[person] >= temp[max]) max = person;\n      this.arr.push(max);\n    }\n  }\n  q(t: number): number {\n    let l = 0;\n    let r = this.times.length - 1;\n    while (l < r) {\n      const mid = (l + r + 1) >> 1;\n      if (this.times[mid] <= t) l = mid;\n      else r = mid - 1;\n    }\n    return this.arr[l];\n  }\n}"}],"tagList":["设计","数组","哈希表","二分查找"],"level":"Medium"}},{"problemName":"912.排序数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/912.排序数组.json","problemData":{"id":"948","name":"912.排序数组","url":"https://leetcode.cn/problems/sort-an-array","desc":"给你一个整数数组 nums，请你将该数组升序排列。","solutions":[{"date":"2021-05-07","time":156,"memory":51.9,"script":"typescript","desc":"利用内部排序。","code":"function sortArray(nums: number[]): number[] {\n  return nums.sort((a, b) => a - b);\n}"}],"tagList":["数组","分治","桶排序","计数排序","基数排序","排序","堆（优先队列）","归并排序"],"level":"Medium"}},{"problemName":"914.卡牌分组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/914.卡牌分组.json","problemData":{"id":"950","name":"914.卡牌分组","url":"https://leetcode.cn/problems/x-of-a-kind-in-a-deck-of-cards","desc":"给定一副牌，每张牌上都写着一个整数。此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：每组都有  X  张牌。组内所有的牌上都写着相同的整数。仅当你可选的 X >= 2 时返回  true。","solutions":[{"date":"2022-01-07","time":4,"memory":17,"script":"cpp","desc":"求所有数出现的次数最大公约数是否大于等于 2。","code":"class Solution {\n   public:\n    int gcd(int a, int b) {\n        if (b) return gcd(b, a % b);\n        return a;\n    }\n    bool hasGroupsSizeX(vector<int> &deck) {\n        map<int, int> m;\n        int ans = -1;\n        for (auto &num : deck) m[num]++;\n        for (auto &num : m) {\n            if (ans == -1)\n                ans = num.second;\n            else\n                ans = gcd(ans, num.second);\n            if (ans == 1) break;\n        }\n        return ans >= 2;\n    }\n};"}],"tagList":["数组","哈希表","数学","计数","数论"],"level":"Easy"}},{"problemName":"915.分割数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/915.分割数组.json","problemData":{"id":"951","name":"915.分割数组","url":"https://leetcode.cn/problems/partition-array-into-disjoint-intervals","desc":"在完成这样的分组后返回 left 的 长度 。","solutions":[{"date":"2022-10-24","time":732,"memory":136.2,"script":"cpp","desc":"维护有序序列。","code":"class Solution {\npublic:\n    int partitionDisjoint(vector<int>& nums) {\n        int n = nums.size();\n        map<int, int> m1, m2;\n        m1[nums[0]]++;\n        for (int i = 1; i < n; i++) m2[nums[i]]++;\n        int idx = 1;\n        while (m1.crbegin()->first > m2.cbegin()->first) {\n            m1[nums[idx]]++;\n            m2[nums[idx]]--;\n            if (m2[nums[idx]] == 0) m2.erase(nums[idx]);\n            ++idx;\n        }\n        return idx;\n    }\n};"},{"date":"2022-10-24","time":140,"memory":91.9,"script":"cpp","desc":"一次遍历，维护左边的最大值。","code":"class Solution {\npublic:\n    int partitionDisjoint(vector<int>& nums) {\n        int n = nums.size(), cur_max = nums[0], ans = 1, ans_max = nums[0];\n        for (int i = 1; i < n; i++) {\n            cur_max = max(cur_max, nums[i]);\n            if (nums[i] < ans_max) {\n                ans_max = cur_max;\n                ans = i + 1;\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["数组"],"level":"Medium"}},{"problemName":"917.仅仅反转字母.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/917.仅仅反转字母.json","problemData":{"id":"953","name":"917.仅仅反转字母","url":"https://leetcode.cn/problems/reverse-only-letters","desc":"返回反转后的 s 。","solutions":[{"date":"2022-02-23","time":0,"memory":5.9,"script":"cpp","desc":"双指针。","code":"class Solution {\n   public:\n    string reverseOnlyLetters(string s) {\n        for (int l = 0, r = s.size() - 1; l < r; l++, r--) {\n            while (l < s.size() && !isalpha(s[l])) l++;\n            while (r >= 0 && !isalpha(s[r])) r--;\n            if (l < r) swap(s[l], s[r]);\n        }\n        return s;\n    }\n};"}],"tagList":["双指针","字符串"],"level":"Easy"}},{"problemName":"918.环形子数组的最大和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/918.环形子数组的最大和.json","problemData":{"id":"954","name":"918.环形子数组的最大和","url":"https://leetcode.cn/problems/maximum-sum-circular-subarray","desc":"定一个长度为 n 的环形整数数组 nums ，返回 nums 的非空 子数组 的最大可能和 。","solutions":[{"script":"cpp","time":100,"memory":48,"desc":"前缀和统计，单调队列记录区间最大值。","code":"class Solution {\npublic:\n    int maxSubarraySumCircular(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> sums(1, 0);\n        for (auto &num : nums) {\n            sums.push_back(num + sums.back());\n        }\n        for (auto &num : nums) {\n            sums.push_back(num + sums.back());\n        }\n        deque<int> q;\n        for (int i = 1; i <= n; i++) {\n            while (q.size() && sums[q.back()] > sums[i]) q.pop_back();\n            q.push_back(i);\n        }\n        int res = INT_MIN;\n        for (int i = n + 1; i < sums.size(); i++) {\n            res = max(res, nums[i - n - 1]);\n            while (q.size() && q.front() < i - n) q.pop_front();\n            while (q.size() && sums[q.back()] > sums[i]) q.pop_back();\n            if (q.size()) res = max(res, sums[i] - sums[q.front()]);\n            q.push_back(i);\n        }\n        return res;\n    }\n};","date":"2023-07-20"},{"script":"python","time":396,"memory":22.3,"desc":"同上。","code":"class Solution:\n    def maxSubarraySumCircular(self, nums: List[int]) -> int:\n        n = len(nums)\n        sums = [0]\n        for num in nums:\n            sums.append(num + sums[-1])\n        for num in nums:\n            sums.append(num + sums[-1])\n        q = deque()\n        for i in range(1, n+1):\n            while len(q) and sums[q[-1]] > sums[i]:\n                q.pop()\n            q.append(i)\n        res = -inf\n        for i in range(n+1, len(sums)):\n            res = max(res, nums[i-n-1])\n            while len(q) and q[0] < i - n:\n                q.popleft()\n            while len(q) and sums[q[-1]] > sums[i]:\n                q.pop()\n            if len(q):\n                res = max(res, sums[i] - sums[q[0]])\n            q.append(i)\n        return res","date":"2023-07-20"},{"script":"rust","time":16,"memory":2.8,"desc":"同上。","code":"impl Solution {\n    pub fn max_subarray_sum_circular(nums: Vec<i32>) -> i32 {\n        let n = nums.len();\n        let mut sums = vec![0];\n        for num in &nums {\n            sums.push(sums.last().unwrap() + num);\n        }\n        for num in &nums {\n            sums.push(sums.last().unwrap() + num);\n        }\n        let mut q = std::collections::VecDeque::<usize>::new();\n        for i in 1..=n {\n            while !q.is_empty() && sums[*q.back().unwrap()] > sums[i] {\n                q.pop_back();\n            }\n            q.push_back(i);\n        }\n        let mut res = i32::MIN;\n        for i in (n + 1)..sums.len() {\n            res = res.max(nums[i - n - 1]);\n            while !q.is_empty() && *q.front().unwrap() < i - n {\n                q.pop_front();\n            }\n            while !q.is_empty() && sums[*q.back().unwrap()] > sums[i] {\n                q.pop_back();\n            }\n            if !q.is_empty() {\n                res = res.max(sums[i] - sums[*q.front().unwrap()]);\n            }\n            q.push_back(i);\n        }\n        res\n    }\n}","date":"2023-07-20"}],"tagList":["队列","数组","分治","动态规划","单调队列"],"level":"Medium"}},{"problemName":"919.完全二叉树插入器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/919.完全二叉树插入器.json","problemData":{"id":"955","name":"919.完全二叉树插入器","url":"https://leetcode.cn/problems/complete-binary-tree-inserter","desc":"设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。","solutions":[{"date":"2022-07-25","time":0,"memory":2.1,"script":"cpp","desc":"利用完全二叉树特性，列表快速查找父亲。","code":"class CBTInserter {\n   public:\n    TreeNode* root;\n    vector<TreeNode*> list;\n    CBTInserter(TreeNode* _root) {\n        this->root = _root;\n        queue<TreeNode*> q;\n        q.push(root);\n        list.push_back(root);\n        while (q.size()) {\n            TreeNode* node = q.front();\n            q.pop();\n            if (node->left) {\n                q.push(node->left);\n                list.push_back(node->left);\n            }\n            if (node->right) {\n                q.push(node->right);\n                list.push_back(node->right);\n            }\n        }\n    }\n    int insert(int val) {\n        int idx = list.size(), pidx = idx / 2 - (idx & 1 ? 0 : 1);\n        list.push_back(new TreeNode(val));\n        if (idx & 1)\n            list[pidx]->left = list[idx];\n        else\n            list[pidx]->right = list[idx];\n        return list[pidx]->val;\n    }\n    TreeNode* get_root() { return root; }\n};"},{"date":"2022-07-25","time":0,"memory":2.5,"script":"rust","desc":"利用完全二叉树特性，列表快速查找父亲。","code":"use std::cell::RefCell;\nuse std::collections::VecDeque;\nuse std::rc::Rc;\nstruct CBTInserter {\n    root: Rc<RefCell<TreeNode>>,\n    list: RefCell<Vec<Rc<RefCell<TreeNode>>>>,\n}\nimpl CBTInserter {\n    fn new(root: Option<Rc<RefCell<TreeNode>>>) -> Self {\n        let root = root.unwrap();\n        let list: RefCell<Vec<Rc<RefCell<TreeNode>>>> = RefCell::new(Vec::new());\n        {\n            let mut list = list.borrow_mut();\n            let mut q: VecDeque<Rc<RefCell<TreeNode>>> = VecDeque::new();\n            q.push_back(root.clone());\n            list.push(root.clone());\n            while q.len() > 0 {\n                let node = q.pop_front().unwrap();\n                if node.as_ref().borrow().left.is_some() {\n                    q.push_back(node.as_ref().borrow().left.as_ref().unwrap().clone());\n                    list\n                        .push(node.as_ref().borrow().left.as_ref().unwrap().clone());\n                }\n                if node.as_ref().borrow().right.is_some() {\n                    q.push_back(node.as_ref().borrow().right.as_ref().unwrap().clone());\n                    list\n                        .push(node.as_ref().borrow().right.as_ref().unwrap().clone());\n                }\n            }\n        }\n        Self { root, list }\n    }\n    fn insert(&self, val: i32) -> i32 {\n        let mut list = self.list.borrow_mut();\n        let idx = list.len();\n        let pidx = if idx & 1 == 1 { idx / 2 } else { idx / 2 - 1 };\n        let node = Rc::new(RefCell::new(TreeNode::new(val)));\n        list.push(node.clone());\n        let mut parent = list.get(pidx).unwrap().as_ref().borrow_mut();\n        if idx & 1 == 1 {\n            parent.left = Some(node.clone());\n        } else {\n            parent.right = Some(node.clone());\n        }\n        parent.val\n    }\n    fn get_root(&self) -> Option<Rc<RefCell<TreeNode>>> {\n        Some(self.root.clone())\n    }\n}"}],"tagList":["树","广度优先搜索","设计","二叉树"],"level":"Medium"}},{"problemName":"921.使括号有效的最少添加.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/921.使括号有效的最少添加.json","problemData":{"id":"957","name":"921.使括号有效的最少添加","url":"https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid","desc":"返回 为使结果字符串 s 有效而必须添加的最少括号数。","solutions":[{"date":"2022-10-04","time":0,"memory":6,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    int minAddToMakeValid(string s) {\n        int cnt = 0, l = 0;\n        for (auto &c : s) {\n            if (c == '(') l++;\n            else if (l == 0) cnt++;\n            else l--;\n        }\n        return cnt + l;\n    }\n};"}],"tagList":["栈","贪心","字符串"],"level":"Medium"}},{"problemName":"922.按奇偶排序数组II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/922.按奇偶排序数组II.json","problemData":{"id":"958","name":"922.按奇偶排序数组II","url":"https://leetcode.cn/problems/sort-array-by-parity-ii","desc":"给定一个非负整数数组  A， A 中一半整数是奇数，一半整数是偶数。对数组进行排序，以便当  A[i] 为奇数时，i  也是奇数；当  A[i]  为偶数时， i 也是偶数。","solutions":[{"date":"2020-11-12","time":120,"memory":44.1,"script":"typescript","desc":"检测当前位置是否符合，不符合查找替换。","code":"function sortArrayByParityII(A: number[]): number[] {\n  const len = A.length;\n  for (let i = 0; i < len; i++) {\n    if (i & 1) {\n      if ((A[i] & 1) === 0) {\n        let j = i + 1;\n        while (j < len) {\n          if (A[j] & 1) break;\n          j++;\n        }\n        swap(i, j);\n      }\n    } else {\n      if (A[i] & 1) {\n        let j = i + 1;\n        while (j < len) {\n          if ((A[j] & 1) === 0) break;\n          j++;\n        }\n        swap(i, j);\n      }\n    }\n  }\n  function swap(i1: number, i2: number) {\n    const t = A[i1];\n    A[i1] = A[i2];\n    A[i2] = t;\n  }\n  return A;\n}"},{"date":"2020-11-12","time":364,"memory":47.1,"script":"typescript","desc":"遍历查找符合的元素。","code":"function sortArrayByParityII(A: number[]): number[] {\n  const ans: number[] = [];\n  while (A.length !== 0) {\n    if (A.length === 1) {\n      ans.push(A.pop()!);\n    } else {\n      const nowLen = ans.length;\n      let i = 0;\n      if (nowLen & 1) {\n        for (; i < A.length; i++) {\n          if (A[i] & 1) break;\n        }\n      } else {\n        for (; i < A.length; i++) {\n          if ((A[i] & 1) === 0) break;\n        }\n      }\n      ans.push(A.splice(i, 1)[0]);\n    }\n  }\n  return ans;\n}"},{"date":"2020-11-12","time":140,"memory":47.2,"script":"typescript","desc":"遍历一次储存奇偶。","code":"function sortArrayByParityII(A: number[]): number[] {\n  const cache: Record<number, number[]> = { 1: [], 0: [] };\n  const ans: number[] = [];\n  const len = A.length;\n  A.forEach(num => cache[num & 1].push(num));\n  let i = 0;\n  while (i !== len) {\n    ans.push(cache[i++ & 1].pop()!);\n  }\n  return ans;\n}"}],"tagList":["数组","双指针","排序"],"level":"Easy"}},{"problemName":"923.三数之和的多种可能.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/923.三数之和的多种可能.json","problemData":{"id":"959","name":"923.三数之和的多种可能","url":"https://leetcode.cn/problems/3sum-with-multiplicity","desc":"给定一个整数数组  arr ，以及一个整数  target  作为目标值，返回满足 i < j < k 且  arr[i] + arr[j] + arr[k] == target  的元组  i, j, k  的数量。","solutions":[{"date":"2022-03-07","time":12,"memory":10.6,"script":"cpp","desc":"合并重复元素，通过双指针查找第三个数出现的次数。","code":"class Solution {\n   public:\n    static const int mod = 1e9 + 7;\n    // 三个数一样时， 从n个数中排列组合3个\n    int comp1(int num) { return (1 + num) * num / 2; }\n    // 两个数一样时， 从n个数中排列组合2个\n    int comp2(int num) {\n        int ans = 0;\n        for (int i = 1, n = num; i <= n; i++, num--)\n            ans = (ans + num * i) % mod;\n        return ans;\n    }\n    int threeSumMulti(vector<int> &arr, int target) {\n        map<int, int> m;\n        for (auto &num : arr) m[num]++;\n        vector<int> list;\n        for (auto &item : m) list.push_back(item.first);\n        int ans = 0, n = list.size();\n        for (int i = 0; i < n; i++) {\n            int num1 = list[i];\n            for (int j = i; j < n; j++) {\n                int num2 = list[j], num3 = target - num2 - num1, sum;\n                if (num3 < num2) break;\n                if (num1 == num2 && num1 == num3) {\n                    sum = comp2(m[num1] - 2);\n                } else if (num1 == num2 && num1 != num3) {\n                    sum = comp1(m[num1] - 1) * m[num3];\n                } else if (num1 != num2 && num2 == num3) {\n                    sum = m[num1] * comp1(m[num2] - 1);\n                } else {\n                    sum = m[num1] * m[num2] * m[num3];\n                }\n                ans = (ans + sum) % mod;\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","双指针","计数","排序"],"level":"Medium"}},{"problemName":"924.尽量减少恶意软件的传播.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/924.尽量减少恶意软件的传播.json","problemData":{"id":"960","name":"924.尽量减少恶意软件的传播","url":"https://leetcode.cn/problems/minimize-malware-spread","desc":"如果从 initial 中移除某一节点能够最小化 M(initial)， 返回该节点。如果有多个节点满足条件，就返回索引最小的节点。","solutions":[{"script":"python","time":163,"memory":19.87,"desc":"并查集。","code":"class UnionFind:\n    def __init__(self, n) -> None:\n        self.n = n\n        self.data = [i for i in range(0, n)]\n        self.sizes = [1] * n\n        self.cnt = n\n    def size(self, v: int) -> int:\n        return self.sizes[self.find(v)]\n    def find(self, v: int) -> int:\n        if self.data[v] != v:\n            self.data[v] = self.find(self.data[v])\n        return self.data[v]\n    def uni(self, v1: int, v2: int):\n        p1 = self.find(v1)\n        p2 = self.find(v2)\n        if p1 != p2:\n            self.sizes[p1] += self.sizes[p2]\n            self.cnt -= self.sizes[p2]\n            self.data[p2] = p1\n    def same(self, v1: int, v2: int):\n        return self.find(v1) == self.find(v2)\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        n = len(graph)\n        uf = UnionFind(n)\n        resIndex = -1\n        resVal = inf\n        for i in range(n):\n            for j in range(n):\n                if graph[i][j]:\n                    uf.uni(i, j)\n        for i in initial:\n            sum = 0\n            used = set()\n            for j in initial:\n                if i != j:\n                    parent = uf.find(j)\n                    if parent not in used:\n                        used.add(parent)\n                        sum += uf.size(parent)\n            if sum < resVal or (sum == resVal and i < resIndex):\n                resVal = sum\n                resIndex = i\n        return resIndex","date":"2024-04-16"}],"tagList":["深度优先搜索","广度优先搜索","并查集","图","数组","哈希表"],"level":"Hard"}},{"problemName":"925.长按键入.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/925.长按键入.json","problemData":{"id":"961","name":"925.长按键入","url":"https://leetcode.cn/problems/long-pressed-name","desc":"你的朋友正在使用键盘输入他的名字  name。偶尔，在键入字符  c  时，按键可能会被长按，而字符可能被输入 1 次或多次。你将会检查键盘输入的字符  typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回  True。","solutions":[{"date":"2020-10-23","time":88,"memory":40.2,"script":"typescript","desc":"利用指针逐个遍历。","code":"function isLongPressedName(name: string, typed: string): boolean {\n  let p = 0;\n  for (let i = 0, l = typed.length; i < l; i++) {\n    const c = typed[i];\n    if (c === name[p]) {\n      p++;\n    } else if (i !== 0 && typed[i] === typed[i - 1]) {\n    } else return false;\n  }\n  return p === name.length;\n}"}],"tagList":["双指针","字符串"],"level":"Easy"}},{"problemName":"926.将字符串翻转到单调递增.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/926.将字符串翻转到单调递增.json","problemData":{"id":"962","name":"926.将字符串翻转到单调递增","url":"https://leetcode.cn/problems/flip-string-to-monotone-increasing","desc":"返回使 S 单调递增的最小翻转次数。","solutions":[{"date":"2022-01-07","time":20,"memory":10.8,"script":"cpp","desc":"对于每个位置统计前面有几个 1，后面有几个 0，和为要翻转的总数。","code":"class Solution {\n   public:\n    int minFlipsMonoIncr(string s) {\n        int cnt0 = 0, cnt1 = 0, ans;\n        for (auto &ch : s)\n            if (ch == '0') cnt0++;\n        ans = cnt0;\n        for (auto &ch : s) {\n            if (ch == '0')\n                cnt0--;\n            else\n                cnt1++;\n            ans = min(ans, cnt0 + cnt1);\n        }\n        return ans;\n    }\n};"}],"tagList":["字符串","动态规划"],"level":"Medium"}},{"problemName":"927.三等分.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/927.三等分.json","problemData":{"id":"963","name":"927.三等分","url":"https://leetcode.cn/problems/three-equal-parts","desc":"给定一个由 0 和 1 组成的数组 arr ，将数组分成 3 个非空的部分 ，使得所有这些部分表示相同的二进制值。","solutions":[{"date":"2022-10-06","time":296,"memory":39.3,"script":"cpp","desc":"kmp 方式寻找前后缀。","code":"class Solution {\npublic:\n    vector<int> threeEqualParts(vector<int>& arr) {\n        int n = arr.size(), prefix0 = 0;\n        for (int i = 0; i < n && arr[i] == 0; i++) prefix0++; // 找到前缀有几个0\n        vector<int> ans(2, -1), next;\n        if (prefix0 == n) { // 优化全0的情况\n            ans[0] = 0;\n            ans[1] = 2;\n            return ans;\n        }\n        arr.erase(arr.begin(), arr.begin() + prefix0); // 排除前缀0\n        n = arr.size();\n        next = getNext(arr); // 利用kmp找到相同部分\n        // [0, next[cur]]     : 第一部分\n        // [next[cur] + 1, i] : 第二部分\n        // [i + 1, size() - 1]: 第三部分\n        for (int i = n - 2; i > 0; i--) {\n            int cur = i;\n            bool f = false;\n            while (next[cur] != -1 && !f) f = check(arr, ans, prefix0, next[cur], i + 1), cur = next[cur];\n            if (f) break;\n        }\n        return ans;\n    }\n    vector<int> getNext(vector<int> &arr) {\n        vector<int> next(arr.size(), -1);\n        for (int i = 1, j = -1; i < arr.size(); i++) {\n            while (j >= 0 && arr[i] != arr[j + 1]) j = next[j];\n            if (arr[j + 1] == arr[i]) j++;\n            next[i] = j;\n        }\n        return next;\n    }\n    bool check(vector<int> &arr, vector<int> &ans, int &prefix0, int s1, int s2) {\n        int i1 = s1, i2 = s2 - 1, i3 = arr.size() - 1;\n        // 从后往前依次比较\n        while (i1 >= 0 && i2 >= s1 + 1 && i3 >= s2) {\n            if (arr[i1] == arr[i2] && arr[i2] == arr[i3]) --i1, --i2, --i3;\n            else return false;\n        }\n        // 当一个部分解析完后，判断剩余是不是都是0\n        while (i1 >= 0 && arr[i1] == 0) --i1;\n        while (i2 >= s1 + 1 && arr[i2] == 0) --i2;\n        while (i3 >= s2 && arr[i3] == 0) --i3;\n        if (i1 != 0 - 1 || i2 != s1 || i3 != s2 - 1) return false;\n        ans[0] = s1 + prefix0;\n        ans[1] = s2 + prefix0;\n        return true;\n    }\n};"}],"tagList":["数组","数学"],"level":"Hard"}},{"problemName":"928.尽量减少恶意软件的传播II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/928.尽量减少恶意软件的传播II.json","problemData":{"id":"964","name":"928.尽量减少恶意软件的传播II","url":"https://leetcode.cn/problems/minimize-malware-spread-ii","desc":"我们可以从 initial 中删除一个节点，并完全移除该节点以及从该节点到任何其他节点的任何连接。请返回移除后能够使 M(initial) 最小化的节点。如果有多个节点满足条件，返回索引 最小的节点 。","solutions":[{"script":"python","time":601,"memory":19.4,"desc":"并查集。","code":"class UnionFind:\n    def __init__(self, n) -> None:\n        self.n = n\n        self.data = [i for i in range(0, n)]\n        self.sizes = [1] * n\n        self.cnt = n\n    def size(self, v: int) -> int:\n        return self.sizes[self.find(v)]\n    def find(self, v: int) -> int:\n        if self.data[v] != v:\n            self.data[v] = self.find(self.data[v])\n        return self.data[v]\n    def uni(self, v1: int, v2: int):\n        p1 = self.find(v1)\n        p2 = self.find(v2)\n        if p1 != p2:\n            self.sizes[p1] += self.sizes[p2]\n            self.cnt -= self.sizes[p2]\n            self.data[p2] = p1\n    def same(self, v1: int, v2: int):\n        return self.find(v1) == self.find(v2)\nclass Solution:\n    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:\n        n = len(graph)\n        def get(ignore_index: int) -> int:\n            uf = UnionFind(n)\n            res = 0\n            for i in range(n):\n                for j in range(n):\n                    if i == ignore_index or j == ignore_index: continue\n                    if graph[i][j]: uf.uni(i, j)\n            used = set()\n            for i in initial:\n                if i != ignore_index:\n                    parent = uf.find(i)\n                    if parent not in used:\n                        used.add(parent)\n                        res += uf.size(parent)\n            return (res, ignore_index)\n        return min(get(i) for i in initial)[1]","date":"2024-04-17"}],"tagList":["深度优先搜索","广度优先搜索","并查集","图","数组","哈希表"],"level":"Hard"}},{"problemName":"929.独特的电子邮件地址.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/929.独特的电子邮件地址.json","problemData":{"id":"965","name":"929.独特的电子邮件地址","url":"https://leetcode.cn/problems/unique-email-addresses","desc":"给你一个字符串数组 emails，我们会向每个 emails[i] 发送一封电子邮件。返回实际收到邮件的不同地址数目。","solutions":[{"date":"2022-03-23","time":32,"memory":13.2,"script":"cpp","desc":"遍历后组装新 email。","code":"class Solution {\n   public:\n    int numUniqueEmails(vector<string> &emails) {\n        unordered_set<string> s;\n        for (auto &email : emails) {\n            s.insert(format(email));\n        }\n        for (auto &email : s) cout << email << endl;\n        return s.size();\n    }\n    string format(string &email) {\n        string ans = \"\";\n        int domain = false, ignore = false;\n        for (auto &ch : email) {\n            if (ch == '@') {\n                domain = true;\n                ignore = false;\n            }\n            if (!domain && ch != '+' && ch != '.' && !ignore || domain)\n                ans += ch;\n            if (ch == '+') ignore = true;\n        }\n        return ans;\n    }\n};"},{"date":"2022-06-04","time":16,"memory":14,"script":"typescript","desc":"遍历。","code":"class Solution {\n   public:\n    int numUniqueEmails(vector<string> &emails) {\n        unordered_set<string> s;\n        for (auto &o : emails) s.insert(format(o));\n        return s.size();\n    }\n    string format(string email) {\n        string ans = \"\";\n        bool suffix = false, ignore = false;\n        for (auto &ch : email) {\n            if (ch == '+') {\n                ignore = true;\n            } else if (ch == '@') {\n                suffix = true;\n                ans += ch;\n            } else if (ch == '.' && !suffix) {\n                continue;\n            } else if (suffix || !ignore) {\n                ans += ch;\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","字符串"],"level":"Easy"}},{"problemName":"930.和相同的二元子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/930.和相同的二元子数组.json","problemData":{"id":"966","name":"930.和相同的二元子数组","url":"https://leetcode.cn/problems/binary-subarrays-with-sum","desc":"给你一个二元数组 nums ，和一个整数 goal ，请你统计并返回有多少个和为 goal 的 非空 子数组。","solutions":[{"date":"2021-07-08","time":1800,"memory":46.1,"script":"typescript","desc":"遍历两次。","code":"function numSubarraysWithSum(nums: number[], goal: number): number {\n  const len = nums.length;\n  const sums = [0];\n  for (let i = 0; i < len; i++) sums.push(nums[i] + sums[sums.length - 1]);\n  let ans = 0;\n  for (let i = 1; i <= len; i++) {\n    for (let j = 0; j < i; j++) {\n      const num = sums[i] - sums[j];\n      if (num < goal) break;\n      if (num === goal) ans++;\n    }\n  }\n  return ans;\n}"},{"date":"2021-07-08","time":92,"memory":45.6,"script":"typescript","desc":"利用哈希表储存前缀和进行快速遍历。","code":"function numSubarraysWithSum(nums: number[], goal: number): number {\n  let ans = 0;\n  let sum = 0;\n  const map = new Map<number, number>();\n  for (const num of nums) {\n    map.set(sum, (map.get(sum) ?? 0) + 1);\n    sum += num;\n    ans += map.get(sum - goal) ?? 0;\n  }\n  return ans;\n}"}],"tagList":["数组","哈希表","前缀和","滑动窗口"],"level":"Medium"}},{"problemName":"931.下降路径最小和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/931.下降路径最小和.json","problemData":{"id":"967","name":"931.下降路径最小和","url":"https://leetcode.cn/problems/minimum-falling-path-sum","desc":"给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。","solutions":[{"script":"cpp","time":12,"memory":9.9,"desc":"遍历。","code":"class Solution {\npublic:\n    int minFallingPathSum(vector<vector<int>>& matrix) {\n        int n = matrix.size(), res = INT_MAX;\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                int val = matrix[i][j] + matrix[i - 1][j];\n                if (j > 0) val = min(val, matrix[i][j] + matrix[i - 1][j - 1]);\n                if (j < n - 1) val = min(val, matrix[i][j] + matrix[i - 1][j + 1]);\n                matrix[i][j] = val;\n            }\n        }\n        for (int j = 0; j < n; j++) res = min(res, matrix[n - 1][j]);\n        return res;\n    }\n};","date":"2023-07-13"},{"script":"python","time":80,"memory":17,"desc":"同上。","code":"class Solution:\n    def minFallingPathSum(self, matrix: List[List[int]]) -> int:\n        n = len(matrix)\n        for i in range(1, n):\n            for j in range(n):\n                val = matrix[i][j] + matrix[i-1][j]\n                if j > 0:\n                    val = min(val, matrix[i][j] + matrix[i-1][j-1])\n                if j < n-1:\n                    val = min(val, matrix[i][j] + matrix[i-1][j+1])\n                matrix[i][j] = val\n        return min(matrix[n-1])","date":"2023-07-13"},{"script":"rust","time":4,"memory":2.1,"desc":"同上。","code":"impl Solution {\n    pub fn min_falling_path_sum(mut matrix: Vec<Vec<i32>>) -> i32 {\n        let n = matrix.len();\n        for i in 1..n {\n            for j in 0..n {\n                let mut val = matrix[i][j] + matrix[i - 1][j];\n                if j > 0 {\n                    val = val.min(matrix[i][j] + matrix[i - 1][j - 1]);\n                }\n                if j < n - 1 {\n                    val = val.min(matrix[i][j] + matrix[i - 1][j + 1]);\n                }\n                matrix[i][j] = val;\n            }\n        }\n        *matrix[n - 1].iter().min().unwrap()\n    }\n}","date":"2023-07-13"}],"tagList":["数组","动态规划","矩阵"],"level":"Medium"}},{"problemName":"933.最近的请求次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/933.最近的请求次数.json","problemData":{"id":"969","name":"933.最近的请求次数","url":"https://leetcode.cn/problems/number-of-recent-calls","desc":"写一个 RecentCounter 类来计算特定时间范围内最近的请求。","solutions":[{"date":"2021-03-14","time":264,"memory":47.9,"script":"typescript","desc":"队列直接判断头部值是否符合要求。","code":"class RecentCounter {\n  private queue: number[] = [];\n  ping(t: number): number {\n    this.queue.push(t);\n    while (this.queue[0] < t - 3000) {\n      this.queue.shift();\n    }\n    return this.queue.length;\n  }\n}"},{"date":"2022-05-06","time":132,"memory":56,"script":"cpp","desc":"queue。","code":"class RecentCounter {\n   public:\n    queue<int> q;\n    RecentCounter() {}\n    int ping(int t) {\n        q.push(t);\n        while (t - q.front() > 3000) q.pop();\n        return q.size();\n    }\n};"},{"date":"2022-05-06","time":136,"memory":8.1,"script":"go","desc":"queue。","code":"type RecentCounter struct {\n    queue []int\n}\n\nfunc Constructor() RecentCounter {\n    res := RecentCounter{}\n    return res\n}\nfunc (this *RecentCounter) Ping(t int) int {\n    this.queue = append(this.queue, t)\n    for t-this.queue[0] > 3000 {\n        this.queue = this.queue[1:]\n    }\n    return len(this.queue)\n}"}],"tagList":["设计","队列","数据流"],"level":"Easy"}},{"problemName":"934.最短的桥.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/934.最短的桥.json","problemData":{"id":"971","name":"934.最短的桥","url":"https://leetcode.cn/problems/shortest-bridge","desc":"返回必须翻转的 0 的最小数目。","solutions":[{"date":"2022-10-25","time":44,"memory":18.6,"script":"cpp","desc":"bfs。","code":"typedef pair<int, int> node;\nconst int dirs[4][2] = {\n    {0, 1}, {0, -1},\n    {1, 0}, {-1, 0}\n};\nclass Solution {\npublic:\n    int shortestBridge(vector<vector<int>>& grid) {\n        int n = grid.size();\n        vector<vector<bool>> check(n, vector<bool>(n, false));\n        queue<node> q;\n        int f = true;\n        for (int i = 0; i < n && f; i++) {\n            for (int j = 0; j < n && f; j++) {\n                if (grid[i][j] == 1) {\n                    queue<node> tmp;\n                    tmp.push(make_pair(i, j));\n                    check[i][j] = true;\n                    while (tmp.size()) {\n                        node v = tmp.front();\n                        tmp.pop();\n                        q.push(make_pair(v.first, v.second));\n                        for (int k = 0; k < 4; k++) {\n                            int ni = v.first + dirs[k][0], nj = v.second + dirs[k][1];\n                            if (ni < 0 || ni == n || nj < 0 || nj == n || grid[ni][nj] == 0 || check[ni][nj]) continue;\n                            tmp.push(make_pair(ni, nj));\n                            check[ni][nj] = true;\n                        }\n                    }\n                    f = false;\n                }\n            }\n        }\n        int level = 1, size = q.size();\n        while (q.size()) {\n            node v = q.front();\n            q.pop();\n            for (int i = 0; i < 4; i++) {\n                int ni = v.first + dirs[i][0], nj = v.second + dirs[i][1];\n                if (ni < 0 || ni == n || nj < 0 || nj == n || check[ni][nj]) continue;\n                if (grid[ni][nj]) return level - 1;\n                check[ni][nj] = true;\n                q.push(make_pair(ni, nj));\n            }\n            if (--size == 0) {\n                size = q.size();\n                level++;\n            }\n        }\n        return 0;\n    }\n};"}],"tagList":["深度优先搜索","广度优先搜索","数组","矩阵"],"level":"Medium"}},{"problemName":"937.重新排列日志文件.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/937.重新排列日志文件.json","problemData":{"id":"974","name":"937.重新排列日志文件","url":"https://leetcode.cn/problems/reorder-data-in-log-files","desc":"返回日志的最终顺序。","solutions":[{"date":"2022-03-24","time":60,"memory":32.3,"script":"cpp","desc":"遍历后比较。","code":"vector<string> split(string str) {\n    istringstream iss(str);\n    string tmp;\n    vector<string> ans;\n    while (getline(iss, tmp, ' ')) ans.push_back(tmp);\n    return ans;\n}\nbool comp(string &a, string &b) {\n    vector<string> list1 = split(a), list2 = split(b);\n    string body1 = \"\", body2 = \"\";\n    for (int i = 1; i < list1.size(); i++) body1 += list1[i] + \" \";\n    for (int i = 1; i < list2.size(); i++) body2 += list2[i] + \" \";\n    if (body1 == body2)\n        return list1[0] < list2[0];\n    else\n        return body1 < body2;\n}\nclass Solution {\n   public:\n    vector<string> reorderLogFiles(vector<string> &logs) {\n        vector<string> lets, digs, ans;\n        for (auto &log : logs) {\n            if (isDigLog(log))\n                digs.push_back(log);\n            else\n                lets.push_back(log);\n        }\n        sort(lets.begin(), lets.end(), comp);\n        for (auto &log : lets) ans.push_back(log);\n        for (auto &log : digs) ans.push_back(log);\n        return ans;\n    }\n    bool isDigLog(string log) { return isdigit(split(log)[1][0]); }\n};"},{"date":"2022-05-03","time":4,"memory":4.6,"script":"cpp","desc":"分割字符串，排序。","code":"type Item struct {\n    raw   []string\n    state int\n    idx   int\n}\n\nfunc reorderLogFiles(logs []string) []string {\n    n := len(logs)\n    list := make([]Item, n)\n    for i := 0; i < n; i++ {\n        list[i] = toItem(logs[i], i)\n    }\n    sort.Slice(list, func(i, j int) bool {\n        if list[i].state == 0 && list[j].state == 0 {\n            return list[i].idx < list[j].idx\n        } else if list[i].state == 0 && list[j].state == 1 {\n            return false\n        } else if list[i].state == 1 && list[j].state == 0 {\n            return true\n        } else {\n            idx := 1\n            for ; idx < len(list[i].raw) && idx < len(list[j].raw); idx++ {\n                comp := strings.Compare(list[i].raw[idx], list[j].raw[idx])\n                if comp < 0 {\n                    return true\n                } else if comp > 0 {\n                    return false\n                }\n            }\n            if idx != len(list[i].raw) {\n                return false\n            } else if idx != len(list[j].raw) {\n                return true\n            } else {\n                return strings.Compare(list[i].raw[0], list[j].raw[0]) < 0\n            }\n\n        }\n    })\n    ans := make([]string, n)\n    for i, val := range list {\n        ans[i] = logs[val.idx]\n    }\n    return ans\n}\nfunc toItem(log string, i int) Item {\n    item := Item{}\n    item.idx = i\n    item.raw = strings.Split(log, \" \")\n    var flag bool = true\n    for _, val := range item.raw[1] {\n        if !unicode.IsDigit(val) {\n            flag = false\n            break\n        }\n    }\n    if flag {\n        item.state = 0\n    } else {\n        item.state = 1\n    }\n    return item\n}"}],"tagList":["数组","字符串","排序"],"level":"Medium"}},{"problemName":"938.二叉搜索树的范围和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/938.二叉搜索树的范围和.json","problemData":{"id":"975","name":"938.二叉搜索树的范围和","url":"https://leetcode.cn/problems/range-sum-of-bst","desc":"给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。","solutions":[{"date":"2020-02-24","time":10,"memory":47.5,"script":"java","desc":"中序遍历后循环判断。","code":"class Solution {\n    ArrayList<Integer> list = new ArrayList<Integer>(10000);\n\n\tpublic int rangeSumBST(TreeNode root, int L, int R) {\n\t\tinorder(root);\n\t\tint sum = 0;\n\t\tfor (int i = 0, len = list.size(); i < len; i++) {\n\t\t\tif (list.get(i) < L)\n\t\t\t\tcontinue;\n\t\t\telse if (list.get(i) >= L && list.get(i) <= R)\n\t\t\t\tsum += list.get(i);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\treturn sum;\n\t}\n\n\tpublic void inorder(TreeNode node) {\n\t\tif (node.left != null)\n\t\t\tinorder(node.left);\n\t\tlist.add(node.val);\n\t\tif (node.right != null)\n\t\t\tinorder(node.right);\n\t}\n}"},{"date":"2021-04-27","time":288,"memory":65.9,"script":"typescript","desc":"递归判断。","code":"function rangeSumBST(root: TreeNode | null, low: number, high: number): number {\n        let sum = 0;\n        const sumNode = (node: TreeNode | null): void => {\n          if (node === null) return;\n          const val = node.val;\n          if (val < low) sumNode(node.right);\n          else if (val > high) sumNode(node.left);\n          else {\n            sum += val;\n            sumNode(node.right);\n            sumNode(node.left);\n          }\n        };\n        sumNode(root);\n        return sum;\n      }}"},{"script":"python","time":98,"memory":24.04,"desc":"dfs。","code":"class Solution:\n    def rangeSumBST(self, root: Optional[TreeNode], low: int, high: int) -> int:\n        if not root: return 0\n        if root.val < low: return self.rangeSumBST(root.right, low, high)\n        if root.val > high: return self.rangeSumBST(root.left, low, high)\n        return root.val + self.rangeSumBST(root.right, low, high) + self.rangeSumBST(root.left, low, high)","date":"2024-02-26"}],"tagList":["树","深度优先搜索","二叉搜索树","二叉树"],"level":"Easy"}},{"problemName":"940.不同的子序列II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/940.不同的子序列II.json","problemData":{"id":"977","name":"940.不同的子序列II","url":"https://leetcode.cn/problems/distinct-subsequences-ii","desc":"给定一个字符串 s，计算 s 的 不同非空子序列 的个数。因为结果可能很大，所以返回答案需要对 10^9 + 7 取余 。","solutions":[{"date":"2022-10-14","time":160,"memory":8.4,"script":"cpp","desc":"动态规划，每个点记录当前值和遍历过的后个节点。","code":"const int mod = 1e9 + 7;\nstruct Item {\n    int val;\n    bool next[26];\n    Item(): val(0) {\n        memset(next, 0, sizeof(bool) * 26);\n    }\n};\nclass Solution {\npublic:\n    int distinctSubseqII(string s) {\n        int n = s.size(), ans = 0;\n        bool charList[26] = {0};\n        vector<Item> dp(n);\n        for (int i = 0; i < n; i++) {\n            char c = s[i];\n            if (charList[c - 'a'] == 0) dp[i].val += 1, charList[c - 'a'] = 1;\n            for (int j = 0; j < i; j++) {\n                if (dp[j].next[c - 'a']) continue;\n                dp[j].next[c - 'a'] = true;\n                dp[i].val = (dp[i].val + dp[j].val) % mod;\n            }\n            ans = (ans + dp[i].val) % mod;\n        }\n        return ans;\n    }\n};"}],"tagList":["字符串","动态规划"],"level":"Hard"}},{"problemName":"941.有效的山脉数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/941.有效的山脉数组.json","problemData":{"id":"978","name":"941.有效的山脉数组","url":"https://leetcode.cn/problems/valid-mountain-array","desc":"给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。","solutions":[{"date":"2020-11-03","time":116,"memory":40.3,"script":"javascript","desc":"获取山顶然后向两侧遍历。","code":"/**\n * @param {number[]} A\n * @return {boolean}\n */\nvar validMountainArray = function (A) {\n  const l = A.length;\n  if (l < 3) return false;\n  let top;\n  for (let i = 1; i < l - 1; i++) {\n    if (A[i] > A[i - 1] && A[i] > A[i + 1]) {\n      if (top !== undefined) return false;\n      top = i;\n    }\n  }\n  if (top === undefined) return false;\n  for (let i = top; i >= 0; i--) {\n    if (A[i] <= A[i - 1]) return false;\n  }\n  for (let i = top; i < l; i++) {\n    if (A[i] <= A[i + 1]) return false;\n  }\n  return true;\n};"},{"date":"2021-12-12","time":76,"memory":40.9,"script":"typescript","desc":"双指针从两头开始遍历。","code":"function validMountainArray(arr: number[]): boolean {\n  const n = arr.length;\n  let l = 0;\n  let r = n - 1;\n  while (l < r && arr[l] < arr[l + 1]) l++;\n  while (l < r && arr[r] < arr[r - 1]) r--;\n  return l === r && l !== 0 && l !== n - 1;\n}"}],"tagList":["数组"],"level":"Easy"}},{"problemName":"942.增减字符串匹配.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/942.增减字符串匹配.json","problemData":{"id":"979","name":"942.增减字符串匹配","url":"https://leetcode.cn/problems/di-string-match","desc":"给定一个字符串 s ，重构排列 perm 并返回它。如果有多个有效排列 perm，则返回其中 任何一个 。","solutions":[{"date":"2022-03-24","time":4,"memory":8.7,"script":"cpp","desc":"贪心，每次 I 选最小值，D 选最大值。","code":"class Solution {\n   public:\n    vector<int> diStringMatch(string s) {\n        int n = s.size(), l = 0, r = s.size();\n        vector<int> ans;\n        for (auto &ch : s) {\n            if (ch == 'I') {\n                ans.push_back(l++);\n            } else {\n                ans.push_back(r--);\n            }\n        }\n        ans.push_back(l++);\n        return ans;\n    }\n};"}],"tagList":["贪心","数组","双指针","字符串"],"level":"Easy"}},{"problemName":"944.删列造序.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/944.删列造序.json","problemData":{"id":"981","name":"944.删列造序","url":"https://leetcode.cn/problems/delete-columns-to-make-sorted","desc":"给你由 n 个小写字母字符串组成的数组 strs，其中每个字符串长度相等。返回你需要删除的列数。","solutions":[{"date":"2022-03-25","time":36,"memory":12,"script":"cpp","desc":"按列遍历。","code":"class Solution {\n   public:\n    int minDeletionSize(vector<string>& strs) {\n        int ans = 0, n = strs.size(), m = strs[0].size();\n        for (int i = 0; i < m; i++) {\n            char prev = strs[0][i];\n            for (int j = 1; j < n; j++) {\n                if (strs[j][i] < prev) {\n                    ans++;\n                    break;\n                }\n                prev = strs[j][i];\n            }\n        }\n        return ans;\n    }\n};"},{"date":"2022-05-12","time":52,"memory":12,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    int minDeletionSize(vector<string>& strs) {\n        string prev = strs[0];\n        int ans = 0;\n        unordered_set<int> used;\n        for (int i = 1; i < strs.size(); i++) {\n            for (int j = 0; j < prev.size(); j++) {\n                if (used.count(j)) continue;\n                if (strs[i][j] < prev[j]) {\n                    ans++;\n                    used.insert(j);\n                }\n            }\n            prev = strs[i];\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","字符串"],"level":"Easy"}},{"problemName":"946.验证栈序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/946.验证栈序列.json","problemData":{"id":"983","name":"946.验证栈序列","url":"https://leetcode.cn/problems/validate-stack-sequences","desc":"给定  pushed  和  popped  两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。","solutions":[{"date":"2021-03-19","time":96,"memory":40,"script":"typescript","desc":"维护栈，判断数据是否正常弹出。","code":"function validateStackSequences(pushed: number[], popped: number[]): boolean {\n  const stack: number[] = [];\n  for (const push of pushed) {\n    stack.push(push);\n    while (popped.length > 0 && popped[0] === stack[stack.length - 1]) {\n      stack.pop();\n      popped.shift();\n    }\n  }\n  return popped.length === 0;\n}"},{"date":"2022-08-31","time":16,"memory":14.8,"script":"cpp","desc":"stack。","code":"class Solution {\npublic:\n    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {\n        int len = popped.size();\n        stack<int> s;\n        for (int i1 = 0, i2 = 0; i1 < len; i1++) {\n            s.push(pushed[i1]);\n            while (i2 < len && s.size() && s.top() == popped[i2]) {\n                s.pop();\n                i2++;\n            }\n        }\n        return s.empty();\n    }\n};"}],"tagList":["栈","数组","模拟"],"level":"Medium"}},{"problemName":"947.移除最多的同行或同列石头.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/947.移除最多的同行或同列石头.json","problemData":{"id":"984","name":"947.移除最多的同行或同列石头","url":"https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column","desc":"n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头。给你一个长度为 n 的数组 stones ，其中 stones[i] = [xi, yi] 表示第 i 块石头的位置，返回 可以移除的石子 的最大数量。","solutions":[{"date":"2021-01-15","time":108,"memory":45.4,"script":"typescript","desc":"并查集。","code":"function removeStones(stones: number[][]): number {\n  const arr: number[] = [];\n  const n = stones.length;\n  let count = 0;\n  const find = (x: number) => {\n    if (arr[x] === undefined) {\n      arr[x] = x;\n      count++;\n    }\n    if (x !== arr[x]) {\n      arr[x] = find(arr[x]);\n    }\n    return arr[x];\n  };\n  const union = (u: number, v: number) => {\n    const x = find(u);\n    const y = find(v);\n    if (x !== y) {\n      arr[x] = y;\n      count--;\n    }\n  };\n  stones.forEach(([x, y]) => union(x + 10000, y));\n  return n - count;\n}"},{"date":"2021-05-01","time":208,"memory":44.1,"script":"typescript","desc":"并查集。","code":"class UnionFind {\n  elements: number[];\n  constructor(public size: number) {\n    this.elements = new Array(size).fill(0).map((_, i) => i);\n  }\n  same(v1: number, v2: number): boolean {\n    return this.find(v1) === this.find(v2);\n  }\n  find(v: number): number {\n    return v === this.elements[v] ? v : (this.elements[v] = this.find(this.elements[v]));\n  }\n  union(v1: number, v2: number): void {\n    const e1 = this.find(v1);\n    const e2 = this.find(v2);\n    if (e1 !== e2) {\n      this.elements[e1] = e2;\n      this.size--;\n    }\n  }\n}\nfunction removeStones(stones: number[][]): number {\n  const len = stones.length;\n  const uf = new UnionFind(len);\n  const findIndex = (stone: number[]): number[] => {\n    const ans: number[] = [];\n    for (let i = 0; i < len; i++) {\n      const s = stones[i];\n      if (s !== stone && (s[0] === stone[0] || s[1] === stone[1])) {\n        ans.push(i);\n      }\n    }\n    return ans;\n  };\n  for (let i = 0; i < len; i++) {\n    const stone = stones[i];\n    findIndex(stone).forEach(v => uf.union(i, v));\n  }\n  const cache: Record<number, number> = {};\n  for (let i = 0, l = uf.elements.length; i < l; i++) {\n    const index = uf.find(i);\n    cache[index] = (cache[index] ?? 0) + 1;\n  }\n  return Object.values(cache).reduce((total, cur) => (total += cur - 1), 0);\n}"}],"tagList":["深度优先搜索","并查集","图","哈希表"],"level":"Medium"}},{"problemName":"952.按公因数计算最大组件大小.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/952.按公因数计算最大组件大小.json","problemData":{"id":"989","name":"952.按公因数计算最大组件大小","url":"https://leetcode.cn/problems/largest-component-size-by-common-factor","desc":"返回 图中最大连通组件的大小 。","solutions":[{"date":"2022-07-31","time":308,"memory":128.8,"script":"cpp","desc":"对于合数先进行合并。","code":"class UnionFind {\n   public:\n    vector<int> list;\n    UnionFind(int len) {\n        list = vector<int>(len);\n        for (int i = 0; i < len; i++) list[i] = i;\n    }\n    int find(int idx) {\n        if (list[idx] == idx) return idx;\n        int p = find(list[idx]);\n        list[idx] = p;\n        return p;\n    }\n    void uni(int idx1, int idx2) {\n        int p1 = find(idx1), p2 = find(idx2);\n        if (p1 == p2) return;\n        list[p1] = p2;\n    }\n};\n\n#define MAX 2e5\n\nclass Solution {\n   public:\n    int largestComponentSize(vector<int>& nums) {\n        int n = nums.size();\n        UnionFind uf(MAX);\n        for (int num : nums) {\n            for (int i = 2; i * i <= num; i++) {\n                if (num % i == 0) {\n                    uf.uni(num, i);\n                    uf.uni(num, num / i);\n                }\n            }\n        }\n        int ans = 0;\n        unordered_map<int, int> m;\n        for (auto& num : nums) {\n            int p = uf.find(num);\n            m[p]++;\n            ans = max(ans, m[p]);\n        }\n        return ans;\n    }\n};"}],"tagList":["并查集","数组","哈希表","数学","数论"],"level":"Hard"}},{"problemName":"953.验证外星语词典.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/953.验证外星语词典.json","problemData":{"id":"990","name":"953.验证外星语词典","url":"https://leetcode.cn/problems/verifying-an-alien-dictionary","desc":"给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。","solutions":[{"date":"2021-12-23","time":4,"memory":9.1,"script":"cpp","desc":"转换成地球文进行比较。","code":"class Solution {\n   public:\n    bool isAlienSorted(vector<string> &words, string order) {\n        int nums[30] = {0};\n        for (int i = 0; i < order.size(); i++) nums[order[i] - 'a'] = i;\n        for (auto &str : words) {\n            for (auto &ch : str) {\n                ch = nums[ch - 'a'] + 'a';\n            }\n        }\n        for (int i = 1; i < words.size(); i++) {\n            if (words[i] < words[i - 1]) return 0;\n        }\n        return 1;\n    }\n};"},{"date":"2022-05-17","time":4,"memory":9.1,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    bool isAlienSorted(vector<string> &words, string order) {\n        char map[26] = {0};\n        for (int i = 0; i < order.size(); i++) map[order[i] - 'a'] = i;\n        string prev = words[0];\n        for (int i = 1; i < words.size(); i++) {\n            if (!check(prev, words[i], map)) return false;\n            prev = words[i];\n        }\n        return true;\n    }\n    bool check(string &s1, string &s2, char *map) {\n        int i1 = 0, n1 = s1.size(), i2 = 0, n2 = s2.size();\n        while (i1 < n1 && i2 < n2) {\n            if (map[s1[i1] - 'a'] > map[s2[i2] - 'a']) return false;\n            if (map[s1[i1] - 'a'] < map[s2[i2] - 'a']) return true;\n            i1++;\n            i2++;\n        }\n        return i1 == n1;\n    }\n};"}],"tagList":["数组","哈希表","字符串"],"level":"Easy"}},{"problemName":"954.二倍数对数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/954.二倍数对数组.json","problemData":{"id":"991","name":"954.二倍数对数组","url":"https://leetcode.cn/problems/array-of-doubled-pairs","desc":"给定一个长度为偶数的整数数组 arr，只有对 arr 进行重组后可以满足 “对于每个 0 <= i < len(arr) / 2，都有 arr[2 * i + 1] = 2 _ arr[2 _ i]” 时，返回 true；否则，返回 false。","solutions":[{"date":"2022-04-01","time":100,"memory":56.9,"script":"cpp","desc":"排序后检查。","code":"class Solution {\n   public:\n    bool canReorderDoubled(vector<int> &arr) {\n        deque<int> q1, q2;\n        unordered_map<int, int> m;\n        sort(arr.begin(), arr.end());\n        for (auto &num : arr) {\n            m[num]++;\n            if (num >= 0 && (q1.empty() || q1.back() != num))\n                q1.push_back(num);\n            else if (num < 0 && (q2.empty() || q2.front() != num))\n                q2.push_front(num);\n        }\n        return check(m, q1) && check(m, q2);\n    }\n    bool check(unordered_map<int, int> &m, deque<int> q) {\n        while (q.size()) {\n            int num = q.front();\n            q.pop_front();\n            if (m[num] == 0) continue;\n            if (m[num * 2] < m[num]) return false;\n            m[num * 2] -= m[num];\n        }\n        return true;\n    }\n};"}],"tagList":["贪心","数组","哈希表","排序"],"level":"Medium"}},{"problemName":"958.二叉树的完全性检验.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/958.二叉树的完全性检验.json","problemData":{"id":"998","name":"958.二叉树的完全性检验","url":"https://leetcode.cn/problems/check-completeness-of-a-binary-tree","desc":"给定一个二叉树，确定它是否是一个完全二叉树。","solutions":[{"date":"2021-07-29","time":144,"memory":46.8,"script":"typescript","desc":"dfs 递归遍历。","code":"function isCompleteTree(root: TreeNode | null): boolean {\n  if (root === null) return true;\n  const n = count(root);\n  let m = 1;\n  let cnt = 0;\n  while (cnt + 2 * m < n) cnt += m <<= 1;\n  return judge(root, n, m);\n  function count(node: TreeNode | null): number {\n    if (node === null) return 0;\n    return count(node.left) + count(node.right) + 1;\n  }\n  function judge(node: TreeNode | null, n: number, m: number): boolean {\n    console.log(node, n, m);\n    if (node === null) return n === 0;\n    if (n === 0) return false;\n    if (n === 1) return node.left === null && node.right === null;\n    const sum = Math.max(0, m * 2 - 1);\n    const left = Math.min(m, n - sum);\n    const right = n - sum - left;\n    return (\n      judge(node.left, ((sum - 1) >> 1) + left, m >> 1) &&\n      judge(node.right, ((sum - 1) >> 1) + right, m >> 1)\n    );\n  }\n}"}],"tagList":["树","广度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"959.由斜杠划分区域.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/959.由斜杠划分区域.json","problemData":{"id":"999","name":"959.由斜杠划分区域","url":"https://leetcode.cn/problems/regions-cut-by-slashes","desc":"在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\\ 或空格构成。这些字符会将方块划分为一些共边的区域。","solutions":[{"date":"2021-12-04","time":4,"memory":6.6,"script":"c","desc":"并查集。","code":"typedef struct unionfind\n{\n    int *father, len, size;\n} UnionFind;\nUnionFind *unionfind_create(int len)\n{\n    UnionFind *uf = (UnionFind *)malloc(sizeof(UnionFind));\n    uf->size = uf->len = len;\n    uf->father = (int *)malloc(sizeof(int) * len);\n    for (int i = 0; i < len; i++)\n        uf->father[i] = i;\n    return uf;\n}\nvoid unionfind_free(UnionFind *uf)\n{\n    free(uf->father);\n    free(uf);\n}\nint unionfind_find(UnionFind *uf, int data)\n{\n    return uf->father[data] = uf->father[data] == data ? data : unionfind_find(uf, uf->father[data]);\n}\nvoid unionfind_union(UnionFind *uf, int data1, int data2)\n{\n    int p1 = unionfind_find(uf, data1), p2 = unionfind_find(uf, data2);\n    if (p1 == p2) return ;\n    uf->size--;\n    uf->father[p1] = p2;\n}\n#define BLOCK 4\nint get_idx(int row, int col, int n) {\n    return row * n * BLOCK + col * BLOCK;\n}\nint regionsBySlashes(char ** grid, int gridSize){\n    UnionFind *uf = unionfind_create(gridSize * gridSize * BLOCK);\n    for (int row = 0; row < gridSize; row++) {\n        for (int col = 0; col < gridSize; col++) {\n            char ch = grid[row][col];\n            int idx1 = get_idx(row, col, gridSize), idx2 = idx1 + 1, idx3 = idx1 + 2, idx4 = idx1 + 3;\n            if (ch == ' ') {\n                unionfind_union(uf, idx1, idx2);\n                unionfind_union(uf, idx1, idx3);\n                unionfind_union(uf, idx1, idx4);\n            } else if (ch == '/') {\n                unionfind_union(uf, idx1, idx2);\n                unionfind_union(uf, idx3, idx4);\n            } else {\n                unionfind_union(uf, idx1, idx4);\n                unionfind_union(uf, idx2, idx3);\n            }\n            //if (row > 0) unionfind_union(uf, idx1, get_idx(row - 1, col, gridSize) + 2);\n            //if (col > 0) unionfind_union(uf, idx2, get_idx(row, col - 1, gridSize) + 3);\n            if (col < gridSize - 1) unionfind_union(uf, idx4, get_idx(row, col + 1, gridSize) + 1);\n            if (row < gridSize - 1) unionfind_union(uf, idx3, get_idx(row + 1, col, gridSize));\n        }\n    }\n    return uf->size;\n}"}],"tagList":["深度优先搜索","广度优先搜索","并查集","数组","哈希表","矩阵"],"level":"Medium"}},{"problemName":"961.在长度2N的数组中找出重复N次的元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/961.在长度2N的数组中找出重复N次的元素.json","problemData":{"id":"1001","name":"961.在长度2N的数组中找出重复N次的元素","url":"https://leetcode.cn/problems/n-repeated-element-in-size-2n-array","desc":"找出并返回重复了 n 次的那个元素。","solutions":[{"date":"2022-03-25","time":20,"memory":24.1,"script":"cpp","desc":"查找某个元素的出现次数是否大于 1。","code":"class Solution {\n   public:\n    int repeatedNTimes(vector<int>& nums) {\n        int m[10004] = {0};\n        for (auto& num : nums) {\n            if (++m[num] > 1) return num;\n        }\n        return 0;\n    }\n};"},{"date":"2022-05-21","time":28,"memory":24.1,"script":"cpp","desc":"随机选择,只有目标数是重复的。","code":"class Solution {\n   public:\n    int repeatedNTimes(vector<int> &nums) {\n        srand(time(0));\n        int n = nums.size();\n        while (1) {\n            int x = rand() % n, y = rand() % n;\n            if (x != y && nums[x] == nums[y]) return nums[x];\n        }\n        return -1;\n    }\n};"}],"tagList":["数组","哈希表"],"level":"Easy"}},{"problemName":"965.单值二叉树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/965.单值二叉树.json","problemData":{"id":"1005","name":"965.单值二叉树","url":"https://leetcode.cn/problems/univalued-binary-tree","desc":"如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。","solutions":[{"date":"2022-03-25","time":4,"memory":9.6,"script":"cpp","desc":"dfs。","code":"class Solution {\n   public:\n    bool isUnivalTree(TreeNode* root) { return dfs(root, root->val); }\n    bool dfs(TreeNode* node, int val) {\n        if (!node) return true;\n        if (node->val != val) return false;\n        return dfs(node->left, val) && dfs(node->right, val);\n    }\n};"},{"date":"2022-05-24","time":0,"memory":9.5,"script":"cpp","desc":"dfs。","code":"class Solution {\n   public:\n    bool isUnivalTree(TreeNode* root) { return _isUnivalTree(root, root->val); }\n    bool _isUnivalTree(TreeNode* node, int val) {\n        if (node == nullptr) return true;\n        return node->val == val && _isUnivalTree(node->left, val) &&\n               _isUnivalTree(node->right, val);\n    }\n};"},{"date":"2022-05-24","time":0,"memory":9.6,"script":"cpp","desc":"dfs。","code":"class Solution {\n   public:\n    int val = 0;\n    bool isUnivalTree(TreeNode* root) {\n        if (!root) return true;\n        if (val == 0) val = root->val;\n        return root->val == val && isUnivalTree(root->left) &&\n               isUnivalTree(root->right);\n    }\n};"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉树"],"level":"Easy"}},{"problemName":"967.连续差相同的数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/967.连续差相同的数字.json","problemData":{"id":"1007","name":"967.连续差相同的数字","url":"https://leetcode.cn/problems/numbers-with-same-consecutive-differences","desc":"返回所有长度为 n 且满足其每两个连续位上的数字之间的差的绝对值为 k 的 非负整数 。","solutions":[{"date":"2021-12-30","time":0,"memory":8.5,"script":"cpp","desc":"dfs。","code":"class Solution {\n   public:\n    void dfs(vector<int> &ans, int n, int k, int num) {\n        if (n == 0) {\n            ans.push_back(num);\n            return;\n        }\n        if (num % 10 + k <= 9) {\n            dfs(ans, n - 1, k, num * 10 + k + num % 10);\n        }\n        if (k != 0 && num % 10 - k >= 0) {\n            dfs(ans, n - 1, k, num * 10 - k + num % 10);\n        }\n    }\n    vector<int> numsSameConsecDiff(int n, int k) {\n        vector<int> ans;\n        for (int i = 1; i <= 9; i++) dfs(ans, n - 1, k, i);\n        return ans;\n    }\n};"},{"date":"2022-02-18","time":0,"memory":8.3,"script":"cpp","desc":"dfs。","code":"class Solution {\n   public:\n    int n, k;\n    vector<int> ans;\n    void dfs(int cur, int cnt, int last) {\n        if (cnt == 0) {\n            ans.push_back(cur);\n            return;\n        }\n        if (last + k < 10) dfs(cur * 10 + last + k, cnt - 1, last + k);\n        if (k != 0 && last - k >= 0)\n            dfs(cur * 10 + last - k, cnt - 1, last - k);\n    }\n    vector<int> numsSameConsecDiff(int n, int k) {\n        this->n = n;\n        this->k = k;\n        for (int i = 1; i <= 9; i++) dfs(i, n - 1, i);\n        return ans;\n    }\n};"}],"tagList":["广度优先搜索","回溯"],"level":"Medium"}},{"problemName":"968.监控二叉树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/968.监控二叉树.json","problemData":{"id":"1008","name":"968.监控二叉树","url":"https://leetcode.cn/problems/binary-tree-cameras","desc":"给定一个二叉树，我们在树的节点上安装摄像头。节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。计算监控树的所有节点所需的最小摄像头数量。","solutions":[{"date":"2020-09-22","time":96,"memory":43,"script":"typescript","desc":"[参考连接](https://leetcode-cn.com/problems/binary-tree-cameras/solution/jian-kong-er-cha-shu-by-leetcode-solution/)。","code":"function minCameraCover(root: TreeNode | null): number {\n  return dfs(root)[1];\n  /**\n   * @return\n   * 状态 a：root 必须放置摄像头的情况下，覆盖整棵树需要的摄像头数目。\n   * 状态 b：覆盖整棵树需要的摄像头数目，无论 root 是否放置摄像头。\n   * 状态 c：覆盖两棵子树需要的摄像头数目，无论节点 root 本身是否被监控到。\n   */\n  function dfs(root: TreeNode | null): [number, number, number] {\n    if (root === null) return [Infinity, 0, 0];\n    const [la, lb, lc] = dfs(root.left);\n    const [ra, rb, rc] = dfs(root.right);\n    const a = lc + rc + 1;\n    return [a, Math.min(a, la + rb, ra + lb), Math.min(a, lb + rb)];\n  }\n}"},{"date":"2021-04-04","time":140,"memory":48.4,"script":"typescript","desc":"递归计算每个点的存在摄像头和父节点存在摄像头的情况。","code":"/**\n *    dp[0][0] 父节点和当前节点都不存在摄像头\n *    dp[1][0] 父节点存在摄像头，当前节点不存在\n *    dp[0][1] 父节点不存在摄像头，当前节点存在\n *    dp[1][1] 父节点和当前节点都存在摄像头\n */\nfunction minCameraCover(root: TreeNode | null): number {\n  const getArr = (): number[][] => new Array(2).fill(0).map(_ => new Array(2).fill(0));\n  const dp: number[][] = getArr();\n  const dfs = (node: TreeNode | null, dp: number[][]): void => {\n    if (!node) {\n      // 如果节点是null\n      dp[1][0] = dp[0][0] = 0;\n      dp[0][1] = dp[1][1] = Infinity; // null节点不存在摄像头\n    } else if (!node.left && !node.right) {\n      // 如果节点是叶子节点\n      dp[0][0] = Infinity; // 不存在此种情况，叶子节点和父节点必须有一个有摄像头\n      dp[1][1] = dp[0][1] = 1;\n      dp[1][0] = 0;\n    } else {\n      const left: number[][] = getArr();\n      const right: number[][] = getArr();\n      dfs(node.left, left);\n      dfs(node.right, right);\n      dp[0][0] = Math.min(\n        left[0][1] + right[0][0],\n        left[0][0] + right[0][1],\n        left[0][1] + right[0][1]\n      ); // 如果父节点和当前节点都不存在摄像头，则子节点最少存在一个摄像头\n      dp[1][0] = Math.min(left[0][0] + right[0][0], dp[0][0]); // 如果父节点存在摄像头，当前节点不存在，则子节点可以存在任意情况\n      dp[1][1] = dp[0][1] =\n        1 +\n        Math.min(\n          left[1][0] + right[1][0],\n          left[1][1] + right[1][0],\n          left[1][0] + right[1][1],\n          left[1][1] + right[1][1]\n        ); // 如果父节点不存在摄像头，当前节点存在，则子节点可存在任意情况，由于当前节点存在，则需增1\n    }\n  };\n  dfs(root, dp);\n  return Math.min(dp[0][1], dp[0][0]);\n}"}],"tagList":["树","深度优先搜索","动态规划","二叉树"],"level":"Hard"}},{"problemName":"969.煎饼排序.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/969.煎饼排序.json","problemData":{"id":"1009","name":"969.煎饼排序","url":"https://leetcode.cn/problems/pancake-sorting","desc":"给你一个整数数组 arr ，请使用 煎饼翻转 完成对数组的排序。","solutions":[{"date":"2021-03-15","time":84,"memory":39.9,"script":"typescript","desc":"每个值进行翻转到第一位，再翻转一次到最后一位进行比较。","code":"function pancakeSort(arr: number[]): number[] {\n  const len = arr.length;\n  const indexes: number[] = [];\n  const reverse = (last: number) => {\n    for (let i = 0, j = last; i < j; i++, j--) {\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n      [indexes[arr[i]], indexes[arr[j]]] = [indexes[arr[j]], indexes[arr[i]]];\n    }\n  };\n  const ans: number[] = [];\n  for (let i = 0; i < len; i++) indexes[arr[i]] = i;\n  for (let i = len - 1; i >= 0; i--) {\n    ans.push(indexes[i + 1] + 1);\n    reverse(indexes[i + 1]);\n    ans.push(i + 1);\n    reverse(i);\n  }\n  return ans;\n}"},{"date":"2022-02-19","time":4,"memory":11,"script":"cpp","desc":"每次翻转把最大值翻转到首位，再翻转到结尾。","code":"class Solution {\n   public:\n    vector<int> pancakeSort(vector<int>& arr) {\n        vector<int> ans;\n        _pancakeSort(ans, arr, 0, arr.size() - 1);\n        return ans;\n    }\n    void _pancakeSort(vector<int>& ans, vector<int>& arr, int start, int end) {\n        if (end == 0) return;\n        int vmax = start;\n        for (int i = start; i <= end; i++) {\n            if (arr[i] > arr[vmax]) vmax = i;\n        }\n        if (vmax != end) {\n            reverse(arr, 0, vmax);\n            ans.push_back(vmax + 1);\n            reverse(arr, 0, end);\n            ans.push_back(end + 1);\n        }\n        _pancakeSort(ans, arr, start, end - 1);\n    }\n    void reverse(vector<int>& arr, int start, int end) {\n        for (int l = start, r = end; l < r; l++, r--) {\n            swap(arr[l], arr[r]);\n        }\n    }\n};"}],"tagList":["贪心","数组","双指针","排序"],"level":"Medium"}},{"problemName":"970.强整数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/970.强整数.json","problemData":{"id":"1010","name":"970.强整数","url":"https://leetcode.cn/problems/powerful-integers","desc":"给定三个整数 x 、 y 和 bound ，返回 值小于或等于 bound 的所有 强整数 组成的列表 。","solutions":[{"script":"cpp","time":0,"memory":6.6,"desc":"dfs。","code":"class Solution {\npublic:\n    vector<int> powerfulIntegers(int x, int y, int bound) {\n        vector<int> list;\n        unordered_set<int> res;\n        for (int i = 0; pow(x, i) <= bound; i++) {\n            list.push_back(pow(x, i));\n            if (x == 1) break;\n        }\n        for (int i = 0; pow(y, i) <= bound; i++) {\n            int ynum = pow(y, i);\n            for (auto &xnum : list)\n                if (ynum + xnum <= bound) res.insert(ynum + xnum);\n                else break;\n            if (y == 1) break;\n        }\n        return vector<int>(res.begin(), res.end());\n    }\n};","date":"2023-05-02"},{"script":"python","time":48,"memory":16.2,"desc":"同上。","code":"class Solution:\n    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:\n        list = []\n        res = set()\n        i = 0\n        while pow(x, i) <= bound:\n            list.append(pow(x, i))\n            if x == 1:\n                break\n            i += 1\n        i = 0\n        while pow(y, i) <= bound:\n            ynum = pow(y, i)\n            for xnum in list:\n                if ynum + xnum <= bound:\n                    res.add(ynum + xnum)\n                else:\n                    break\n            if y == 1:\n                break\n            i += 1\n        return [num for num in res]","date":"2023-05-02"},{"script":"rust","time":4,"memory":2.2,"desc":"同上。","code":"impl Solution {\n    pub fn powerful_integers(x: i32, y: i32, bound: i32) -> Vec<i32> {\n        let mut list = vec![];\n        let mut res = std::collections::HashSet::<i32>::new();\n        let mut i = 0;\n        while x.pow(i) <= bound {\n            list.push(x.pow(i));\n            if x == 1 {\n                break;\n            }\n            i += 1;\n        }\n        i = 0;\n        while y.pow(i) <= bound {\n            let ynum = y.pow(i);\n            for xnum in &list {\n                if ynum + *xnum <= bound {\n                    res.insert(ynum + *xnum);\n                } else {\n                    break;\n                }\n            }\n            if y == 1 {\n                break;\n            }\n            i += 1;\n        }\n        res.into_iter().collect()\n    }\n}\n","date":"2023-05-02"}],"tagList":["哈希表","数学","枚举"],"level":"Medium"}},{"problemName":"971.翻转二叉树以匹配先序遍历.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/971.翻转二叉树以匹配先序遍历.json","problemData":{"id":"1011","name":"971.翻转二叉树以匹配先序遍历","url":"https://leetcode.cn/problems/flip-binary-tree-to-match-preorder-traversal","desc":"请翻转 最少 的树中节点，使二叉树的 先序遍历 与预期的遍历行程 voyage 相匹配 。 。","solutions":[{"date":"2021-08-14","time":84,"memory":39.5,"script":"typescript","desc":"dfs。","code":"function flipMatchVoyage(root: TreeNode | null, voyage: number[]): number[] {\n  if (root === null) return [];\n  const ans: number[] = [];\n  let stop = false;\n  dfs(root, voyage);\n  return stop ? [-1] : ans;\n  function dfs(node: TreeNode, voyage: number[]) {\n    if (stop) return;\n    const val = node.val;\n    const n = voyage.length;\n    if (val !== voyage[0]) {\n      stop = true;\n      return;\n    }\n    if (node.left === null && node.right === null) {\n      if (!(n === 1 && voyage[0] === val)) stop = true;\n      return;\n    }\n    if (node.left === null) {\n      if (voyage[1] !== node.right!.val) stop = true;\n      else dfs(node.right!, voyage.slice(1));\n      return;\n    }\n    if (node.right === null) {\n      if (voyage[1] !== node.left!.val) stop = true;\n      else dfs(node.left!, voyage.slice(1));\n      return;\n    }\n    const valL = node.left!.val;\n    const valR = node.right!.val;\n    if (voyage[1] === valL) {\n      let idx = 1;\n      while (idx < n && voyage[idx] !== valR) idx++;\n      dfs(node.left!, voyage.slice(1, idx));\n      dfs(node.right!, voyage.slice(idx));\n    } else {\n      let idx = 1;\n      while (idx < n && voyage[idx] !== valL) idx++;\n      dfs(node.right!, voyage.slice(1, idx));\n      dfs(node.left!, voyage.slice(idx));\n      ans.push(val);\n    }\n  }\n}"}],"tagList":["树","深度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"973.最接近原点的K个点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/973.最接近原点的K个点.json","problemData":{"id":"1014","name":"973.最接近原点的K个点","url":"https://leetcode.cn/problems/k-closest-points-to-origin","desc":"我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。","solutions":[{"date":"2020-11-09","time":280,"memory":51.1,"script":"typescript","desc":"计算距离后排序。","code":"function kClosest(points: number[][], K: number): number[][] {\n  return points\n    .sort(([x1, y1], [x2, y2]) => Math.sqrt(x1 ** 2 + y1 ** 2) - Math.sqrt(x2 ** 2 + y2 ** 2))\n    .slice(0, K);\n}"}],"tagList":["几何","数组","数学","分治","快速选择","排序","堆（优先队列）"],"level":"Medium"}},{"problemName":"974.和可被K整除的子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/974.和可被K整除的子数组.json","problemData":{"id":"1016","name":"974.和可被K整除的子数组","url":"https://leetcode.cn/problems/subarray-sums-divisible-by-k","desc":"给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。","solutions":[{"date":"2020-05-27","time":96,"memory":39.7,"script":"typescript","desc":"遍历一遍，O(n)，遍历到该值时累加，然后判断是否能够整除，若不能则判断所相差数，存入数组，若相差数在数组中不为 1 则累加数量，总思想：前面 i 和与前面 j 和余数相同，相减必可被整除。","code":"var subarraysDivByK = function (A: number[], K: number): number {\n  const arr: number[] = new Array(K).fill(0);\n  let sum = 0;\n  let count = 0;\n  for (const num of A) {\n    sum += num;\n    if (sum % K === 0) count++;\n    const y = (K - (sum % K)) % K;\n    if (arr[y] !== 0) count += arr[y];\n    arr[y] += 1;\n  }\n  return count;\n};"}],"tagList":["数组","哈希表","前缀和"],"level":"Medium"}},{"problemName":"976.三角形的最大周长.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/976.三角形的最大周长.json","problemData":{"id":"1018","name":"976.三角形的最大周长","url":"https://leetcode.cn/problems/largest-perimeter-triangle","desc":"给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。","solutions":[{"date":"2020-11-29","time":136,"memory":42.8,"script":"typescript","desc":"贪心，从最长数寻找。","code":"function largestPerimeter(A: number[]): number {\n  A.sort((a, b) => a - b);\n  const len = A.length;\n  const can = (edge1: number, edge2: number, edge3: number): number =>\n    edge1 + edge2 > edge3 && edge2 + edge3 > edge1 && edge1 + edge3 > edge2\n      ? edge1 + edge2 + edge3\n      : 0;\n  for (let i = len - 1; i >= 0; i--) {\n    const num = can(A[i], A[i - 1], A[i - 2]);\n    if (num !== 0) return num;\n  }\n  return 0;\n}"}],"tagList":["贪心","数组","数学","排序"],"level":"Easy"}},{"problemName":"977.有序数组的平方.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/977.有序数组的平方.json","problemData":{"id":"1019","name":"977.有序数组的平方","url":"https://leetcode.cn/problems/squares-of-a-sorted-array","desc":"给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。","solutions":[{"date":"2020-10-16","time":208,"memory":45.7,"script":"typescript","desc":"平方后排序。","code":"function sortedSquares(A: number[]): number[] {\n  return A.map(v => v ** 2).sort((a, b) => a - b);\n}"},{"date":"2020-10-16","time":204,"memory":46,"script":"typescript","desc":"利用有序性进行双指针遍历排序。","code":"function sortedSquares(A: number[]): number[] {\n  const ans: number[] = [];\n  const len = A.length;\n  let i = 0;\n  let j = len - 1;\n  const arr = A.map(v => v ** 2);\n  while (i <= j) {\n    const numL = arr[i];\n    const numR = arr[j];\n    if (numL <= numR) {\n      ans.unshift(numR);\n      j--;\n    } else if (numL > numR) {\n      ans.unshift(numL);\n      i++;\n    }\n  }\n  return ans;\n}"}],"tagList":["数组","双指针","排序"],"level":"Easy"}},{"problemName":"978.最长湍流子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/978.最长湍流子数组.json","problemData":{"id":"1020","name":"978.最长湍流子数组","url":"https://leetcode.cn/problems/longest-turbulent-subarray","desc":"返回 A 的最大湍流子数组的长度。","solutions":[{"date":"2021-02-08","time":104,"memory":43.8,"script":"typescript","desc":"利用双指针进行最大区间的判断。","code":"function maxTurbulenceSize(arr: number[]): number {\n  let len = arr.length;\n  while (len > 1 && arr[0] === arr[1]) {\n    arr.shift();\n    len--;\n  }\n  if (len === 1) return 1;\n  let max = 2;\n  let l = 0;\n  let r = 1;\n  let f = arr[0] < arr[1];\n  while (r < len - 1) {\n    if (f ? arr[r] > arr[r + 1] : arr[r] < arr[r + 1]) {\n      f = !f;\n    } else {\n      max = Math.max(max, r - l + 1);\n      l = arr[r] === arr[r + 1] ? r + 1 : r;\n    }\n    r++;\n  }\n  return Math.max(max, r - l + 1);\n}"}],"tagList":["数组","动态规划","滑动窗口"],"level":"Medium"}},{"problemName":"979.在二叉树中分配硬币.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/979.在二叉树中分配硬币.json","problemData":{"id":"1021","name":"979.在二叉树中分配硬币","url":"https://leetcode.cn/problems/distribute-coins-in-binary-tree","desc":"给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。返回使每个结点上只有一枚硬币所需的移动次数。","solutions":[{"date":"2021-07-25","time":76,"memory":41.7,"script":"typescript","desc":"分别统计每个子节点进行递归。","code":"function distributeCoins(root: TreeNode | null): number {\n  return get()[0];\n  function get(node = root): [number, number, number] {\n    if (node === null) return [0, 0, 0];\n    let ans = 0;\n    let nodeCount = 1;\n    let coinCount = node.val;\n    let [subAns, subNodeCount, subCoinCount] = get(node.left);\n    ans += subAns + Math.abs(subNodeCount - subCoinCount);\n    nodeCount += subNodeCount;\n    coinCount += subCoinCount;\n    [subAns, subNodeCount, subCoinCount] = get(node.right);\n    ans += subAns + Math.abs(subNodeCount - subCoinCount);\n    nodeCount += subNodeCount;\n    coinCount += subCoinCount;\n    return [ans, nodeCount, coinCount];\n  }\n}"},{"script":"cpp","time":8,"memory":13.5,"desc":"dfs。","code":"#define X first\n#define Y second\n#define pii pair<int, int>\nclass Solution {\npublic:\n    int distributeCoins(TreeNode* root) {\n        int res = 0;\n        function<pii(TreeNode*)> dfs = [&](TreeNode *node) {\n            if (!node) return make_pair(0, 0);\n            auto l = dfs(node->left), r = dfs(node->right);\n            int nsum = l.X + r.X + 1, csum = l.Y + r.Y + node->val;\n            res += abs(nsum - csum);\n            return make_pair(nsum, csum);\n        };\n        dfs(root);\n        return res;\n    }\n};","date":"2023-07-14"},{"script":"python","time":52,"memory":16.1,"desc":"同上。","code":"class Solution:\n    def distributeCoins(self, root: Optional[TreeNode]) -> int:\n        res = 0\n\n        def dfs(node: Optional[TreeNode]) -> Tuple[int, int]:\n            nonlocal res\n            if not node:\n                return (0, 0)\n            l = dfs(node.left)\n            r = dfs(node.right)\n            nsum = l[0] + r[0] + 1\n            csum = l[1] + r[1] + node.val\n            res += abs(nsum-csum)\n            return (nsum, csum)\n\n        dfs(root)\n        return res","date":"2023-07-14"},{"script":"rust","time":0,"memory":2.1,"desc":"同上。","code":"use std::cell::RefCell;\nuse std::rc::Rc;\nimpl Solution {\n    pub fn distribute_coins(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\n        let mut res = 0;\n        fn dfs(res: &mut i32, node: &Option<Rc<RefCell<TreeNode>>>) -> (i32, i32) {\n            match node {\n                None => (0, 0),\n                Some(node) => {\n                    let node_ref = node.as_ref().borrow();\n                    let l = dfs(res, &node_ref.left);\n                    let r = dfs(res, &node_ref.right);\n                    let nsum = l.0 + r.0 + 1;\n                    let csum = l.1 + r.1 + node_ref.val;\n                    *res += (nsum - csum).abs();\n                    (nsum, csum)\n                }\n            }\n        }\n        dfs(&mut res, &root);\n        return res;\n    }\n}","date":"2023-07-14"}],"tagList":["树","深度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"980.不同路径III.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/980.不同路径III.json","problemData":{"id":"1022","name":"980.不同路径III","url":"https://leetcode.cn/problems/unique-paths-iii","desc":"返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。","solutions":[{"script":"cpp","time":4,"memory":6.77,"desc":"dfs。","code":"#define X first\n#define Y second\n#define pii pair<int, int>\nvector<vector<int>> dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nclass Solution {\npublic:\n    int uniquePathsIII(vector<vector<int>>& grid) {\n        int res = 0, n = grid.size(), m = grid[0].size(), sum = n * m;\n        pii start, end;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 1) start = make_pair(i, j);\n                else if (grid[i][j] == 2) end = make_pair(i, j);\n                else if (grid[i][j] == -1) sum -= 1;\n            }\n        }\n        vector<vector<bool>> used(n, vector<bool>(m, false));\n        used[start.X][start.Y] = true;\n        function<void(pii, int)> dfs = [&](pii cur, int cnt) {\n            if (cur.X == end.X && cur.Y == end.Y) {\n                if (cnt == sum) res += 1;\n                return;\n            }\n            for (auto &dir : dirs) {\n                int nx = cur.X + dir[0], ny = cur.Y + dir[1];\n                if (0 <= nx && nx < n && 0 <= ny && ny < m && grid[nx][ny] != -1 && !used[nx][ny]) {\n                    used[nx][ny] = true;\n                    dfs(make_pair(nx, ny), cnt + 1);\n                    used[nx][ny] = false;\n                }\n            }\n        };\n        dfs(start, 1);\n        return res;\n    }\n};","date":"2023-08-04"},{"script":"python","time":68,"memory":15.83,"desc":"同上。","code":"dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\nclass Solution:\n    def uniquePathsIII(self, grid: List[List[int]]) -> int:\n        res = 0\n        n = len(grid)\n        m = len(grid[0])\n        sum = n * m\n        start = end = (0, 0)\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] == 1:\n                    start = (i, j)\n                elif grid[i][j] == 2:\n                    end = (i, j)\n                elif grid[i][j] == -1:\n                    sum -= 1\n        used = [[False for _ in range(m)] for _ in range(n)]\n        used[start[0]][start[1]] = True\n        def dfs(cur: Tuple[int, int], cnt: int):\n            nonlocal res\n            if cur[0] == end[0] and cur[1] == end[1]:\n                if cnt == sum:\n                    res += 1\n                return\n            for dir in dirs:\n                nx = cur[0] + dir[0]\n                ny = cur[1] + dir[1]\n                if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != -1 and not used[nx][ny]:\n                    used[nx][ny] = True\n                    dfs((nx, ny), cnt + 1)\n                    used[nx][ny] = False\n        dfs(start, 1)\n        return res","date":"2023-08-04"},{"script":"rust","time":4,"memory":1.86,"desc":"同上。","code":"pub const DIRS: [[i32; 2]; 4] = [[0, 1], [0, -1], [1, 0], [-1, 0]];\nimpl Solution {\n    pub fn unique_paths_iii(grid: Vec<Vec<i32>>) -> i32 {\n        let mut res = 0;\n        let n = grid.len();\n        let m = grid[0].len();\n        let mut start = (0, 0);\n        let mut end = (0, 0);\n        let mut sum = n * m;\n        for i in 0..n {\n            for j in 0..m {\n                if grid[i][j] == 1 {\n                    start = (i, j);\n                } else if grid[i][j] == 2 {\n                    end = (i, j);\n                } else if grid[i][j] == -1 {\n                    sum -= 1;\n                }\n            }\n        }\n        let mut used: Vec<Vec<bool>> = vec![vec![false; m]; n];\n        used[start.0][start.1] = true;\n        fn dfs(\n            res: &mut i32,\n            sum: usize,\n            grid: &Vec<Vec<i32>>,\n            used: &mut Vec<Vec<bool>>,\n            cur: (usize, usize),\n            end: (usize, usize),\n            cnt: usize,\n        ) {\n            if cur.0 == end.0 && cur.1 == end.1 {\n                if cnt == sum {\n                    *res += 1;\n                }\n            } else {\n                for dir in DIRS {\n                    let nx = (cur.0 as i32 + dir[0]) as usize;\n                    let ny = (cur.1 as i32 + dir[1]) as usize;\n                    if 0 <= nx\n                        && nx < grid.len()\n                        && 0 <= ny\n                        && ny < grid[0].len()\n                        && grid[nx][ny] != -1\n                        && !used[nx][ny]\n                    {\n                        used[nx][ny] = true;\n                        dfs(res, sum, grid, used, (nx, ny), end, cnt + 1);\n                        used[nx][ny] = false;\n                    }\n                }\n            }\n        }\n        dfs(&mut res, sum, &grid, &mut used, start, end, 1);\n        res\n    }\n}\n","date":"2023-08-04"}],"tagList":["位运算","数组","回溯","矩阵"],"level":"Hard"}},{"problemName":"981.基于时间的键值存储.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/981.基于时间的键值存储.json","problemData":{"id":"1023","name":"981.基于时间的键值存储","url":"https://leetcode.cn/problems/time-based-key-value-store","desc":"创建一个基于时间的键值存储类 TimeMap。","solutions":[{"date":"2021-07-10","time":412,"memory":77.1,"script":"typescript","desc":"利用 map 储存所有值。","code":"class TimeMap {\n  private map: Record<string, [string, number][]> = {};\n  set(key: string, value: string, timestamp: number): void {\n    let list = this.map[key];\n    if (!list) this.map[key] = list = [];\n    list.push([value, timestamp]);\n  }\n  get(key: string, timestamp: number): string {\n    return this.find(this.map[key] ?? [], timestamp);\n  }\n  private find(\n    list: [string, number][],\n    timestamp: number,\n    first = 0,\n    last = list.length - 1\n  ): string {\n    if (first > last) {\n      while (first > list.length - 1) first--;\n      while (first >= 0) {\n        if (list[first][1] < timestamp) return list[first][0];\n        first--;\n      }\n      return '';\n    }\n    const mid = (first + last) >> 1;\n    const [midStr, midTime] = list[mid];\n    if (midTime > timestamp) return this.find(list, timestamp, first, mid - 1);\n    else if (midTime < timestamp) return this.find(list, timestamp, mid + 1, last);\n    else return midStr;\n  }\n}"},{"date":"2021-08-14","time":404,"memory":76.4,"script":"typescript","desc":"map 储存，二分查找。","code":"class TimeMap {\n  map = new Map<string, [string, number][]>();\n  set(key: string, value: string, timestamp: number): void {\n    let data = this.map.get(key);\n    if (!data) this.map.set(key, (data = []));\n    data.push([value, timestamp]);\n  }\n  get(key: string, timestamp: number): string {\n    let data = this.map.get(key);\n    if (!data) return '';\n    const idx = this.bs(data, timestamp);\n    if (idx === 0) {\n      if (data[idx][1] > timestamp) return '';\n      else return data[idx][0];\n    }\n    if (data[idx][1] <= timestamp) return data[idx][0];\n    return data[idx - 1][0];\n  }\n  bs(data: [string, number][], timestamp: number): number {\n    let l = 0;\n    let r = data.length - 1;\n    while (l < r) {\n      const mid = (l + r) >> 1;\n      if (data[mid][1] > timestamp) r = mid;\n      else l = mid + 1;\n    }\n    return l;\n  }\n}"}],"tagList":["设计","哈希表","字符串","二分查找"],"level":"Medium"}},{"problemName":"983.最低票价.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/983.最低票价.json","problemData":{"id":"1025","name":"983.最低票价","url":"https://leetcode.cn/problems/minimum-cost-for-tickets","desc":"在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为  days  的数组给出。每一项是一个从  1  到  365  的整数。","solutions":[{"date":"2020-05-06","time":208,"memory":38.2,"script":"javascript","desc":"回溯+剪枝，递归判断每次遍历的值，通过 cache 储存计算过的值。","code":"/**\n * @param {number[]} days\n * @param {number[]} costs\n * @return {number}\n */\nvar mincostTickets = function (days, costs) {\n  const len = days.length;\n  const costDays = [1, 7, 30];\n  const lastDay = days[len];\n  const cache = {};\n  return getMin(0, 0);\n  function getMin(start, maxDay) {\n    if (cache[format(start, maxDay)]) return cache[format(start, maxDay)];\n    while (start < len && days[start] < maxDay) start++;\n    if (start === len || lastDay <= maxDay) return 0;\n    let minCost = 999999;\n    if (days[start] > maxDay)\n      for (let j = 0; j < 3; j++) {\n        const cost = costs[j];\n        minCost = Math.min(getMin(start + 1, days[start] + costDays[j] - 1) + cost, minCost);\n      }\n    else minCost = getMin(start + 1, maxDay);\n    cache[format(start, maxDay)] = minCost;\n    return minCost;\n  }\n  function format(start, maxDay) {\n    return `${start}-${maxDay}`;\n  }\n};"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"987.二叉树的垂序遍历.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/987.二叉树的垂序遍历.json","problemData":{"id":"1029","name":"987.二叉树的垂序遍历","url":"https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree","desc":"给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。","solutions":[{"date":"2021-07-31","time":92,"memory":40,"script":"typescript","desc":"哈希储存。","code":"function verticalTraversal(root: TreeNode | null): number[][] {\n  if (root === null) return [];\n  const map = new Map<number, number[][]>();\n  order(root, 0, 0);\n  const list = [...map.entries()]\n    .sort(([col1], [col2]) => col1 - col2)\n    .map(([, list]) =>\n      list\n        .sort(([, row1, val1], [, row2, val2]) => (row1 === row2 ? val1 - val2 : row1 - row2))\n        .map(([, , v]) => v)\n    );\n  return list;\n  function order(node: TreeNode | null, row: number, col: number) {\n    if (node === null) return null;\n    let list = map.get(col);\n    if (!list) map.set(col, (list = []));\n    list.push([col, row, node.val]);\n    order(node.left, row + 1, col - 1);\n    order(node.right, row + 1, col + 1);\n  }\n}"},{"date":"2021-10-25","time":88,"memory":39.7,"script":"typescript","desc":"哈希存储。","code":"function verticalTraversal(root: TreeNode | null): number[][] {\n  if (root === null) return [];\n  const map = new Map<number, [number, number][]>();\n  dfs(root);\n  return Array.from(map.entries())\n    .sort(([a], [b]) => a - b)\n    .map(([, arr]) =>\n      arr\n        .sort(([num1, row1], [num2, row2]) => (row1 === row2 ? num1 - num2 : row1 - row2))\n        .map(([num]) => num)\n    );\n  function dfs(node: TreeNode | null, row = 0, col = 0) {\n    if (node === null) return;\n    let arr = map.get(col);\n    if (!arr) map.set(col, (arr = []));\n    arr.push([node.val, row]);\n    dfs(node.left, row + 1, col - 1);\n    dfs(node.right, row + 1, col + 1);\n  }\n}"},{"script":"python","time":49,"memory":16.71,"desc":"dfs。","code":"class Solution:\n    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:\n        map = defaultdict(defaultdict)\n        def dfs(node: Optional[TreeNode], row: int, col: int):\n            if not node: return\n            if row not in map[col]: map[col][row] = []\n            map[col][row].append(node.val)\n            if node.left: dfs(node.left, row + 1, col - 1)\n            if node.right: dfs(node.right, row + 1, col + 1)\n        dfs(root, 0, 0)\n        arr = []\n        for _, cols in sorted(map.items()):\n            item = []\n            for _, values in sorted(cols.items()):\n                item += sorted(values)\n            arr.append(item)\n        return arr","date":"2024-02-13"}],"tagList":["树","深度优先搜索","广度优先搜索","哈希表","二叉树","排序"],"level":"Hard"}},{"problemName":"989.数组形式的整数加法.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/989.数组形式的整数加法.json","problemData":{"id":"1031","name":"989.数组形式的整数加法","url":"https://leetcode.cn/problems/add-to-array-form-of-integer","desc":"对于非负整数  X  而言，X  的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果  X = 1231，那么其数组形式为  [1,2,3,1]。给定非负整数 X 的数组形式  A，返回整数  X+K  的数组形式。","solutions":[{"date":"2021-01-22","time":140,"memory":43.2,"script":"typescript","desc":"倒序相加。","code":"function addToArrayForm(A: number[], K: number): number[] {\n  let add: 1 | 0 = 0;\n  const kArr: number[] = [];\n  while (K !== 0) {\n    kArr.push(K % 10);\n    K = ~~(K / 10);\n  }\n  A = A.reverse();\n  for (let i = 0, len = Math.max(A.length, kArr.length); i < len; i++) {\n    let num = (A[i] ?? 0) + (kArr[i] ?? 0) + add;\n    if (num >= 10) {\n      num -= 10;\n      add = 1;\n    } else {\n      add = 0;\n    }\n    A[i] = num;\n  }\n  add === 1 && A.push(1);\n  return A.reverse();\n}"}],"tagList":["数组","数学"],"level":"Easy"}},{"problemName":"990.等式方程的可满足性.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/990.等式方程的可满足性.json","problemData":{"id":"1032","name":"990.等式方程的可满足性","url":"https://leetcode.cn/problems/satisfiability-of-equality-equations","desc":"给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：\"a==b\" 或  \"a!=b\"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回  true，否则返回 false。","solutions":[{"date":"2020-05-06","time":120,"memory":41.5,"script":"typescript","desc":"相同的值用一个对象储存，不同的值用另一个对象去储存。","code":"function equationsPossible(equations: string[]): boolean {\n  const map = new Map<string, { eq: Set<string>; neq: Set<string> }>();\n  for (const equation of new Set(equations)) {\n    const c1 = equation[0];\n    const c2 = equation[3];\n    const isEqual = equation[1] === '=';\n    if (c1 === c2) {\n      if (!isEqual) return false;\n      else continue;\n    }\n    const e1 = map.get(c1);\n    const e2 = map.get(c2);\n    if (e1 === undefined && e2 === undefined) {\n      if (isEqual) {\n        const obj = {\n          eq: new Set<string>([c1, c2]),\n          neq: new Set<string>(),\n        };\n        map.set(c1, obj);\n        map.set(c2, obj);\n      } else {\n        map.set(c1, { eq: new Set<string>([c1]), neq: new Set<string>([c2]) });\n        map.set(c2, { eq: new Set<string>([c2]), neq: new Set<string>([c1]) });\n      }\n    } else if (e1 !== undefined && e2 === undefined) {\n      if (isEqual) {\n        e1.eq.add(c2);\n        map.set(c2, e1);\n        for (let c of e1.neq) map.get(c)?.neq.add(c2);\n      } else {\n        e1.neq.add(c2);\n        map.set(c2, {\n          eq: new Set<string>([c2]),\n          neq: new Set<string>([c1, ...e1.eq]),\n        });\n      }\n    } else if (e1 === undefined && e2 !== undefined) {\n      if (isEqual) {\n        e2.eq.add(c1);\n        map.set(c1, e2);\n        for (let c of e2.neq) map.get(c)?.neq.add(c1);\n      } else {\n        e2.neq.add(c1);\n        map.set(c1, {\n          eq: new Set<string>([c1]),\n          neq: new Set<string>([c2, ...e2.eq]),\n        });\n      }\n    } else if (e1 !== undefined && e2 !== undefined) {\n      if (isEqual) {\n        if (e1.neq.has(c2)) return false;\n        for (const c of e2.eq) {\n          e1.eq.add(c);\n          map.set(c, e1);\n        }\n        for (const c of e2.neq) e1.neq.add(c);\n        for (const c of e1.neq) for (const eq of e1.eq) map.get(c)?.neq.add(eq);\n      } else {\n        if (e1.eq.has(c2)) return false;\n        for (const c of e2.eq) e1.neq.add(c);\n        for (const c of e1.eq) e2.neq.add(c);\n      }\n    }\n  }\n  return true;\n}"},{"date":"2021-04-30","time":108,"memory":41.8,"script":"typescript","desc":"并查集。","code":"class UnionFind {\n  elements: number[];\n  constructor(public size: number) {\n    this.elements = new Array(size).fill(0).map((_, i) => i);\n  }\n  same(v1: number, v2: number): boolean {\n    return this.find(v1) === this.find(v2);\n  }\n  find(v: number): number {\n    return v === this.elements[v] ? v : (this.elements[v] = this.find(this.elements[v]));\n  }\n  union(v1: number, v2: number): void {\n    const e1 = this.find(v1);\n    const e2 = this.find(v2);\n    if (e1 !== e2) {\n      this.elements[e1] = e2;\n      this.size--;\n    }\n  }\n}\nfunction equationsPossible(equations: string[]): boolean {\n  equations.sort((a, b) => {\n    if (a[1] === '=') return -1;\n    return 1;\n  });\n  const uf = new UnionFind(26);\n  const toNum = (char: string) => char.codePointAt(0)! - 'a'.codePointAt(0)!;\n  for (const equation of equations) {\n    const num1 = toNum(equation[0]);\n    const num2 = toNum(equation[3]);\n    const same = equation[1] === '=';\n    if (same) uf.union(num1, num2);\n    else if (uf.same(num1, num2)) return false;\n  }\n  return true;\n}"}],"tagList":["并查集","图","数组","字符串"],"level":"Medium"}},{"problemName":"992.K个不同整数的子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/992.K个不同整数的子数组.json","problemData":{"id":"1034","name":"992.K个不同整数的子数组","url":"https://leetcode.cn/problems/subarrays-with-k-different-integers","desc":"返回 A 中好子数组的数目。","solutions":[{"date":"2021-02-10","time":108,"memory":45.9,"script":"typescript","desc":"转换题目为最多包含 K 种数组，进行相减得到解。","code":"function subarraysWithKDistinct(A: number[], K: number): number {\n  const atMostWithKDistinct = (k: number): number => {\n    const len = A.length;\n    const freq: number[] = new Array(len + 1).fill(0);\n    let l = 0;\n    let r = 0;\n    let c = 0;\n    let res = 0;\n    while (r < len) {\n      if (freq[A[r]]++ === 0) cpp;\n      r++;\n      while (c > k) {\n        if (--freq[A[l]] === 0) c--;\n        l++;\n      }\n      res += r - l;\n    }\n    return res;\n  };\n  return atMostWithKDistinct(K) - atMostWithKDistinct(K - 1);\n}"}],"tagList":["数组","哈希表","计数","滑动窗口"],"level":"Hard"}},{"problemName":"993.二叉树的堂兄弟节点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/993.二叉树的堂兄弟节点.json","problemData":{"id":"1035","name":"993.二叉树的堂兄弟节点","url":"https://leetcode.cn/problems/cousins-in-binary-tree","desc":"如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。","solutions":[{"date":"2021-05-17","time":116,"memory":39.3,"script":"typescript","desc":"生成节点的继承链进行比较。","code":"function isCousins(root: TreeNode | null, x: number, y: number): boolean {\n  if (root === null) return false;\n  const findGrandParent = (\n    val: number,\n    queue: TreeNode[],\n    node: TreeNode | null = root\n  ): boolean => {\n    if (node === null) return false;\n    queue.unshift(node);\n    if (node.val === val) return true;\n    if (findGrandParent(val, queue, node.left)) return true;\n    if (findGrandParent(val, queue, node.right)) return true;\n    queue.shift();\n    return false;\n  };\n  const queueX: TreeNode[] = [];\n  findGrandParent(x, queueX);\n  const queueY: TreeNode[] = [];\n  findGrandParent(y, queueY);\n  if (queueX.length < 3 || queueY.length < 3) return false;\n  return queueX[1] !== queueY[1] && queueX.length === queueY.length;\n}"},{"date":"2021-07-25","time":72,"memory":39.6,"script":"typescript","desc":"dfs。","code":"function isCousins(root: TreeNode | null, x: number, y: number): boolean {\n  const map = new Map<number, { parent: TreeNode | null; level: number }>();\n  dfs();\n  const xNode = map.get(x)!;\n  const yNode = map.get(y)!;\n  return xNode.level === yNode.level && xNode.parent !== yNode.parent;\n  function dfs(node: TreeNode | null = root, level = 0, parent: TreeNode | null = null) {\n    if (node === null) return;\n    map.set(node.val, {\n      parent,\n      level,\n    });\n    dfs(node.left, level + 1, node);\n    dfs(node.right, level + 1, node);\n  }\n}"},{"script":"python","date":"2024-02-08","time":41,"memory":16.5,"desc":"遍历记录父亲和level。","code":"class Solution:\n    def isCousins(self, root: Optional[TreeNode], x: int, y: int) -> bool:\n        map = {}\n        xlevel = ylevel = 0\n        xnode, ynode = None, None\n        def dfs(node: Optional[TreeNode], level = 0):\n            nonlocal xnode, ynode, xlevel, ylevel\n            if not node: return\n            if node.val == x:\n                xnode = node\n                xlevel = level\n            if node.val == y:\n                ynode = node\n                ylevel = level\n            if node.left:\n                map[node.left] = node\n                dfs(node.left, level + 1)\n            if node.right:\n                map[node.right] = node\n                dfs(node.right, level + 1)\n        dfs(root)\n        if xlevel != ylevel: return False\n        if map[xnode] == map[ynode]: return False\n        return True"}],"tagList":["树","深度优先搜索","广度优先搜索","二叉树"],"level":"Easy"}},{"problemName":"994.腐烂的橘子.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/994.腐烂的橘子.json","problemData":{"id":"1036","name":"994.腐烂的橘子","url":"https://leetcode.cn/problems/rotting-oranges","desc":"返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。","solutions":[{"script":"python","time":37,"memory":16.37,"desc":"bfs。","code":"dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    class Solution:\n        def orangesRotting(self, grid: List[List[int]]) -> int:\n            n, m = len(grid), len(grid[0])\n            count = sum([grid[i][j] == 1 for i in range(n) for j in range(m)])\n            if count == 0: return 0\n            q = deque([(i, j) for i in range(n) for j in range(m) if grid[i][j] == 2])\n            step = 0\n            size = len(q)\n            while q:\n                i, j = q.popleft()\n                for dir in dirs:\n                    ni, nj = i + dir[0], j + dir[1]\n                    if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 1:\n                        count -= 1\n                        grid[ni][nj] = 2\n                        q.append((ni, nj))\n                size -= 1\n                if size == 0:\n                    step += 1\n                    size = len(q)\n            return step - 1 if count == 0 else -1","date":"2024-05-13"}],"tagList":["广度优先搜索","数组","矩阵"],"level":"Medium"}},{"problemName":"995.K连续位的最小翻转次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/995.K连续位的最小翻转次数.json","problemData":{"id":"1037","name":"995.K连续位的最小翻转次数","url":"https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips","desc":"在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。返回所需的 K 位翻转的最小次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。","solutions":[{"date":"2021-02-18","time":1580,"memory":46.4,"script":"typescript","desc":"贪心，直接翻转每个 0。","code":"function minKBitFlips(A: number[], K: number): number {\n  const checkZero = (v: number) => !(v & 1);\n  if (K === 1) return A.filter(checkZero).length;\n  const startI = A.findIndex(checkZero);\n  if (startI === -1) return 0;\n  const flip = (index: number) => {\n    for (let i = index, l = index + K; i < l; i++) {\n      A[i] ^= 1;\n    }\n  };\n  const len = A.length - K;\n  let ans = 0;\n  for (let i = startI; i <= len; i++) {\n    if (!(A[i] & 1)) {\n      ans++;\n      flip(i);\n    }\n  }\n  return A.slice(len).every(v => v & 1) ? ans : -1;\n}"}],"tagList":["位运算","队列","数组","前缀和","滑动窗口"],"level":"Hard"}},{"problemName":"997.找到小镇的法官.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/997.找到小镇的法官.json","problemData":{"id":"1039","name":"997.找到小镇的法官","url":"https://leetcode.cn/problems/find-the-town-judge","desc":"如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的编号。否则，返回 -1。","solutions":[{"date":"2021-12-19","time":112,"memory":46.8,"script":"typescript","desc":"统计每个人是否都有 n-1 个人相信且没有相信别人。","code":"class Person {\n  parent: number = 0;\n  children: number = 0;\n  constructor(public idx: number) {}\n}\nfunction findJudge(n: number, trust: number[][]): number {\n  const persons = new Array(n).fill(0).map((_, i) => new Person(i + 1));\n  for (const [i1, i2] of trust) {\n    persons[i1 - 1].parent++;\n    persons[i2 - 1].children++;\n  }\n  return persons.find(p => p.children === n - 1 && p.parent === 0)?.idx ?? -1;\n}"}],"tagList":["图","数组","哈希表"],"level":"Easy"}},{"problemName":"998.最大二叉树II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/998.最大二叉树II.json","problemData":{"id":"1040","name":"998.最大二叉树II","url":"https://leetcode.cn/problems/maximum-binary-tree-ii","desc":"返回 Construct(b) 。","solutions":[{"date":"2022-08-30","time":8,"memory":12.9,"script":"cpp","desc":"每次查看右子树。","code":"class Solution {\npublic:\n    TreeNode* insertIntoMaxTree(TreeNode* root, int val) {\n        TreeNode *node = root, *pre = nullptr;\n        while (node && node->val > val) {\n            pre  = node;\n            node = node->right;\n        }\n        if (!pre) return new TreeNode(val, root, nullptr);\n        pre->right = new TreeNode(val, node, nullptr);\n        return root;\n    }\n};"}],"tagList":["树","二叉树"],"level":"Medium"}},{"problemName":"999.可以被一步捕获的棋子数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/901-1000/999.可以被一步捕获的棋子数.json","problemData":{"id":"1041","name":"999.可以被一步捕获的棋子数","url":"https://leetcode.cn/problems/available-captures-for-rook","desc":"给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。返回这些数字之和。","solutions":[{"date":"2022-03-26","time":0,"memory":16.3,"script":"cpp","desc":"dfs。","code":"class Solution {\n   public:\n    int sumRootToLeaf(TreeNode *root) {\n        int ans = 0;\n        dfs(root, ans, 0);\n        return ans;\n    }\n    void dfs(TreeNode *node, int &ans, int num) {\n        if (!node) return;\n        num = num << 1 | node->val;\n        if (!node->left && !node->right) {\n            ans += num;\n            return;\n        }\n        dfs(node->left, ans, num);\n        dfs(node->right, ans, num);\n    }\n};"},{"date":"2022-05-30","time":4,"memory":16.1,"script":"cpp","desc":"dfs。","code":"class Solution {\n   public:\n    int sumRootToLeaf(TreeNode* root) {\n        int ans = 0;\n        dfs(root, ans, 0);\n        return ans;\n    }\n    void dfs(TreeNode* node, int& ans, int val) {\n        val = val << 1 | node->val;\n        if (node->left == nullptr && node->right == nullptr) {\n            ans += val;\n            return;\n        }\n        if (node->left) dfs(node->left, ans, val);\n        if (node->right) dfs(node->right, ans, val);\n    }\n};"}],"tagList":["数组","矩阵","模拟"],"level":"Easy"}}]},{"dirName":"LCP","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\LCP","problems":[{"problemName":"LCP06.拿硬币.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCP/LCP06.拿硬币.json","problemData":{"id":"1000056","name":"LCP06.拿硬币","url":"https://leetcode.cn/problems/na-ying-bi","desc":"桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。","solutions":[{"script":"cpp","time":4,"memory":8.17,"desc":"遍历。","code":"class Solution {\npublic:\n    int minCount(vector<int>& coins) {\n        int res = 0;\n        for (auto &coin : coins) res += ceil(1.0 * coin / 2);\n        return res;\n    }\n};","date":"2023-09-20"},{"script":"python","time":40,"memory":16,"desc":"同上。","code":"class Solution:\n    def minCount(self, coins: List[int]) -> int:\n        return sum(ceil(coin / 2) for coin in coins)","date":"2023-09-20"},{"script":"rust","time":0,"memory":2.3,"desc":"同上。","code":"impl Solution {\n    pub fn min_count(coins: Vec<i32>) -> i32 {\n        coins\n            .into_iter()\n            .map(|coin| (coin as f64 / 2.0).ceil() as i32)\n            .sum()\n    }\n}","date":"2023-09-20"}],"tagList":["数组","数学"],"level":"Easy"}},{"problemName":"LCP07.传递信息.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCP/LCP07.传递信息.json","problemData":{"id":"1000063","name":"LCP07.传递信息","url":"https://leetcode.cn/problems/chuan-di-xin-xi","desc":"给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。","solutions":[{"date":"2021-07-01","time":104,"memory":41.5,"script":"typescript","desc":"储存每个伙伴的下一个伙伴。","code":"function numWays(n: number, relation: number[][], k: number): number {\n  const nextPartnerMap = new Map<number, Set<number>>();\n  for (const [cur, next] of relation) {\n    let set = nextPartnerMap.get(cur);\n    if (!set) nextPartnerMap.set(cur, (set = new Set()));\n    set.add(next);\n  }\n  let list = [0];\n  while (k--) {\n    list = list\n      .map(item => (nextPartnerMap.has(item) ? [...nextPartnerMap.get(item)!] : []))\n      .flat();\n  }\n  return list.filter(v => v === n - 1).length;\n}"}],"tagList":["深度优先搜索","广度优先搜索","图","动态规划"],"level":"Easy"}},{"problemName":"LCP19.秋叶收藏集.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCP/LCP19.秋叶收藏集.json","problemData":{"id":"1000130","name":"LCP19.秋叶收藏集","url":"https://leetcode.cn/problems/UlBDOe","desc":"小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 leaves， 字符串 leaves 仅包含小写字符 r 和 y， 其中字符 r 表示一片红叶，字符 y 表示一片黄叶。出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。","solutions":[{"date":"2020-10-01","time":688,"memory":70.4,"script":"typescript","desc":"[参考链接](https://leetcode-cn.com/problems/UlBDOe/solution/qiu-xie-shou-cang-ji-by-leetcode-solution/)。","code":"function minimumOperations(leaves: string): number {\n  const len = leaves.length;\n  const check = (i: number, type: 'r' | 'y') => (leaves[i] === type ? 1 : 0);\n  const isRed = (i: number) => check(i, 'r');\n  const isYellow = (i: number) => check(i, 'y');\n  const dp: number[][] = new Array(len).fill(0).map(_ => new Array(3).fill(0));\n  dp[0][0] = isYellow(0);\n  dp[0][1] = dp[0][2] = dp[1][2] = Infinity;\n  for (let i = 1; i < len; i++) {\n    dp[i][0] = dp[i - 1][0] + isYellow(i);\n    dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][1]) + isRed(i);\n    if (i >= 2) dp[i][2] = Math.min(dp[i - 1][1], dp[i - 1][2]) + isYellow(i);\n  }\n  return dp[len - 1][2];\n}"}],"tagList":["字符串","动态规划"],"level":"Medium"}},{"problemName":"LCP24.数字游戏.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCP/LCP24.数字游戏.json","problemData":{"id":"1000131","name":"LCP24.数字游戏","url":"https://leetcode.cn/problems/5TxKeK","desc":"主办方请小扣回答出一个长度为 N 的数组，第 i 个元素(0 <= i < N)表示将 0~i 号计数器 初始 所示数字操作成满足所有条件 nums[a]+1 == nums[a+1],(0 <= a < i) 的最小操作数。","solutions":[{"script":"python","time":248,"memory":34.91,"desc":"依次递增转换为使每个数都保持一致的最小步数。","code":"class Solution:\n    def numsGame(self, nums: List[int]) -> List[int]:\n        lq = []\n        rq = []\n        res = []\n        rsum = lsum = 0\n        mod = 10 ** 9 + 7\n        for i in range(len(nums)):\n            num = nums[i] - i\n            if lq and -lq[0] >= num:\n                lsum += num\n                heappush(lq, -num)\n            else:\n                rsum += num\n                heappush(rq, num)\n            # print(f'lq = {lq}, lsum = {lsum}')\n            # print(f'rq = {rq}, rsum = {rsum}')\n            if len(lq) > len(rq):\n                num = -heappop(lq)\n                lsum -= num\n                rsum += num\n                heappush(rq, num)            \n            elif len(lq) < len(rq) - 1:\n                num = heappop(rq)\n                lsum += num\n                rsum -= num\n                heappush(lq, -num)\n            # print(f'lq = {lq}, lsum = {lsum}')\n            # print(f'rq = {rq}, rsum = {rsum}')\n            if (i + 1) % 2 == 0:\n                res.append((rsum - lsum) % mod)\n            else:\n                res.append((rsum - lsum - rq[0]) % mod)\n        return res","date":"2024-02-01"}],"tagList":["数组","数学","堆（优先队列）"],"level":"Hard"}},{"problemName":"LCP30.魔塔游戏.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCP/LCP30.魔塔游戏.json","problemData":{"id":"1000224","name":"LCP30.魔塔游戏","url":"https://leetcode.cn/problems/p0NxJO","desc":"小扣初始血量为 1，且无上限。假定小扣原计划按房间编号升序访问所有房间补血/打怪，为保证血量始终为正值，小扣需对房间访问顺序进行调整，每次仅能将一个怪物房间（负数的房间）调整至访问顺序末尾。请返回小扣最少需要调整几次，才能顺利访问所有房间。若调整顺序也无法访问完全部房间，请返回 -1。","solutions":[{"script":"python","time":109,"memory":30.9,"desc":"对遍历过的负数进行记录，如果打不过，就拿出前面最大的负数放到后面。","code":"class Solution:\n    def magicTower(self, nums: List[int]) -> int:\n        q = []\n        cur = 1\n        ans = sum = 0\n        for num in nums:\n            if num < 0: heappush(q, num)\n            while q and cur <= -num:\n                ans += 1\n                top = heappop(q)\n                cur -= top\n                sum += top\n            if cur <= -num: return -1\n            cur += num\n        return ans if cur > -sum else -1","date":"2024-02-06"}],"tagList":["贪心","数组","堆（优先队列）"],"level":"Medium"}},{"problemName":"LCP33.蓄水.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCP/LCP33.蓄水.json","problemData":{"id":"1000221","name":"LCP33.蓄水","url":"https://leetcode.cn/problems/o8SXZn","desc":"每个水缸对应最低蓄水量记作 vat[i]，返回小扣至少需要多少次操作可以完成所有水缸蓄水要求。","solutions":[{"script":"cpp","time":84,"memory":8,"desc":"利用堆获取需要次数最多的桶。","code":"class Solution {\npublic:\n    int storeWater(vector<int>& bucket, vector<int>& vat) {\n        auto get_cnt = [&](int idx) {\n            if (bucket[idx] == 0) {\n                if (vat[idx] == 0) return 0;\n                return 0x3f3f3f3f;\n            }\n            return (int)ceil(1.0 * vat[idx] / bucket[idx]);\n        };\n        auto cmp = [&](int x, int y) -> bool { \n            return get_cnt(x) < get_cnt(y);\n        };\n        priority_queue<int, vector<int>, decltype(cmp)> q(cmp);\n        for (int i = 0; i < bucket.size(); i++) q.push(i);\n        int res = get_cnt(q.top()), add = 0;\n        while (get_cnt(q.top()) > 1) {\n            int cur_cnt = get_cnt(q.top());\n            while (get_cnt(q.top()) == cur_cnt) {\n                int idx = q.top();\n                q.pop();\n                do {\n                    bucket[idx] += 1;\n                    add += 1;\n                } while(get_cnt(idx) == cur_cnt);\n                q.push(idx);\n            }\n            res = min(res, get_cnt(q.top()) + add);\n        }\n        return res;\n    }\n};","date":"2023-05-21"}],"tagList":["贪心","数组","堆（优先队列）"],"level":"Easy"}},{"problemName":"LCP40.心算挑战.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCP/LCP40.心算挑战.json","problemData":{"id":"1000368","name":"LCP40.心算挑战","url":"https://leetcode.cn/problems/uOAnQW","desc":"「力扣挑战赛」心算项目的挑战比赛中，要求选手从 N 张卡牌中选出 cnt 张卡牌，若这 cnt 张卡牌数字总和为偶数，则选手成绩「有效」且得分为 cnt 张卡牌数字总和。 给定数组 cards 和 cnt，其中 cards[i] 表示第 i 张卡牌上的数字。 请帮参赛选手计算最大的有效得分。若不存在获取有效得分的卡牌方案，则返回 0。","solutions":[{"script":"python","time":209,"memory":25.76,"desc":"从大到小排序后依次取值，如果最后为偶数则就是最大值，如果最后为奇数，比较删除一个奇数，增加一个偶数，和删除一个偶数，增加一个奇数两种方案的最大值。","code":"class Solution:\n    def maxmiumScore(self, cards: List[int], cnt: int) -> int:\n        res = i = f = 0\n        arr = sorted(Counter(cards).items(), reverse = True)\n        while i < len(arr) and cnt > 0:\n            k, v = arr[i]\n            c = min(cnt, v)\n            cnt -= c\n            arr[i] = (k, v - c)\n            res += k * c\n            f ^= (k * c) & 1\n            i += 1\n        if f == 0: return res\n        else:\n            # v1\n            idx = i - 1\n            while idx > 0:\n                if arr[idx][0] % 2 != 0: break\n                idx -= 1\n            if idx == -1: v1 = 0\n            else:\n                v1 = res - arr[idx][0]\n                idx = i\n                if idx > 0 and arr[idx - 1][1] > 0: idx -= 1\n                while idx < len(arr):\n                    if arr[idx][0] % 2 == 0: break\n                    idx += 1\n                if idx == len(arr): v1 = 0\n                else: v1 += arr[idx][0]\n            # v2\n            idx = i - 1\n            while idx >= 0:\n                if arr[idx][0] % 2 == 0: break\n                idx -= 1\n            if idx == -1: v2 = 0\n            else:\n                v2 = res - arr[idx][0]\n                idx = i\n                if idx > 0 and arr[idx - 1][1] > 0: idx -= 1\n                while idx < len(arr):\n                    if arr[idx][0] % 2 != 0: break\n                    idx += 1\n                if idx == len(arr): v2 = 0\n                else: v2 += arr[idx][0]\n            return max(v1, v2)","date":"2024-08-01"}],"tagList":["贪心","数组","排序"],"level":"Easy"}},{"problemName":"LCP41.黑白翻转棋.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCP/LCP41.黑白翻转棋.json","problemData":{"id":"1000370","name":"LCP41.黑白翻转棋","url":"https://leetcode.cn/problems/fHi6rV","desc":"在 n*m 大小的棋盘中，有黑白两种棋子，黑棋记作字母 \"X\", 白棋记作字母 \"O\"，空余位置记作 \".\"。当落下的棋子与其他相同颜色的棋子在行、列或对角线完全包围（中间不存在空白位置）另一种颜色的棋子，则可以翻转这些棋子的颜色。若下一步可放置一枚黑棋，请问选手最多能翻转多少枚白棋。","solutions":[{"script":"cpp","time":8,"memory":11.4,"desc":"暴力枚举。","code":"#define X first\n#define Y second\n#define pii pair<int, int>\n\nclass Solution {\npublic:\n    vector<vector<int>> dirs2 = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};\n\n    int flipChess(vector<string>& chessboard) {\n        int n = chessboard.size(), m = chessboard[0].size(), res = 0;\n        function<void(vector<string>&, int, int, int&)> dfs = [&](vector<string>& chessboard, int i, int j, int& sum) {\n            vector<pii> list;\n            for (auto &dir : dirs2) {\n                int ni = i + dir[0], nj = j + dir[1];\n                vector<pii> tmp;\n                while (ni >= 0 && ni < n && nj >= 0 && nj < m && chessboard[ni][nj] == 'O') {\n                    tmp.push_back(make_pair(ni, nj));\n                    ni += dir[0];\n                    nj += dir[1];\n                }\n                if (ni >= 0 && ni < n && nj >= 0 && nj < m && chessboard[ni][nj] == 'X') {\n                    for (auto &item : tmp) list.push_back(item);\n                }\n            }\n\n            sum += list.size();\n\n            for (auto &next : list) chessboard[next.X][next.Y] = 'X';\n            for (auto &next : list) dfs(chessboard, next.X, next.Y, sum);\n        };\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (chessboard[i][j] == '.') {\n                    auto board = chessboard;\n                    board[i][j] = 'X';\n                    int sum = 0;\n                    dfs(board, i, j, sum);\n                    res = max(res, sum);\n                }\n            }\n        }\n        return res;\n    }\n};","date":"2023-06-21"},{"script":"python","time":88,"memory":16,"desc":"同上。","code":"dirs2 = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n\n    class Solution:\n        def flipChess(self, chessboard: List[str]) -> int:\n            n = len(chessboard)\n            m = len(chessboard[0])\n            sum = res = 0\n    \n            def dfs(board:List[List[str]],i:int,j:int):\n                nonlocal sum\n                list = []\n                for dir in dirs2:\n                    ni = i + dir[0]\n                    nj = j + dir[1]\n                    tmp = []\n                    while 0 <= ni < n and 0 <= nj < m and board[ni][nj] == 'O':\n                        tmp.append((ni,nj))\n                        ni += dir[0]\n                        nj += dir[1]\n                    if 0 <= ni < n and 0 <= nj < m and board[ni][nj] == 'X':\n                        for item in tmp:\n                            list.append(item)\n                sum += len(list)\n    \n                for i,j in list: board[i][j] = 'X'\n                for i,j in list: dfs(board,i,j)\n    \n            for i in range(n):\n                for j in range(m):\n                    if chessboard[i][j] == '.':\n                        board = []\n                        for item in chessboard:\n                            board.append(list(item))\n                        board[i][j] = 'X'\n                        sum = 0\n                        dfs(board, i, j)\n                        res = max(res, sum)\n            return res","date":"2023-06-21"},{"script":"rust","time":0,"memory":2.1,"desc":"同上。","code":"pub fn str_to_vec(s: &String) -> Vec<char> {\n    s.chars().collect()\n}\npub const dirs2: [[i32; 2]; 8] = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];\n\nfn dfs(board: &mut Vec<Vec<char>>, sum: &mut i32, i: usize, j: usize) {\n    let mut list = vec![];\n    for dir in dirs2 {\n        let mut ni = i as i32 + dir[0];\n        let mut nj = j as i32 + dir[1];\n        let mut tmp = vec![];\n        while ni >= 0\n            && ni < board.len() as i32\n            && nj >= 0\n            && nj < board[0].len() as i32\n            && board[ni as usize][nj as usize] == 'O'\n        {\n            tmp.push((ni, nj));\n            ni += dir[0];\n            nj += dir[1];\n        }\n        if ni >= 0\n            && ni < board.len() as i32\n            && nj >= 0\n            && nj < board[0].len() as i32\n            && board[ni as usize][nj as usize] == 'X'\n        {\n            for item in tmp {\n                list.push(item);\n            }\n        }\n    }\n    *sum += list.len() as i32;\n    for (i, j) in &list {\n        board[*i as usize][*j as usize] = 'X';\n    }\n    for (i, j) in &list {\n        dfs(board, sum, *i as usize, *j as usize);\n    }\n}\n\nimpl Solution {\n    pub fn flip_chess(chessboard: Vec<String>) -> i32 {\n        let chessboard = chessboard\n            .into_iter()\n            .map(|item| str_to_vec(&item))\n            .collect::<Vec<Vec<char>>>();\n        let n = chessboard.len();\n        let m = chessboard[0].len();\n        let mut res = 0;\n        for i in 0..n {\n            for j in 0..m {\n                if chessboard[i][j] == '.' {\n                    let mut board = chessboard.clone();\n                    board[i][j] = 'X';\n                    let mut sum = 0;\n                    dfs(&mut board, &mut sum, i, j);\n                    res = res.max(sum);\n                }\n            }\n        }\n        res\n    }\n}","date":"2023-06-21"}],"tagList":["广度优先搜索","数组","矩阵"],"level":"Medium"}},{"problemName":"LCP50.宝石补给.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCP/LCP50.宝石补给.json","problemData":{"id":"1000433","name":"LCP50.宝石补给","url":"https://leetcode.cn/problems/WHnhjV","desc":"在完成所有的赠送后，请找到拥有最多宝石的勇者和拥有最少宝石的勇者，并返回他们二者的宝石数量之差。","solutions":[{"script":"cpp","time":44,"memory":21.7,"desc":"方向数组遍历。","code":"class Solution {\npublic:\n    int giveGem(vector<int>& gem, vector<vector<int>>& operations) {\n        for (auto &item : operations) {\n            gem[item[1]] += gem[item[0]] / 2;\n            gem[item[0]] -= gem[item[0]] / 2;\n        }\n        return *max_element(gem.begin(), gem.end()) - *min_element(gem.begin(), gem.end());\n    }\n};","date":"2023-09-15"},{"script":"python","time":60,"memory":17.7,"desc":"同上。","code":"class Solution:\n    def giveGem(self, gem: List[int], operations: List[List[int]]) -> int:\n        for [i1, i2] in operations:\n            gem[i2] += gem[i1] // 2\n            gem[i1] -= gem[i1] // 2\n        return max(gem) - min(gem)","date":"2023-09-15"},{"script":"rust","time":4,"memory":2.3,"desc":"同上。","code":"impl Solution {\n    pub fn give_gem(mut gem: Vec<i32>, operations: Vec<Vec<i32>>) -> i32 {\n        for item in operations {\n            gem[item[1] as usize] += gem[item[0] as usize] / 2;\n            gem[item[0] as usize] -= gem[item[0] as usize] / 2;\n        }\n        *gem.iter().max() - *gem.iter().min()\n    }\n}","date":"2023-09-15"}],"tagList":["数组","模拟"],"level":"Easy"}},{"problemName":"LCP61.气温变化趋势.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCP/LCP61.气温变化趋势.json","problemData":{"id":"1000476","name":"LCP61.气温变化趋势","url":"https://leetcode.cn/problems/6CE719","desc":"已知 temperatureA[i] 和 temperatureB[i] 分别表示第 i 天两地区的气温。 组委会希望找到一段天数尽可能多，且两地气温变化趋势相同的时间举办嘉年华活动。请分析并返回两地气温变化趋势相同的最大连续天数。","solutions":[{"script":"python","time":51,"memory":16.46,"desc":"遍历。","code":"clamp = lambda v, nmin, nmax: min(max(v, nmin), nmax)\nclass Solution:\n    def temperatureTrend(self, temperatureA: List[int], temperatureB: List[int]) -> int:\n        res = cur = 0\n        arrA = [clamp(temperatureA[i + 1] - temperatureA[i], -1, 1) for i in range(len(temperatureA) - 1)]\n        arrB = [clamp(temperatureB[i + 1] - temperatureB[i], -1, 1) for i in range(len(temperatureB) - 1)]\n        for i in range(len(arrA)):\n            if arrA[i] == arrB[i]:\n                cur += 1\n                res = max(res, cur)\n            else:\n                cur = 0\n        return res","date":"2024-06-21"}],"tagList":["数组"],"level":"Easy"}}]},{"dirName":"LCR","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\LCR","problems":[{"problemName":"LCR003.比特位计数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR003.比特位计数.json","problemData":{"id":"1000230","name":"LCR003.比特位计数","url":"https://leetcode.cn/problems/w3tCBm","desc":"给定一个非负整数 n ，请计算 0 到 n 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。","solutions":[{"date":"2021-12-23","time":8,"memory":8.4,"script":"cpp","desc":"当遇到 2 的指数幂后，从 0 开始重新遍历。","code":"class Solution {\n   public:\n    vector<int> countBits(int n) {\n        vector<int> ans;\n        ans.push_back(0);\n        if (n == 0) return ans;\n        ans.push_back(1);\n        if (n == 1) return ans;\n        for (int num = 2, i = 0; num <= n; num++, i++) {\n            if ((num & (num - 1)) == 0) i = 0;\n            ans.push_back(ans[i] + 1);\n        }\n        return ans;\n    }\n};"}],"tagList":["位运算","动态规划"],"level":"Easy"}},{"problemName":"LCR005.最大单词长度乘积.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR005.最大单词长度乘积.json","problemData":{"id":"1000236","name":"LCR005.最大单词长度乘积","url":"https://leetcode.cn/problems/aseY1I","desc":"给定一个字符串数组  words，请计算当两个字符串 words[i] 和 words[j] 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。","solutions":[{"date":"2021-12-24","time":380,"memory":20.2,"script":"cpp","desc":"用二进制存储每个字符串存在的字符，两个字符串值与运算为 0 说明无重复。","code":"class Solution {\n   public:\n    int s2i(string str) {\n        int ans = 0;\n        for (auto &ch : str) ans |= 1 << (ch - 'a');\n        return ans;\n    }\n    int maxProduct(vector<string> &words) {\n        unordered_map<string, int> mmap;\n        for (auto &word : words) mmap[word] = s2i(word);\n        int ans = 0;\n        for (int i = 0; i < words.size(); i++) {\n            for (int j = 0; j < i; j++) {\n                if (mmap[words[i]] & mmap[words[j]]) continue;\n                ans = max(ans, (int)(words[i].size() * words[j].size()));\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["位运算","数组","字符串"],"level":"Medium"}},{"problemName":"LCR007.三数之和.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR007.三数之和.json","problemData":{"id":"1000239","name":"LCR007.三数之和","url":"https://leetcode.cn/problems/1fGaJU","desc":"给定一个包含 n 个整数的数组  nums，判断  nums  中是否存在三个元素  a ，b ，c ，使得  a + b + c = 0 ？请找出所有和为 0 且   不重复   的三元组。","solutions":[{"date":"2022-02-18","time":60,"memory":19.3,"script":"cpp","desc":"循环双指针。","code":"class Solution {\n   public:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        vector<vector<int>> ans;\n        sort(nums.begin(), nums.end());\n        for (int i = 0; i < nums.size() && nums[i] <= 0; i++) {\n            if (i != 0 && nums[i] == nums[i - 1]) continue;\n            int sum, l = i + 1, r = nums.size() - 1;\n            while (l < r) {\n                sum = nums[l] + nums[r] + nums[i];\n                if (sum == 0) {\n                    ans.push_back(vector<int>{nums[i], nums[l], nums[r]});\n                    while (l < r && nums[l] == nums[l + 1]) l++;\n                    l++;\n                } else if (sum > 0)\n                    r--;\n                else\n                    l++;\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","双指针","排序"],"level":"Medium"}},{"problemName":"LCR008.长度最小的子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR008.长度最小的子数组.json","problemData":{"id":"1000242","name":"LCR008.长度最小的子数组","url":"https://leetcode.cn/problems/2VG8Kg","desc":"给定一个含有  n  个正整数的数组和一个正整数 target 。找出该数组中满足其和 ≥ target 的长度最小的 连续子数组  [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。","solutions":[{"date":"2021-12-24","time":8,"memory":10.4,"script":"cpp","desc":"双指针。","code":"class Solution {\n   public:\n    int minSubArrayLen(int target, vector<int>& nums) {\n        int l = 0, r = 0, num = 0, ans = INT_MAX, n = nums.size();\n        while (r < n) {\n            while (r < n && num < target) num += nums[r++];\n            while (l < r && num - nums[l] >= target) num -= nums[l++];\n            if (num >= target) ans = min(ans, r - l);\n            num -= nums[l++];\n        }\n        return ans == INT_MAX ? 0 : ans;\n    }\n};"}],"tagList":["数组","二分查找","前缀和","滑动窗口"],"level":"Medium"}},{"problemName":"LCR009.乘积小于K的子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR009.乘积小于K的子数组.json","problemData":{"id":"1000244","name":"LCR009.乘积小于K的子数组","url":"https://leetcode.cn/problems/ZVAVXX","desc":"请找出该数组内乘积小于 k 的连续的子数组的个数。","solutions":[{"date":"2021-12-24","time":84,"memory":59.7,"script":"cpp","desc":"双指针。","code":"class Solution {\n   public:\n    int numSubarrayProductLessThanK(vector<int>& nums, int k) {\n        if (k == 0) return 0;\n        int n = nums.size(), l = 0, r = 0, num = 1, ans = 0;\n        while (l < n && r <= n) {\n            while (r < n && num < k) num *= nums[r++];\n            ans += r - l - (num >= k ? 1 : 0);\n            num /= nums[l++];\n        }\n        return max(ans, 0);\n    }\n};"},{"date":"2021-12-24","time":49,"memory":59.8,"script":"cpp","desc":"双指针。","code":"class Solution {\n   public:\n    int numSubarrayProductLessThanK(vector<int>& nums, int k) {\n        if (k == 0) return 0;\n        int ans = 0, num = 1, l = 0;\n        for (int r = 0; r < nums.size(); r++) {\n            num *= nums[r];\n            while (l <= r && num >= k) num /= nums[l++];\n            ans += r - l + 1;\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","滑动窗口"],"level":"Medium"}},{"problemName":"LCR010.和为K的子数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR010.和为K的子数组.json","problemData":{"id":"1000246","name":"LCR010.和为K的子数组","url":"https://leetcode.cn/problems/QTMn0o","desc":"给定一个整数数组和一个整数 k ，请找到该数组中和为 k 的连续子数组的个数。","solutions":[{"date":"2021-12-23","time":80,"memory":40.7,"script":"cpp","desc":"前缀和。","code":"class Solution {\n   public:\n    int subarraySum(vector<int>& nums, int k) {\n        unordered_map<int, int> mmap;\n        int sum = 0, ans = 0;\n        mmap[0] = 1;\n        for (auto& num : nums) {\n            sum += num;\n            if (mmap[sum - k]) ans += mmap[sum - k];\n            mmap[sum]++;\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","前缀和"],"level":"Medium"}},{"problemName":"LCR011.连续数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR011.连续数组.json","problemData":{"id":"1000247","name":"LCR011.连续数组","url":"https://leetcode.cn/problems/A1NYOS","desc":"给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。","solutions":[{"date":"2021-12-23","time":116,"memory":81.7,"script":"cpp","desc":"前缀和。","code":"class Solution {\n   public:\n    int findMaxLength(vector<int>& nums) {\n        int ans = 0, sum = 0;\n        unordered_map<int, int> mmap;\n        mmap[0] = -1;\n        for (int i = 0; i < nums.size(); i++) {\n            sum += nums[i] == 1 ? 1 : -1;\n            if (mmap.count(sum)) {\n                ans = max(ans, i - mmap[sum]);\n            } else {\n                mmap[sum] = i;\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","前缀和"],"level":"Medium"}},{"problemName":"LCR012.寻找数组的中心下标.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR012.寻找数组的中心下标.json","problemData":{"id":"1000248","name":"LCR012.寻找数组的中心下标","url":"https://leetcode.cn/problems/tvdfij","desc":"给你一个整数数组 nums ，请计算数组的 中心下标 。","solutions":[{"date":"2021-12-23","time":12,"memory":30.2,"script":"cpp","desc":"前缀和。","code":"class Solution {\n   public:\n    int findMiddleIndex(vector<int>& nums) {\n        int sum = 0;\n        for (auto& num : nums) sum += num;\n        int pre = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (sum - nums[i] == pre) return i;\n            pre += nums[i];\n            sum -= nums[i];\n        }\n        return -1;\n    }\n};"}],"tagList":["数组","前缀和"],"level":"Easy"}},{"problemName":"LCR016.无重复字符的最长子串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR016.无重复字符的最长子串.json","problemData":{"id":"1000252","name":"LCR016.无重复字符的最长子串","url":"https://leetcode.cn/problems/wtcaE1","desc":"给定一个字符串 s ，请你找出其中不含有重复字符的 最长连续子字符串 的长度。","solutions":[{"date":"2021-12-24","time":8,"memory":6.8,"script":"cpp","desc":"双指针。","code":"class Solution {\n          public:\n    int lengthOfLongestSubstring(string s) {\n        int arr[200] = {0}, l = 0, r = 0, ans = 0, n = s.size();\n        while (r < n) {\n            while (r < n && arr[s[r]] < 1) arr[s[r++]]++;\n            ans = max(ans, r - l);\n            char ch = s[r++];\n            arr[ch]++;\n            while (s[l] != ch) arr[s[l++]]--;\n            arr[s[l++]]--;\n        }\n        return ans;\n    }\n};"}],"tagList":["哈希表","字符串","滑动窗口"],"level":"Medium"}},{"problemName":"LCR018.验证回文串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR018.验证回文串.json","problemData":{"id":"1000254","name":"LCR018.验证回文串","url":"https://leetcode.cn/problems/XltzEq","desc":"给定一个字符串 s ，验证 s 是否是 回文串 ，只考虑字母和数字字符，可以忽略字母的大小写。","solutions":[{"date":"2022-02-18","time":4,"memory":7.2,"script":"cpp","desc":"双指针遍历。","code":"class Solution {\n   public:\n    bool isPalindrome(string s) {\n        if (s == \" \") return 1;\n        int l = 0, r = s.size() - 1;\n        char lc, rc;\n        while (l < r) {\n            do {\n                lc = tolower(s[l++]);\n            } while (l < s.size() && !isdigit(lc) && !isalpha(lc));\n            do {\n                rc = tolower(s[r--]);\n            } while (r >= 0 && !isdigit(rc) && !isalpha(rc));\n            if (l < s.size() && r >= 0 && lc != rc) return 0;\n        }\n        return 1;\n    }\n};"}],"tagList":["双指针","字符串"],"level":"Easy"}},{"problemName":"LCR019.验证回文串II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR019.验证回文串II.json","problemData":{"id":"1000255","name":"LCR019.验证回文串II","url":"https://leetcode.cn/problems/RQku0D","desc":"给定一个非空字符串 s，请判断如果 最多 从字符串中删除一个字符能否得到一个回文字符串。","solutions":[{"date":"2022-02-18","time":48,"memory":19,"script":"cpp","desc":"双指针遍历。","code":"class Solution {\n   public:\n    bool check(string &s, int l, int r) {\n        while (l < r) {\n            if (s[l] != s[r]) return 0;\n            l++;\n            r--;\n        }\n        return 1;\n    }\n    bool validPalindrome(string s) {\n        int l = 0, r = s.size() - 1;\n        for (int l = 0, r = s.size() - 1; l < r; l++, r--) {\n            if (s[l] == s[r])\n                continue;\n            else\n                return check(s, l, r - 1) || check(s, l + 1, r);\n        }\n        return 1;\n    }\n};"}],"tagList":["贪心","双指针","字符串"],"level":"Easy"}},{"problemName":"LCR029.循环有序列表的插入.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR029.循环有序列表的插入.json","problemData":{"id":"1000265","name":"LCR029.循环有序列表的插入","url":"https://leetcode.cn/problems/4ueAj6","desc":"给定循环单调非递减列表中的一个点，写一个函数向这个列表中插入一个新元素 insertVal ，使这个列表仍然是循环升序的。","solutions":[{"date":"2022-06-18","time":8,"memory":7.9,"script":"cpp","desc":"遍历，考虑小于最小值和大于最大值。","code":"class Solution {\n   public:\n    Node* insert(Node* head, int insertVal) {\n        if (!head) {\n            Node* ans = new Node(insertVal);\n            ans->next = ans;\n            return ans;\n        }\n        Node *p = head, *node = new Node(insertVal);\n        if (p->next != head) {\n            int nmin = INT_MAX, nmax = INT_MIN;\n            do {\n                nmin = min(nmin, p->val);\n                nmax = max(nmax, p->val);\n                p = p->next;\n            } while (p != head);\n            if (nmin >= insertVal || nmax <= insertVal) {\n                while (p->val <= p->next->val && p->next != head) p = p->next;\n            } else {\n                while (!(p->val <= insertVal && p->next->val >= insertVal))\n                    p = p->next;\n            }\n        }\n        node->next = p->next;\n        p->next = node;\n        return head;\n    }\n};"}],"tagList":["链表"],"level":"Medium"}},{"problemName":"LCR033.字母异位词分组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR033.字母异位词分组.json","problemData":{"id":"1000275","name":"LCR033.字母异位词分组","url":"https://leetcode.cn/problems/sfvd7V","desc":"给定一个字符串数组 strs ，将 变位词 组合在一起。 可以按任意顺序返回结果列表。","solutions":[{"date":"2021-12-23","time":20,"memory":19.1,"script":"cpp","desc":"对字符串进行排序后归并。","code":"class Solution {\n   public:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, vector<string>> m;\n        for (int i = 0; i < strs.size(); i++) {\n            string str = strs[i];\n            string head = str;\n            sort(head.begin(), head.end());\n            m[head].push_back(str);\n        }\n        vector<vector<string>> ans;\n        for (auto it = m.begin(); it != m.end(); it++) {\n            ans.push_back(it->second);\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","哈希表","字符串","排序"],"level":"Medium"}},{"problemName":"LCR034.验证外星语词典.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR034.验证外星语词典.json","problemData":{"id":"1000276","name":"LCR034.验证外星语词典","url":"https://leetcode.cn/problems/lwyVBB","desc":"给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。","solutions":[{"date":"2021-12-23","time":4,"memory":9,"script":"cpp","desc":"转换成地球文进行比较。","code":"class Solution {\n   public:\n    bool isAlienSorted(vector<string> &words, string order) {\n        int nums[30] = {0};\n        for (int i = 0; i < order.size(); i++) nums[order[i] - 'a'] = i;\n        for (auto &str : words) {\n            for (auto &ch : str) {\n                ch = nums[ch - 'a'] + 'a';\n            }\n        }\n        for (int i = 1; i < words.size(); i++) {\n            if (words[i] < words[i - 1]) return 0;\n        }\n        return 1;\n    }\n};"}],"tagList":["数组","哈希表","字符串"],"level":"Easy"}},{"problemName":"LCR035.最小时间差.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR035.最小时间差.json","problemData":{"id":"1000278","name":"LCR035.最小时间差","url":"https://leetcode.cn/problems/569nqc","desc":"给定一个 24 小时制（小时:分钟 \"HH:MM\"）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。","solutions":[{"date":"2021-12-23","time":16,"memory":13.6,"script":"cpp","desc":"排序后遍历,多塞一倍时间进去。","code":"class Solution {\n   public:\n    int toMin(string s) {\n        int hor = (s[0] - '0') * 10 + s[1] - '0';\n        int min = (s[3] - '0') * 10 + s[4] - '0';\n        return hor * 60 + min;\n    }\n    int findMinDifference(vector<string>& timePoints) {\n        vector<int> data;\n        for (int i = 0; i < timePoints.size(); i++) {\n            int min = toMin(timePoints[i]);\n            data.push_back(min);\n            data.push_back(24 * 60 + min);\n        }\n        sort(data.begin(), data.end());\n        int ans = INT_MAX;\n        for (int i = 1; i < data.size(); i++) {\n            ans = min(ans, data[i] - data[i - 1]);\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","数学","字符串","排序"],"level":"Medium"}},{"problemName":"LCR036.逆波兰表达式求值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR036.逆波兰表达式求值.json","problemData":{"id":"1000279","name":"LCR036.逆波兰表达式求值","url":"https://leetcode.cn/problems/8Zf90G","desc":"根据 逆波兰表示法，求该后缀表达式的计算结果。","solutions":[{"date":"2021-12-23","time":12,"memory":11.6,"script":"cpp","desc":"栈存储。","code":"class Solution {\n   public:\n    int s2i(string str) {\n        int ans = 0, f = 1;\n        for (int i = 0; i < str.size(); i++) {\n            if (i == 0 && str[i] == '-') {\n                f = -1;\n                continue;\n            }\n            ans = ans * 10 + str[i] - '0';\n        }\n        return ans * f;\n    }\n    int evalRPN(vector<string>& tokens) {\n        stack<int> s;\n        for (auto& str : tokens) {\n            if (str == \"+\" || str == \"-\" || str == \"*\" || str == \"/\") {\n                int num1 = s.top();\n                s.pop();\n                int num2 = s.top();\n                s.pop();\n                int ans;\n                if (str == \"+\")\n                    ans = num2 + num1;\n                else if (str == \"-\")\n                    ans = num2 - num1;\n                else if (str == \"*\")\n                    ans = num2 * num1;\n                else\n                    ans = num2 / num1;\n                s.push(ans);\n            } else {\n                s.push(s2i(str));\n            }\n        }\n        return s.top();\n    }\n};"}],"tagList":["栈","数组","数学"],"level":"Medium"}},{"problemName":"LCR041.数据流中的移动平均值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR041.数据流中的移动平均值.json","problemData":{"id":"1000292","name":"LCR041.数据流中的移动平均值","url":"https://leetcode.cn/problems/qIsx9U","desc":"给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。","solutions":[{"date":"2022-07-16","time":20,"memory":13.7,"script":"cpp","desc":"queue。","code":"class MovingAverage {\n   public:\n    int size, sum = 0;\n    queue<int> q;\n    MovingAverage(int size) { this->size = size; }\n    double next(int val) {\n        if (q.size() >= size) {\n            sum -= q.front();\n            q.pop();\n        }\n        q.push(val);\n        sum += val;\n        return sum * 1.0 / q.size();\n    }\n};"}],"tagList":["设计","队列","数组","数据流"],"level":"Easy"}},{"problemName":"LCR053.二叉搜索树中的中序后继.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR053.二叉搜索树中的中序后继.json","problemData":{"id":"1000313","name":"LCR053.二叉搜索树中的中序后继","url":"https://leetcode.cn/problems/P5rCT8","desc":"给定一棵二叉搜索树和其中的一个节点 p ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 null 。","solutions":[{"date":"2021-08-14","time":96,"memory":48.1,"script":"typescript","desc":"中序遍历。","code":"function inorderSuccessor(root: TreeNode | null, p: TreeNode | null): TreeNode | null {\n  if (p === null || root === null) return null;\n  let prev: TreeNode | null = null;\n  let ans: TreeNode | null = null;\n  inorder(root);\n  return ans;\n  function inorder(node: TreeNode | null): boolean {\n    if (node === null) return false;\n    if (inorder(node.left)) return true;\n    if (prev === p) {\n      ans = node;\n      return true;\n    }\n    prev = node;\n    if (inorder(node.right)) return true;\n    return false;\n  }\n}"}],"tagList":["树","深度优先搜索","二叉搜索树","二叉树"],"level":"Medium"}},{"problemName":"LCR067.数组中两个数的最大异或值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR067.数组中两个数的最大异或值.json","problemData":{"id":"1000331","name":"LCR067.数组中两个数的最大异或值","url":"https://leetcode.cn/problems/ms70jA","desc":"给定一个整数数组 nums ，返回 nums[i] XOR nums[j] 的最大运算结果，其中 0 ≤ i ≤ j < n 。","solutions":[{"date":"2021-10-25","time":784,"memory":67.3,"script":"typescript","desc":"二叉字典树。","code":"const MAX = 31;\nclass BitTrieNode {\n  // 0\n  left: BitTrieNode | null = null;\n  // 1\n  right: BitTrieNode | null = null;\n  val = -1;\n}\nclass BitTrie {\n  root = new BitTrieNode();\n  add(num: number) {\n    const str = num.toString(2).padStart(MAX, '0');\n    let node = this.root;\n    for (let i = 0, l = str.length; i < l; i++) {\n      const ch = str[i];\n      if (ch === '0') node = node.left ?? (node.left = new BitTrieNode());\n      else node = node.right ?? (node.right = new BitTrieNode());\n    }\n    node.val = num;\n  }\n  find(num: number) {\n    const str = num.toString(2).padStart(MAX, '0');\n    let node = this.root;\n    for (let i = 0, l = str.length; i < l; i++) {\n      if (!node.left && !node.right) break;\n      const ch = str[i];\n      if (ch === '0') {\n        node = node.right ?? node.left!;\n      } else {\n        node = node.left ?? node.right!;\n      }\n    }\n    return node;\n  }\n}\nfunction findMaximumXOR(nums: number[]): number {\n  const trie = new BitTrie();\n  nums.forEach(num => trie.add(num));\n  trie.find(5).val;\n  let ans = -Infinity;\n  nums.forEach(num => {\n    ans = Math.max(ans, trie.find(num).val ^ num);\n  });\n  return ans;\n}"}],"tagList":["位运算","字典树","数组","哈希表"],"level":"Medium"}},{"problemName":"LCR069.山脉数组的峰顶索引.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR069.山脉数组的峰顶索引.json","problemData":{"id":"1000333","name":"LCR069.山脉数组的峰顶索引","url":"https://leetcode.cn/problems/B1IidL","desc":"给定由整数组成的山峰数组 arr ，返回任何满足 arr[0] < arr[1] < ... arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1] 的下标 i ，即山峰顶部。","solutions":[{"date":"2021-10-14","time":76,"memory":40.2,"script":"typescript","desc":"遍历。","code":"function peakIndexInMountainArray(arr: number[]): number {\n  let ans = 0;\n  for (let i = 0, l = arr.length; i < l; i++) ans = arr[i] > arr[ans] ? i : ans;\n  return ans;\n}"},{"date":"2021-10-14","time":68,"memory":40.1,"script":"typescript","desc":"二分。","code":"function peakIndexInMountainArray(arr: number[]): number {\n  return find(0, arr.length - 1);\n  function find(l: number, r: number): number {\n    if (l >= r) return l;\n    const lnum = arr[l];\n    const rnum = arr[r];\n    const mid = (l + r) >> 1;\n    const midnum = arr[mid];\n    if (midnum > lnum && midnum > rnum) {\n      const i1 = find(l, mid);\n      const i2 = find(mid, r);\n      return arr[i1] > arr[i2] ? i1 : i2;\n    } else if (midnum <= rnum) {\n      return find(mid + 1, r);\n    } else {\n      return find(l, mid - 1);\n    }\n  }\n}"}],"tagList":["数组","二分查找"],"level":"Easy"}},{"problemName":"LCR074.合并区间.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR074.合并区间.json","problemData":{"id":"1000338","name":"LCR074.合并区间","url":"https://leetcode.cn/problems/SsGoHC","desc":"以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。","solutions":[{"date":"2021-12-23","time":20,"memory":13.8,"script":"cpp","desc":"排序后合并。","code":"class Solution {\n   public:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end());\n        vector<vector<int>> ans;\n        for (auto& interval : intervals) {\n            if (ans.size() > 0 && ans[ans.size() - 1][1] >= interval[0]) {\n                ans[ans.size() - 1][1] =\n                    max(interval[1], ans[ans.size() - 1][1]);\n            } else {\n                ans.push_back(interval);\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","排序"],"level":"Medium"}},{"problemName":"LCR091.粉刷房子.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR091.粉刷房子.json","problemData":{"id":"1000268","name":"LCR091.粉刷房子","url":"https://leetcode.cn/problems/JEj789","desc":"请计算出粉刷完所有房子最少的花费成本。","solutions":[{"date":"2021-09-03","time":108,"memory":40.5,"script":"typescript","desc":"动态规划。","code":"function minCost(costs: number[][]): number {\n  const n = costs.length;\n  const dp: number[][] = new Array(2).fill(0).map(_ => new Array(3).fill(Infinity));\n  for (let i = 0; i < 3; i++) dp[0][i] = costs[0][i];\n  for (let i = 1; i < n; i++) {\n    const idx = i % 2;\n    const prevIdx = idx ^ 1;\n    dp[idx][0] = Math.min(dp[prevIdx][1], dp[prevIdx][2]) + costs[i][0];\n    dp[idx][1] = Math.min(dp[prevIdx][0], dp[prevIdx][2]) + costs[i][1];\n    dp[idx][2] = Math.min(dp[prevIdx][1], dp[prevIdx][0]) + costs[i][2];\n  }\n  return Math.min(...dp[(n - 1) % 2]);\n}"},{"date":"2022-06-25","time":8,"memory":9.6,"script":"cpp","desc":"dp。","code":"class Solution {\n   public:\n    int minCost(vector<vector<int>>& costs) {\n        int n = costs.size(), ans = INT_MAX;\n        vector<vector<int>> dp(3, vector<int>(n, 0));\n        for (int i = 0; i < 3; i++) dp[i][0] = costs[0][i];\n        for (int j = 1; j < n; j++) {\n            dp[0][j] = min(dp[1][j - 1], dp[2][j - 1]) + costs[j][0];\n            dp[1][j] = min(dp[0][j - 1], dp[2][j - 1]) + costs[j][1];\n            dp[2][j] = min(dp[0][j - 1], dp[1][j - 1]) + costs[j][2];\n        }\n        for (int i = 0; i < 3; i++) ans = min(ans, dp[i][n - 1]);\n        return ans;\n    }\n};"}],"tagList":["数组","动态规划"],"level":"Medium"}},{"problemName":"LCR114.火星词典.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR114.火星词典.json","problemData":{"id":"1000312","name":"LCR114.火星词典","url":"https://leetcode.cn/problems/Jf1JuT","desc":"请你根据该词典还原出此语言中已知的字母顺序，并 按字母递增顺序 排列。若不存在合法字母顺序，返回 \"\" 。若存在多种可能的合法字母顺序，返回其中 任意一种 顺序即可。","solutions":[{"date":"2022-05-31","time":84,"memory":45.8,"script":"typescript","desc":"拓扑排序+bfs。","code":"class MyNode {\n  next = new Set<MyNode>();\n  parent = new Set<MyNode>();\n  constructor(public val: string) {}\n}\nfunction alienOrder(words: string[]): string {\n  const map = new Map<string, MyNode>();\n  const n = words.length;\n  let error = false;\n  for (let i = 0; i < n; i++) {\n    for (const ch of words[i]) {\n      if (!map.has(ch)) map.set(ch, new MyNode(ch));\n    }\n    if (i >= 1) comp(i - 1, i);\n    if (error) return '';\n  }\n  const q: MyNode[] = [];\n  for (const node of map.values()) {\n    if (node.parent.size === 0) q.push(node);\n  }\n  const set = new Set<MyNode>();\n  let ans = '';\n  while (q.length) {\n    const node = q.shift()!;\n    if (set.has(node)) continue;\n    set.add(node);\n    ans += node.val;\n    for (const child of node.next) {\n      child.parent.delete(node);\n      if (child.parent.size === 0) {\n        q.push(child);\n      }\n    }\n  }\n  if (ans.length !== map.size) return '';\n  return ans;\n  function comp(idx1: number, idx2: number) {\n    const word1 = words[idx1];\n    const word2 = words[idx2];\n    const n = Math.min(word1.length, word2.length);\n    for (let i = 0; i < n; i++) {\n      if (word1[i] !== word2[i]) {\n        const n1 = map.get(word1[i])!;\n        const n2 = map.get(word2[i])!;\n        n1.next.add(n2);\n        n2.parent.add(n1);\n        return;\n      }\n    }\n    if (word1.length > word2.length) error = true;\n  }\n}"}],"tagList":["深度优先搜索","广度优先搜索","图","拓扑排序","数组","字符串"],"level":"Hard"}},{"problemName":"LCR115.序列重建.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR115.序列重建.json","problemData":{"id":"1000314","name":"LCR115.序列重建","url":"https://leetcode.cn/problems/ur2n8P","desc":"检查 nums 是否是唯一的最短 超序列 。","solutions":[{"date":"2022-07-23","time":188,"memory":107.3,"script":"cpp","desc":"判断是否只有唯一的拓扑排序。","code":"class Solution {\n   public:\n    struct node {\n        unordered_set<int> children, parent;\n    };\n    bool sequenceReconstruction(vector<int>& nums,\n                                vector<vector<int>>& sequences) {\n        int n = nums.size();\n        vector<node> m(n + 1, node());\n        for (auto& item : sequences) {\n            for (int i = 0; i < item.size() - 1; i++) {\n                int parent = item[i], child = item[i + 1];\n                m[parent].children.insert(child);\n                m[child].parent.insert(parent);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            int num = nums[i];\n            if (m[num].parent.size()) return false;\n            int nextcnt = 0;\n            for (auto& child : m[num].children) {\n                m[child].parent.erase(num);\n                if (m[child].parent.size() == 0) nextcnt++;\n            }\n            if (i < n - 1 && nextcnt != 1) return false;\n        }\n        return true;\n    }\n};"}],"tagList":["图","拓扑排序","数组"],"level":"Medium"}},{"problemName":"LCR120.寻找文件副本.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR120.寻找文件副本.json","problemData":{"id":"100275","name":"LCR120.寻找文件副本","url":"https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof","desc":"找出数组中重复的数字。","solutions":[{"date":"2021-12-23","time":40,"memory":22.4,"script":"cpp","desc":"排序后遍历。","code":"class Solution {\n   public:\n    int findRepeatNumber(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        for (int i = 1; i < nums.size(); i++) {\n            if (nums[i] == nums[i - 1]) return nums[i];\n        }\n        return 0;\n    }\n};"}],"tagList":["数组","哈希表","排序"],"level":"Easy"}},{"problemName":"LCR125.图书整理II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR125.图书整理II.json","problemData":{"id":"100273","name":"LCR125.图书整理II","url":"https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof","desc":"用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。","solutions":[{"date":"2020-06-30","time":464,"memory":47.9,"script":"typescript","desc":"入队则直接入栈，出队时判断 out 栈是否为空，为空的话把 in 栈出栈到 out 栈。","code":"class CQueue {\n  inStack: number[] = [];\n  outStack: number[] = [];\n  appendTail(value: number): void {\n    this.inStack.push(value);\n  }\n  deleteHead(): number {\n    if (this.outStack.length === 0) {\n      if (this.inStack.length === 0) return -1;\n      while (this.inStack.length !== 0) this.outStack.push(this.inStack.pop()!);\n    }\n    return this.outStack.pop()!;\n  }\n}"}],"tagList":["栈","设计","队列"],"level":"Easy"}},{"problemName":"LCR126.斐波那契数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR126.斐波那契数.json","problemData":{"id":"100274","name":"LCR126.斐波那契数","url":"https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof","desc":"写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。","solutions":[{"date":"2021-09-04","time":68,"memory":39.2,"script":"typescript","desc":"动态规划。","code":"function fib(n: number): number {\n  const MOD = 1e9 + 7;\n  let [num0, num1] = [0, 1];\n  if (n === 0) return num0;\n  while (--n) [num0, num1] = [num1, (num1 + num0) % MOD];\n  return num1;\n}"}],"tagList":["记忆化搜索","数学","动态规划"],"level":"Easy"}},{"problemName":"LCR128.库存管理I.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR128.库存管理I.json","problemData":{"id":"100278","name":"LCR128.库存管理I","url":"https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof","desc":"把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组  [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为 1。","solutions":[{"date":"2020-07-22","time":76,"memory":37.9,"script":"typescript","desc":"二分查找。","code":"function minArray(numbers: number[]): number {\n  let last = numbers.length - 1;\n  const firstNum = numbers[0];\n  while (firstNum === numbers[last] && last !== 0) {\n    numbers.pop();\n    last--;\n  }\n  if (firstNum < numbers[last]) return firstNum;\n  else if (last === 0) return firstNum;\n  else return _find(0, last);\n  function _find(l: number, r: number): number {\n    // console.log(`[find],l=${l},r=${r}`);\n    if (l === r) return numbers[l];\n    const mid = (l + r) >> 1;\n    const num = numbers[mid];\n    return num >= firstNum ? _find(mid + 1, r) : _find(l, mid);\n  }\n}"}],"tagList":["数组","二分查找"],"level":"Easy"}},{"problemName":"LCR130.衣橱整理.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR130.衣橱整理.json","problemData":{"id":"100281","name":"LCR130.衣橱整理","url":"https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof","desc":"地上有一个 m 行 n 列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于 k 的格子。例如，当 k 为 18 时，机器人能够进入方格 [35, 37] ，因为 3+5+3+7=18。但它不能进入方格 [35, 38]，因为 3+5+3+8=19。请问该机器人能够到达多少个格子？","solutions":[{"date":"2020-04-08","time":92,"memory":37.6,"script":"javascript","desc":"广度优先搜索，从 0，0 开始依次向左下搜索。","code":"/**\n * @param {number} m\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nvar movingCount = function (m, n, k) {\n  const comp = num => (num < 10 ? num : (num % 10) + Math.floor(num / 10));\n  const nowComp = (num1, num2) => comp(num1) + comp(num2);\n  let result = 0;\n  const find = [[0, 0]],\n    finded = {};\n  while (find.length !== 0) {\n    const [row, col] = find.shift();\n    if (finded[`${row}:${col}`]) continue;\n    if (col >= n || row >= m) continue;\n    result++;\n    finded[`${row}:${col}`] = true;\n    if (nowComp(row, col + 1) <= k) find.push([row, col + 1]);\n    if (nowComp(row + 1, col) <= k) find.push([row + 1, col]);\n  }\n  return result;\n};"}],"tagList":["深度优先搜索","广度优先搜索","动态规划"],"level":"Medium"}},{"problemName":"LCR133.位1的个数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR133.位1的个数.json","problemData":{"id":"100292","name":"LCR133.位1的个数","url":"https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof","desc":"请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9  表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。","solutions":[{"date":"2021-06-23","time":96,"memory":39.1,"script":"typescript","desc":"二进制判断。","code":"var hammingWeight = function (n) {\n  let ans = 0;\n  for (let i = 0; i <= 31; i++) {\n    if ((n >> i) & 1) ans++;\n  }\n  return ans;\n};"}],"tagList":["位运算"],"level":"Easy"}},{"problemName":"LCR139.训练计划I.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR139.训练计划I.json","problemData":{"id":"100291","name":"LCR139.训练计划I","url":"https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof","desc":"输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。","solutions":[{"date":"2021-05-07","time":132,"memory":47.1,"script":"typescript","desc":"利用内部排序。","code":"function exchange(nums: number[]): number[] {\n  return [...nums.filter(v => v & 1), ...nums.filter(v => !(v & 1))];\n}"}],"tagList":["数组","双指针","排序"],"level":"Easy"}},{"problemName":"LCR140.训练计划II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR140.训练计划II.json","problemData":{"id":"100294","name":"LCR140.训练计划II","url":"https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof","desc":"输入一个链表，输出该链表中倒数第 k 个节点。为了符合大多数人的习惯，本题从 1 开始计数，即链表的尾节点是倒数第 1 个节点。","solutions":[{"date":"2021-09-02","time":72,"memory":39.5,"script":"typescript","desc":"计算总长度相减后 dfs。","code":"function getKthFromEnd(head: ListNode | null, k: number): ListNode | null {\n  let count = 0;\n  let p = head;\n  while (p !== null) {\n    count++;\n    p = p.next;\n  }\n  return dfs(head, count - k);\n  function dfs(node: ListNode | null, count: number): ListNode | null {\n    if (node === null) return null;\n    if (count === 0) return node;\n    return dfs(node.next, count - 1);\n  }\n}"},{"date":"2021-09-02","time":80,"memory":39.4,"script":"typescript","desc":"双指针。","code":"function getKthFromEnd(head: ListNode | null, k: number): ListNode | null {\n  let slow = head;\n  let fast = head;\n  while (fast && k) {\n    fast = fast.next;\n    k--;\n  }\n  while (fast) {\n    fast = fast.next;\n    slow = slow!.next;\n  }\n  return slow;\n}"}],"tagList":["链表","双指针"],"level":"Easy"}},{"problemName":"LCR143.子结构判断.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR143.子结构判断.json","problemData":{"id":"100287","name":"LCR143.子结构判断","url":"https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof","desc":"输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。","solutions":[{"date":"2021-04-03","time":144,"memory":58.2,"script":"typescript","desc":"依次比较所有值。","code":"function isSubStructure(A: TreeNode | null, B: TreeNode | null): boolean {\n  if (!A || !B) return false;\n  if (A.val === B.val) {\n    if (\n      (!B.left && !B.right) ||\n      (!B.left && A.right?.val === B.right?.val && isSubStructure(A.right, B.right)) ||\n      (!B.right && A.left?.val === B.left?.val && isSubStructure(A.left, B.left)) ||\n      (A.right?.val === B.right?.val &&\n        A.left?.val === B.left?.val &&\n        isSubStructure(A.left, B.left) &&\n        isSubStructure(A.right, B.right))\n    )\n      return true;\n    return isSubStructure(A.left, B) || isSubStructure(A.right, B);\n  } else {\n    return isSubStructure(A.left, B) || isSubStructure(A.right, B);\n  }\n}"},{"date":"2021-04-03","time":144,"memory":58.1,"script":"typescript","desc":"利用辅助检测判断是否相等。","code":"const check = (A: TreeNode | null, B: TreeNode | null): boolean => {\n  if (!B) return true;\n  if (!A) return false;\n  return A.val === B.val && check(A.left, B.left) && check(A.right, B.right);\n};\nfunction isSubStructure(A: TreeNode | null, B: TreeNode | null): boolean {\n  if (!A || !B) return false;\n  if (check(A, B)) return true;\n  return isSubStructure(A.left, B) || isSubStructure(A.right, B);\n}"}],"tagList":["树","深度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"LCR146.螺旋遍历二维数组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR146.螺旋遍历二维数组.json","problemData":{"id":"100293","name":"LCR146.螺旋遍历二维数组","url":"https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof","desc":"输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。","solutions":[{"date":"2020-06-05","time":96,"memory":39.6,"script":"typescript","desc":"递归判断每一圈","code":"function spiralOrder(matrix: number[][]): number[] {\n  const row = matrix.length;\n  if (row === 0) return [];\n  else if (row === 1) return matrix[0];\n  const ans: number[] = [];\n  const col = matrix[0].length;\n  spiral(0, row - 1, 0, col - 1);\n  return ans;\n  function spiral(startI: number, endI: number, startJ: number, endJ: number): void {\n    if (endI < startI || endJ < startJ) return;\n    for (let i = startJ; i <= endJ; i++) ans.push(matrix[startI][i]);\n    for (let i = startI + 1; i <= endI; i++) ans.push(matrix[i][endJ]);\n    for (let i = endJ - 1; startI !== endI && i >= startJ; i--) ans.push(matrix[endI][i]);\n    for (let i = endI - 1; startJ !== endJ && i >= startI + 1; i--) ans.push(matrix[i][startJ]);\n    if (startI !== endI && startJ !== endJ) spiral(startI + 1, endI - 1, startJ + 1, endJ - 1);\n  }\n}"}],"tagList":["数组","矩阵","模拟"],"level":"Easy"}},{"problemName":"LCR152.验证二叉搜索树的后序遍历序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR152.验证二叉搜索树的后序遍历序列.json","problemData":{"id":"100315","name":"LCR152.验证二叉搜索树的后序遍历序列","url":"https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof","desc":"输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。","solutions":[{"date":"2021-08-07","time":72,"memory":39.9,"script":"typescript","desc":"验证左边是否都小于中值，右边是否都大于中值。","code":"function verifyPostorder(postorder: number[]): boolean {\n  const n = postorder.length;\n  if (n === 0) return true;\n  const mid = postorder[n - 1];\n  let i = 0;\n  for (; i < n - 1; i++) if (postorder[i] > mid) break;\n  for (let j = i; j < n - 1; j++) if (postorder[j] < mid) return false;\n  return verifyPostorder(postorder.slice(0, i)) && verifyPostorder(postorder.slice(i, n - 1));\n}"}],"tagList":["栈","树","二叉搜索树","递归","数组","二叉树","单调栈"],"level":"Medium"}},{"problemName":"LCR155.将二叉搜索树转化为排序的双向链表.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR155.将二叉搜索树转化为排序的双向链表.json","problemData":{"id":"100305","name":"LCR155.将二叉搜索树转化为排序的双向链表","url":"https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof","desc":"输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。","solutions":[{"date":"2021-07-29","time":84,"memory":39.3,"script":"javascript","desc":"中序遍历。","code":"var treeToDoublyList = function (root) {\n  if (root === null) return null;\n  let head, pre;\n  inorder(root);\n  head.left = pre;\n  pre.right = head;\n  return head;\n  function inorder(node) {\n    if (!node) return;\n    inorder(node.left);\n    if (!pre) {\n      head = node;\n    } else {\n      pre.right = node;\n    }\n    node.left = pre;\n    pre = node;\n    inorder(node.right);\n  }\n};"}],"tagList":["栈","树","深度优先搜索","二叉搜索树","链表","二叉树","双向链表"],"level":"Medium"}},{"problemName":"LCR156.序列化与反序列化二叉树.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR156.序列化与反序列化二叉树.json","problemData":{"id":"100307","name":"LCR156.序列化与反序列化二叉树","url":"https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof","desc":"请实现两个函数，分别用来序列化和反序列化二叉树。","solutions":[{"date":"2021-06-30","time":152,"memory":48.1,"script":"typescript","desc":"利用 JSON 化。","code":"/**\n * Encodes a tree to a single string.\n *\n * @param {TreeNode} root\n * @return {string}\n */\nvar serialize = function (root) {\n  return JSON.stringify(root);\n};\n/**\n * Decodes your encoded data to tree.\n *\n * @param {string} data\n * @return {TreeNode}\n */\nvar deserialize = function (data) {\n  return JSON.parse(data);\n};"}],"tagList":["树","深度优先搜索","广度优先搜索","设计","字符串","二叉树"],"level":"Hard"}},{"problemName":"LCR157.套餐内商品的排列顺序.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR157.套餐内商品的排列顺序.json","problemData":{"id":"100308","name":"LCR157.套餐内商品的排列顺序","url":"https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof","desc":"输入一个字符串，打印出该字符串中字符的所有排列。","solutions":[{"date":"2021-06-22","time":140,"memory":47.5,"script":"typescript","desc":"全排列。","code":"function permutation(s: string): string[] {\n  const list = new Set<string>();\n  const dfs = (curStr: string = '', waitStr: string = s) => {\n    if (waitStr.length === 1) {\n      list.add(curStr + waitStr);\n      return;\n    }\n    for (let i = 0, l = waitStr.length; i < l; i++) {\n      const newCurStr = curStr + waitStr[i];\n      const newWaitStr = waitStr.substring(0, i) + waitStr.substring(i + 1);\n      dfs(newCurStr, newWaitStr);\n    }\n  };\n  dfs();\n  return [...list];\n}"}],"tagList":["字符串","回溯"],"level":"Medium"}},{"problemName":"LCR159.库存管理III.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR159.库存管理III.json","problemData":{"id":"100301","name":"LCR159.库存管理III","url":"https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof","desc":"输入整数数组 arr ，找出其中最小的 k 个数。","solutions":[{"date":"2021-04-09","time":228,"memory":45.5,"script":"typescript","desc":"构建堆。","code":"class Heap {\n  private arr: number[] = [];\n  get isEmpty() {\n    return this.size === 0;\n  }\n  get size() {\n    return this.arr.length;\n  }\n  constructor(private compare: (num1: number, num2: number) => number) {}\n  add(num: number): void {\n    this.arr.push(num);\n    this.shiftUp(this.size - 1);\n  }\n  remove(): number {\n    const num = this.arr.shift();\n    this.arr.unshift(this.arr.pop()!);\n    this.shiftDown(0);\n    return num;\n  }\n  private shiftUp(index: number): void {\n    const parentIndex = (index - 1) >> 1;\n    if (this.compare(this.arr[index], this.arr[parentIndex]) > 0) {\n      [this.arr[index], this.arr[parentIndex]] = [this.arr[parentIndex], this.arr[index]];\n      this.shiftUp(parentIndex);\n    }\n  }\n  private shiftDown(index: number): void {\n    let childrenIndex = index * 2 + 1;\n    if (this.compare(this.arr[childrenIndex + 1], this.arr[childrenIndex]) > 0) {\n      childrenIndex++;\n    }\n    if (this.compare(this.arr[childrenIndex], this.arr[index]) > 0) {\n      [this.arr[childrenIndex], this.arr[index]] = [this.arr[index], this.arr[childrenIndex]];\n      this.shiftDown(childrenIndex);\n    }\n  }\n}\n\nfunction getLeastNumbers(arr: number[], k: number): number[] {\n  const ans: number[] = [];\n  const heap = new Heap((num1, num2) => num2 - num1);\n  arr.forEach(v => heap.add(v));\n  while (k--) ans.push(heap.remove());\n  return ans;\n}"}],"tagList":["数组","分治","快速选择","排序","堆（优先队列）"],"level":"Easy"}},{"problemName":"LCR161.连续天数的最高销售额.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR161.连续天数的最高销售额.json","problemData":{"id":"100304","name":"LCR161.连续天数的最高销售额","url":"https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof","desc":"输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。","solutions":[{"date":"2021-07-17","time":4620,"memory":46.1,"script":"typescript","desc":"前缀和。","code":"function maxSubArray(nums: number[]): number {\n  let num = 0;\n  const len = nums.length;\n  const sums = [0, ...nums.map(v => (num += v))];\n  let ans = -Infinity;\n  for (let i = 0; i < len; i++) {\n    ans = Math.max(ans, nums[i]);\n    const sum = sums[i + 1];\n    for (let j = 0; j < i; j++) {\n      const num = sum - sums[j];\n      ans = Math.max(ans, num);\n    }\n  }\n  return ans;\n}"},{"date":"2021-07-17","time":88,"memory":47.6,"script":"typescript","desc":"前缀和。","code":"function maxSubArray(nums: number[]): number {\n  let num = 0;\n  const len = nums.length;\n  const sums = [0, ...nums.map(v => (num += v))];\n  let min = 0;\n  let ans = -Infinity;\n  for (let i = 0; i < len; i++) {\n    const sum = sums[i + 1];\n    ans = Math.max(ans, sum - min, nums[i]);\n    min = Math.min(min, sum);\n  }\n  return ans;\n}"},{"date":"2021-07-22","time":72,"memory":39.6,"script":"typescript","desc":"取最大值。","code":"function maxSubArray(nums: number[]): number {\n  let ans = -Infinity;\n  let max = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (max > 0) max += nums[i];\n    else max = nums[i];\n    ans = Math.max(ans, max);\n  }\n  return ans;\n}"},{"date":"2021-07-22","time":72,"memory":39.9,"script":"typescript","desc":"单调递增队列。","code":"function maxSubArray(nums: number[]): number {\n  if (nums.length === 1) return nums[0];\n  const sums = [0];\n  nums.forEach((num, i) => sums.push(sums[i] + num));\n  const queue: number[] = [0];\n  let ans = -Infinity;\n  for (let i = 1; i <= nums.length; i++) {\n    const num = sums[i];\n    ans = Math.max(ans, num - queue[0]);\n    while (queue.length && queue[queue.length - 1] > num) queue.pop();\n    queue.push(num);\n  }\n  return ans;\n}"}],"tagList":["数组","分治","动态规划"],"level":"Easy"}},{"problemName":"LCR165.解密数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR165.解密数字.json","problemData":{"id":"100325","name":"LCR165.解密数字","url":"https://leetcode.cn/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof","desc":"给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。","solutions":[{"date":"2020-06-09","time":60,"memory":32.4,"script":"typescript","desc":"递归判断当前值是否<=25 不是则分段计算。","code":"function translateNum(num: number): number {\n  if (num < 10) return 1;\n  else if (num <= 25) {\n    return 2;\n  } else if (num < 100) {\n    return 1;\n  } else {\n    const s = num.toString();\n    const subNum2 = Number(s.substr(0, 2));\n    let num2 = 0;\n    if (subNum2 <= 25) num2 = translateNum(Number(s.substr(2)));\n    return translateNum(Number(s.substr(1))) + num2;\n  }\n}"}],"tagList":["字符串","动态规划"],"level":"Medium"}},{"problemName":"LCR166.珠宝的最高价值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR166.珠宝的最高价值.json","problemData":{"id":"100327","name":"LCR166.珠宝的最高价值","url":"https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof","desc":"给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？。","solutions":[{"script":"cpp","time":8,"memory":9,"desc":"dp[i][j]表示i行j列时最多能拿多少礼物。","code":"class Solution {\npublic:\n    int maxValue(vector<vector<int>>& grid) {\n        int n = grid.size(), m = grid[0].size(), dp[205][205] = {0};\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                dp[i][j] = grid[i][j];\n                if (i == 0 && j != 0) dp[i][j] += dp[i][j - 1];\n                else if (i != 0 && j == 0) dp[i][j] += dp[i - 1][j];\n                else if (i != 0 && j != 0)dp[i][j] += max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n        return dp[n - 1][m - 1];\n    }\n};","date":"2023-03-08"},{"script":"python","time":64,"memory":17.6,"desc":"同上。","code":"class Solution:\n    def maxValue(self, grid: List[List[int]]) -> int:\n        n, m = len(grid), len(grid[0])\n        dp = [[grid[i][j] for j in range(m)] for i in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if i == 0 and j != 0:\n                    dp[i][j] += dp[i][j - 1]\n                elif i != 0 and j == 0:\n                    dp[i][j] += dp[i - 1][j]\n                elif i != 0 and j != 0:\n                    dp[i][j] += max(dp[i - 1][j], dp[i][j - 1])\n        return dp[n-1][m-1]","date":"2023-03-08"},{"script":"rust","time":4,"memory":2.5,"desc":"同上。","code":"impl Solution {\n        pub fn max_value(grid: Vec<Vec<i32>>) -> i32 {\n            let (n, m) = (grid.len(), grid[0].len());\n            let mut dp = vec![vec![0; m]; n];\n            for i in 0..n {\n                for j in 0..m {\n                    dp[i][j] = grid[i][j];\n                    if i == 0 && j != 0 {\n                        dp[i][j] += dp[i][j - 1];\n                    } else if i != 0 && j == 0 {\n                        dp[i][j] += dp[i - 1][j];\n                    } else if i != 0 && j != 0 {\n                        dp[i][j] += dp[i - 1][j].max(dp[i][j - 1]);\n                    }\n                }\n            }\n            dp[n - 1][m - 1]\n        }\n    }","date":"2023-03-08"}],"tagList":["数组","动态规划","矩阵"],"level":"Medium"}},{"problemName":"LCR169.招式拆解II.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR169.招式拆解II.json","problemData":{"id":"100316","name":"LCR169.招式拆解II","url":"https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof","desc":"在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。","solutions":[{"date":"2021-12-23","time":20,"memory":10.3,"script":"cpp","desc":"存储次数，遍历两遍。","code":"class Solution {\n   public:\n    char firstUniqChar(string s) {\n        int arr[30] = {0};\n        for (auto &ch : s) arr[ch - 'a']++;\n        for (auto &ch : s) {\n            if (arr[ch - 'a'] == 1) return ch;\n        }\n        return ' ';\n    }\n};"}],"tagList":["队列","哈希表","字符串","计数"],"level":"Easy"}},{"problemName":"LCR170.交易逆序对的总数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR170.交易逆序对的总数.json","problemData":{"id":"100318","name":"LCR170.交易逆序对的总数","url":"https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof","desc":"在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。","solutions":[{"date":"2021-05-14","time":160,"memory":50.7,"script":"typescript","desc":"归并排序中途判断每个值的前部分的数量。","code":"function reversePairs(nums: number[]): number {\n  const len = nums.length;\n  if (len === 0) return 0;\n  const mergeSort = (left: number, right: number): number => {\n    if (left === right) return 0;\n    const mid = (left + right) >> 1;\n    let ans = mergeSort(left, mid) + mergeSort(mid + 1, right);\n    const tempList = nums.slice(left, mid + 1);\n    let p1 = 0;\n    const end1 = mid - left;\n    let p2 = mid + 1;\n    let i = left;\n    while (p1 <= end1) {\n      if (p2 > right || tempList[p1] <= nums[p2]) {\n        nums[i++] = tempList[p1++];\n      } else {\n        nums[i++] = nums[p2++];\n        ans += end1 - p1 + 1;\n      }\n    }\n    return ans;\n  };\n  return mergeSort(0, len - 1);\n}"}],"tagList":["树状数组","线段树","数组","二分查找","分治","有序集合","归并排序"],"level":"Hard"}},{"problemName":"LCR171.训练计划V.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR171.训练计划V.json","problemData":{"id":"100326","name":"LCR171.训练计划V","url":"https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof","desc":"输入两个链表，找出它们的第一个公共节点。","solutions":[{"date":"2021-07-21","time":112,"memory":45.5,"script":"typescript","desc":"利用 set 储存每个节点。","code":"var getIntersectionNode = function (headA, headB) {\n  const set = new Set();\n  let p = headA;\n  while (p) {\n    set.add(p);\n    p = p.next;\n  }\n  p = headB;\n  while (p) {\n    if (set.has(p)) return p;\n    p = p.next;\n  }\n  return null;\n};"},{"date":"2021-07-21","time":88,"memory":45.1,"script":"typescript","desc":"双指针。","code":"var getIntersectionNode = function (headA, headB) {\n  let pA = headA;\n  let pB = headB;\n  if (!pA || !pB) return null;\n  while (pA !== pB) {\n    pA = pA === null ? headB : pA.next;\n    pB = pB === null ? headA : pB.next;\n  }\n  return pA;\n};"}],"tagList":["哈希表","链表","双指针"],"level":"Easy"}},{"problemName":"LCR172.统计目标成绩的出现次数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR172.统计目标成绩的出现次数.json","problemData":{"id":"100329","name":"LCR172.统计目标成绩的出现次数","url":"https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof","desc":"统计一个数字在排序数组中出现的次数。","solutions":[{"date":"2021-07-16","time":84,"memory":40.8,"script":"typescript","desc":"哈希储存。","code":"function search(nums: number[], target: number): number {\n  return (\n    nums.reduce<Record<number, number>>((record, cur) => {\n      record[cur] = (record[cur] ?? 0) + 1;\n      return record;\n    }, {})[target] ?? 0\n  );\n}"}],"tagList":["数组","二分查找"],"level":"Easy"}},{"problemName":"LCR174.寻找二叉搜索树中的目标节点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR174.寻找二叉搜索树中的目标节点.json","problemData":{"id":"100333","name":"LCR174.寻找二叉搜索树中的目标节点","url":"https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof","desc":"给定一棵二叉搜索树，请找出其中第 k 大的节点。","solutions":[{"date":"2021-04-03","time":104,"memory":44.5,"script":"typescript","desc":"中序遍历后读取第 k 个值。","code":"function kthLargest(root: TreeNode | null, k: number): number {\n  const arr: number[] = [];\n  const inorder = (node: TreeNode | null): void => {\n    if (!node) return;\n    inorder(node.left);\n    arr.push(node.val);\n    inorder(node.right);\n  };\n  inorder(root);\n  return arr[arr.length - k];\n}"},{"date":"2021-04-03","time":88,"memory":44.8,"script":"typescript","desc":"统计右侧节点数进行计算。","code":"const countNode = (node: TreeNode | null): number =>\n  node ? 1 + countNode(node.left) + countNode(node.right) : 0;\nfunction kthLargest(root: TreeNode | null, k: number): number {\n  if (!root) return 0;\n  const rightCount = countNode(root.right) + 1;\n  return rightCount > k\n    ? kthLargest(root.right, k)\n    : rightCount < k\n    ? kthLargest(root.left, k - rightCount)\n    : root.val;\n}"}],"tagList":["树","深度优先搜索","二叉搜索树","二叉树"],"level":"Easy"}},{"problemName":"LCR178.训练计划VI.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR178.训练计划VI.json","problemData":{"id":"100321","name":"LCR178.训练计划VI","url":"https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof","desc":"在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。","solutions":[{"date":"2021-12-24","time":40,"memory":15.8,"script":"cpp","desc":"用数组存储每个位有几个 1。","code":"class Solution {\n   public:\n    int singleNumber(vector<int>& nums) {\n        int list[40] = {0};\n        for (auto& num : nums) {\n            for (int i = 0; i < 32; i++) {\n                if (num & (1 << i)) list[i]++;\n            }\n        }\n        int ans = 0;\n        for (int i = 0; i < 32; i++) {\n            if (list[i] % 3) {\n                ans |= 1 << i;\n            }\n        }\n        return ans;\n    }\n};"}],"tagList":["位运算","数组"],"level":"Medium"}},{"problemName":"LCR184.设计自助结算系统.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR184.设计自助结算系统.json","problemData":{"id":"100337","name":"LCR184.设计自助结算系统","url":"https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof","desc":"请定义一个队列并实现函数 max_value 得到队列里的最大值。","solutions":[{"date":"2021-07-20","time":200,"memory":48.3,"script":"typescript","desc":"单调递减队列。","code":"class MaxQueue {\n  private queue: number[] = [];\n  private monoQueue: number[] = [];\n  max_value(): number {\n    if (this.queue.length === 0) return -1;\n    return this.queue[this.monoQueue[0]];\n  }\n  push_back(value: number): void {\n    this.queue.push(value);\n    while (this.monoQueue.length && this.queue[this.monoQueue[this.monoQueue.length - 1]] < value)\n      this.monoQueue.pop();\n    this.monoQueue.push(this.queue.length - 1);\n  }\n  pop_front(): number {\n    if (this.queue.length === 0) return -1;\n    const v = this.queue.shift()!;\n    for (let i = 0, n = this.monoQueue.length; i < n; i++) this.monoQueue[i]--;\n    if (this.monoQueue[0] === -1) this.monoQueue.shift();\n    return v;\n  }\n}"}],"tagList":["设计","队列","单调队列"],"level":"Medium"}},{"problemName":"LCR186.文物朝代判断.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR186.文物朝代判断.json","problemData":{"id":"100341","name":"LCR186.文物朝代判断","url":"https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof","desc":"从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这 5 张牌是不是连续的。2 ～ 10 为数字本身，A 为 1，J 为 11，Q 为 12，K 为 13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。","solutions":[{"date":"2021-12-23","time":0,"memory":9.9,"script":"cpp","desc":"排序后遍历。","code":"class Solution {\n   public:\n    bool isStraight(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int cnt0 = 0;\n        for (int i = 0; i < nums.size() - 1; i++) {\n            int num = nums[i];\n            if (num == 0)\n                cnt0++;\n            else if (nums[i + 1] == num)\n                return 0;\n            else if (nums[i + 1] != num + 1) {\n                if (nums[i + 1] - num - 1 > cnt0) return 0;\n                cnt0 -= nums[i + 1] - num;\n            }\n        }\n        return 1;\n    }\n};"}],"tagList":["数组","排序"],"level":"Easy"}},{"problemName":"LCR189.设计机械累加器.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/LCR/LCR189.设计机械累加器.json","problemData":{"id":"100345","name":"LCR189.设计机械累加器","url":"https://leetcode.cn/problems/qiu-12n-lcof","desc":"求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。","solutions":[{"date":"2020-06-02","time":56,"memory":32.2,"script":"typescript","desc":"利用等差数列直接求和。","code":"var sumNums = function (n: number): number {\n  return ((1 + n) * n) / 2;\n};"},{"date":"2020-06-02","time":80,"memory":34.7,"script":"typescript","desc":"递归求和。","code":"var sumNums = function (n: number): number {\n  n && (n += sumNums(n - 1));\n  return n;\n};"},{"date":"2020-06-02","time":64,"memory":34.9,"script":"typescript","desc":"递归求和。","code":"var sumNums = function (n: number): number {\n  const c = (num: number, count: number): number => (count === 1 ? num : num + c(num, count - 1));\n  return c(n, n + 1) >> 1;\n};"}],"tagList":["位运算","递归","脑筋急转弯"],"level":"Medium"}}]},{"dirName":"面试题","dirPath":"C:\\bestlyg\\projects\\bestlyg\\packages\\leetcode\\data\\面试题","problems":[{"problemName":"面试题01.02.判定是否互为字符重排.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题01.02.判定是否互为字符重排.json","problemData":{"id":"100159","name":"面试题01.02.判定是否互为字符重排","url":"https://leetcode.cn/problems/check-permutation-lcci","desc":"给定两个字符串 s1 和 s2，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。","solutions":[{"date":"2022-09-27","time":0,"memory":6.1,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    bool CheckPermutation(string s1, string s2) {\n        if (s1.size() != s2.size()) return false;\n        char list[130] = {0};\n        for (auto &c : s1) list[c]++;\n        for (auto &c : s2) if (list[c]-- == 0) return false;\n        return true;\n    }\n};"}],"tagList":["哈希表","字符串","排序"],"level":"Easy"}},{"problemName":"面试题01.05.一次编辑.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题01.05.一次编辑.json","problemData":{"id":"1000006","name":"面试题01.05.一次编辑","url":"https://leetcode.cn/problems/one-away-lcci","desc":"字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。","solutions":[{"date":"2021-10-16","time":92,"memory":39.9,"script":"typescript","desc":"遍历。","code":"function oneEditAway(first: string, second: string): boolean {\n  if (first === second) return true;\n  if (first.length < second.length) [first, second] = [second, first];\n  const l1 = first.length;\n  const l2 = second.length;\n  const minus = Math.abs(l1 - l2);\n  if (minus > 1) return false;\n  else if (minus === 0) {\n    for (let i = 0, j = 0; i < l1; i++) {\n      if (first[i] !== second[i]) {\n        if (j === 1) return false;\n        j++;\n      }\n    }\n    return true;\n  } else {\n    let idxFirst = -1;\n    let idxLast = -1;\n    for (let i = 0, l = Math.min(l1, l2); i < l; i++) {\n      if (first[i] !== second[i]) {\n        idxFirst = i;\n        break;\n      }\n    }\n    if (idxFirst === -1) return true;\n    for (let i1 = l1 - 1, i2 = l2 - 1; i1 >= 0 && i2 >= 0; i1--, i2--) {\n      if (first[i1] !== second[i2]) {\n        idxLast = i1;\n        break;\n      }\n    }\n    if (idxLast === -1) return true;\n    return idxFirst === idxLast;\n  }\n}"},{"date":"2022-05-13","time":52,"memory":12,"script":"cpp","desc":"遍历。","code":"class Solution {\n   public:\n    bool oneEditAway(string first, string second) {\n        int n1 = first.size(), n2 = second.size();\n        int i1 = 0, i2 = 0, cnt = 0;\n        for (; i1 < n1 && i2 < n2; i1++, i2++) {\n            if (first[i1] == second[i2]) continue;\n            if (cnt == 1) return false;\n            cnt++;\n            if (i1 + 1 < n1 && first[i1 + 1] == second[i2])\n                i1++;\n            else if (i2 + 1 < n2 && first[i1] == second[i2 + 1])\n                i2++;\n        }\n        if (cnt == 0) return abs(n1 - n2) <= 1;\n        return i1 == n1 && i2 == n2 && cnt <= 1;\n    }\n};"}],"tagList":["双指针","字符串"],"level":"Medium"}},{"problemName":"面试题01.07.旋转矩阵.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题01.07.旋转矩阵.json","problemData":{"id":"100185","name":"面试题01.07.旋转矩阵","url":"https://leetcode.cn/problems/rotate-matrix-lcci","desc":"给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。","solutions":[{"date":"2020-04-07","time":100,"memory":33.8,"script":"javascript","desc":"转换成侧边读取。","code":"/**\n * @param {number[][]} matrix\n * @return {void} Do not return anything, modify matrix in-place instead.\n */\nvar rotate = function (matrix) {\n  const result = [];\n  for (let i = 0; i < matrix.length; i++) {\n    const newRow = [];\n    for (let j = matrix.length - 1; j >= 0; j--) {\n      newRow.push(matrix[j][i]);\n    }\n    result.push(newRow);\n  }\n  for (const row in matrix) {\n    matrix[row] = result[row];\n  }\n};"}],"tagList":["数组","数学","矩阵"],"level":"Medium"}},{"problemName":"面试题01.08.零矩阵.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题01.08.零矩阵.json","problemData":{"id":"100186","name":"面试题01.08.零矩阵","url":"https://leetcode.cn/problems/zero-matrix-lcci","desc":"编写一种算法，若 M × N 矩阵中某个元素为 0，则将其所在的行与列清零。","solutions":[{"date":"2022-09-30","time":12,"memory":11.9,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        int n = matrix.size(), m = matrix[0].size();\n        unordered_set<int> rows, cols;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (matrix[i][j] == 0) {\n                    rows.insert(i);\n                    cols.insert(j);\n                }\n            }\n        }\n        for (auto &row : rows) {\n            for (int i = 0; i < m; i++) matrix[row][i] = 0;\n        }\n        for (auto &col : cols) {\n            for (int i = 0; i < n; i++) matrix[i][col] = 0;\n        }\n    }\n};"}],"tagList":["数组","哈希表","矩阵"],"level":"Medium"}},{"problemName":"面试题01.09.字符串轮转.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题01.09.字符串轮转.json","problemData":{"id":"100162","name":"面试题01.09.字符串轮转","url":"https://leetcode.cn/problems/string-rotation-lcci","desc":"字符串轮转。给定两个字符串 s1 和 s2，请编写代码检查 s2 是否为 s1 旋转而成。","solutions":[{"date":"2022-09-29","time":4,"memory":7.5,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    int n;\n    bool isFlipedString(string s1, string s2) {\n        if (s1.size() != s2.size()) return false;\n        n = s1.size();\n        if (n == 0) return true;\n        vector<int> list;\n        char start = s2[0];\n        for (int i = 0; i < n; i++) if (s1[i] == start) list.push_back(i);\n        for (auto &start : list) if (comp(s1, start, s2, 0)) return true;\n        return false;\n    }\n    bool comp(string &s1, int i1, string &s2, int i2) {\n        while (i2 < n) {\n            if (s1[i1] != s2[i2]) return false;\n            i1 = (i1 + 1) % n;\n            i2++;\n        }\n        return true;\n    }\n};"},{"date":"2022-09-29","time":4,"memory":7.7,"script":"cpp","desc":"拼接两个 s1，如果是旋转，s2 一定是子串。","code":"class Solution {\npublic:\n    bool isFlipedString(string s1, string s2) {\n        return s1.size() == s2.size() && (s1 + s1).find(s2) != string::npos;\n    }\n};"}],"tagList":["字符串","字符串匹配"],"level":"Easy"}},{"problemName":"面试题02.01.移除重复节点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题02.01.移除重复节点.json","problemData":{"id":"100163","name":"面试题02.01.移除重复节点","url":"https://leetcode.cn/problems/remove-duplicate-node-lcci","desc":"编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。","solutions":[{"date":"2020-06-27","time":92,"memory":40.6,"script":"typescript","desc":"利用 Set 储存已遍历过的节点值进行是否重复的判断。","code":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     val: number\n *     next: ListNode | null\n *     constructor(val?: number, next?: ListNode | null) {\n *         this.val = (val===undefined ? 0 : val)\n *         this.next = (next===undefined ? null : next)\n *     }\n * }\n */\nfunction removeDuplicateNodes(head: ListNode | null): ListNode | null {\n  if (head === null) return null;\n  const set = new Set([head.val]);\n  let temp = head;\n  while (temp.next !== null) {\n    const val = temp.next.val;\n    if (set.has(val)) {\n      temp.next = temp.next.next;\n    } else {\n      set.add(val);\n      temp = temp.next as ListNode;\n    }\n  }\n  return head;\n}"},{"date":"2020-06-27","time":584,"memory":40.1,"script":"typescript","desc":"用双重循环判断是否重复，利用时间换空间。","code":"function removeDuplicateNodes(head: ListNode | null): ListNode | null {\n  if (head === null) return null;\n  let temp1: ListNode | null = head;\n  while (temp1 !== null) {\n    const val = temp1.val;\n    let temp2: ListNode | null = temp1;\n    while (temp2 !== null && temp2.next !== null) {\n      if (temp2.next.val === val) temp2.next = temp2.next.next;\n      else temp2 = temp2.next;\n    }\n    temp1 = temp1.next;\n  }\n  return head;\n}"}],"tagList":["哈希表","链表","双指针"],"level":"Easy"}},{"problemName":"面试题03.04.化栈为队.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题03.04.化栈为队.json","problemData":{"id":"100170","name":"面试题03.04.化栈为队","url":"https://leetcode.cn/problems/implement-queue-using-stacks-lcci","desc":"实现一个 MyQueue 类，该类用两个栈来实现一个队列。","solutions":[{"date":"2021-03-19","time":88,"memory":39.2,"script":"typescript","desc":"利用两个栈维护。","code":"class MyQueue {\n  private inStack: number[] = [];\n  private outStack: number[] = [];\n  get len() {\n    return this.inStack.length + this.outStack.length;\n  }\n  push(x: number): void {\n    this.inStack.push(x);\n  }\n  pop(): number {\n    this.outStack.length === 0 && this.numberChange();\n    return this.outStack.pop()!;\n  }\n  peek(): number {\n    this.outStack.length === 0 && this.numberChange();\n    return this.outStack[this.outStack.length - 1];\n  }\n  empty(): boolean {\n    return this.len === 0;\n  }\n  private numberChange() {\n    while (this.inStack.length > 0) {\n      this.outStack.push(this.inStack.pop()!);\n    }\n  }\n}"}],"tagList":["栈","设计","队列"],"level":"Easy"}},{"problemName":"面试题04.06.后继者.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题04.06.后继者.json","problemData":{"id":"100178","name":"面试题04.06.后继者","url":"https://leetcode.cn/problems/successor-lcci","desc":"返回能够访问所有节点的最短路径的长度。","solutions":[{"date":"2021-08-06","time":96,"memory":47.5,"script":"javascript","desc":"找右侧最左，或者父节点的左子节点是目标节点的父节点。","code":"var inorderSuccessor = function (root, p) {\n  if (root === null) return null;\n  const parentList = [];\n  return successor(find(root, p));\n  function find(node, target) {\n    if (node === target) return node;\n    parentList.push(node);\n    let ans;\n    if (node.val < target.val) {\n      ans = find(node.right, target, node);\n    } else {\n      ans = find(node.left, target, node);\n    }\n    if (ans) {\n      return ans;\n    } else {\n      parentList.pop();\n      return null;\n    }\n  }\n  function successor(node) {\n    if (node.right === null) {\n      console.log(parentList);\n      if (parentList.length === 0) return null;\n      let cur = node;\n      for (let i = parentList.length - 1; i >= 0; i--) {\n        const parent = parentList[i];\n        if (parent.left === cur) {\n          return parent;\n        } else {\n          cur = parent;\n        }\n      }\n      return null;\n    }\n    let ans = node.right;\n    while (ans.left) ans = ans.left;\n    return ans;\n  }\n};"},{"date":"2021-08-07","time":96,"memory":47.5,"script":"javascript","desc":"中序遍历。","code":"var inorderSuccessor = function (root, p) {\n  let pre;\n  return inorder(root, p);\n  function inorder(node, p) {\n    if (node === null) return null;\n    let ans;\n    ans = inorder(node.left, p);\n    if (ans) return ans;\n    if (pre === p) return node;\n    pre = node;\n    ans = inorder(node.right, p);\n    if (ans) return ans;\n    return null;\n  }\n};"},{"date":"2022-05-16","time":32,"memory":22.4,"script":"cpp","desc":"递归。","code":"class Solution {\n   public:\n    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {\n        if (root == p) {\n            if (p->right == nullptr) return nullptr;\n            TreeNode* next = p->right;\n            while (next->left) next = next->left;\n            return next;\n        }\n        TreeNode* nextRoot = root->val > p->val ? root->left : root->right;\n        TreeNode* next = inorderSuccessor(nextRoot, p);\n        if (next == nullptr && nextRoot == root->left) next = root;\n        return next;\n    }\n};"}],"tagList":["树","深度优先搜索","二叉搜索树","二叉树"],"level":"Medium"}},{"problemName":"面试题04.08.首个共同祖先.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题04.08.首个共同祖先.json","problemData":{"id":"100179","name":"面试题04.08.首个共同祖先","url":"https://leetcode.cn/problems/first-common-ancestor-lcci","desc":"设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。","solutions":[{"date":"2021-05-13","time":104,"memory":46.9,"script":"javascript","desc":"递归。","code":"var lowestCommonAncestor = function (root, p, q) {\n  if (root === null || root === p || root === q) return root;\n  const left = lowestCommonAncestor(root.left, p, q);\n  const right = lowestCommonAncestor(root.right, p, q);\n  return left && right ? root : left ? left : right;\n};"}],"tagList":["树","深度优先搜索","二叉树"],"level":"Medium"}},{"problemName":"面试题04.09.二叉搜索树序列.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题04.09.二叉搜索树序列.json","problemData":{"id":"1000010","name":"面试题04.09.二叉搜索树序列","url":"https://leetcode.cn/problems/bst-sequences-lcci","desc":"从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。给定一个由不同节点组成的二叉搜索树，输出所有可能生成此树的数组。","solutions":[{"date":"2021-08-07","time":120,"memory":46.1,"script":"typescript","desc":"递归生成左右子树，保证左右子树顺序不变。","code":"function BSTSequences(root: TreeNode | null): number[][] {\n  if (root === null) return [[]];\n  if (root.left === null && root.right === null) return [[root.val]];\n  if (root.left !== null && root.right === null) {\n    const sub = BSTSequences(root.left);\n    return sub.map(v => [root.val, ...v]);\n  }\n  if (root.right !== null && root.left === null) {\n    const sub = BSTSequences(root.right);\n    return sub.map(v => [root.val, ...v]);\n  }\n  const subl = BSTSequences(root.left);\n  const subr = BSTSequences(root.right);\n  const ans: number[][] = [];\n  for (const l of subl) {\n    for (const r of subr) {\n      merge(l, 0, r, 0, [], root.val);\n    }\n  }\n  return ans;\n  function merge(\n    l: number[],\n    idxl: number,\n    r: number[],\n    idxr: number,\n    list: number[],\n    root: number\n  ): void {\n    if (l.length === idxl) {\n      for (let i = idxr; i < r.length; i++) list.push(r[i]);\n      list.unshift(root);\n      ans.push(list);\n      return;\n    }\n    if (r.length === idxr) {\n      for (let i = idxl; i < l.length; i++) list.push(l[i]);\n      list.unshift(root);\n      ans.push(list);\n      return;\n    }\n    merge(l, idxl + 1, r, idxr, [...list, l[idxl]], root);\n    merge(l, idxl, r, idxr + 1, [...list, r[idxr]], root);\n  }\n}"}],"tagList":["树","二叉搜索树","回溯","二叉树"],"level":"Hard"}},{"problemName":"面试题05.02.二进制数转字符串.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题05.02.二进制数转字符串.json","problemData":{"id":"100203","name":"面试题05.02.二进制数转字符串","url":"https://leetcode.cn/problems/bianry-number-to-string-lcci","desc":"二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。","solutions":[{"script":"cpp","time":0,"memory":6,"desc":"遍历。","code":"class Solution {\npublic:\n    string printBin(double num) {\n        string res = \"0.\";\n        for (int i = 1; i < 32 && num > 0; i++) {\n            if (num >= pow(2, -i)) num -= pow(2, -i), res += \"1\";\n            else res += \"0\";\n        }\n        if (num) return \"ERROR\";\n        return res;\n    }\n};","date":"2023-03-02"},{"script":"python","time":28,"memory":14.7,"desc":"同上。","code":"class Solution:\n    def printBin(self, num: float) -> str:\n        res = \"0.\"\n        for i in range(1, 32):\n            if num <= 0:\n                break\n            if num >= pow(2, -i):\n                num -= pow(2, -i)\n                res += \"1\"\n            else:\n                res += \"0\"\n        return \"ERROR\" if num else res","date":"2023-03-02"},{"script":"rust","time":0,"memory":2.4,"desc":"同上。","code":"impl Solution {\n        pub fn print_bin(num: f64) -> String {\n            let mut num = num;\n            let mut res = String::from(\"0.\");\n            for i in 1..32 {\n                if num == 0.0 {\n                    break;\n                }\n                if num >= 2f64.powf(-i as f64) {\n                    num -= 2f64.powf(-i as f64);\n                    res.push('1');\n                } else {\n                    res.push('0');\n                }\n            }\n            if num > 0.0 {\n                \"ERROR\".to_string()\n            } else {\n                res\n            }\n        }\n    }","date":"2023-03-02"}],"tagList":["位运算","数学","字符串"],"level":"Medium"}},{"problemName":"面试题08.03.魔术索引.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题08.03.魔术索引.json","problemData":{"id":"100240","name":"面试题08.03.魔术索引","url":"https://leetcode.cn/problems/magic-index-lcci","desc":"魔术索引。 在数组 A[0...n-1]中，有所谓的魔术索引，满足条件 A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组 A 中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。","solutions":[{"date":"2020-07-31","time":92,"memory":38.6,"script":"typescript","desc":"二分查找。","code":"function findMagicIndex(nums: number[]): number {\n  return _find(0, nums.length);\n  function _find(l: number, r: number): number {\n    if (l >= r) return -1;\n    const mid = (l + r) >> 1;\n    const num = nums[mid];\n    if (num === mid) return mid;\n    const left = _find(l, mid);\n    if (left === -1) return _find(mid + 1, r);\n    else return left;\n  }\n}"}],"tagList":["数组","二分查找"],"level":"Easy"}},{"problemName":"面试题08.13.堆箱子.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题08.13.堆箱子.json","problemData":{"id":"100202","name":"面试题08.13.堆箱子","url":"https://leetcode.cn/problems/pile-box-lcci","desc":"堆箱子。给你一堆n个箱子，箱子宽 wi、深 di、高 hi。箱子不能翻转，将箱子堆起来时，下面箱子的宽度、高度和深度必须大于上面的箱子。实现一种方法，搭出最高的一堆箱子。箱堆的高度为每个箱子高度的总和。","solutions":[{"script":"python","time":1056,"memory":16.35,"desc":"dp[i]表示当前为顶时的最大值。","code":"class Solution:\n    def pileBox(self, box: List[List[int]]) -> int:\n        n = len(box)\n        box.sort(key=lambda o: o[0] * o[1] * o[2], reverse=True)\n        dp = [0] * n\n        for i in range(n):\n            dp[i] = box[i][2]\n            for j in range(i - 1, -1, -1):\n                if box[i][0] < box[j][0] and box[i][1] < box[j][1] and box[i][2] < box[j][2]:\n                    dp[i] = max(dp[i], dp[j] + box[i][2])\n        return max(dp)","date":"2023-10-25"}],"tagList":["数组","动态规划","排序"],"level":"Hard"}},{"problemName":"面试题10.02.变位词组.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题10.02.变位词组.json","problemData":{"id":"1000040","name":"面试题10.02.变位词组","url":"https://leetcode.cn/problems/group-anagrams-lcci","desc":"编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。","solutions":[{"date":"2021-07-19","time":240,"memory":50.6,"script":"typescript","desc":"哈希储存。","code":"function groupAnagrams(strs: string[]): string[][] {\n  const map: Record<string, string[]> = {};\n  const getKey = (str: string) => {\n    const cache: Record<string, number> = {};\n    for (const c of str) cache[c] = (cache[c] ?? 0) + 1;\n    return Object.entries(cache)\n      .sort(([k1], [k2]) => k1.codePointAt(0)! - k2.codePointAt(0)!)\n      .map(([k, v]) => k + v)\n      .join(':');\n  };\n  for (const str of strs) {\n    const key = getKey(str);\n    let arr = map[key];\n    if (!arr) map[key] = arr = [];\n    arr.push(str);\n  }\n  return Object.values(map);\n}"}],"tagList":["数组","哈希表","字符串","排序"],"level":"Medium"}},{"problemName":"面试题10.10.数字流的秩.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题10.10.数字流的秩.json","problemData":{"id":"1000041","name":"面试题10.10.数字流的秩","url":"https://leetcode.cn/problems/rank-from-stream-lcci","desc":"实现一个 MapSum 类。","solutions":[{"date":"2021-11-14","time":80,"memory":39.8,"script":"typescript","desc":"trie。","code":"const getIdx = (ch: string) => ch.codePointAt(0)! - 'a'.codePointAt(0)!;\nclass TrieNode {\n  data = 0;\n  end = false;\n  children: TrieNode[] = [];\n  constructor(public val: string) {}\n  sum() {\n    let sum = this.data;\n    for (const child of this.children) {\n      if (child) sum += child.sum();\n    }\n    return sum;\n  }\n}\nclass Trie {\n  root = new TrieNode('');\n  insert(word: string, data: number): void {\n    let node = this.root;\n    for (const ch of word) {\n      const idx = getIdx(ch);\n      if (!node.children[idx]) node.children[idx] = new TrieNode(ch);\n      node = node.children[idx];\n    }\n    node.data = data;\n    node.end = true;\n  }\n  findNode(word: string): TrieNode | null {\n    let node = this.root;\n    for (const ch of word) {\n      const idx = getIdx(ch);\n      if (!node.children[idx]) return null;\n      node = node.children[idx];\n    }\n    return node;\n  }\n  search(word: string): boolean {\n    return !!this.findNode(word)?.end;\n  }\n  startsWith(prefix: string): boolean {\n    return !!this.findNode(prefix);\n  }\n}\n\nclass MapSum {\n  trie = new Trie();\n  insert(key: string, val: number): void {\n    this.trie.insert(key, val);\n  }\n  sum(prefix: string): number {\n    return this.trie.findNode(prefix)?.sum() ?? 0;\n  }\n}"}],"tagList":["设计","树状数组","二分查找","数据流"],"level":"Medium"}},{"problemName":"面试题16.03.交点.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题16.03.交点.json","problemData":{"id":"100260","name":"面试题16.03.交点","url":"https://leetcode.cn/problems/intersection-lcci","desc":"给定两条线段（表示为起点 start = {X1, Y1}和终点 end = {X2, Y2}），如果它们有交点，请计算其交点，没有交点则返回空值。","solutions":[{"date":"2020-04-12","time":72,"memory":33.7,"script":"javascript","desc":"先判断两条线是否有交点，在判断线段是否有交点，难点在判断各种极端情况。","code":"/**\n * @param {number[]} start1\n * @param {number[]} end1\n * @param {number[]} start2\n * @param {number[]} end2\n * @return {number[]}\n */\nvar intersection = function (start1, end1, start2, end2) {\n  function include(num, num1, num2) {\n    if (num1 > num2) [num1, num2] = [num2, num1];\n    return num >= num1 && num <= num2;\n  }\n  if (start1[0] > end1[0]) [start1, end1] = [end1, start1];\n  if (start2[0] > end2[0]) [start2, end2] = [end2, start2];\n  // console.log(start1, end1, start2, end2);\n  let intersectionX, intersectionY;\n  const k1 = (end1[1] - start1[1]) / (end1[0] - start1[0]);\n  const k2 = (end2[1] - start2[1]) / (end2[0] - start2[0]);\n  const b1 = start1[1] - k1 * start1[0];\n  const b2 = start2[1] - k2 * start2[0];\n  if (!Number.isFinite(k1) && !Number.isFinite(k2)) {\n    if (start1[0] !== start2[0]) return [];\n    else if (include(start1[1], start2[1], end2[1])) return start1;\n    else if (include(end1[1], start2[1], end2[1])) return end1;\n    else return [];\n  } else if (!Number.isFinite(k1) && Number.isFinite(k2)) {\n    intersectionX = start1[0];\n    intersectionY = k2 * start1[0] + b2;\n  } else if (Number.isFinite(k1) && !Number.isFinite(k2)) {\n    intersectionX = start2[0];\n    intersectionY = k1 * start2[0] + b1;\n  } else {\n    if (k1 === k2) {\n      if (b1 === b2) {\n        if (include(start2[0], start1[0], end1[0])) return start2;\n        if (include(start1[0], start2[0], end2[0])) return start1;\n        else return [];\n      } else if (b1 !== b2) return [];\n    }\n    intersectionX = (b1 - b2) / (k2 - k1);\n    intersectionY = k1 * intersectionX + b1;\n  }\n  // console.log(`line1:y=${k1}x${b1 < 0 ? \"\" : \"+\"}${b1}`);\n  // console.log(`line2:y=${k2}x${b2 < 0 ? \"\" : \"+\"}${b2}`);\n  // console.log(`intersection:(${intersectionX},${intersectionY})`);\n  if (\n    include(intersectionX, start1[0], end1[0]) &&\n    include(intersectionX, start2[0], end2[0]) &&\n    include(intersectionY, start1[1], end1[1]) &&\n    include(intersectionY, start2[1], end2[1])\n  )\n    return [intersectionX, intersectionY];\n  else return [];\n};"}],"tagList":["几何","数学"],"level":"Hard"}},{"problemName":"面试题16.11.跳水板.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题16.11.跳水板.json","problemData":{"id":"100352","name":"面试题16.11.跳水板","url":"https://leetcode.cn/problems/diving-board-lcci","desc":"你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为 shorter，长度较长的木板长度为 longer。你必须正好使用 k 块木板。编写一个方法，生成跳水板所有可能的长度。","solutions":[{"date":"2020-07-08","time":172,"memory":48.8,"script":"typescript","desc":"遍历依次增加和减少长度。","code":"function divingBoard(shorter: number, longer: number, k: number): number[] {\n  if (k === 0) return [];\n  const ans = new Set<number>();\n  let l1 = k,\n    l2 = 0;\n  while (l1 !== -1) ans.add(l1-- * shorter + l2++ * longer);\n  return [...ans];\n}"}],"tagList":["数组","数学"],"level":"Easy"}},{"problemName":"面试题16.18.模式匹配.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题16.18.模式匹配.json","problemData":{"id":"1000004","name":"面试题16.18.模式匹配","url":"https://leetcode.cn/problems/pattern-matching-lcci","desc":"你有两个字符串，即 pattern 和 value。 pattern 字符串由字母\"a\"和\"b\"组成，用于描述字符串中的模式。例如，字符串\"catcatgocatgo\"匹配模式\"aabab\"（其中\"cat\"是\"a\"，\"go\"是\"b\"），该字符串也匹配像\"a\"、\"ab\"和\"b\"这样的模式。但需注意\"a\"和\"b\"不能同时表示相同的字符串。编写一个方法判断 value 字符串是否匹配 pattern 字符串。","solutions":[{"date":"2020-06-22","time":84,"memory":37.3,"script":"typescript","desc":"细节判断，复刻 java 代码，并没有很深的理解。","code":"function patternMatching(pattern: string, value: string): boolean {\n  // 如果为空字符串 则只能匹配空字符串\n  if (pattern === '') return value === '';\n  // 如果匹配字符串只有a或b\n  if (pattern === 'a' || pattern === 'b') return true;\n  // 计算pattern里a和b的个数\n  let aCount = 0;\n  let bCount = 0;\n  for (const c of pattern) {\n    if (c === 'a') aCount++;\n    else bCount++;\n  }\n  const vLen = value.length;\n  // value为空时，判断pattern是否只有a或只有b\n  if (value === '') return aCount === 0 || bCount === 0;\n  // a或b的数量为0，判断value能否被等分\n  if (aCount * bCount == 0) {\n    const count = aCount + bCount;\n    if (vLen % count != 0) return false;\n    let len = vLen / count;\n    for (let i = len; i < vLen; i += len) if (!stringEquals(0, i, len)) return false;\n    return true;\n  }\n  // i代表a字符串的长度\n  for (let i = 0; i <= vLen; i++) {\n    // a字符串过长就break\n    if (vLen < aCount * i) break;\n    const bLen = ~~((vLen - aCount * i) / bCount);\n    // lenB满足条件才进行判断\n    if (bLen * bCount + aCount * i !== vLen) continue;\n    let index = 0;\n    // 初始化a和b的初始索引之前设置为-1\n    const ab = [-1, -1];\n    let notMatch = false;\n    for (const c of pattern) {\n      if (c === 'a') {\n        if (ab[0] === -1) ab[0] = index;\n        else if (!stringEquals(ab[0], index, i)) {\n          notMatch = true;\n          break;\n        }\n        index += i;\n      } else {\n        if (ab[1] === -1) ab[1] = index;\n        else if (!stringEquals(ab[1], index, bLen)) {\n          notMatch = true;\n          break;\n        }\n        index += bLen;\n      }\n      if (bLen === i && ab[0] !== -1 && ab[1] !== -1 && stringEquals(ab[0], ab[1], bLen)) {\n        notMatch = true;\n        break;\n      }\n    }\n    // notMatch为false说明之前的几个判断里面都不是因为break跳出\n    if (!notMatch) return true;\n  }\n  return false;\n  function stringEquals(i: number, j: number, len: number): boolean {\n    for (let k = 0; k < len; k++) if (value[i + k] !== value[j + k]) return false;\n    return true;\n  }\n}"}],"tagList":["数学","字符串","回溯","枚举"],"level":"Medium"}},{"problemName":"面试题16.19.水域大小.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题16.19.水域大小.json","problemData":{"id":"1000005","name":"面试题16.19.水域大小","url":"https://leetcode.cn/problems/pond-sizes-lcci","desc":"你有一个用于表示一片土地的整数矩阵land，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。","solutions":[{"script":"cpp","time":8,"memory":11.4,"desc":"bfs。","code":"#define X first\n#define Y second\n#define pii pair<int, int>\n\nvector<vector<int>> dirs2 = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};\n\nclass Solution {\npublic:\n    vector<int> pondSizes(vector<vector<int>>& land) {\n        int n = land.size(), m = land[0].size(), used[n][m];\n        memset(used, 0, sizeof(used));\n        vector<int> res;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!used[i][j] && land[i][j] == 0) {\n                    used[i][j] = 1;\n                    queue<pii> q;\n                    q.push(make_pair(i, j));\n                    int cnt = 1;\n                    while (q.size()) {\n                        auto cur = q.front();\n                        q.pop();\n                        for (auto &dir : dirs2) {\n                            int ni = cur.X + dir[0], nj = cur.Y + dir[1];\n                            if (0 <= ni && ni < n && 0 <= nj && nj < m && land[ni][nj] == 0 && !used[ni][nj]) {\n                                cnt += 1;\n                                used[ni][nj] = 1;\n                                q.push(make_pair(ni, nj));\n                            }\n                        }\n                    }\n                    res.push_back(cnt);\n                }\n            }\n        }\n        sort(res.begin(), res.end());\n        return res;\n    }\n};","date":"2023-06-22"},{"script":"python","time":204,"memory":27.5,"desc":"同上。","code":"dirs2 = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]\n\n    class Solution:\n        def pondSizes(self, land: List[List[int]]) -> List[int]:\n            n = len(land)\n            m = len(land[0])\n            used = [[False for _ in range(m)] for _ in range(n)]\n            res = []\n            for i in range(n):\n                for j in range(m):\n                    if not used[i][j] and land[i][j] == 0:\n                        used[i][j] = True\n                        q = deque()\n                        q.append((i, j))\n                        cnt = 1\n                        while len(q):\n                            cur = q.popleft()\n                            for dir in dirs2:\n                                ni = cur[0] + dir[0]\n                                nj = cur[1] + dir[1]\n                                if 0 <= ni < n and 0 <= nj < m and land[ni][nj] == 0 and not used[ni][nj]:\n                                    cnt += 1\n                                    used[ni][nj] = True\n                                    q.append((ni, nj))\n                        res.append(cnt)\n            res.sort()\n            return res","date":"2023-06-22"},{"script":"rust","time":16,"memory":4,"desc":"同上。","code":"pub const dirs2: [[i32; 2]; 8] = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];\n\nimpl Solution {\n    pub fn pond_sizes(land: Vec<Vec<i32>>) -> Vec<i32> {\n        let n = land.len();\n        let m = land[0].len();\n        let mut used = vec![vec![false; m]; n];\n        let mut res = vec![];\n        for i in 0..n {\n            for j in 0..m {\n                if !used[i][j] && land[i][j] == 0 {\n                    used[i][j] = true;\n                    let mut q = std::collections::VecDeque::<(usize, usize)>::new();\n                    q.push_back((i, j));\n                    let mut cnt = 1;\n                    while !q.is_empty() {\n                        let (i, j) = q.pop_front().unwrap();\n                        for dir in dirs2 {\n                            let ni = i as i32 + dir[0];\n                            let nj = j as i32 + dir[1];\n                            if 0 <= ni\n                                && ni < n as i32\n                                && 0 <= nj\n                                && nj < m as i32\n                                && land[ni as usize][nj as usize] == 0\n                                && !used[ni as usize][nj as usize]\n                            {\n                                let ni = ni as usize;\n                                let nj = nj as usize;\n                                cnt += 1;\n                                used[ni][nj] = true;\n                                q.push_back((ni, nj));\n                            }\n                        }\n                    }\n                    res.push(cnt);\n                }\n            }\n        }\n        res.sort();\n        res\n    }\n}","date":"2023-06-22"}],"tagList":["深度优先搜索","广度优先搜索","并查集","数组","矩阵"],"level":"Medium"}},{"problemName":"面试题17.05.字母与数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题17.05.字母与数字.json","problemData":{"id":"1000033","name":"面试题17.05.字母与数字","url":"https://leetcode.cn/problems/find-longest-subarray-lcci","desc":"给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。","solutions":[{"script":"cpp","time":160,"memory":92.1,"desc":"前缀和。","code":"class Solution {\npublic:\n    vector<string> findLongestSubarray(vector<string>& array) {\n        int cur = 0, resMax = 0, resIdx = -1;\n        unordered_map<int, int> m;\n        m[0] = -1;\n        for (int i = 0; i < array.size(); i++) {\n            cur += isalpha(array[i][0]) ? 1 : -1;\n            if (m.count(cur) && i - m[cur] > resMax) resIdx = m[cur] + 1, resMax = i - m[cur];\n            if (!m.count(cur)) m[cur] = i;\n        }\n        vector<string> res;\n        for (int i = resIdx; i < resIdx + resMax; i++) res.push_back(array[i]);\n        return res;\n    }\n};","date":"2023-03-11"},{"script":"python","time":108,"memory":32.6,"desc":"同上。","code":"class Solution:\n    def findLongestSubarray(self, array: List[str]) -> List[str]:\n        cur, resMax, resIdx = 0, 0, -1\n        m = dict()\n        m[0] = -1\n        for i in range(len(array)):\n            cur += 1 if array[i].isalpha() else -1\n            if cur in m and i - m[cur] > resMax:\n                resIdx = m[cur] + 1\n                resMax = i - m[cur]\n            if cur not in m:\n                m[cur] = i\n        return array[resIdx:resIdx + resMax]","date":"2023-03-11"},{"script":"rust","time":84,"memory":11.4,"desc":"同上。","code":"impl Solution {\n    pub fn find_longest_subarray(array: Vec<String>) -> Vec<String> {\n        let (mut cur, mut resMax, mut resIdx) = (0, 0, 0);\n        let mut m = std::collections::HashMap::<i32, i32>::new();\n        m.insert(0, -1);\n        for i in 0..array.len() {\n            let s = array[i].chars().collect::<Vec<char>>();\n            cur += if s[0].is_alphabetic() { 1 } else { -1 };\n            if m.contains_key(&cur) && i as i32 - *m.get(&cur).unwrap() > resMax {\n                resIdx = *m.get(&cur).unwrap() + 1;\n                resMax = i as i32 - *m.get(&cur).unwrap();\n            }\n            if !m.contains_key(&cur) {\n                m.insert(cur, i as i32);\n            }\n        }\n        let resMax = resMax as usize;\n        let resIdx = resIdx as usize;\n        array[resIdx..resIdx + resMax].to_vec()\n    }\n}","date":"2023-03-11"}],"tagList":["数组","哈希表","前缀和"],"level":"Medium"}},{"problemName":"面试题17.09.第k个数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题17.09.第k个数.json","problemData":{"id":"1000037","name":"面试题17.09.第k个数","url":"https://leetcode.cn/problems/get-kth-magic-number-lcci","desc":"有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。","solutions":[{"date":"2021-03-14","time":92,"memory":39.3,"script":"typescript","desc":"依次获取最小值排序。","code":"function getKthMagicNumber(k: number): number {\n  if (k === 1) return 1;\n  let p3 = 0,\n    p5 = 0,\n    p7 = 0;\n  const arr: number[] = [1];\n  while (arr.length <= k) {\n    const num3 = arr[p3] * 3,\n      num5 = arr[p5] * 5,\n      num7 = arr[p7] * 7;\n    if (num3 < num5 && num3 < num7) {\n      while (true) {\n        const nextNum = arr[++p3] * 3;\n        if (nextNum !== num5 && nextNum !== num7) break;\n      }\n      arr.push(num3);\n    }\n    if (num5 < num3 && num5 < num7) {\n      while (true) {\n        const nextNum = arr[++p5] * 5;\n        if (nextNum !== num3 && nextNum !== num7) break;\n      }\n      arr.push(num5);\n    }\n    if (num7 < num5 && num7 < num3) {\n      while (true) {\n        const nextNum = arr[++p7] * 7;\n        if (nextNum !== num5 && nextNum !== num3) break;\n      }\n      arr.push(num7);\n    }\n  }\n  return arr[k - 1];\n}"},{"date":"2021-03-14","time":108,"memory":39.3,"script":"typescript","desc":"优化题解 1。","code":"function getKthMagicNumber(k: number): number {\n  if (k === 1) return 1;\n  let p3 = 0,\n    p5 = 0,\n    p7 = 0;\n  const arr: number[] = [1];\n  while (arr.length < k) {\n    const num3 = arr[p3] * 3,\n      num5 = arr[p5] * 5,\n      num7 = arr[p7] * 7;\n    const num = Math.min(num3, num5, num7);\n    if (num === num3) p3++;\n    if (num === num5) p5++;\n    if (num === num7) p7++;\n    arr.push(num);\n  }\n  return arr[k - 1];\n}"},{"date":"2022-09-28","time":0,"memory":6.1,"script":"cpp","desc":"遍历。","code":"class Solution {\npublic:\n    int getKthMagicNumber(int k) {\n        vector<int> list(k);\n        list[0] = 1;\n        int p[3] = {0};\n        for (int i = 1; i < k; i++) {\n            int next = min(list[p[0]] * 3, min(list[p[1]] * 5, list[p[2]] * 7));\n            list[i] = next;\n            if (next % 3 == 0) p[0]++;\n            if (next % 5 == 0) p[1]++;\n            if (next % 7 == 0) p[2]++;\n        }\n        return list.back();\n    }\n};"}],"tagList":["哈希表","数学","动态规划","堆（优先队列）"],"level":"Medium"}},{"problemName":"面试题17.10.主要元素.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题17.10.主要元素.json","problemData":{"id":"1000038","name":"面试题17.10.主要元素","url":"https://leetcode.cn/problems/find-majority-element-lcci","desc":"数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素。若没有，返回 -1 。请设计时间复杂度为 O(N) 、空间复杂度为 O(1) 的解决方案。","solutions":[{"date":"2021-07-09","time":72,"memory":42.6,"script":"typescript","desc":"利用 map 储存所有值。","code":"function majorityElement(nums: number[]): number {\n  const map: Map<number, number> = new Map();\n  const len = nums.length;\n  for (let i = 0; i < len; i++) {\n    const num = nums[i];\n    map.set(num, (map.get(num) ?? 0) + 1);\n  }\n  let num: number | null = null;\n  for (const [k, v] of map.entries()) if (v > len / 2) num = k;\n  return num ?? -1;\n}"},{"date":"2021-07-09","time":76,"memory":42.1,"script":"typescript","desc":"Boyer-Moore 投票算法。","code":"function majorityElement(nums: number[]): number {\n  let candidate = -1;\n  let count = 0;\n  nums.forEach(num => {\n    if (count === 0) candidate = num;\n    if (candidate === num) count++;\n    else count--;\n  });\n  count = 0;\n  nums.forEach(num => {\n    if (candidate === num) count++;\n  });\n  return count > nums.length / 2 ? candidate : -1;\n}"}],"tagList":["数组","计数"],"level":"Easy"}},{"problemName":"面试题17.11.单词距离.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题17.11.单词距离.json","problemData":{"id":"1000039","name":"面试题17.11.单词距离","url":"https://leetcode.cn/problems/find-closest-lcci","desc":"有个内含单词的超大文本文件，给定任意两个不同的单词，找出在这个文件中这两个单词的最短距离(相隔单词数)。","solutions":[{"date":"2022-05-27","time":96,"memory":57.9,"script":"cpp","desc":"一次遍历。","code":"class Solution {\n   public:\n    int findClosest(vector<string>& words, string word1, string word2) {\n        int p[2], ans = INT_MAX, n = words.size();\n        p[0] = p[1] = -1;\n        for (int i = 0; i < n; i++) {\n            string word = words[i];\n            int f = -1;\n            if (word == word1) f = 0;\n            if (word == word2) f = 1;\n            if (f == -1) continue;\n            p[f] = i;\n            if (p[0] == -1 || p[1] == -1) continue;\n            ans = min(ans, abs(p[0] - p[1]));\n        }\n        return ans;\n    }\n};"}],"tagList":["数组","字符串"],"level":"Medium"}},{"problemName":"面试题17.12.BiNode.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题17.12.BiNode.json","problemData":{"id":"1000019","name":"面试题17.12.BiNode","url":"https://leetcode.cn/problems/binode-lcci","desc":"二叉树数据结构 TreeNode 可用来表示单向链表（其中 left 置空，right 为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。返回转换后的单向链表的头节点。","solutions":[{"date":"2021-08-07","time":120,"memory":53.6,"script":"typescript","desc":"中序遍历。","code":"function convertBiNode(root: TreeNode | null): TreeNode | null {\n  if (root === null) return null;\n  const q: TreeNode[] = [];\n  inorder(root);\n  for (let i = 0; i < q.length - 1; i++) {\n    q[i].left = null;\n    q[i].right = q[i + 1];\n  }\n  q[q.length - 1].left = q[q.length - 1].right = null;\n  return q[0];\n  function inorder(node: TreeNode | null): void {\n    if (node === null) return;\n    inorder(node.left);\n    q.push(node);\n    inorder(node.right);\n  }\n}"}],"tagList":["栈","树","深度优先搜索","二叉搜索树","链表","二叉树"],"level":"Easy"}},{"problemName":"面试题17.13.恢复空格.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题17.13.恢复空格.json","problemData":{"id":"1000020","name":"面试题17.13.恢复空格","url":"https://leetcode.cn/problems/re-space-lcci","desc":"设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。","solutions":[{"date":"2020-07-09","time":360,"memory":73.3,"script":"typescript","desc":"构造前缀树，dp[i]为前 i 项有 n 项多余，每次遍历时向前比对是否匹配。","code":"class Trie {\n  private _tree = new Map<string, Trie>();\n  constructor(public end = false) {}\n  get(char: string): Trie | undefined {\n    return this._tree.get(char);\n  }\n  add(word: string): void {\n    if (word.length === 1) {\n      const t = this._tree.get(word);\n      if (t) {\n        t.end = true;\n      } else {\n        this._tree.set(word, new Trie(true));\n      }\n      return;\n    }\n    const chars = word;\n    const firstChar = chars[0];\n    const surplusChar = chars.substr(1);\n    const char = this._tree.get(firstChar);\n    if (char) {\n      this._tree.get(firstChar)?.add(surplusChar);\n    } else {\n      const trie = new Trie();\n      trie.add(surplusChar);\n      this._tree.set(firstChar, trie);\n    }\n  }\n  toString(intend = 0): string {\n    const blank = ''.padStart(intend);\n    let res = '';\n    for (const [k, v] of this._tree) {\n      res += `\n${intend === 0 ? '===\\n' : ''}${blank}${k}${v.end ? ']' : ''}`;\n      res += `${blank}${v ? v.toString(intend + 1) : ''}`;\n    }\n    return res;\n  }\n  print() {\n    console.log(this.toString());\n  }\n}\nfunction respace(dictionary: string[], sentence: string): number {\n  const trie = new Trie();\n  dictionary.forEach(word => {\n    trie.add(word.split('').reverse().join(''));\n  });\n  const len = sentence.length;\n  const dp = new Array(len + 1).fill(Infinity);\n  dp[0] = 0;\n  let rootTrie: Trie = trie;\n  for (let i = 1; i <= len; i++) {\n    dp[i] = dp[i - 1] + 1;\n    for (let j = i; j >= 1; j--) {\n      const char = sentence[j - 1];\n      const nextTrie = rootTrie.get(char);\n      if (!nextTrie) {\n        break;\n      } else if (nextTrie.end) {\n        dp[i] = Math.min(dp[i], dp[j - 1]);\n      }\n      if (dp[i] == 0) {\n        break;\n      }\n      rootTrie = nextTrie;\n    }\n    rootTrie = trie;\n  }\n  return dp[len];\n}"}],"tagList":["字典树","数组","哈希表","字符串","动态规划","哈希函数","滚动哈希"],"level":"Medium"}},{"problemName":"面试题17.14.最小K个数.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题17.14.最小K个数.json","problemData":{"id":"1000021","name":"面试题17.14.最小K个数","url":"https://leetcode.cn/problems/smallest-k-lcci","desc":"设计一个算法，找出数组中最小的 k 个数。以任意顺序返回这 k 个数均可。","solutions":[{"date":"2021-05-07","time":164,"memory":45.1,"script":"typescript","desc":"利用内部排序。","code":"function smallestK(arr: number[], k: number): number[] {\n  return arr.sort((a, b) => a - b).slice(0, k);\n}"},{"date":"2021-09-03","time":8000,"memory":48.4,"script":"typescript","desc":"堆。","code":"class Heap<T = number> {\n  private arr: T[] = [];\n  get isEmpty() {\n    return this.size === 0;\n  }\n  get size() {\n    return this.arr.length;\n  }\n  get top() {\n    return this.arr[0];\n  }\n  constructor(private compare: (t1: T, t2: T) => number) {}\n  add(num: T): void {\n    this.arr.push(num);\n    this.shiftUp(this.size - 1);\n  }\n  remove(): T {\n    const num = this.arr.shift()!;\n    if (this.size) {\n      this.arr.unshift(this.arr.pop()!);\n      this.shiftDown(0);\n    }\n    return num;\n  }\n  private shiftUp(index: number): void {\n    if (index === 0) return;\n    const parentIndex = (index - 1) >> 1;\n    if (this.compare(this.arr[index], this.arr[parentIndex]) > 0) {\n      [this.arr[index], this.arr[parentIndex]] = [this.arr[parentIndex], this.arr[index]];\n      this.shiftUp(parentIndex);\n    }\n  }\n  private shiftDown(index: number): void {\n    let childrenIndex = index * 2 + 1;\n    if (childrenIndex > this.size - 1) return;\n    if (\n      childrenIndex + 1 <= this.size - 1 &&\n      this.compare(this.arr[childrenIndex + 1], this.arr[childrenIndex]) > 0\n    ) {\n      childrenIndex++;\n    }\n    if (this.compare(this.arr[childrenIndex], this.arr[index]) > 0) {\n      [this.arr[childrenIndex], this.arr[index]] = [this.arr[index], this.arr[childrenIndex]];\n      this.shiftDown(childrenIndex);\n    }\n  }\n  *[Symbol.iterator](): IterableIterator<T> {\n    for (const t of this.arr) {\n      yield t;\n    }\n  }\n}\nfunction smallestK(arr: number[], k: number): number[] {\n  const heap = new Heap((t1, t2) => t2 - t1);\n  arr.forEach(v => heap.add(v));\n  const ans: number[] = [];\n  while (k--) ans.push(heap.remove());\n  return ans;\n}"}],"tagList":["数组","分治","快速选择","排序","堆（优先队列）"],"level":"Medium"}},{"problemName":"面试题17.19.消失的两个数字.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题17.19.消失的两个数字.json","problemData":{"id":"1000044","name":"面试题17.19.消失的两个数字","url":"https://leetcode.cn/problems/missing-two-lcci","desc":"给定一个数组，包含从 1 到 N 所有的整数，但其中缺了两个数字。你能在 O(N) 时间内只用 O(1) 的空间找到它们吗？。","solutions":[{"date":"2022-09-26","time":24,"memory":21.7,"script":"cpp","desc":"遍历,因为只缺少两个不同的数字,使用异或遍历所有数和所有存在数,只有缺少的两个数字会被异或,其他的都会抵消,此时利用最低位 1 说明两个不同的数字异或必存在一个 1 且一个数字有,一个数字无。","code":"class Solution {\npublic:\n    vector<int> missingTwo(vector<int>& nums) {\n        int xor_num = 0, n = nums.size() + 2;\n        for (auto &num : nums) xor_num ^= num;\n        for (int i = 1; i <= n; i++) xor_num ^= i;\n        int num = xor_num & -xor_num;\n        vector<int> list(2, 0);\n        for (auto &item : nums) {\n            if (item & num) list[0] ^= item;\n            else list[1] ^= item;\n        }\n        for (int item = 1; item <= n; item++) {\n            if (item & num) list[0] ^= item;\n            else list[1] ^= item;\n        }\n        return list;\n    }\n};"}],"tagList":["位运算","数组","哈希表"],"level":"Hard"}},{"problemName":"面试题17.20.连续中值.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题17.20.连续中值.json","problemData":{"id":"1000028","name":"面试题17.20.连续中值","url":"https://leetcode.cn/problems/continuous-median-lcci","desc":"随机产生数字并传递给一个方法。你能否完成这个方法，在每次产生新值时，寻找当前所有值的中间值（中位数）并保存。","solutions":[{"date":"2021-04-10","time":280,"memory":58.9,"script":"typescript","desc":"构建左侧大顶堆和右侧小顶堆，中间值为左侧堆最大值和右侧堆最小值的比较。","code":"class Heap<T> {\n  private arr: T[] = [];\n  get isEmpty() {\n    return this.size === 0;\n  }\n  get size() {\n    return this.arr.length;\n  }\n  get top() {\n    return this.arr[0];\n  }\n  constructor(private compare: (t1: T, t2: T) => number) {}\n  add(num: T): void {\n    this.arr.push(num);\n    this.shiftUp(this.size - 1);\n  }\n  remove(): T {\n    const num = this.arr.shift()!;\n    if (this.size) {\n      this.arr.unshift(this.arr.pop()!);\n      this.shiftDown(0);\n    }\n    return num;\n  }\n  private shiftUp(index: number): void {\n    if (index === 0) return;\n    const parentIndex = (index - 1) >> 1;\n    if (this.compare(this.arr[index], this.arr[parentIndex]) > 0) {\n      [this.arr[index], this.arr[parentIndex]] = [this.arr[parentIndex], this.arr[index]];\n      this.shiftUp(parentIndex);\n    }\n  }\n  private shiftDown(index: number): void {\n    let childrenIndex = index * 2 + 1;\n    if (childrenIndex > this.size - 1) return;\n    if (\n      childrenIndex + 1 <= this.size - 1 &&\n      this.compare(this.arr[childrenIndex + 1], this.arr[childrenIndex]) > 0\n    ) {\n      childrenIndex++;\n    }\n    if (this.compare(this.arr[childrenIndex], this.arr[index]) > 0) {\n      [this.arr[childrenIndex], this.arr[index]] = [this.arr[index], this.arr[childrenIndex]];\n      this.shiftDown(childrenIndex);\n    }\n  }\n}\n\nclass MedianFinder {\n  private leftHeap = new Heap<number>((num1: number, num2: number) => num1 - num2);\n  private rightHeap = new Heap<number>((num1: number, num2: number) => num2 - num1);\n  get size() {\n    return this.leftHeap.size + this.rightHeap.size;\n  }\n  addNum(num: number): void {\n    if (!this.leftHeap.size || this.leftHeap.top >= num) {\n      this.leftHeap.add(num);\n    } else {\n      this.rightHeap.add(num);\n    }\n    if (this.leftHeap.size === this.rightHeap.size + 2) {\n      this.rightHeap.add(this.leftHeap.remove());\n    } else if (this.leftHeap.size === this.rightHeap.size - 1) {\n      this.leftHeap.add(this.rightHeap.remove());\n    }\n  }\n  findMedian(): number {\n    if (this.size % 2 === 0) {\n      return (this.leftHeap.top + this.rightHeap.top) / 2;\n    } else {\n      return this.leftHeap.top;\n    }\n  }\n}"}],"tagList":["设计","双指针","数据流","排序","堆（优先队列）"],"level":"Hard"}},{"problemName":"面试题17.21.直方图的水量.json","problemPath":"C:/bestlyg/projects/bestlyg/packages/leetcode/data/面试题/面试题17.21.直方图的水量.json","problemData":{"id":"1000029","name":"面试题17.21.直方图的水量","url":"https://leetcode.cn/problems/volume-of-histogram-lcci","desc":"给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。","solutions":[{"date":"2021-04-02","time":108,"memory":39.9,"script":"typescript","desc":"求出左右最高高度进行比较。","code":"function trap(height: number[]): number {\n  let max = 0;\n  const len = height.length;\n  const left: number[] = [0];\n  for (let i = 1; i < len; i++) left.push((max = Math.max(max, height[i - 1])));\n  const right: number[] = [0];\n  max = 0;\n  for (let i = len - 2; i >= 0; i--) right.unshift((max = Math.max(max, height[i + 1])));\n  let ans = 0;\n  for (let i = 0; i < len; i++) {\n    const num = Math.min(left[i], right[i]) - height[i];\n    ans += num > 0 ? num : 0;\n  }\n  return ans;\n}"},{"date":"2021-04-02","time":112,"memory":39.8,"script":"typescript","desc":"优化题解 1，取消右数组。","code":"function trap(height: number[]): number {\n  let max = 0;\n  const len = height.length;\n  const left: number[] = [0];\n  for (let i = 1; i < len; i++) left.push((max = Math.max(max, height[i - 1])));\n  let ans = 0;\n  max = 0;\n  for (let i = len - 2; i >= 0; i--) {\n    const num = Math.min(left[i], (max = Math.max(max, height[i + 1]))) - height[i];\n    ans += num > 0 ? num : 0;\n  }\n  return ans;\n}"}],"tagList":["栈","数组","双指针","动态规划","单调栈"],"level":"Hard"}}]}];