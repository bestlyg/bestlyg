---
title: 859.亲密字符串
order: 859
nav:
  title: 力扣题解
  path: /leetcode
  order: 3
group:
  title: 801-900
  path: /801-900
  order: 801
---

# 859. 亲密字符串

> 链接：[859. 亲密字符串](https://leetcode-cn.com/problems/buddy-strings/)  
> 难度：简单  
> 标签：字符串  
> 简介：给定两个由小写字母构成的字符串 A 和 B ，只要我们可以通过交换 A 中的两个字母得到与 B 相等的结果，就返回 true ；否则返回 false 。

## 题解 1 - typescript

- 编辑时间：2021.3.14
- 执行用时：92ms
- 内存消耗：40.5mb
- 编程语言：typescript
- 解法介绍：取三段进行比较。

```typescript
function buddyStrings(a: string, b: string): boolean {
  const len = a.length;
  if (len !== b.length) return false;
  if (a === b) return new Set([...a]).size !== len;
  let i = 0;
  while (i < len && a[i] === b[i]) i++;
  let j = i + 1;
  while (j < len && a[j] === b[j]) j++;
  if (j === len) return false;
  if (a[i] !== b[j] || a[j] !== b[i]) return false;
  return (
    a.substring(0, i) === b.substring(0, i) &&
    a.substring(i + 1, j) === b.substring(i + 1, j) &&
    a.substring(j + 1) === b.substring(j + 1)
  );
}
```

## 题解 2 - typescript

- 编辑时间：2021.3.14
- 执行用时：100ms
- 内存消耗：40.6mb
- 编程语言：typescript
- 解法介绍：优化题解 1,直接判断最后一段。

```typescript
function buddyStrings(a: string, b: string): boolean {
  const len = a.length;
  if (len !== b.length) return false;
  if (a === b) return new Set([...a]).size !== len;
  let i = 0;
  while (i < len && a[i] === b[i]) i++;
  let j = i + 1;
  while (j < len && a[j] === b[j]) j++;
  if (j === len) return false;
  if (a[i] !== b[j] || a[j] !== b[i]) return false;
  while (++j < len) if (a[j] !== b[j]) return false;
  return true;
}
```
