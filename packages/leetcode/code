class Solution:
    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:
        dirs = [[1, -2], [1, 2], [2, -1], [2, 1], [-1, -2], [-1, 2], [-2, -1], [-2, 1]]
        @cache
        def dfs(i, j, k) -> int:
            if i < 0 or i >= n or j < 0 or j >= n:
                return 0
            elif k == 0:
                return 1
            else:
                res = 0
                for dir in dirs:
                    ni = i + dir[0]
                    nj = j + dir[1]
                    res += dfs(ni, nj, k - 1)
                return res
        return dfs(row, column, k) / (8 ** k)