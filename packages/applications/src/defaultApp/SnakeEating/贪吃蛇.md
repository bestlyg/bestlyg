---
title: 贪吃蛇
nav:
  title: 应用合集
  path: /applications
  order: 5
group:
  title: 默认
  path: /default-app
  order: 1
---

# 贪吃蛇

通过上下左右操作蛇使其吃到更多的零食，吃的越多蛇的移动速度会越快。

## 应用程序

```jsx
/**
 * inline: true
 */
import React from 'react';
import { SnakeEating } from '@bestlyg/applications';
export default SnakeEating;
```


## [核心代码](https://gitee.com/bestlyg/bestlyg/tree/master/packages/applications/src/defaultApp/SnakeEating/useSnakeEating.ts)
```ts
import Color from 'color';
import { useInterval, useKeyPress } from 'ahooks';
import { useMemo, useState, useCallback, useEffect, useRef } from 'react';
import { Direction } from '@bestlyg/shared';
import { useScore } from '../../hooks';
import { message } from 'antd';
import { random } from 'lodash';
/** 边框最小值 */
export const SIZE_MIN = 10;
/** 边框最大值 */
export const SIZE_MAX = 50;
/** 点半径 */
export const POINT_RADIUS = 10;
/** 初始速度(毫秒) */
export const SPEED = 1000;
/** 速度提升倍数(每x分提升一倍) */
export const SPEED_MULTIPLE = 10;
/** 颜色配置 */
export enum SnakeColor {
  /** 边框 */
  BORDER = '#000000',
  /** 蛇头 */
  FOOTER = '#FDD819',
  /** 蛇尾 */
  HEADER = '#E80505',
  /** 食物 */
  FOOD = '#000000',
}
/** 点格式化 */
export const pointFormat = (x: number, y: number) => `${x}::${y}`;
/** 状态标记 */
export enum State {
  /** 准备开始 */
  start,
  /** 运行中 */
  run,
  /** 结束了 */
  end,
}
/** 计算下一个点 */
const getNextPoint: Record<Direction, (x: number, y: number) => [number, number]> = {
  [Direction.UP]: (x: number, y: number) => [x, y - 1],
  [Direction.DOWN]: (x: number, y: number) => [x, y + 1],
  [Direction.LEFT]: (x: number, y: number) => [x - 1, y],
  [Direction.RIGHT]: (x: number, y: number) => [x + 1, y],
};
export const useSnakeEating = () => {
  const { maxScore, setScore, score } = useScore('GAME_SNAKEEATING_');
  /** canvasDOM引用 */
  const canvas = useRef<HTMLCanvasElement>(null as any);
  /** 速度，null为停止 */
  const [speed, setSpeed] = useState<number | null>(null);
  /** 状态 */
  const [state, setState] = useState<State>(State.start);
  /** 当前方向 */
  const [curDirection, setCurDirection] = useState<Direction>(Direction.RIGHT);
  /** 下一个方向 */
  const [nextDirection, setNextDirection] = useState<Direction | null>(null);
  /** 蛇身标记 */
  const [snake, setSnake] = useState<[number, number][]>([]);
  /** 蛇大小 */
  const size = useMemo(() => snake.length, [snake]);
  /** 存在蛇的点集合 */
  const snakeSet = useMemo(
    () => new Set<string>(snake.map(([x, y]) => pointFormat(x, y))),
    [snake]
  );
  /** 宽度 */
  const [width, setWidth] = useState(SIZE_MIN);
  /** 高度 */
  const [height, setHeight] = useState(SIZE_MIN);
  /** canvas宽度(点宽度*直径) */
  const canvasWidth = useMemo(() => width * POINT_RADIUS * 2, [width]);
  /** canvas高度(点高度*直径) */
  const canvasHeight = useMemo(() => height * POINT_RADIUS * 2, [height]);
  /** 食物(null为没食物) */
  const [food, setFood] = useState<[number, number] | null>(null);
  /** 可能存在食物的点集合(没有蛇且不是边框的点) */
  const foodSet = useMemo(() => {
    const set = new Set<string>();
    for (let i = 1; i < width - 1; i++) {
      for (let j = 1; j < height - 1; j++) {
        const format = pointFormat(i, j);
        snakeSet.has(format) || set.add(format);
      }
    }
    return set;
  }, [snake]);
  /** 绘制点 */
  const drawPoint = useCallback((x: number, y: number) => {
    const ctx = canvas.current?.getContext('2d');
    if (!ctx) return;
    ctx.arc(POINT_RADIUS * (1 + x * 2), POINT_RADIUS * (1 + y * 2), POINT_RADIUS, 0, 2 * Math.PI);
  }, []);
  /** 清空画布 */
  const drawClear = useCallback(() => {
    const ctx = canvas.current?.getContext('2d');
    if (!ctx) return;
    ctx?.clearRect(0, 0, canvasWidth, canvasHeight);
  }, [canvasWidth, canvasHeight]);
  /** 绘制边框 */
  const drawBorder = useCallback(() => {
    const ctx = canvas.current?.getContext('2d');
    if (!ctx) return;
    for (let i = 0; i < width; i++) {
      ctx.beginPath();
      drawPoint(i, 0);
      drawPoint(i, height - 1);
      ctx.fillStyle = SnakeColor.BORDER;
      ctx.fill();
      ctx.closePath();
    }
    for (let i = 0; i < height; i++) {
      ctx.beginPath();
      drawPoint(0, i);
      drawPoint(width - 1, i);
      ctx.fillStyle = SnakeColor.BORDER;
      ctx.fill();
      ctx.closePath();
    }
  }, [drawPoint, width, height]);
  /** 绘制蛇身 */
  const drawSnake = useCallback(() => {
    const ctx = canvas.current?.getContext('2d');
    let mixin = Color(SnakeColor.FOOTER);
    let color = Color(SnakeColor.HEADER);
    if (!ctx) return;
    for (let i = 0, l = snake.length; i < l; i++) {
      const [x, y] = snake[i];
      ctx.beginPath();
      drawPoint(x, y);
      ctx.fillStyle = color.hex();
      ctx.fill();
      ctx.closePath();
      color = color.mix(mixin, 0.2);
    }
  }, [snake, drawPoint]);
  /** 绘制食物 */
  const drawFood = useCallback(() => {
    const ctx = canvas.current?.getContext('2d');
    if (!ctx) return;
    let newFood = food;
    // 如果没有食物或者状态为开始时就生成新食物
    if (!newFood || state === State.start) {
      newFood = [...foodSet][random(foodSet.size - 1)].split('::').map(v => parseInt(v)) as [
        number,
        number
      ];
      setFood(newFood);
    }
    ctx.beginPath();
    drawPoint(newFood[0], newFood[1]);
    ctx.fillStyle = SnakeColor.FOOD;
    ctx.fill();
    ctx.closePath();
  }, [food, foodSet, drawPoint, state]);
  /** 绘制画布 */
  const draw = useCallback(() => {
    drawClear();
    drawBorder();
    drawSnake();
    drawFood();
  }, [drawClear, drawBorder, drawSnake, drawFood]);
  /** 初始化状态 */
  const drawInit = useCallback(() => {
    /** 蛇 */
    const snake: [number, number][] = [];
    let [x, y] = [random(2, width - 3), random(2, height - 3)];
    snake.unshift([x, y]);
    x += 1;
    snake.unshift([x, y]);
    setSnake(snake);
    setSpeed(null);
    setState(State.start);
  }, [width, height, drawClear, draw]);
  /** 移动 */
  const move = useCallback(
    (interval = false) => {
      if (state === State.start) {
        // 如果状态为开始状态，则设置为运行状态并设置初始速度
        setState(State.run);
        setSpeed(SPEED);
      } else if (state === State.end) {
        // 如果状态为结束状态，则取消定时器，不进行其他操作
        setSpeed(null);
      } else if (
        (curDirection === Direction.UP && nextDirection === Direction.DOWN) ||
        (curDirection === Direction.DOWN && nextDirection === Direction.UP) ||
        (curDirection === Direction.LEFT && nextDirection === Direction.RIGHT) ||
        (curDirection === Direction.RIGHT && nextDirection === Direction.LEFT)
      ) {
        // 如果当前方向为下一个方向的反方向，则重置下一个方向
        setNextDirection(curDirection);
      } else if (nextDirection === null) {
        // 如果没有下一个方向则不进行操作
      } else if (!interval) {
        // 如果不是定时器触发的移动则不进行操作
      } else {
        setCurDirection(nextDirection);
        const head = snake[0];
        const nextPoint = getNextPoint[nextDirection](head[0], head[1]);
        if (
          (nextDirection === Direction.UP && snake[0][1] === 1) ||
          (nextDirection === Direction.DOWN && snake[0][1] === height - 2) ||
          (nextDirection === Direction.LEFT && snake[0][0] === 1) ||
          (nextDirection === Direction.RIGHT && snake[0][0] === width - 2) ||
          snakeSet.has(pointFormat(nextPoint[0], nextPoint[1]))
        ) {
          // 如果下一个点是边框或者蛇身，则游戏结束
          setState(State.end);
          return;
        }
        const newSnake = [...snake];
        newSnake.unshift(nextPoint);
        if (nextPoint[0] === food![0] && nextPoint[1] === food![1]) {
          // 如果下一个点是食物则删除食物
          setFood(null);
        } else {
          newSnake.pop();
        }
        setSnake(newSnake);
        draw();
      }
    },
    [state, curDirection, snake, nextDirection, draw, snakeSet]
  );
  // 方向键触发，禁止滚动
  useKeyPress(Direction.UP, e => {
    e.preventDefault();
    setNextDirection(Direction.UP);
  });
  useKeyPress(Direction.DOWN, e => {
    e.preventDefault();
    setNextDirection(Direction.DOWN);
  });
  useKeyPress(Direction.LEFT, e => {
    e.preventDefault();
    setNextDirection(Direction.LEFT);
  });
  useKeyPress(Direction.RIGHT, e => {
    e.preventDefault();
    setNextDirection(Direction.RIGHT);
  });
  useEffect(() => {
    // 改变宽高时初始化
    drawInit();
  }, [width, height]);
  useEffect(() => {
    // 蛇进行移动后重新绘制
    draw();
  }, [snake]);
  useEffect(() => {
    // 长度改变后，重置速度，每SPEED_MULTIPLE倍除以2
    setSpeed(SPEED / 2 ** ~~(size / SPEED_MULTIPLE));
  }, [size]);
  useEffect(() => {
    // 切换下一个方向时触发移动
    nextDirection && move();
  }, [nextDirection]);
  useEffect(() => {
    setScore(size);
  }, [size]);
  useEffect(() => {
    state === State.end && message.info(`游戏结束，本次分数${score}`);
  }, [state, score]);
  useInterval(() => move(true), speed);
  return {
    canvas,
    setHeight,
    setWidth,
    canvasHeight,
    canvasWidth,
    drawInit,
    setNextDirection,
    size,
    speed,
    state,
    maxScore,
    score,
  };
};

```
