---
title: 数独
nav:
  title: 应用合集
  path: /applications
  order: 5
group:
  title: 数字游戏
  path: /number-game
  order: 2
---

# 数独

在 9\*9 的方格内，满足每一行、每一列、每一个粗线宫（3\*3）内的数字均含 1-9，不重复

## 应用程序

```jsx
/**
 * inline: true
 */
import React from 'react';
import { Sudoku } from '@bestlyg/applications';
export default Sudoku;
```

## [核心代码](https://gitee.com/bestlyg/bestlyg/tree/master/packages/applications/src/numberGame/Sudoku/useSudoku.ts)

```ts
import { useEffect, useState, useCallback } from 'react';
import { message } from 'antd';
import { useKeyPress } from 'ahooks';
import { intersection, random, cloneDeep } from 'lodash';
/** 每行每列格数 */
export const COUNT = 9;
/** 总格数 */
export const FULL_COUNT = COUNT ** 2;
/** 所有下标合集 */
const INDEX_LIST: [number, number][] = [];
for (let i = 0; i < COUNT; i++) for (let j = 0; j < COUNT; j++) INDEX_LIST.push([i, j]);
/** 初始默认空格数 */
const BLANK_COUNT = 12;
/** 通过行列下标计算块下标 */
const getBlockIndex = (row: number, col: number) => ~~(row / 3) * 3 + ~~(col / 3);
/** 快速生成Set列表 */
const getSetList = () => new Array(COUNT).fill(0).map(_ => new Set<number>());
/** 快速生成下标列表 */
const getIndexList = () =>
  new Array(COUNT).fill(0).map(_ => new Array(COUNT).fill(0).map((_, i) => i + 1));
/** 快速生成一个空数独 */
const getInitBoard: () => number[][] = () =>
  new Array(COUNT).fill(0).map(_ => new Array(COUNT).fill(0));
/** 快速生成一个完整数独 */
const getFullBoard = () => {
  const board = getInitBoard();
  const rowsList: number[][] = getIndexList();
  const colsList: number[][] = getIndexList();
  const blocksList: number[][] = getIndexList();
  const setNum = (row: number, col: number) => {
    if (row === COUNT) return true;
    const nextCol = (col + 1) % COUNT;
    const nextRow = row + +!nextCol;
    const blockIndex = getBlockIndex(row, col);
    const numList = intersection(rowsList[row], colsList[col], blocksList[blockIndex]);
    while (numList.length > 0) {
      const num = numList.splice(random(0, numList.length - 1), 1)[0];
      rowsList[row] = rowsList[row].filter(v => v !== num);
      colsList[col] = colsList[col].filter(v => v !== num);
      blocksList[blockIndex] = blocksList[blockIndex].filter(v => v !== num);
      board[row][col] = num;
      if (setNum(nextRow, nextCol)) return true;
      rowsList[row].push(num);
      colsList[col].push(num);
      blocksList[blockIndex].push(num);
    }
    return false;
  };
  setNum(0, 0);
  return board;
};
/** 检测数独是否有效 */
const checkSudoku = (board: number[][]): boolean => {
  const rowSetList = getSetList();
  const colSetList = getSetList();
  const blockSetList = getSetList();
  for (let row = 0; row < COUNT; row++) {
    for (let col = 0; col < COUNT; col++) {
      const num = board[row][col];
      const rowSet = rowSetList[row];
      const colSet = colSetList[col];
      const blockSet = blockSetList[getBlockIndex(row, col)];
      if (!num || rowSet.has(num) || colSet.has(num) || blockSet.has(num)) return false;
      rowSet.add(num);
      colSet.add(num);
      blockSet.add(num);
    }
  }
  return true;
};
/** 快速生成一个带空格的数独 */
const getHalfBoard = (blankNum: number) => {
  const curBoard = getFullBoard();
  const fullBoard = cloneDeep(curBoard);
  const fixedList = [...INDEX_LIST];
  const emptyList: [number, number][] = [];
  while (blankNum--) {
    const index = fixedList.splice(random(0, fixedList.length - 1), 1)[0];
    emptyList.push(index);
    curBoard[index[0]][index[1]] = 0;
  }
  return { curBoard, fullBoard, fixedList, emptyList };
};
/** 下标格式化 */
export const indexFormat = (i: number, j: number) => `${i}::${j}`;
export const useSudoku = () => {
  /** 空格数 */
  const [blankCount, setBlankCount] = useState(FULL_COUNT - BLANK_COUNT);
  /** 当前数独格 */
  const [curBoard, setCurBoard] = useState<number[][]>(getInitBoard());
  /** 完整数独 */
  const [fullBoard, setFullBoard] = useState<number[][]>(getInitBoard());
  /** 初始默认数字列表 */
  const [fixedSet, setFixedSet] = useState(new Set<string>());
  /** 当前选中的方格 */
  const [active, setActive] = useState<[number, number]>([
    random(0, COUNT - 1),
    random(0, COUNT - 1),
  ]);
  /** 是否显示题解 */
  const [solutionVisible, setSolutionVisible] = useState(false);
  /** 初始化 */
  const init = useCallback(() => {
    const { curBoard, fullBoard, fixedList, emptyList } = getHalfBoard(blankCount);
    setCurBoard(curBoard);
    setFullBoard(fullBoard);
    setFixedSet(new Set(fixedList.map(([row, col]) => indexFormat(row, col))));
    setSolutionVisible(false);
    setActive(emptyList[random(0, emptyList.length - 1)]);
  }, [blankCount, setCurBoard, setFullBoard, setFixedSet, setSolutionVisible]);
  /** 在当前选中的方格中填入数字 */
  const setNum = useCallback(
    (num: number) => {
      const newBoard = [...curBoard];
      newBoard[active[0]][active[1]] = num;
      setCurBoard(newBoard);
    },
    [curBoard, setCurBoard, active]
  );
  useEffect(() => {
    init();
  }, [blankCount]);
  useEffect(() => {
    if (checkSudoku(curBoard)) {
      message.success('你解对啦！');
    }
  }, [curBoard]);
  for (let i = 0; i <= 9; i++) useKeyPress(`${i}`, () => setNum(i));
  return {
    blankCount,
    setBlankCount,
    init,
    active,
    setActive,
    setNum,
    fullBoard,
    curBoard,
    fixedSet,
    solutionVisible,
    setSolutionVisible,
  };
};
```
