---
title: 彩色立方体
order: 3
nav:
  title: 应用合集
  path: /applications
  order: 5
group:
  title: WebGL
  path: /webgl
  order: 3
---

# 彩色立方体

一个彩色立方体

## 应用程序

```jsx
/**
 * inline: true
 */
import React from 'react';
import { Webgl } from '@bestlyg/applications';
export default Webgl.ColorCube;
```

## [核心代码](https://gitee.com/bestlyg/bestlyg/tree/master/packages/applications/src/webgl/common/ColorCube.tsx)

```ts
import React, { useRef, useEffect } from 'react';
import { Webgl, THREE, Sence, Object3D } from '@bestlyg/webgl';
import { useCreation } from 'ahooks';

const { Matrix4, Color } = THREE;
const vertexShaderSource = `
attribute vec4 a_Position;
attribute vec4 a_Color;
uniform mat4 u_ModelMatrix ;
varying vec4 v_Color;
void main(){
  gl_Position = u_ModelMatrix * a_Position;
  v_Color = a_Color;
}
`;
const fragmentShaderSource = `
precision mediump float;
varying vec4 v_Color;
void main(){
  gl_FragColor=v_Color;
}
`;
//    v6----- v5
//   /|      /|
//  v1------v0|
//  | |     | |
//  | |v7---|-|v4
//  |/      |/
//  v2------v3
const arrays = [
  [1, 1, 1], //v0
  [-1, 1, 1], //v1
  [-1, -1, 1], //v2
  [1, -1, 1], //v3
  [1, -1, -1], //v4
  [1, 1, -1], //v5
  [-1, 1, -1], //v6
  [-1, -1, -1], //v7
]
  .flat()
  .map(v => v / 2);
const colors = [
  '#4158D0',
  '#C850C0',
  '#FFCC70',
  '#FF4196',
  '#C850C0',
  '#FFCC70',
  '#FF4196',
  '#4158D0',
]
  .map(color => new Color(color).toArray())
  .flat();
const indexes = [
  [0, 1, 2, 0, 2, 3], // front
  [6, 5, 4, 6, 4, 7], // back
  [1, 6, 7, 1, 7, 2], // left
  [5, 0, 3, 5, 3, 4], // right
  [5, 6, 1, 5, 1, 0], // top
  [4, 7, 2, 4, 2, 3], // bottom
].flat();
export default function ColorCube() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const webglRef = useRef<Webgl>();
  const senceRef = useRef<Sence>();
  const objRef = useRef<Object3D>();
  const rotateMatrixs = useCreation(
    () => [
      new Matrix4().makeRotationX(0.01),
      new Matrix4().makeRotationY(0.008),
      new Matrix4().makeRotationZ(0.005),
    ],
    []
  );
  const modelMatrix = useCreation(() => new Matrix4(), []);
  useEffect(() => {
    const webgl = (webglRef.current = new Webgl({
      canvas: canvasRef.current!,
      size: [300, 300],
    }));
    webgl.context.enable(webgl.context.DEPTH_TEST);
    const sence = (senceRef.current = new Sence(webgl));
    const obj = (objRef.current = new Object3D({
      id: 'cube',
      webgl,
      vertexShaderSource,
      fragmentShaderSource,
      geoProps: {
        attributes: [
          {
            name: 'a_Position',
            data: arrays,
            size: 3,
          },
          {
            name: 'a_Color',
            data: colors,
            size: 3,
          },
        ],
        indexes,
      },
      matProps: {
        uniforms: [
          { name: 'u_ModelMatrix', data: modelMatrix.elements, method: 'uniformMatrix4fv' },
        ],
        textures: [],
      },
      drawTypes: ['TRIANGLES'],
    }));
    sence.add(obj);
    sence.draw();
    (function render() {
      rotateMatrixs.forEach(mat => modelMatrix.multiply(mat));
      sence.setUniform('u_ModelMatrix', modelMatrix.elements);
      sence.draw();
      requestAnimationFrame(render);
    })();
  }, []);
  return <canvas ref={canvasRef} />;
}
```
