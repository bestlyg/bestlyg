---
title: 多着色器绘制
order: 3
nav:
  title: 应用合集
  path: /applications
  order: 5
group:
  title: WebGL
  path: /webgl
  order: 3
---

# 多着色器绘制

生成多个 webgl 程序进行绘制

## 应用程序

```jsx
/**
 * inline: true
 */
import React from 'react';
import { Webgl } from '@bestlyg/applications';
export default Webgl.MultiShaderDrawing;
```

## [核心代码](https://gitee.com/bestlyg/bestlyg/tree/master/packages/applications/src/webgl/common/MultiShaderDrawing.tsx)

```ts
import React, { useRef, useEffect } from 'react';
import { Webgl, THREE, Sence, Object3D } from '@bestlyg/webgl';
import { useCreation } from 'ahooks';
import { cube } from '../assets';

const { Matrix4, Color } = THREE;
const colorCubeVertShader = `
attribute vec4 a_Position;
attribute vec4 a_Color;
uniform mat4 u_ModelMatrix ;
varying vec4 v_Color;
void main(){
  gl_Position = u_ModelMatrix * a_Position;
  v_Color = a_Color;
}
`;
const colorCubeFragShader = `
precision mediump float;
varying vec4 v_Color;
void main(){
  gl_FragColor=v_Color;
}
`;
//    v6----- v5
//   /|      /|
//  v1------v0|
//  | |     | |
//  | |v7---|-|v4
//  |/      |/
//  v2------v3
const arrays = [
  [1, 1, 1], //v0
  [-1, 1, 1], //v1
  [-1, -1, 1], //v2
  [1, -1, 1], //v3
  [1, -1, -1], //v4
  [1, 1, -1], //v5
  [-1, 1, -1], //v6
  [-1, -1, -1], //v7
]
  .flat()
  .map(v => v / 5);
const colors = [
  '#4158D0',
  '#C850C0',
  '#FFCC70',
  '#FF4196',
  '#C850C0',
  '#FFCC70',
  '#FF4196',
  '#4158D0',
]
  .map(color => new Color(color).toArray())
  .flat();
const indexes = [
  [0, 1, 2, 0, 2, 3], // front
  [6, 5, 4, 6, 4, 7], // back
  [1, 6, 7, 1, 7, 2], // left
  [5, 0, 3, 5, 3, 4], // right
  [5, 6, 1, 5, 1, 0], // top
  [4, 7, 2, 4, 2, 3], // bottom
].flat();
const rubikCubeVertShader = `
attribute vec4 a_Position;
attribute vec2 a_Pin;
uniform mat4 u_ModelMatrix ;
varying vec2 v_Pin;
void main(){
  gl_Position = u_ModelMatrix * a_Position;
  v_Pin=a_Pin;
}
`;
const rubikCubeFragShader = `
precision mediump float;
uniform sampler2D u_Sampler;
varying vec2 v_Pin;
void main(){
  gl_FragColor=texture2D(u_Sampler,v_Pin);
}
`;
export default function MultiShaderDrawing() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const webglRef = useRef<Webgl>();
  const senceRef = useRef<Sence>();
  const colorCubeRef = useRef<Object3D>();
  const rubikCubeRef = useRef<Object3D>();
  const rotateMatrixs = useCreation(
    () => [
      new Matrix4().makeRotationX(0.01),
      new Matrix4().makeRotationY(0.008),
      new Matrix4().makeRotationZ(0.005),
    ],
    []
  );
  const colorCubeModelMatrix = useCreation(() => new Matrix4().setPosition(-0.5, 0.5, 0), []);
  const rubikCubeModelMatrix = useCreation(() => new Matrix4().setPosition(0.5, -0.5, 0), []);
  useEffect(() => {
    const webgl = (webglRef.current = new Webgl({
      canvas: canvasRef.current!,
      size: [300, 300],
    }));
    webgl.context.enable(webgl.context.DEPTH_TEST);
    const sence = (senceRef.current = new Sence(webgl));
    const colorCube = (colorCubeRef.current = new Object3D({
      id: 'colorCube',
      webgl,
      vertexShaderSource: colorCubeVertShader,
      fragmentShaderSource: colorCubeFragShader,
      geoProps: {
        attributes: [
          {
            name: 'a_Position',
            data: arrays,
            size: 3,
          },
          {
            name: 'a_Color',
            data: colors,
            size: 3,
          },
        ],
        indexes,
      },
      matProps: {
        uniforms: [
          {
            name: 'u_ModelMatrix',
            data: colorCubeModelMatrix.elements,
            method: 'uniformMatrix4fv',
          },
        ],
        textures: [],
      },
      drawTypes: ['TRIANGLES'],
    }));
    console.log(cube);
    const rubikCube = (rubikCubeRef.current = new Object3D({
      id: 'rubikCube',
      webgl,
      vertexShaderSource: rubikCubeVertShader,
      fragmentShaderSource: rubikCubeFragShader,
      drawTypes: ['TRIANGLES'],
      geoProps: {
        attributes: [
          {
            name: 'a_Position',
            data: cube.arrays.map(v => (v * 2) / 5),
            size: 3,
          },
          {
            name: 'a_Pin',
            data: cube.pins,
            size: 2,
          },
        ],
      },
      matProps: {
        uniforms: [
          {
            name: 'u_ModelMatrix',
            data: rubikCubeModelMatrix.elements,
            method: 'uniformMatrix4fv',
          },
        ],
        textures: [
          {
            name: 'u_Sampler',
            source: cube.image,
            format: 'RGB',
            options: {
              minFilter: 'LINEAR',
            },
          },
        ],
      },
    }));
    sence.add(colorCube);
    sence.add(rubikCube);
    (function render() {
      rotateMatrixs.forEach(mat => {
        colorCubeModelMatrix.multiply(mat);
        rubikCubeModelMatrix.multiply(mat);
      });
      sence.map
        .get('rubikCube')
        ?.material.setUniform('u_ModelMatrix', rubikCubeModelMatrix.elements);
      sence.map
        .get('colorCube')
        ?.material.setUniform('u_ModelMatrix', colorCubeModelMatrix.elements);
      sence.draw();
      requestAnimationFrame(render);
    })();
  }, []);
  return <canvas ref={canvasRef} />;
}
```
