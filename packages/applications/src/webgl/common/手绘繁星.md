---
title: 手绘繁星
order: 3
nav:
  title: 应用合集
  path: /applications
  order: 5
group:
  title: WebGL
  path: /webgl
  order: 3
---

# 手绘繁星

手绘繁星，用鼠标在画布上任意点击即可个点亮一颗星星

- 原理
  - 监听 canvas 单击事件，获取单击时的鼠标相对于于浏览器左上角 0 点的**clientX**,**clientY**,通过此算出基于 webgl 坐标的**x**和**y**
  - 利用 Track 控制每个点的动画方式
  - 利用 Compose 统一管理所有的 Track
  - 利用 requestAnimationFrame 在每一帧进行线性补间

## 应用程序

```jsx
/**
 * inline: true
 */
import React from 'react';
import { Webgl } from '@bestlyg/applications';
export default Webgl.StarDrawWebgl;
```

## [核心代码](https://gitee.com/bestlyg/bestlyg/tree/master/packages/applications/src/webgl/common/StarDrawWebgl.tsx)

```ts
import { WEBGL } from '@bestlyg/shared';
import React, { useEffect, useRef } from 'react';
import { useEventListener } from 'ahooks';
import { sky } from '../assets';
const vertexShaderSource = `
attribute vec4 a_Position;
attribute float a_PointSize;
attribute vec4 a_Color;
varying vec4 v_Color;
void main(){
    gl_Position = a_Position;
    gl_PointSize = a_PointSize;
    v_Color = a_Color;
}
`;
const fragmentShaderSource = `
precision mediump float;
varying vec4 v_Color;
void main(){
    float dist=distance(gl_PointCoord,vec2(0.5,0.5));
    if(dist<0.5){
      gl_FragColor=v_Color;
    }else{
      discard;
    }
}
`;
const pointList: {
  x: number;
  y: number;
  size: number;
  r: number;
  g: number;
  b: number;
  a: number;
}[] = [];
const pointMap = ({
  x,
  y,
  size,
  r,
  g,
  b,
  a,
}: {
  x: number;
  y: number;
  size: number;
  r: number;
  g: number;
  b: number;
  a: number;
}) => [x, y, size, r, g, b, a];
export default function StarDrawWebgl() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const webglRef = useRef<WEBGL.Webgl>();
  const polyRef = useRef<WEBGL.Poly>();
  const composeRef = useRef<WEBGL.Compose>(new WEBGL.Compose());
  useEffect(() => {
    if (!canvasRef.current) return;
    pointList.length = 0;
    const webgl = (webglRef.current = new WEBGL.Webgl({
      canvas: canvasRef.current!,
      vertexShaderSource,
      fragmentShaderSource,
      canvasSize: [600, 400],
    }));
    webgl.color = [0, 0, 0, 0];
    webgl.clear();
    const ctx = webgl.context;
    ctx.enable(ctx.BLEND);
    ctx.blendFunc(ctx.SRC_ALPHA, ctx.ONE_MINUS_SRC_ALPHA);
    const poly = (polyRef.current = new WEBGL.Poly(
      webglRef.current,
      pointList.map(pointMap).flat(),
      ['POINTS'],
      [
        { name: 'a_Position', size: 2 },
        { name: 'a_PointSize', size: 1 },
        { name: 'a_Color', size: 4 },
      ],
      [],
      []
    ));
    polyRef.current.draw();
    (function ani() {
      composeRef.current.update(Date.now());
      poly.data = pointList.map(pointMap).flat();
      poly.updateAttributes();
      poly.draw();
      requestAnimationFrame(ani);
    })();
  }, []);
  useEventListener(
    'click',
    e => {
      const webgl = webglRef.current;
      const poly = polyRef.current;
      const compose = composeRef.current;
      if (!webgl || !poly || !compose) return;
      const { clientX, clientY } = e;
      const position = webgl.transformPosition({ client: [clientX, clientY] }).webgl;
      const item = {
        x: position[0],
        y: position[1],
        size: ~~(Math.random() * 4 + 4),
        r: 0.87,
        g: 0.91,
        b: 1,
        a: 1,
      };
      const track = new WEBGL.Track(item, [
        {
          key: 'a',
          loop: true,
          frames: [
            { time: 0, value: 1 },
            { time: 1000, value: 0 },
            { time: 2000, value: 1 },
          ],
        },
      ]);
      compose.addChildren(track);
      pointList.push(item);
    },
    {
      target: canvasRef.current,
    }
  );
  return (
    <canvas
      ref={canvasRef}
      style={{
        background: `url(${sky.image})`,
        backgroundSize: 'cover',
        backgroundPosition: 'right bottom',
      }}
    />
  );
}
```
