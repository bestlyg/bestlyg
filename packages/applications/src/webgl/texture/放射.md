---
title: 放射
order: 2
nav:
  title: 应用合集
  path: /applications
  order: 5
group:
  title: WebGL
  path: /webgl
  order: 3
---

# 放射

产生极坐标肌理

- 原理
  - 计算当前片元相对于中心点的弧度值
  - 对同一种弧度应用相同的随机算法，使相同弧度的片元颜色相等
  - 通过控制取值范围来控制放射的条数，取值范围越大，相邻弧度越不容易相同颜色，放射条数就越多

## 应用程序

```jsx
/**
 * inline: true
 */
import React from 'react';
import { Webgl } from '@bestlyg/applications';
export default Webgl.RadiationTexture;
```

## [核心代码](https://gitee.com/bestlyg/bestlyg/tree/master/packages/applications/src/webgl/texture/RadiationTexture.tsx)

```ts
import { WEBGL } from '@bestlyg/shared';
import { InputNumber, Space } from 'antd';
import React, { useEffect, useRef, useState } from 'react';
const vertexShaderSource = `
attribute vec4 a_Position;
void main(){
  gl_Position=a_Position;
}
`;
const fragmentShaderSource = `
precision mediump float;
uniform vec2 u_Center ;
float random(vec2 fragCoord){
  vec2 modelVec = vec2(0.123,0.234);
  float randVal = dot( fragCoord , modelVec );
  return fract( sin(randVal) * 10000.0 );
}
void main(){
    vec2 curVec = gl_FragCoord.xy - u_Center;
    float rad = atan(curVec.y,curVec.x) * 10.0;
    float color = random( vec2( int(rad) , 0.0 ) );
    gl_FragColor = vec4( color , color , color , 1.0) ;
}
`;
const CANVAS_SIZE = 300;
export default function RadiationTexture() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const webglRef = useRef<WEBGL.Webgl>();
  const polyRef = useRef<WEBGL.Poly>();
  useEffect(() => {
    webglRef.current = new WEBGL.Webgl({
      canvas: canvasRef.current!,
      vertexShaderSource,
      fragmentShaderSource,
      canvasSize: [CANVAS_SIZE, CANVAS_SIZE],
    });
    polyRef.current = new WEBGL.Poly(
      webglRef.current,
      [-1, 1, -1, -1, 1, 1, 1, -1],
      ['TRIANGLE_STRIP'],
      [{ name: 'a_Position', size: 2 }],
      [
        {
          name: 'u_Center',
          method: 'uniform2fv',
          data: [CANVAS_SIZE / 2, CANVAS_SIZE / 2],
        },
      ]
    );
    polyRef.current.draw();
  }, []);
  return <canvas ref={canvasRef} />;
}
```
