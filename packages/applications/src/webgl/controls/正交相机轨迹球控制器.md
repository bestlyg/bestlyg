---
title: 正交相机轨迹球控制器
order: 4
nav:
  title: 应用合集
  path: /applications
  order: 5
group:
  title: WebGL
  path: /webgl
  order: 3
---

# 正交相机轨迹球控制器

利用鼠标控制画布，进行轨迹球方向上的平移、缩放、旋转

## 应用程序

```jsx
/**
 * inline: true
 */
import React from 'react';
import { Webgl } from '@bestlyg/applications';
export default Webgl.OrthographicTrackballControls;
```

## [核心代码](https://gitee.com/bestlyg/bestlyg/tree/master/packages/applications/src/webgl/controls/OrthographicTrackballControls.tsx)

```ts
import { WEBGL } from '@bestlyg/shared';
import { useCreation, usePersistFn, useMount, useEventListener } from 'ahooks';
import React, { useRef, useEffect } from 'react';
import { Vector3, OrthographicCamera, Quaternion, Matrix4, Vector2 } from 'three';
import { cube } from '../assets';

type ControlsState = WEBGL.ControlsState;
const { ControlsState } = WEBGL;
function useOrthographicTrackballControls({
  canvasRef,
  onUpdated,
  zoomScale = 0.95,
  panDirection = 'xy',
}: {
  canvasRef: React.RefObject<HTMLCanvasElement>;
  onUpdated: () => void;
  zoomScale?: number;
  panDirection?: string;
}) {
  const cameraParams = useCreation(
    () => ({
      width: 3,
      height: 3,
      near: -1,
      far: 6,
      eye: new Vector3(1, 1, 1),
      target: new Vector3(0, 0, 0),
      up: new Vector3(0, 1, 0),
    }),
    []
  );
  const camera = useCreation(
    () =>
      new OrthographicCamera(
        -cameraParams.width / 2,
        cameraParams.width / 2,
        cameraParams.height / 2,
        -cameraParams.height / 2,
        cameraParams.near,
        cameraParams.far
      ),
    []
  );
  const quaternion = useCreation(() => new Quaternion().setFromRotationMatrix(new Matrix4()), []);
  const mat = useCreation(
    () => new Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse),
    []
  );
  const update = usePersistFn(() => {
    camera.lookAt(cameraParams.target);
    camera.updateWorldMatrix(true, false);
    mat.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
    onUpdated();
  });
  useMount(() => {
    camera.position.copy(cameraParams.eye);
    update();
  });
  const state = useRef(ControlsState.NONE);
  const dragStart = useCreation(() => new Vector2(), []);
  const dragEnd = useCreation(() => new Vector2(), []);
  const pan = usePersistFn((delta: Vector2) => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const { right, left, top, bottom, matrix } = camera;
    // 相机宽度
    const width = right - left;
    // 相机高度
    const height = top - bottom;
    // canvas x轴 移动比例
    const ratioX = delta.x / canvas.width;
    // canvas y轴 移动比例
    const ratioY = delta.y / canvas.height;
    // 相机 x轴 移动距离
    const distanceX = ratioX * width;
    // 相机 y轴 移动距离
    const distanceY = ratioY * height;
    // 沿 x轴 移动的量
    const vecX = new Vector3().setFromMatrixColumn(matrix, 0).multiplyScalar(-distanceX);
    // 沿 -z轴 移动的量
    const vecZ = new Vector3()
      .crossVectors(camera.up, new Vector3().setFromMatrixColumn(matrix, 0))
      .multiplyScalar(distanceY);
    // 沿 y轴 移动的量
    const vecY = new Vector3().setFromMatrixColumn(matrix, 1).multiplyScalar(distanceY);
    if (panDirection.includes('x')) {
      cameraParams.target.add(vecX);
      camera.position.add(vecX);
    }
    if (panDirection.includes('y')) {
      cameraParams.target.add(vecY);
      camera.position.add(vecY);
    } else if (panDirection.includes('z')) {
      cameraParams.target.add(vecZ);
      camera.position.add(vecZ);
    }
    update();
  });
  const dooly = usePersistFn((doolyScale: number) => {
    camera.zoom *= doolyScale;
    camera.updateProjectionMatrix();
    update();
  });
  const rotate = usePersistFn((delta: Vector2) => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    const { right, left, top, bottom, matrix, position } = camera;
    const target = cameraParams.target;
    const [width, height] = [right - left, top - bottom];
    const ratioX = delta.x / canvas.width;
    const ratioY = -delta.y / canvas.height;
    const ratioLen = new Vector2(delta.x / canvas.height, ratioY).length();
    const angle = ratioLen * Math.PI * 2;
    const distanceX = ratioX * width;
    const distanceY = ratioY * height;
    const mx = new Vector3().setFromMatrixColumn(matrix, 0);
    const my = new Vector3().setFromMatrixColumn(matrix, 1);
    const vx = mx.clone().multiplyScalar(distanceX);
    const vy = my.clone().multiplyScalar(distanceY);
    const move = vx.clone().add(vy).normalize();
    const eye = position.clone().sub(target).normalize();
    const axis = new Vector3().crossVectors(move, eye);
    quaternion.setFromAxisAngle(axis, angle);
    const rotateOffect = position.clone().sub(target).applyQuaternion(quaternion);
    camera.position.copy(target.clone().add(rotateOffect));
    camera.up.applyQuaternion(quaternion);
    quaternion.setFromRotationMatrix(new Matrix4());
    update();
  });
  const dragMap = useCreation(
    () => ({
      [ControlsState.PAN]: pan,
      [ControlsState.ROTATE]: rotate,
    }),
    []
  );
  useEventListener('contextmenu', e => e.preventDefault(), { target: canvasRef });
  useEventListener(
    'pointerdown',
    ({ button, clientX, clientY }) => {
      dragStart.set(clientX, clientY);
      if (button === 0) {
        // 左键
        state.current = ControlsState.ROTATE;
      } else if (button === 1) {
        // 滚轮
      } else if (button === 2) {
        // 右键
        state.current = ControlsState.PAN;
      }
    },
    { target: canvasRef }
  );
  useEventListener('pointerup', () => (state.current = ControlsState.NONE), { target: canvasRef });
  useEventListener(
    'pointermove',
    ({ clientX, clientY }) => {
      if (state.current === ControlsState.NONE) return;
      dragEnd.set(clientX, clientY);
      dragMap[state.current]?.(dragEnd.clone().sub(dragStart));
      dragStart.copy(dragEnd);
    },
    { target: canvasRef }
  );
  useEventListener(
    'wheel',
    e => {
      e.preventDefault();
      const { deltaY } = e;
      const doolyScale = deltaY > 0 ? zoomScale : 1 / zoomScale;
      dooly(doolyScale);
    },
    { target: canvasRef }
  );
  return {
    camera,
    mat,
  };
}
const vertexShaderSource = `
attribute vec4 a_Position;
attribute vec2 a_Pin;
uniform mat4 u_Matrix ;
varying vec2 v_Pin;
void main(){
  gl_Position = u_Matrix * a_Position;
  v_Pin=a_Pin;
}
`;
const fragmentShaderSource = `
precision mediump float;
uniform sampler2D u_Sampler;
varying vec2 v_Pin;
void main(){
  gl_FragColor=texture2D(u_Sampler,v_Pin);
}
`;

export default function OrthographicTrackballControls() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const webglRef = useRef<WEBGL.Webgl>();
  const polyRef = useRef<WEBGL.Poly>();
  const { mat } = useOrthographicTrackballControls({
    canvasRef,
    onUpdated: () => {
      if (!webglRef.current || !polyRef.current) return;
      webglRef.current!.clear();
      polyRef.current.updateUniforms();
      polyRef.current!.draw();
    },
  });
  useEffect(() => {
    if (!canvasRef.current) return;
    const webgl = (webglRef.current = new WEBGL.Webgl({
      canvas: canvasRef.current!,
      vertexShaderSource,
      fragmentShaderSource,
      canvasSize: [300, 300],
    }));
    const { context } = webgl;
    context.enable(context.CULL_FACE);
    // context.enable(context.DEPTH_TEST);
    webgl.clear();
    const poly = (polyRef.current = new WEBGL.Poly(
      webglRef.current!,
      cube.source,
      ['TRIANGLES'],
      [
        { name: 'a_Position', size: 3 },
        { name: 'a_Pin', size: 2 },
      ],
      [
        {
          name: 'u_Matrix',
          data: mat.elements,
          method: 'uniformMatrix4fv',
        },
      ],
      [
        {
          name: 'u_Sampler',
          source: cube.image,
          format: 'RGB',
          minFilter: 'LINEAR',
        },
      ]
    ));
    poly.async.then(() => {
      webgl.clear();
      poly.draw();
    });
  }, []);
  return <canvas ref={canvasRef} />;
}
```
