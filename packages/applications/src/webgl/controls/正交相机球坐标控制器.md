---
title: 正交相机球坐标控制器
order: 4
nav:
  title: 应用合集
  path: /applications
  order: 5
group:
  title: WebGL
  path: /webgl
  order: 3
---

# 正交相机球坐标控制器

利用鼠标控制画布

## 应用程序

```jsx
/**
 * inline: true
 */
import React from 'react';
import { Webgl } from '@bestlyg/applications';
export default Webgl.OrthographicOrbitControls;
```

## [核心代码](https://gitee.com/bestlyg/bestlyg/tree/master/packages/applications/src/webgl/controls/OrthographicOrbitControls.tsx)

```ts
import { WEBGL, angleToRad, line, sin } from '@bestlyg/shared';
import React, { useEffect, useRef, useState } from 'react';
import { useEventListener, useCreation } from 'ahooks';
import { Matrix4, Vector3 } from 'three';
const vertexShaderSource = `
attribute vec4 a_Position;
attribute float a_PointSize;
attribute vec4 a_Color;
uniform mat4 u_ViewMatrix;
varying vec4 v_Color;
void main(){
    gl_Position = u_ViewMatrix * a_Position;
    gl_PointSize = a_PointSize;
    v_Color = a_Color;
}
`;
const fragmentShaderSource = `
precision mediump float;
varying vec4 v_Color;
void main(){
    float dist=distance(gl_PointCoord,vec2(0.5,0.5));
    if(dist<0.5){
      gl_FragColor=v_Color;
    }else{
      discard;
    }
}
`;
const [width, height] = [1000, 400];
const data: number[] = [];
const pointSize = 6;
const [xCounts, zCounts] = [20, 20];
const [xBlank, zBlank] = [400, 40];
const [xSpaceing, zSpaceing] = [50, 50];
const viewMatrix = new Matrix4().lookAt(
  new Vector3(0.3, 0.3, 1),
  new Vector3(0, 0, 0),
  new Vector3(0, 1, 0)
);
const categorySize = 8;
const color1 = [0, 0.8588235294117647, 0.8705882352941177];
const color2 = [0.9882352941176471, 0, 1];
const a = 0.05;
const init = () => {
  data.length = 0;
  const tempData: number[] = [];
  const reflowList: number[] = [];
  const getCount = (x: number, z: number) => x * xCounts + z;
  for (let x = 0; x < xCounts; x++) {
    for (let z = 0; z < zCounts; z++) {
      if (x !== xCounts - 1 && z !== zCounts - 1) {
        reflowList.push(
          getCount(x, z),
          getCount(x + 1, z),
          getCount(x + 1, z + 1),
          getCount(x, z),
          getCount(x, z + 1),
          getCount(x + 1, z + 1)
        );
      }
      const item = [
        -1 + (xBlank + x * (pointSize + xSpaceing)) / width,
        0,
        -1 + (zBlank + z * (pointSize + zSpaceing)) / height,
        pointSize,
        1,
        1,
        1,
        0.65,
      ];
      tempData.push(...item);
    }
  }
  data.push(...reflowList.map(idx => tempData.slice(idx * 8, (idx + 1) * 8)).flat());
  const firstItem = data.slice(0, categorySize);
  const lastItem = data.slice(-categorySize);
  return {
    lineX: line([firstItem[0], 0], [lastItem[0], Math.PI * 4]),
    lineZ: line([firstItem[2], 0], [lastItem[2], Math.PI * 2]),
    lineR: line([-a, color1[0]], [a, color2[0]]),
    lineG: line([-a, color1[1]], [a, color2[1]]),
    lineB: line([-a, color1[2]], [a, color2[2]]),
  };
};
export default function StarDrawWebgl() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const webglRef = useRef<WEBGL.Webgl>();
  const polyRef = useRef<WEBGL.Poly>();
  const trackRef = useRef<WEBGL.Track>();
  useEffect(() => {
    if (!canvasRef.current) return;
    const track = (trackRef.current = new WEBGL.Track(data, []));
    const { lineX, lineZ, lineR, lineG, lineB } = init();
    for (let i = 0, l = data.length; i < l; i += categorySize) {
      const x = data[i];
      const z = data[i + 2];
      track.updateQueue.push((timestamp, data) => {
        const y = (data[i + 1] = sin(a, 2, lineX(x) + timestamp * 0.004)(lineZ(z)));
        data[i + 4] = lineR(y);
        data[i + 5] = lineG(y);
        data[i + 6] = lineB(y);
      });
    }
    const webgl = (webglRef.current = new WEBGL.Webgl({
      canvas: canvasRef.current!,
      vertexShaderSource,
      fragmentShaderSource,
      canvasSize: [width, height],
    }));
    webgl.clear();
    const ctx = webgl.context;
    ctx.enable(ctx.BLEND);
    ctx.blendFunc(ctx.SRC_ALPHA, ctx.ONE_MINUS_SRC_ALPHA);
    ctx.blendFunc(ctx.SRC_ALPHA, ctx.ONE);
    const poly = (polyRef.current = new WEBGL.Poly(
      webglRef.current,
      data,
      ['TRIANGLES', 'LINES'],
      [
        { name: 'a_Position', size: 3 },
        { name: 'a_PointSize', size: 1 },
        { name: 'a_Color', size: 4 },
      ],
      [{ name: 'u_ViewMatrix', data: viewMatrix.elements, method: 'uniformMatrix4fv' }],
      []
    ));
    polyRef.current.draw();
    (function ani() {
      track.update(Date.now());
      poly.updateAttributes();
      poly.draw();
      requestAnimationFrame(ani);
    })();
  }, []);
  return <canvas ref={canvasRef} />;
}
```
