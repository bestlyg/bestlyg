---
title: 三点渐变
order: 4
nav:
  title: 应用合集
  path: /applications
  order: 5
group:
  title: WebGL
  path: /webgl
  order: 3
---

# 三点渐变

产生不同颜色的三点渐变

- 参数
  - u_Color ： 颜色
  - u_Point : 点
- 原理
  - 当前片元代号:**c**
  - 判断当前片元是否在三角内
    1. 利用弧度是否大于 ∠13x 且小于 ∠23x，判断是否在三角形的弧度内
    1. 利用向量 12 和向量 1c 叉乘判断 z 值，z>0 在向量 12 左边，z<0 在向量 12 右边
  - 求出 ∠13c 与 ∠231 的比值**ratio_3c_21**，通过比值来获取向量 12 与向量 3c 的交点 4 的点坐标**p4**和颜色插值**color4**
    1. 根据**ratio_3c_21**求出 向量 14 = ratio_3c_21 \* 向量 12 = p4 - p1
    1. p4 = p1 + ratio_3c_21 \* 向量 12
  - 根据 3c 的长度与 34 的长度求出比值**ratio_3c_34**
  - 根据**ratio_3c_34**，求出当前片元在**color4**与**color3**的插值

## 应用程序

```jsx
/**
 * inline: true
 */
import React from 'react';
import { Webgl } from '@bestlyg/applications';
export default Webgl.Point3Gradient;
```

## [核心代码](https://gitee.com/bestlyg/bestlyg/tree/master/packages/applications/src/webgl/gradients/Point3Gradient.tsx)

```ts
import { WEBGL, angleToRad } from '@bestlyg/shared';
import React, { useEffect, useRef } from 'react';
import { Color } from 'three';

const vertexShaderSource = `
attribute vec4 a_Position;
void main(){
  gl_Position=a_Position;
}
`;
const fragmentShaderSource = `
precision mediump float;
uniform vec2 u_Center;
uniform mat4 u_Data1;
uniform mat4 u_Data2;
const int Count = 8 ;
vec4 color[Count];
float ratio[Count];
float pi2 = radians( 360.0 );
void load(){
  for(int i = 0 ; i < Count / 2 ; i++ ){
    color[i] = vec4( vec3( u_Data1[i] ) , 1 );
    ratio[i] = u_Data1[i][3];
  }
  for(int i = 0 ; i < Count / 2 ; i++ ){
    color[ 4 + i] = vec4( vec3( u_Data2[i] ) , 1 );
    ratio[ 4 + i] = u_Data2[i][3];
  }
}
vec4 compColor(vec4 color1,vec4 color2,float ratio){
  return color1 + (color2 - color1) * ratio;
}
void main(){
  load();
  vec4 curColor = color[3];
  vec2 curVec = vec2( gl_FragCoord ) - u_Center;
  float curRad = atan( curVec.y , curVec.x );
  if ( curRad < 0.0 ) { curRad += pi2 ; }
  float curRatio = curRad / pi2 ;
  for(int i = 1 ; i < Count ; i++ ){
    if( ratio[i-1] <= curRatio && ratio[i] >= curRatio){
        curColor = compColor(
            color[i-1] ,
            color[i] ,
            (curRatio - ratio[i-1]) / (ratio[i] - ratio[i-1])
        );
        break;
    }
  }
  gl_FragColor = curColor ;

}
`;
/** 画布宽高 */
const CANVAS_SIZE = 300;
export default function PolarGradient() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const webglRef = useRef<WEBGL.Webgl>();
  const polyRef = useRef<WEBGL.Poly>();
  useEffect(() => {
    webglRef.current = new WEBGL.Webgl({
      canvas: canvasRef.current!,
      vertexShaderSource,
      fragmentShaderSource,
      canvasSize: [CANVAS_SIZE, CANVAS_SIZE],
    });
    polyRef.current = new WEBGL.Poly(
      webglRef.current,
      new Float32Array([-1, 1, -1, -1, 1, 1, 1, -1]),
      'TRIANGLE_STRIP',
      [{ name: 'a_Position', size: 2, index: 0, byteIndex: 0 }],
      [
        { name: 'u_Center', data: new Float32Array([150, 150]), method: 'uniform2fv' },
        {
          name: 'u_Data1',
          data: [
            ...new Color('#d71345').toArray(),
            0,
            ...new Color('#f47920').toArray(),
            0.16,
            ...new Color('#a3cf62').toArray(),
            0.32,
            ...new Color('#007947').toArray(),
            0.48,
          ],
          method: 'uniformMatrix4fv',
        },
        {
          name: 'u_Data2',
          data: [
            ...new Color('#009ad6').toArray(),
            0.64,
            ...new Color('#33a3dc').toArray(),
            0.8,
            ...new Color('#8552a1').toArray(),
            0.96,
            ...new Color('#d71345').toArray(),
            1,
          ],
          method: 'uniformMatrix4fv',
        },
      ]
    );
    polyRef.current.draw();
  }, []);
  return <canvas ref={canvasRef}></canvas>;
}
```
