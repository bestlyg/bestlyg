---
title: 2048游戏
nav:
  title: 应用合集
  path: /applications
  order: 4
group:
  title: 数字游戏
  path: /number-game
  order: 2
---

# 2048

在 4\*4 的方格内尽可能获得更高的分数。

## 应用程序

```jsx
/**
 * inline: true
 */
import React from 'react';
import { Game2048 } from '@bestlyg/applications';
export default Game2048;
```

## 核心代码

```ts
import { directionMap, getLocalStorage, setLocalStorage, Direction, lodash } from '@bestlyg/shared';
import { useKeyPress } from 'ahooks';
import { message } from 'antd';
import Color from 'color';
import { useCallback, useEffect, useState } from 'react';
import { useScore } from '../components';

const { cloneDeep, random } = lodash;
/** 行列数 */
export const COUNT = 4;
/** 每合成一个数则获取SCORE_MULTIPLE倍的分数 */
export const SCORE_MULTIPLE = 2;
/** 混入颜色 */
export const mixColor = Color('#66ccff');
/** 初始颜色 */
export const initColor = Color('#bcd6dd');
/** 颜色映射 */
export const colorMap: Record<number, Color> = {
  0: initColor,
  2: initColor.mix(mixColor, 0.2),
};
/** 获取不同的分数所对应的颜色 */
export const getColor = (num: number): Color => {
  let color = colorMap[num];
  if (color) return color;
  return (colorMap[num] = getColor(num / 2).mix(mixColor, 0.2));
};
/** 获取随机单元格 */
export const getRandomCell = (): [number, number] => [random(COUNT - 1), random(COUNT - 1)];
/** 生成初始数组 */
export const getInitNums = (): number[][] =>
  new Array(COUNT).fill(0).map(_ => new Array(COUNT).fill(0));
/** 在所有空格中随机添加2 */
export const addNewNum = (nums: number[][]) => {
  const list: [number, number][] = [];
  for (let i = 0; i < COUNT; i++) {
    for (let j = 0; j < COUNT; j++) {
      if (nums[i][j] === 0) {
        list.push([i, j]);
      }
    }
  }
  const [i, j] = list[random(list.length - 1)];
  nums[i][j] = 2;
};
/** 储存键 */
export const KEY_NUMS = 'GAME_2048_NUMS';

export const useGame2048 = () => {
  /** 分数 */
  const { score, setScore, Tag: SorceTag } = useScore('GAME_2048_');
  /** 数数组 */
  const [nums, setNums] = useState(getInitNums());
  /** 校验是否结束游戏 */
  const checkGameOver = useCallback(() => {
    let isGameOver = true;
    for (let row = 0; row < COUNT; row++) {
      for (let col = 0; col < COUNT; col++) {
        const num = nums[row][col];
        if (
          num === 0 ||
          (col !== COUNT - 1 && num === nums[row][col + 1]) ||
          (row !== COUNT - 1 && num === nums[row + 1][col])
        ) {
          // 如果有空 或者与右侧数相等 或与左侧数相等 则游戏并未结束
          isGameOver = false;
          break;
        }
      }
      if (!isGameOver) break;
    }
    isGameOver && message.info(`游戏结束，本次分数${score}`);
  }, [nums, score]);
  /** 移动 */
  const move = useCallback(
    (direction: Direction) => {
      const newNums = cloneDeep(nums);
      let newScore = score;
      let moved = false;
      // 逐行逐列移动，进行合并数和增加分数
      switch (direction) {
        case 'up': {
          for (let i = 0; i < COUNT; i++) {
            for (let j = 0; j < COUNT; j++) {
              let val = newNums[i][j];
              if (!val) continue;
              newNums[i][j] = 0;
              let p = i;
              while (p - 1 >= 0 && (newNums[p - 1][j] === 0 || newNums[p - 1][j] === val)) {
                p--;
                moved = true;
                if (newNums[p][j] === val) {
                  val *= 2;
                  newScore += val * SCORE_MULTIPLE;
                  newNums[p][j] = 0;
                  break;
                }
              }
              newNums[p][j] = val;
            }
          }
          break;
        }
        case 'down': {
          for (let i = COUNT - 1; i >= 0; i--) {
            for (let j = COUNT - 1; j >= 0; j--) {
              let val = newNums[i][j];
              if (!val) continue;
              newNums[i][j] = 0;
              let p = i;
              while (p + 1 < COUNT && (newNums[p + 1][j] === 0 || newNums[p + 1][j] === val)) {
                p++;
                moved = true;
                if (newNums[p][j] === val) {
                  val *= 2;
                  newScore += val * SCORE_MULTIPLE;
                  newNums[p][j] = 0;
                  break;
                }
              }
              newNums[p][j] = val;
            }
          }
          break;
        }
        case 'left': {
          for (let i = 0; i < COUNT; i++) {
            for (let j = 0; j < COUNT; j++) {
              let val = newNums[i][j];
              if (!val) continue;
              newNums[i][j] = 0;
              let p = j;
              while (p - 1 >= 0 && (newNums[i][p - 1] === 0 || newNums[i][p - 1] === val)) {
                p--;
                moved = true;
                if (newNums[i][p] === val) {
                  val *= 2;
                  newScore += val * SCORE_MULTIPLE;
                  newNums[i][p] = 0;
                  break;
                }
              }
              newNums[i][p] = val;
            }
          }
          break;
        }
        case 'right': {
          for (let i = COUNT - 1; i >= 0; i--) {
            for (let j = COUNT - 1; j >= 0; j--) {
              let val = newNums[i][j];
              if (!val) continue;
              newNums[i][j] = 0;
              let p = j;
              while (p + 1 < COUNT && (newNums[i][p + 1] === 0 || newNums[i][p + 1] === val)) {
                p++;
                moved = true;
                if (newNums[i][p] === val) {
                  val *= 2;
                  newScore += val * SCORE_MULTIPLE;
                  newNums[i][p] = 0;
                  break;
                }
              }
              newNums[i][p] = val;
            }
          }
          break;
        }
      }
      if (!moved) {
        message.error(`没法继续${directionMap[direction]}移啦！`);
        return;
      }
      addNewNum(newNums);
      setScore(newScore);
      setNums(newNums);
    },
    [nums, score, checkGameOver]
  );
  /** 重置单元格 */
  const reset = useCallback(() => {
    const newNums = getInitNums();
    const [i1, j1] = getRandomCell();
    newNums[i1][j1] = 2;
    let [i2, j2] = getRandomCell();
    while (i1 === i2 && j1 === j2) [i2, j2] = getRandomCell();
    newNums[i2][j2] = 2;
    setNums(newNums);
    setScore(0);
  }, []);
  /** 从缓存中读取数据*/
  useEffect(() => {
    try {
      const numsStr = getLocalStorage(KEY_NUMS);
      if (!numsStr) throw new Error();
      const nums = JSON.parse(numsStr);
      setNums(nums);
    } catch {
      reset();
    }
  }, []);
  /** 数数组改变时设置缓存和检测游戏是否结束 */
  useEffect(() => {
    setLocalStorage(KEY_NUMS, JSON.stringify(nums));
    checkGameOver();
  }, [nums]);
  // 方向键触发，禁止滚动
  useKeyPress(Direction.UP, e => {
    e.preventDefault();
    move(Direction.UP);
  });
  useKeyPress(Direction.DOWN, e => {
    e.preventDefault();
    move(Direction.DOWN);
  });
  useKeyPress(Direction.LEFT, e => {
    e.preventDefault();
    move(Direction.LEFT);
  });
  useKeyPress(Direction.RIGHT, e => {
    e.preventDefault();
    move(Direction.RIGHT);
  });
  return {
    SorceTag,
    nums,
    reset,
    move,
  };
};
```
