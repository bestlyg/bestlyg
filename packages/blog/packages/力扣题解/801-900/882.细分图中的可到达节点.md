---
title: 882. 细分图中的可到达节点
order: 882
nav:
  title: 力扣题解
  path: /leetcode
  order: 4
group:
  title: 801-900
  path: /801-900
  order: 801
---

# 882. 细分图中的可到达节点
    
> 链接：[882. 细分图中的可到达节点](https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/)  
> 难度：困难  
> 标签：图、最短路、堆(优先队列)  
> 简介：给你原始图和 maxMoves ，返回 新的细分图中从节点 0 出发 可到达的节点数 。
      
## 题解 1 - cpp
- 编辑时间：2022.11.26
- 执行用时：268ms
- 内存消耗：70.6MB
- 编程语言：cpp
- 解法介绍：Dijkstra。
```cpp
struct Node {
    int visit;
    unordered_map<int, int> to;
    vector<int> next;
    Node(): visit(-1) {}
};
struct Item {
    int from, to, cnt;
    Item() {}
    Item(int from, int to, int cnt): from(from), to(to), cnt(cnt) {}
};
class Solution {
public:
    int reachableNodes(vector<vector<int>>& edges, int maxMoves, int n) {
        vector<Node> list(n);
        unordered_map<int, unordered_map<int, int>> mcnt;
        for (auto &edge : edges) {
            int from = edge[0], to = edge[1], cnt = edge[2];
            list[from].next.push_back(to);
            list[to].next.push_back(from);
            mcnt[from][to] = mcnt[to][from] = cnt;
        }
        auto ItemCmp = [&](Item &a, Item &b){ return a.cnt < b.cnt; };
        priority_queue<Item, vector<Item>, decltype(ItemCmp)> q(ItemCmp);
        q.push(Item(-1, 0, maxMoves));
        list[0].visit = maxMoves;
        while (q.size()) {
            Item item = q.top();
            q.pop();
            for (auto &next : list[item.to].next) {
                int cnt = mcnt[item.to][next];
                if (cnt > 0 && item.cnt <= cnt) 
                    list[item.to].to[next] = max(item.cnt, list[item.to].to[next]);
                else {
                    list[item.to].to[next] = cnt;
                    int surplus = item.cnt - cnt - 1;
                    if (surplus > list[next].visit) {
                        list[next].visit = surplus;
                        if (surplus > 0) q.push(Item(item.to, next, surplus));
                    }
                }
            }
        }
        int ans = 0;
        for (int i = 0; i < list.size(); i++) {
            if (list[i].visit != -1) ans++;
            for (auto &item : list[i].to) {
                if (item.first >= i || list[item.first].to[i] == 0) 
                    ans += min(mcnt[i][item.first], item.second + list[item.first].to[i]);
            }
        }
        return ans;
    }
};
```

      