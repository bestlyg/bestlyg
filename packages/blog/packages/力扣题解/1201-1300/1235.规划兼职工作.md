---
title: 1235. 规划兼职工作
order: 1235
nav:
  title: 力扣题解
  path: /leetcode
  order: 4
group:
  title: 1201-1300
  path: /1201-1300
  order: 1201
---

# 1235. 规划兼职工作
    
> 链接：[1235. 规划兼职工作](https://leetcode.cn/problems/maximum-profit-in-job-scheduling/)  
> 难度：困难  
> 标签：数组、二分查找、动态规划、排序  
> 简介：给你一份兼职工作表，包含开始时间 startTime，结束时间 endTime 和预计报酬 profit 三个数组，请你计算并返回可以获得的最大报酬。
      
## 题解 1 - cpp
- 编辑时间：2022.10.22
- 执行用时：252ms
- 内存消耗：64.1MB
- 编程语言：cpp
- 解法介绍：dp存储当前点选中和不选中两种情况，利用map快速查找当前节点启动前结束的最大值。
```cpp
struct Node { int l, r, profit; };
class Solution {
public:
    map<int, int> m;
    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {
        int n = startTime.size();
        vector<Node> list(n);
        for (int i = 0; i < n; i++) {
            list[i].l = startTime[i];
            list[i].r = endTime[i];
            list[i].profit = profit[i];
        }
        sort(list.begin(), list.end(), [](Node &a, Node &b){ return a.r < b.r; });
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][1] = list[0].profit;
        m[list[0].r] = list[0].profit;
        for (int i = 1; i < n; i++) {
            dp[i][1] += list[i].profit;
            dp[i][0] = max(dp[i][0], dp[i - 1][0]);
            dp[i][0] = max(dp[i][0], dp[i - 1][1]);
            auto upper = m.upper_bound(list[i].l);
            upper--;
            if (upper->first <= list[i].l) dp[i][1] = upper->second + list[i].profit;
            m[list[i].r] = max(m[list[i].r], max(dp[i][0], dp[i][1]));
        }
        return max(dp[n - 1][0], dp[n - 1][1]);
    }
};
```

      