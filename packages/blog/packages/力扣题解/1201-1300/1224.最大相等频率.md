---
title: 1224. 最大相等频率
order: 1224
nav:
  title: 力扣题解
  path: /leetcode
  order: 4
group:
  title: 1201-1300
  path: /1201-1300
  order: 1201
---

# 1224. 最大相等频率
    
> 链接：[1224. 最大相等频率](https://leetcode.cn/problems/maximum-equal-frequency/)  
> 难度：困难  
> 标签：数组、哈希表  
> 简介：给你一个正整数数组 nums，请你帮忙从该数组中找出能满足下面要求的 最长 前缀，并返回该前缀的长度。
      
## 题解 1 - rust
- 编辑时间：2022.08.18
- 执行用时：52ms
- 内存消耗：3.4MB
- 编程语言：rust
- 解法介绍：只有三种情况可以成立，1.最大频率只有一，2.所有数只有最大频率和第二大频率且最大频率只有一种数，3.所有数除了一个都是最大频率，剩下的一个数频率是1。
```rust
impl Solution {
    pub fn max_equal_freq(nums: Vec<i32>) -> i32 {
        use std::collections::HashMap;
        let (mut freq_map, mut cnt_map) =
            (HashMap::<usize, usize>::new(), HashMap::<i32, usize>::new());
        let mut ans = 0;
        let mut max_freq = 0;
        for i in 0..nums.len() {
            let num = nums[i];
            let cnt = cnt_map.get(&num).unwrap_or(&0);
            let prev_freq = freq_map.get_mut(cnt);
            if prev_freq.is_some() {
                *prev_freq.unwrap() -= 1;
            }
            let cnt = *cnt + 1;
            cnt_map.insert(num, cnt);
            freq_map.insert(cnt, freq_map.get(&cnt).unwrap_or(&0) + 1);
            max_freq = max_freq.max(cnt);
            if max_freq == 1
                || freq_map.get(&max_freq).unwrap_or(&0) * max_freq
                    + freq_map.get(&(max_freq - 1)).unwrap_or(&0) * (max_freq - 1)
                    == i + 1
                    && *freq_map.get(&max_freq).unwrap_or(&0) == 1
                || freq_map.get(&max_freq).unwrap_or(&0) * max_freq == i
                    && *freq_map.get(&1).unwrap_or(&0) == 1
            {
                ans = i + 1;
            }
        }
        ans as i32
    }
}
```

      