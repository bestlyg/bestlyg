---
title: 6248. 统计中位数为 K 的子数组
order: 6248
nav:
  title: 力扣题解
  path: /leetcode
  order: 4
group:
  title: 6201-6300
  path: /6201-6300
  order: 6201
---

# 6248. 统计中位数为 K 的子数组
    
> 链接：[6248. 统计中位数为 K 的子数组](https://leetcode.cn/problems/count-subarrays-with-median-k)  
> 难度：困难  
> 标签：  
> 简介：给你一个长度为 n 的数组 nums ，该数组由从 1 到 n 的 不同 整数组成。另给你一个正整数 k 。统计并返回 num 中的 中位数 等于 k 的非空子数组的数目。
      
## 题解 1 - cpp
- 编辑时间：2022.11.27
- 执行用时：76ms
- 内存消耗：51.4MB
- 编程语言：cpp
- 解法介绍：因为是中位数且只有一个，找到唯一的k，向左遍历记录情况存储，再向右遍历统计。
```cpp
#define X first
#define Y second
#define lb(x) ((x) & (-x))
#define mem(a,b) memset(a,b,sizeof(a))
#define debug freopen("r.txt","r",stdin)
#define pi pair<int,int>
using namespace std;
typedef long long ll;

class Solution {
public:
    int countSubarrays(vector<int>& nums, int k) {
        int ans = 1, idx = findK(nums, k), n = nums.size();
        unordered_map<int, int> m;
        pi item = make_pair(0, 0);
        for (int i = idx - 1; i >= 0; i--) {
            if (nums[i] > k) item.Y += 1;
            else item.X += 1;
            if (item.Y - item.X == 0 || item.Y - item.X == 1) ans++;
            m[item.Y - item.X]++;
        }
        item = make_pair(0, 0);
        for (int j = idx + 1; j < n; j++) {
          if (nums[j] > k) item.Y += 1;
          else item.X += 1;
          if (item.Y - item.X == 0) ans += 1 + m[0] + m[1];
          else if (item.Y - item.X == 1) ans += 1 + m[0] + m[-1];
          else ans += m[item.X - item.Y] + m[item.X - item.Y + 1];
        }
        return ans;
    }
    int findK(vector<int>& nums, int k) {
      for (int i = 0; i < nums.size(); i++) if (nums[i] == k) return i;
      return -1;
    }
};
```

      