---
title: 6285. 执行 K 次操作后的最大分数
order: 6285
nav:
  title: 力扣题解
  path: /leetcode
  order: 4
group:
  title: 6201-6300
  path: /6201-6300
  order: 6201
---

# 6285. 执行 K 次操作后的最大分数

> 链接：[6285. 执行 K 次操作后的最大分数](https://leetcode.cn/problems/maximal-score-after-applying-k-operations/)  
> 难度：中等  
> 标签：  
> 简介：给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。你的 起始分数 为 0 。返回在 恰好 执行 k 次操作后，你可能获得的最大分数。

## 题解 1 - c++

- 编辑时间：2023.01.08
- 执行用时：160ms
- 内存消耗：70.8MB
- 编程语言：c++
- 解法介绍：堆。

```c++
class Solution {
public:
    long long maxKelements(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        priority_queue<int> q;
        long long ans = 0;
        int idx = nums.size() - 1;
        while (k--) {
            if (q.size() && (idx < 0 || q.top() >= nums[idx])) {
                int num = q.top();
                q.pop();
                ans += num;
                q.push(ceil(1.0 * num / 3));
            } else {
                int num = nums[idx--];
                ans += num;
                q.push(ceil(1.0 * num / 3));
            }
        }
        return ans;
    }
};
```

## 题解 2 - rust

- 编辑时间：2023.01.08
- 执行用时：36ms
- 内存消耗：4.6MB
- 编程语言：rust
- 解法介绍：同上。

```rust
use std::collections::BinaryHeap;
impl Solution {
    pub fn max_kelements(nums: Vec<i32>, k: i32) -> i64 {
        let mut k = k;
        let mut heap = BinaryHeap::new();
        for num in nums {
            heap.push(num);
        }
        let mut ans: i64 = 0;
        while k != 0 {
            let num = heap.pop().unwrap() as i64;
            ans += num;
            let num = (num as f64 / 3.0).ceil() as i32;
            heap.push(num);
            k -= 1;
        }
        ans
    }
}
```
