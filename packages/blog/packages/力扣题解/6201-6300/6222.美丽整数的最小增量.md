---
title: 6222. 美丽整数的最小增量
order: 6222
nav:
  title: 力扣题解
  path: /leetcode
  order: 4
group:
  title: 6201-6300
  path: /6201-6300
  order: 6201
---

# 6222. 美丽整数的最小增量

> 链接：[6222. 美丽整数的最小增量](https://leetcode.cn/problems/minimum-addition-to-make-integer-beautiful/)  
> 难度：中等  
> 标签：  
> 简介：找出并返回满足 n + x 是 美丽整数 的最小非负整数 x 。生成的输入保证总可以使 n 变成一个美丽整数。

## 题解 1 - cpp

- 编辑时间：2022.10.30
- 执行用时：0ms
- 内存消耗：5.7MB
- 编程语言：cpp
- 解法介绍：通过把每一位都变成 0 尝试是否总数小于 target。

```cpp

  class Solution {
  public:
      long long n;
      int target;
      int getCnt() {
          long long num = n;
          int cnt = 0;
          while (num) {
              cnt++;
              num /= 10;
          }
          return cnt;
      }
      long long comp(int size) {
          long long num = n, val = 0, m = 1;
          for (int i = 0; i < size; i++) {
              val = (num % 10) * m + val;
              // cout << "Val = " << val << endl;
              num /= 10;
              m *= 10;
          }
          return n - val + m;
      }
      int sum(long long num) {
          int sum = 0;
          while (num) {
              sum += num % 10;
              num /= 10;
          }
          return sum;
      }
      long long makeIntegerBeautiful(long long n, int target) {
          if (sum(n) <= target) return 0;
          this->n = n;
          this->target = target;
          int cnt = getCnt();
          int l = 0, r = cnt;
          while (l < r) {
              int m = (l + r) / 2;
              long long num = comp(m);
              if (sum(num) <= target) r = m;
              else l = m + 1;
          }
          return comp(l) - n;
      }
  };
```
