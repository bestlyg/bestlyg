---
title: 6255. 两个城市间路径的最小分数
order: 6255
nav:
  title: 力扣题解
  path: /leetcode
  order: 4
group:
  title: 6201-6300
  path: /6201-6300
  order: 6201
---

# 6255. 两个城市间路径的最小分数
    
> 链接：[6255. 两个城市间路径的最小分数](https://leetcode.cn/problems/minimum-score-of-a-path-between-two-cities/)  
> 难度：中等  
> 标签：  
> 简介：城市 1 和城市 n 之间的所有路径的 最小 分数。
      
## 题解 1 - cpp
- 编辑时间：2022.12.04
- 执行用时：412ms
- 内存消耗：130.8MB
- 编程语言：cpp
- 解法介绍：因为同一条路可以走多次，且1和n一定存在路，遍历1出发的所有路，找到最小值即可。
```cpp
#include <iostream>
#include <vector>
// bestlyg
# define X first
# define Y second
# define lb(x) ((x) & (-x))
# define mem(a,b) memset(a,b,sizeof(a))
# define debug freopen("r.txt","r",stdin)
# define pi pair<int,int>

#ifdef DEBUG
#define log(frm, args...) {    printf(frm, ##args); }
#else
#define log(frm, args...)
#endif
typedef long long ll;

using namespace std;

class Solution {
public:
    int minScore(int n, vector<vector<int>>& roads) {
        vector<vector<pi>> list(n);
        for (auto &road : roads) {
            int v1 = road[0] - 1, v2 = road[1] - 1;
            list[v1].push_back(make_pair(v2, road[2]));
            list[v2].push_back(make_pair(v1, road[2]));
        }
        int ans = 0x7fffffff;
        unordered_set<int> s;
        queue<int> q;
        q.push(0);
        s.insert(0);
        while (q.size()) {
            int cur = q.front();
            q.pop();
            for (auto &next : list[cur]) {
                ans = min(ans, next.Y);
                if (s.count(next.X)) continue;
                q.push(next.X);
                s.insert(next.X);
            }

        }
        return ans;
    }
};
```

      