---
title: 1775. 通过最少操作次数使数组的和相等
order: 1775
nav:
  title: 力扣题解
  path: /leetcode
  order: 4
group:
  title: 1701-1800
  path: /1701-1800
  order: 1701
---

# 1775. 通过最少操作次数使数组的和相等
    
> 链接：[1775. 通过最少操作次数使数组的和相等](https://leetcode.cn/problems/equal-sum-arrays-with-minimum-number-of-operations/submissions/)  
> 难度：中等  
> 标签：贪心、数组、哈希表、计数  
> 简介：请你返回使 nums1 中所有数的和与 nums2 中所有数的和相等的最少操作次数。
      
## 题解 1 - cpp
- 编辑时间：2022.12.07
- 执行用时：116ms
- 内存消耗：111.3MB
- 编程语言：cpp
- 解法介绍：统计每个数的个数后遍历。
```cpp
class Solution {
public:
    int minOperations(vector<int>& nums1, vector<int>& nums2) {
        int n1 = nums1.size(), sum1 = accumulate(nums1.begin(), nums1.end(), 0), l1[7] = {0},
            n2 = nums2.size(), sum2 = accumulate(nums2.begin(), nums2.end(), 0), l2[7] = {0};
        for (auto &num : nums1) l1[num]++;
        for (auto &num : nums2) l2[num]++;
        if (sum1 > sum2) swap(n1, n2), swap(sum1, sum2), swap(l1, l2);
        if (sum1 == sum2) return 0;
        if (!(n2 >= n1 && n2 <= n1 * 6 || n1 >= n2 && n1 <= n2 * 6)) return -1;
        int ans = 0;
        for (int i = 1; i <= 6; i++) ans += comp(l1, l2, i, sum1, sum2);
        return ans;
    }
    int comp(int *l1, int *l2, int num, int &sum1, int &sum2) {
        int ans = 0;
        for (int i = 6; i > num; i--) {
            while (l1[num] && i - num + sum1 <= sum2) ans++, l1[num]--, sum1 += i - num;
            while (l2[7 - num] && i - num + sum1 <= sum2) ans++, l2[7 - num]--, sum2 -= i - num;
        }
        return ans;
    }
};
```

      