/// # cargo run --example 2023-8-7
/// - 请阅读比特币白皮书，并写下你的观后感。需条理清晰，200字以上。
/// - 比特币白皮书：https://bitcoin.org/files/bitcoin-paper/bitcoin_zh_cn.pdf
/// 
/// 相比较于传统的一个网络中交易来说，存在太多的不信任，对于一个网络来说所有数据都是基于0和1。
/// 当一个用户把一个币转给另一个用户时，如何确保付款者的币会减少，如何确保收款者的币会增多，如何确保付款者只扣一次，收款者只增加一次且不会有其他收款者，如何确保付款者有足够的币。
/// 传统的做法是有一个中间人，付款者把钱给中间人，中间人把钱给收款者。由中间人来确保付款者和收款者的信息。
/// 这样就需要这个中间人足够的安全和诚信。
/// 
/// 所以比特币中提出一种概念，基于密码学来确保信任的问题。
/// 对于一串电子货币，只需要拿到所有的交易和顺序，就可以从初始值开始计算出当前的值。
/// 通过对每一个块进行hash，来获取到一个特殊的字符串当作唯一标识符，
/// 他依赖于上一个块的hash，依赖于一个有序的时间戳，依赖于收款人的信息，依赖于付款人私钥的一个签名（利用椭圆曲线算法），再加上一个随机值。
/// 并且可以用付款人的公钥去验证他的信息真伪。
/// 再把这些块串成一个链结构，每一个块都是需要消耗CPU的算力，这就可以解决获取到所有的交易和顺序，从而解决信任问题。
/// 
/// 将一个块的信息教给一群矿工，由他们负责计算块的hash，但是由于时间等因素，他们可能计算出的天差地别
/// 那么如何来生成一个块的hash，用到了POW。
/// 让矿工们去计算hash并且要求前X位都是0，随着X的增大消耗的算力也越大，会优先采用先算出符合值的矿工算出的hash
/// 因为这个计算只能通过更改随机值进行穷举，最先算出来的代表他们足够努力。
/// 
/// 当采纳一个符合要求的hash时，会进行广播去通知其他的节点这个块的hash。
/// 但是因为时间差的存在，可能存在两个矿工在差不多的时间算出了一个符合要求的hash，此时会同时采用两个hash，
/// 随着时间慢慢的推移，总会存在一个链的长度大于另一个长度，节点会优先采取最长的链当作正确的链，而短的链会在后面被重组。
/// 这样久而久之节点只会保证最长链是唯一的。
/// 
/// 当矿工交付一个符合的hash时，将会被奖励币，这样能够使得币的数量会稳定的增加。
/// 如果存在一个攻击者，他掌握了一些节点想篡改交易信息，使得一些数据产生错误，那么他需要掌握超过一半的节点，
/// 因为当数据发生不对等的时候，总是信任多的那一方。
/// 那么攻击者就需要掌握超过一半的算力，但是此时他也将会获得超过一半的奖励，此时相比于继续攻击，显然当个诚实节点收益更大。
/// 
/// 而节点中存储的信息是一直存在的，随着交易的增多存储的数据量会一直增大，所以比特币采用merkle tree的方式来存储节点的头信息，这样每一个头大约需要存储80KB的信息，完全能够cover。
/// 
/// 下面经过一系列算法证明大约距离当前块后面产生了6个块左右，那么当前块可以被认为是稳定的。
/// 
/// 
/// 总结：
/// 文章中首先指出了现阶段互联网中心化的交易系统中一些存在的问题，主要问题是信任。
/// 所以我们需要一种去中心化的交易系统，他能够让用户点对点的交易，而不需要依赖中心化的第三方。
/// 他通过密码学来保证了每一笔交易的可信，以及工作量证明机制、节点间的通信协议、交易验证和防止双重支付等技术细节。
/// 使用户可以在没有中介机构的情况下进行安全、快速和低成本的交易。
/// 
fn main() {
    println!("Bitcoin: A Peer-to-Peer Electronic Cash System");
}

