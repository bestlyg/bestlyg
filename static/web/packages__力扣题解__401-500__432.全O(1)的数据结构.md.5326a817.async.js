(self["webpackChunkblog"]=self["webpackChunkblog"]||[]).push([[84998],{31680:function(e,n,t){"use strict";t.r(n);var o=t(96832),c=t(22131),d=t(89730),r=o.memo((e=>{e.demos;return o.createElement(o.Fragment,null,o.createElement("div",{className:"markdown"},o.createElement("h1",{id:"432-\u5168-o1-\u7684\u6570\u636e\u7ed3\u6784"},o.createElement(c.AnchorLink,{to:"#432-\u5168-o1-\u7684\u6570\u636e\u7ed3\u6784","aria-hidden":"true",tabIndex:-1},o.createElement("span",{className:"icon icon-link"})),"432. \u5168 O(1) \u7684\u6570\u636e\u7ed3\u6784"),o.createElement("blockquote",null,o.createElement("p",null,"\u94fe\u63a5\uff1a",o.createElement(c.Link,{to:"https://leetcode-cn.com/problems/all-oone-data-structure/"},"432. \u5168 O(1) \u7684\u6570\u636e\u7ed3\u6784"),o.createElement("br",null),"\u96be\u5ea6\uff1a\u56f0\u96be",o.createElement("br",null),"\u6807\u7b7e\uff1a\u8bbe\u8ba1\u3001\u54c8\u5e0c\u8868\u3001\u94fe\u8868\u3001\u53cc\u5411\u94fe\u8868",o.createElement("br",null),"\u7b80\u4ecb\uff1a\u8bf7\u4f60\u8bbe\u8ba1\u4e00\u4e2a\u7528\u4e8e\u5b58\u50a8\u5b57\u7b26\u4e32\u8ba1\u6570\u7684\u6570\u636e\u7ed3\u6784\uff0c\u5e76\u80fd\u591f\u8fd4\u56de\u8ba1\u6570\u6700\u5c0f\u548c\u6700\u5927\u7684\u5b57\u7b26\u4e32\u3002")),o.createElement("h2",{id:"\u9898\u89e3-1---c"},o.createElement(c.AnchorLink,{to:"#\u9898\u89e3-1---c","aria-hidden":"true",tabIndex:-1},o.createElement("span",{className:"icon icon-link"})),"\u9898\u89e3 1 - c++"),o.createElement("ul",null,o.createElement("li",null,"\u7f16\u8f91\u65f6\u95f4\uff1a2022.03.16"),o.createElement("li",null,"\u6267\u884c\u7528\u65f6\uff1a136ms"),o.createElement("li",null,"\u5185\u5b58\u6d88\u8017\uff1a55.9MB"),o.createElement("li",null,"\u7f16\u7a0b\u8bed\u8a00\uff1ac++"),o.createElement("li",null,"\u89e3\u6cd5\u4ecb\u7ecd\uff1a\u5229\u7528\u54c8\u5e0c\u5220\u67e5 O1\uff0c\u94fe\u8868\u589e\u5220 O1 \u6765\u7ef4\u62a4\u7ed3\u6784\u3002")),o.createElement(d.Z,{code:'class VNode {\n   public:\n    int cnt;\n    string value;\n    VNode(string _value) {\n        value = _value;\n        cnt = 1;\n    }\n};\nclass CNode {\n   public:\n    int value;\n    CNode *prev, *next;\n    unordered_set<VNode *> children;\n    CNode(int _value, CNode *_prev = NULL) {\n        value = _value;\n        prev = _prev;\n        next = NULL;\n        if (prev) {\n            insert(prev);\n        }\n    }\n    void insert(CNode *prev) {\n        CNode *next = prev->next;\n        prev->next = this;\n        next->prev = this;\n        this->next = next;\n        this->prev = prev;\n    };\n    void remove() {\n        if (prev) prev->next = next;\n        if (next) next->prev = prev;\n        prev = NULL;\n        next = NULL;\n    };\n};\nclass AllOne {\n   public:\n    unordered_map<string, VNode *> vmap;\n    unordered_map<int, CNode *> cmap;\n    // first min | last max\n    CNode *first = new CNode(-1), *last = new CNode(-1);\n    void\n    log() { /*\n    cout << "======START LOG=====" << endl;\n    cout << "CNode : first -> ";\n    CNode *p = first->next;\n    while (p != last) {\n        cout << "(" << p->prev->value << ", " << p->value << ", "\n             << p->next->value << ") -> ";\n        p = p->next;\n    }\n    cout << "last" << endl;\n\n    cout << "VMap" << endl;\n    for (auto &it : vmap) {\n        cout << "(" << it.first << ", " << it.second->cnt << ")" << endl;\n    }\n\n    cout << "CMap" << endl;\n    for (auto &it : cmap) {\n        cout << "(" << it.first << ", " << it.second->children.size() << ")"\n             << endl;\n    }\n    cout << "======END LOG=====" << endl;*/\n    }\n    AllOne() {\n        first->next = last;\n        last->prev = first;\n    }\n    /*\n    ~AllOne() {\n        last = NULL;\n        CNode *p = first;\n        while (p) {\n            CNode *cur = p;\n            p = p->next;\n            cur->remove();\n            delete cur;\n        }\n    }\n    */\n    void inc(string key) {\n        // cout << "inc " << key << endl;\n        if (vmap.count(key))\n            inc_key(key);\n        else\n            inc_nokey(key);\n        log();\n    }\n    // \u589e\u52a0key\u4e14\u5f53\u524d\u5b58\u5728\n    void inc_key(string key) {\n        VNode *vnode = vmap[key];\n        CNode *cnode = cmap[vnode->cnt];\n        cnode->children.erase(vnode);\n        if (cnode->children.size() == 0) {\n            CNode *prev = cnode->prev;\n            cnode->remove();\n            cmap.erase(cnode->value);\n            delete cnode;\n            cnode = prev;\n        }\n        vnode->cnt += 1;\n        if (cnode->next->value == vnode->cnt) {\n            cnode->next->children.insert(vnode);\n        } else {\n            CNode *cnode_next = new CNode(vnode->cnt, cnode);\n            cnode_next->children.insert(vnode);\n            cmap[vnode->cnt] = cnode_next;\n        }\n    }\n    // \u589e\u52a0key\u4e14\u5f53\u524d\u4e0d\u5b58\u5728\n    void inc_nokey(string key) {\n        VNode *vnode = new VNode(key);\n        vmap[key] = vnode;\n        CNode *cnode =\n            first->next->value == 1 ? cmap[1] : (cmap[1] = new CNode(1, first));\n        cnode->children.insert(vnode);\n    }\n    void dec(string key) {\n        // cout << "dec " << key << endl;\n        if (vmap[key]->cnt == 1) {\n            dec_nokey(key);\n        } else {\n            dec_key(key);\n        }\n        log();\n    }\n    // \u51cf\u5c11key\u4e14\u5f53\u524d\u5b58\u5728\n    void dec_key(string key) {\n        VNode *vnode = vmap[key];\n        CNode *cnode = cmap[vnode->cnt], *prev = cnode->prev;\n        cnode->children.erase(vnode);\n        if (cnode->children.size() == 0) {\n            cnode->remove();\n            cmap.erase(vnode->cnt);\n            delete cnode;\n        }\n        if (prev != first && prev->value == vnode->cnt - 1) {\n            prev->children.insert(vnode);\n        } else {\n            CNode *cnode_new = new CNode(vnode->cnt - 1, prev);\n            cmap[vnode->cnt - 1] = cnode_new;\n            cnode_new->children.insert(vnode);\n        }\n        vnode->cnt -= 1;\n    }\n    // \u51cf\u5c11key\u4e14\u5f53\u524d\u4e0d\u5b58\u5728\n    void dec_nokey(string key) {\n        VNode *vnode = vmap[key];\n        CNode *cnode = cmap[vnode->cnt];\n        cnode->children.erase(vnode);\n        if (cnode->children.size() == 0) {\n            cnode->remove();\n            cmap.erase(vnode->cnt);\n            delete cnode;\n        }\n        vmap.erase(vnode->value);\n        delete vnode;\n    }\n    string getMaxKey() {\n        if (first->next == last) return "";\n        auto it = last->prev->children.begin();\n        return (*it)->value;\n    }\n\n    string getMinKey() {\n        if (first->next == last) return "";\n        auto it = first->next->children.begin();\n        return (*it)->value;\n    }\n};',lang:"cpp"})))}));n["default"]=e=>{var n=o.useContext(c.context),t=n.demos;return o.useEffect((()=>{var n;null!==e&&void 0!==e&&null!==(n=e.location)&&void 0!==n&&n.hash&&c.AnchorLink.scrollToAnchor(decodeURIComponent(e.location.hash.slice(1)))}),[]),o.createElement(r,{demos:t})}}}]);