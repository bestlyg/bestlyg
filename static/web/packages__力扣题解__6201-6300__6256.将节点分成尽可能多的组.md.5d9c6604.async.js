(self["webpackChunkblog"]=self["webpackChunkblog"]||[]).push([[74003],{28037:function(n,e,t){"use strict";t.r(e);var i=t(96832),l=t(22131),r=t(89730),s=i.memo((n=>{n.demos;return i.createElement(i.Fragment,null,i.createElement("div",{className:"markdown"},i.createElement("h1",{id:"6256-\u5c06\u8282\u70b9\u5206\u6210\u5c3d\u53ef\u80fd\u591a\u7684\u7ec4"},i.createElement(l.AnchorLink,{to:"#6256-\u5c06\u8282\u70b9\u5206\u6210\u5c3d\u53ef\u80fd\u591a\u7684\u7ec4","aria-hidden":"true",tabIndex:-1},i.createElement("span",{className:"icon icon-link"})),"6256. \u5c06\u8282\u70b9\u5206\u6210\u5c3d\u53ef\u80fd\u591a\u7684\u7ec4"),i.createElement("blockquote",null,i.createElement("p",null,"\u94fe\u63a5\uff1a",i.createElement(l.Link,{to:"https://leetcode.cn/problems/divide-nodes-into-the-maximum-number-of-groups"},"6256. \u5c06\u8282\u70b9\u5206\u6210\u5c3d\u53ef\u80fd\u591a\u7684\u7ec4"),i.createElement("br",null),"\u96be\u5ea6\uff1a\u7b80\u5355",i.createElement("br",null),"\u6807\u7b7e\uff1a",i.createElement("br",null),"\u7b80\u4ecb\uff1a\u8bf7\u4f60\u8fd4\u56de\u6700\u591a\u53ef\u4ee5\u5c06\u8282\u70b9\u5206\u4e3a\u591a\u5c11\u4e2a\u7ec4\uff08\u4e5f\u5c31\u662f\u6700\u5927\u7684 m \uff09\u3002\u5982\u679c\u6ca1\u529e\u6cd5\u5728\u7ed9\u5b9a\u6761\u4ef6\u4e0b\u5206\u7ec4\uff0c\u8bf7\u4f60\u8fd4\u56de -1 \u3002")),i.createElement("h2",{id:"\u9898\u89e3-1---cpp"},i.createElement(l.AnchorLink,{to:"#\u9898\u89e3-1---cpp","aria-hidden":"true",tabIndex:-1},i.createElement("span",{className:"icon icon-link"})),"\u9898\u89e3 1 - cpp"),i.createElement("ul",null,i.createElement("li",null,"\u7f16\u8f91\u65f6\u95f4\uff1a2022.12.04"),i.createElement("li",null,"\u6267\u884c\u7528\u65f6\uff1a1960ms"),i.createElement("li",null,"\u5185\u5b58\u6d88\u8017\uff1a141.3MB"),i.createElement("li",null,"\u7f16\u7a0b\u8bed\u8a00\uff1acpp"),i.createElement("li",null,"\u89e3\u6cd5\u4ecb\u7ecd\uff1a\u5148\u901a\u8fc7\u5e76\u67e5\u96c6\u533a\u5206\u4e0d\u540c\u7684\u8fde\u901a\u56fe\uff0c\u5bf9\u6bcf\u4e2a\u8fde\u901a\u56fe\u7684\u6bcf\u4e2a\u70b9\u8fdb\u884c\u679a\u4e3ebfs\u5224\u65ad\u5bf9\u957f\u7ec4\u3002")),i.createElement(r.Z,{code:'#include <iostream>\n#include <vector>\n// bestlyg\n# define X first\n# define Y second\n# define lb(x) ((x) & (-x))\n# define mem(a,b) memset(a,b,sizeof(a))\n# define debug freopen("r.txt","r",stdin)\n# define pi pair<int,int>\n\n#ifdef DEBUG\n#define log(frm, args...) {    printf(frm, ##args); }\n#else\n#define log(frm, args...)\n#endif\ntypedef long long ll;\n\nusing namespace std;\n\nclass UnionFind {\npublic:\n    int n;\n    vector<int> list;\n    UnionFind(int n): n(n) {\n        list = vector<int>(n);\n        for (int i = 0; i < n; i++) list[i] = i;\n    }\n    int find(int v) {\n        if (list[v] == v) return v;\n        return list[v] = find(list[v]);\n    }\n    void uni(int v1, int v2) {\n        int p1 = find(v1), p2 = find(v2);\n        if (p1 != p2) list[p1] = p2;\n    }\n\n};\nclass Node {\npublic:\n    int v;\n    unordered_set<int> next;\n};\nclass Solution {\npublic:\n    int magnificentSets(int n, vector<vector<int>>& edges) {\n        vector<Node> list(n);\n        UnionFind uf(n);\n        for (int i = 0; i < n; i++) list[i].v = i;\n        for (auto &edge : edges) {\n            int v1 = edge[0] - 1, v2 = edge[1] - 1;\n            list[v1].next.insert(v2);\n            list[v2].next.insert(v1);\n            uf.uni(v1, v2);\n        }\n        auto comp = [&](int start){\n            // cout << "====" << start << endl;\n            queue<int> q;\n            q.push(start);\n            unordered_set<int> used;\n            unordered_map<int, unordered_set<int>> m;\n            int level = 0, size = 1;\n            used.insert(start);\n            m[0].insert(start);\n            while (q.size()) {\n                int cur = q.front();\n                // cout << "cur = " << cur << ", level = " << level << endl;\n                q.pop();\n                for (auto &next : list[cur].next) {\n                    // cout << "next = " << next << ", " << used.count(next) << endl;\n                    if (used.count(next)) {\n                        if (m[level - 1].count(next) || m[level + 1].count(next)) continue;\n                        else return -1;\n                    }\n                    used.insert(next);\n                    m[level + 1].insert(next);\n                    q.push(next);\n                }\n                if (--size == 0) {\n                    size = q.size();\n                    level++;\n                }\n            }\n            return level;\n        };\n        unordered_map<int, int> m;\n        for (int i = 0; i < n; i++) {\n            int p = uf.find(i), v = comp(i);\n            if (v == -1) return -1;\n            m[p] = max(m[p], v);\n        }\n        int ans = 0;\n        for (auto &item : m) ans += item.Y;\n        return ans;\n    }\n};',lang:"cpp"})))}));e["default"]=n=>{var e=i.useContext(l.context),t=e.demos;return i.useEffect((()=>{var e;null!==n&&void 0!==n&&null!==(e=n.location)&&void 0!==e&&e.hash&&l.AnchorLink.scrollToAnchor(decodeURIComponent(n.location.hash.slice(1)))}),[]),i.createElement(s,{demos:t})}}}]);