(self["webpackChunkblog"]=self["webpackChunkblog"]||[]).push([[54491],{34689:function(e,n,t){"use strict";t.r(n);var r=t(96832),a=t(22131),l=t(89730),i=r.memo((e=>{e.demos;return r.createElement(r.Fragment,null,r.createElement("div",{className:"markdown"},r.createElement("h1",{id:"avl-\u6811avltree"},r.createElement(a.AnchorLink,{to:"#avl-\u6811avltree","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"AVL \u6811(AVLTree)"),r.createElement("p",null,"\u6700\u65e9\u53d1\u660e\u7684\u81ea\u5e73\u8861\u4e8c\u53c9\u641c\u7d22\u6811\u4e4b\u4e00"),r.createElement("h2",{id:"\u5e73\u8861\u56e0\u5b50blancefactor"},r.createElement(a.AnchorLink,{to:"#\u5e73\u8861\u56e0\u5b50blancefactor","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"\u5e73\u8861\u56e0\u5b50(BlanceFactor)"),r.createElement("p",null,"\u67d0\u8282\u70b9\u5de6\u53f3\u5b50\u6811\u7684\u9ad8\u5ea6\u5dee"),r.createElement("h2",{id:"\u7279\u70b9"},r.createElement(a.AnchorLink,{to:"#\u7279\u70b9","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"\u7279\u70b9"),r.createElement("ul",null,r.createElement("li",null,"\u6bcf\u4e2a\u8282\u70b9\u7684\u5e73\u8861\u56e0\u5b50\u53ea\u53ef\u80fd\u662f-1\u30010\u30011(\u7edd\u5bf9\u503c<=1\uff0c\u5982\u679c\u8d85\u8fc7 1\uff0c\u79f0\u4e4b\u4e3a\u5931\u8861)"),r.createElement("li",null,"\u6bcf\u4e2a\u7ed3\u70b9\u7684\u5de6\u53f3\u5b50\u6811\u9ad8\u5ea6\u5dee\u4e0d\u8d85\u8fc7 1"),r.createElement("li",null,"\u641c\u7d22\u3001\u6dfb\u52a0\u3001\u5220\u9664\u7684\u65f6\u95f4\u590d\u6742\u5ea6\u662f O(logN)")),r.createElement("h2",{id:"\u6838\u5fc3\u4ee3\u7801"},r.createElement(a.AnchorLink,{to:"#\u6838\u5fc3\u4ee3\u7801","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),r.createElement(a.Link,{to:"https://gitee.com/bestlyg/bestlyg/tree/master/packages/data-structures/src/tree/avlTree.ts"},"\u6838\u5fc3\u4ee3\u7801")),r.createElement(l.Z,{code:"import { BlanceBinarySearchTree } from './blanceBinarySearchTree';\nimport { BinaryTreeNode } from './binaryTree';\nexport class AVLTreeNode<T> extends BinaryTreeNode<T> {\n  get leftHeight(): number {\n    return (this.left as AVLTreeNode<T>)?.height ?? 0;\n  }\n  get rightHeight(): number {\n    return (this.right as AVLTreeNode<T>)?.height ?? 0;\n  }\n  get balance() {\n    return Math.abs(this.leftHeight - this.rightHeight) <= 1;\n  }\n  get height() {\n    return Math.max(this.leftHeight, this.rightHeight) + 1;\n  }\n  /* istanbul ignore next */\n  constructor(\n    public val: T,\n    public parent: AVLTreeNode<T> | null = null,\n    public left: AVLTreeNode<T> | null = null,\n    public right: AVLTreeNode<T> | null = null\n  ) {\n    super(val, parent, left, right);\n  }\n}\nexport class AVLTree<T> extends BlanceBinarySearchTree<T> {\n  protected createNode(\n    val: T,\n    parent: BinaryTreeNode<T> | null = null,\n    left: BinaryTreeNode<T> | null = null,\n    right: BinaryTreeNode<T> | null = null\n  ): BinaryTreeNode<T> {\n    return new AVLTreeNode(\n      val,\n      parent as AVLTreeNode<T> | null,\n      left as AVLTreeNode<T> | null,\n      right as AVLTreeNode<T> | null\n    );\n  }\n  protected afterAdd(node: AVLTreeNode<T>) {\n    let parent = node.parent;\n    while (parent !== null) {\n      if (!parent.balance) {\n        this.reBalance(parent);\n        break;\n      }\n      parent = parent.parent;\n    }\n  }\n  protected afterRemove(node: AVLTreeNode<T>) {\n    let parent = node.parent;\n    while (parent !== null) {\n      if (!parent.balance) this.reBalance(parent);\n      parent = parent.parent;\n    }\n  }\n  private reBalance(grandParent: AVLTreeNode<T>) {\n    const parent = this.getUnbalancedChild(grandParent);\n    const child = this.getUnbalancedChild(parent);\n    /**\n     \u5de6\u53f3\u65cb\u8f6c1\n    if (parent.isLeftChild) {\n      // L\n      if (child.isRightChild) this.rotateLeft(parent);\n      this.rotateRight(grandParent);\n    } else {\n      // R\n      if (child.isLeftChild) this.rotateRight(parent);\n      this.rotateLeft(grandParent);\n    }\n     */\n    if (parent.isLeftChild) {\n      if (child.isLeftChild)\n        this.rotate(\n          grandParent,\n          parent,\n          child,\n          child.left,\n          child.right,\n          grandParent,\n          parent.right,\n          grandParent.right\n        );\n      else\n        this.rotate(\n          grandParent,\n          child,\n          parent,\n          parent.left,\n          child.left,\n          grandParent,\n          child.right,\n          grandParent.right\n        );\n    } else {\n      // R\n      if (child.isRightChild)\n        this.rotate(\n          grandParent,\n          parent,\n          grandParent,\n          grandParent.left,\n          parent.left,\n          child,\n          child.left,\n          child.right\n        );\n      else\n        this.rotate(\n          grandParent,\n          child,\n          grandParent,\n          grandParent.left,\n          child.left,\n          parent,\n          child.right,\n          parent.right\n        );\n    }\n  }\n  private getUnbalancedChild(node: AVLTreeNode<T>): AVLTreeNode<T> {\n    return (\n      node.leftHeight > node.rightHeight\n        ? node.left\n        : node.leftHeight < node.rightHeight\n        ? node.right\n        : node[node.childPosition]\n    ) as AVLTreeNode<T>;\n  }\n}",lang:"ts"})))}));n["default"]=e=>{var n=r.useContext(a.context),t=n.demos;return r.useEffect((()=>{var n;null!==e&&void 0!==e&&null!==(n=e.location)&&void 0!==n&&n.hash&&a.AnchorLink.scrollToAnchor(decodeURIComponent(e.location.hash.slice(1)))}),[]),r.createElement(i,{demos:t})}}}]);