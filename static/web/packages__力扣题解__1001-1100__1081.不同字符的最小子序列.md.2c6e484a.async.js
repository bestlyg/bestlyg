(self["webpackChunkblog"]=self["webpackChunkblog"]||[]).push([[17698],{47513:function(e,t,n){"use strict";n.r(t);var c=n(96832),l=n(22131),s=n(89730),a=c.memo((e=>{e.demos;return c.createElement(c.Fragment,null,c.createElement("div",{className:"markdown"},c.createElement("h1",{id:"1081-\u4e0d\u540c\u5b57\u7b26\u7684\u6700\u5c0f\u5b50\u5e8f\u5217"},c.createElement(l.AnchorLink,{to:"#1081-\u4e0d\u540c\u5b57\u7b26\u7684\u6700\u5c0f\u5b50\u5e8f\u5217","aria-hidden":"true",tabIndex:-1},c.createElement("span",{className:"icon icon-link"})),"1081. \u4e0d\u540c\u5b57\u7b26\u7684\u6700\u5c0f\u5b50\u5e8f\u5217"),c.createElement("blockquote",null,c.createElement("p",null,"\u94fe\u63a5\uff1a",c.createElement(l.Link,{to:"https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters/"},"1081. \u4e0d\u540c\u5b57\u7b26\u7684\u6700\u5c0f\u5b50\u5e8f\u5217"),c.createElement("br",null),"\u96be\u5ea6\uff1a\u4e2d\u7b49",c.createElement("br",null),"\u6807\u7b7e\uff1a\u6808\u3001\u8d2a\u5fc3\u3001\u5b57\u7b26\u4e32\u3001\u5355\u8c03\u6808",c.createElement("br",null),"\u7b80\u4ecb\uff1a\u8fd4\u56de s \u5b57\u5178\u5e8f\u6700\u5c0f\u7684\u5b50\u5e8f\u5217\uff0c\u8be5\u5b50\u5e8f\u5217\u5305\u542b s \u7684\u6240\u6709\u4e0d\u540c\u5b57\u7b26\uff0c\u4e14\u53ea\u5305\u542b\u4e00\u6b21\u3002")),c.createElement("h2",{id:"\u9898\u89e3-1---typescript"},c.createElement(l.AnchorLink,{to:"#\u9898\u89e3-1---typescript","aria-hidden":"true",tabIndex:-1},c.createElement("span",{className:"icon icon-link"})),"\u9898\u89e3 1 - typescript"),c.createElement("ul",null,c.createElement("li",null,"\u7f16\u8f91\u65f6\u95f4\uff1a2021.07.30"),c.createElement("li",null,"\u6267\u884c\u7528\u65f6\uff1a176ms"),c.createElement("li",null,"\u5185\u5b58\u6d88\u8017\uff1a46.1MB"),c.createElement("li",null,"\u7f16\u7a0b\u8bed\u8a00\uff1atypescript"),c.createElement("li",null,"\u89e3\u6cd5\u4ecb\u7ecd\uff1a\u5355\u8c03\u6808\u3002")),c.createElement(s.Z,{code:"function smallestSubsequence(s: string): string {\n  const map: Record<string, number> = {};\n  for (const c of s) map[c] = (map[c] ?? 0) + 1;\n  const stack: string[] = [];\n  const set = new Set<string>();\n  const toNum = (c: string) => c.codePointAt(0)! - 'a'.codePointAt(0)!;\n  for (const c of s) {\n    if (set.has(c)) {\n      map[c]--;\n      continue;\n    }\n    while (\n      stack.length &&\n      toNum(stack[stack.length - 1]) > toNum(c) &&\n      map[stack[stack.length - 1]] > 0\n    ) {\n      console.log(set);\n      set.delete(stack.pop()!);\n    }\n    stack.push(c);\n    set.add(c);\n    map[c]--;\n  }\n  return stack.join('');\n}",lang:"typescript"})))}));t["default"]=e=>{var t=c.useContext(l.context),n=t.demos;return c.useEffect((()=>{var t;null!==e&&void 0!==e&&null!==(t=e.location)&&void 0!==t&&t.hash&&l.AnchorLink.scrollToAnchor(decodeURIComponent(e.location.hash.slice(1)))}),[]),c.createElement(a,{demos:n})}}}]);