(self["webpackChunkblog"]=self["webpackChunkblog"]||[]).push([[66146],{22890:function(e,n,o){"use strict";o.r(n);var l=o(96832),t=o(22131),d=o(89730),r=l.memo((e=>{e.demos;return l.createElement(l.Fragment,null,l.createElement("div",{className:"markdown"},l.createElement("h1",{id:"729-\u6211\u7684\u65e5\u7a0b\u5b89\u6392\u8868-i"},l.createElement(t.AnchorLink,{to:"#729-\u6211\u7684\u65e5\u7a0b\u5b89\u6392\u8868-i","aria-hidden":"true",tabIndex:-1},l.createElement("span",{className:"icon icon-link"})),"729. \u6211\u7684\u65e5\u7a0b\u5b89\u6392\u8868 I"),l.createElement("blockquote",null,l.createElement("p",null,"\u94fe\u63a5\uff1a",l.createElement(t.Link,{to:"https://leetcode.cn/problems/my-calendar-i/"},"729. \u6211\u7684\u65e5\u7a0b\u5b89\u6392\u8868 I"),l.createElement("br",null),"\u96be\u5ea6\uff1a\u4e2d\u7b49",l.createElement("br",null),"\u6807\u7b7e\uff1a\u8bbe\u8ba1\u3001\u7ebf\u6bb5\u6811\u3001\u4e8c\u5206\u67e5\u627e\u3001\u6709\u5e8f\u96c6\u5408",l.createElement("br",null),"\u7b80\u4ecb\uff1a\u5b9e\u73b0\u4e00\u4e2a MyCalendar \u7c7b\u6765\u5b58\u653e\u4f60\u7684\u65e5\u7a0b\u5b89\u6392\u3002\u5982\u679c\u8981\u6dfb\u52a0\u7684\u65e5\u7a0b\u5b89\u6392\u4e0d\u4f1a\u9020\u6210 \u91cd\u590d\u9884\u8ba2 \uff0c\u5219\u53ef\u4ee5\u5b58\u50a8\u8fd9\u4e2a\u65b0\u7684\u65e5\u7a0b\u5b89\u6392\u3002")),l.createElement("h2",{id:"\u9898\u89e3-1---typescript"},l.createElement(t.AnchorLink,{to:"#\u9898\u89e3-1---typescript","aria-hidden":"true",tabIndex:-1},l.createElement("span",{className:"icon icon-link"})),"\u9898\u89e3 1 - typescript"),l.createElement("ul",null,l.createElement("li",null,"\u7f16\u8f91\u65f6\u95f4\uff1a2022.07.05"),l.createElement("li",null,"\u6267\u884c\u7528\u65f6\uff1a188ms"),l.createElement("li",null,"\u5185\u5b58\u6d88\u8017\uff1a50.3MB"),l.createElement("li",null,"\u7f16\u7a0b\u8bed\u8a00\uff1atypescript"),l.createElement("li",null,"\u89e3\u6cd5\u4ecb\u7ecd\uff1a\u6784\u5efa rbtree\uff0c\u6bcf\u6b21\u901a\u8fc7 start\u3001end \u67e5\u627e\u4ed6\u6700\u8fd1\u7684\u503c\u7136\u540e\u8fdb\u884c\u6bd4\u8f83\u3002")),l.createElement(d.Z,{code:"let NIL: RBNode<any>;\nclass RBNode<T> {\n  constructor(public key: T, public color = 0, public lchild = NIL, public rchild = NIL) {}\n  hasRedChild() {\n    return this.lchild.color === 0 || this.rchild.color === 0;\n  }\n}\nNIL = new RBNode(0, 1);\n\nclass RBTree<T extends Array<any>> {\n  root: RBNode<T> = NIL;\n  constructor(public compare: (v1: T, v2: T) => number) {}\n  print(node = this.root, init = true) {\n    if (node == NIL) return;\n    if (init) console.log('===[RBTree Print]===');\n    console.log(`${node.key}, (${node.lchild.key}, ${node.rchild.key})`);\n    this.print(node.lchild, false);\n    this.print(node.rchild, false);\n  }\n  rotateLeft(node: RBNode<T>) {\n    const newNode = node.rchild;\n    node.rchild = newNode.lchild;\n    newNode.lchild = node;\n    return newNode;\n  }\n  rotateRight(node: RBNode<T>) {\n    const newNode = node.lchild;\n    node.lchild = newNode.rchild;\n    newNode.rchild = node;\n    return newNode;\n  }\n  insert(key: T) {\n    this.root = this._insert(this.root, key);\n    this.root.color = 1;\n  }\n  _insert(node: RBNode<T>, key: T) {\n    if (node === NIL) return new RBNode(key);\n    const compare = this.compare(key, node.key);\n    if (compare === 0) {\n      node.key = key;\n      return node;\n    }\n    if (compare > 0) node.rchild = this._insert(node.rchild, key);\n    else node.lchild = this._insert(node.lchild, key);\n    return this._insertMaintain(node);\n  }\n  _insertMaintain(node: RBNode<T>) {\n    if (!node.hasRedChild()) return node;\n    if (\n      !(node.lchild.color === 0 && node.lchild.hasRedChild()) &&\n      !(node.rchild.color === 0 && node.rchild.hasRedChild())\n    )\n      return node;\n    if (node.lchild.color === 1) {\n      if (node.rchild.lchild.color === 0) node.rchild = this.rotateRight(node.rchild);\n      node = this.rotateLeft(node);\n    } else if (node.rchild.color === 1) {\n      if (node.lchild.rchild.color === 0) node.lchild = this.rotateLeft(node.lchild);\n      node = this.rotateRight(node);\n    }\n    node.color = 0;\n    node.lchild.color = node.rchild.color = 1;\n    return node;\n  }\n\n  remove(key: T) {\n    this.root = this._remove(this.root, key);\n    this.root.color = 1;\n  }\n  _remove(node: RBNode<T>, key: T) {\n    if (node == NIL) return node;\n    const compare = this.compare(key, node.key);\n    if (compare > 0) node.rchild = this._remove(node.rchild, key);\n    else if (compare < 0) node.lchild = this._remove(node.lchild, key);\n    else {\n      if (node.lchild === NIL || node.rchild === NIL) {\n        const tmp = node.lchild === NIL ? node.rchild : node.lchild;\n        tmp.color += node.color;\n        return tmp;\n      } else {\n        let tmp = node.lchild;\n        while (tmp.rchild !== NIL) tmp = tmp.rchild;\n        node.key = tmp.key;\n        node.lchild = this._remove(node.lchild, tmp.key);\n      }\n    }\n    return this._removeMaintain(node);\n  }\n  _removeMaintain(node: RBNode<T>) {\n    if (node.lchild.color !== 2 && node.rchild.color !== 2) return node;\n    if (node.hasRedChild()) {\n      let type = 0;\n      node.color = 0;\n      if (node.lchild.color === 0) node = this.rotateRight(node);\n      else (node = this.rotateLeft(node)), (type = 1);\n      node.color = 1;\n      if (type === 1) node.lchild = this._removeMaintain(node.lchild);\n      else node.rchild = this._removeMaintain(node.rchild);\n      return node;\n    }\n    if (\n      (node.lchild.color === 1 && !node.lchild.hasRedChild()) ||\n      (node.rchild.color === 1 && !node.rchild.hasRedChild())\n    ) {\n      node.color += 1;\n      node.lchild.color -= 1;\n      node.rchild.color -= 1;\n      return node;\n    }\n    if (node.lchild.color === 1) {\n      if (node.lchild.lchild.color !== 0) {\n        node.lchild.color = 0;\n        node.lchild = this.rotateLeft(node.lchild);\n        node.lchild.color = 1;\n      }\n      node.lchild.color = node.color;\n      node.rchild.color = 1;\n      node = this.rotateRight(node);\n    } else {\n      if (node.rchild.rchild.color !== 0) {\n        node.rchild.color = 0;\n        node.rchild = this.rotateRight(node.rchild);\n        node.rchild.color = 1;\n      }\n      node.rchild.color = node.color;\n      node.lchild.color = 1;\n      node = this.rotateLeft(node);\n    }\n    node.lchild.color = node.rchild.color = 1;\n    return node;\n  }\n  successor(node: RBNode<T>) {\n    let successor = NIL;\n    if (node.rchild) {\n      successor = node.rchild;\n      while (successor.lchild) successor = successor!.lchild;\n      return successor;\n    }\n    let tmp = this.root;\n    while (tmp) {\n      if (tmp.key > node.key) {\n        successor = tmp;\n        tmp = tmp.lchild;\n      } else {\n        tmp = tmp.rchild;\n      }\n    }\n    return tmp;\n  }\n  check([start, end]: T): boolean {\n    let node = this.root;\n    while (node !== NIL) {\n      if (node.key[0] >= end) node = node.lchild;\n      else if (node.key[1] <= start) node = node.rchild;\n      else break;\n    }\n    if (node === NIL) return true;\n    let tmp = node;\n    while (tmp !== NIL && tmp.key[1] >= start) {\n      const [tstart, tend] = tmp.key;\n      if (\n        (start > tstart && start < tend) ||\n        (end > tstart && end < tend) ||\n        (start <= tstart && end >= tend)\n      )\n        return false;\n      tmp = this.successor(tmp);\n    }\n    return true;\n  }\n}\nclass MyCalendar {\n  tree = new RBTree<number[]>((v1, v2) => v1[0] - v2[0]);\n  book(start: number, end: number): boolean {\n    const ans = this.tree.check([start, end]);\n    if (ans) this.tree.insert([start, end]);\n    return ans;\n  }\n}",lang:"typescript"})))}));n["default"]=e=>{var n=l.useContext(t.context),o=n.demos;return l.useEffect((()=>{var n;null!==e&&void 0!==e&&null!==(n=e.location)&&void 0!==n&&n.hash&&t.AnchorLink.scrollToAnchor(decodeURIComponent(e.location.hash.slice(1)))}),[]),l.createElement(r,{demos:o})}}}]);