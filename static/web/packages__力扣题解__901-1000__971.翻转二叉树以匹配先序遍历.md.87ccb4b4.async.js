(self["webpackChunkblog"]=self["webpackChunkblog"]||[]).push([[82550],{57793:function(e,n,t){"use strict";t.r(n);var l=t(96832),o=t(22131),r=t(89730),a=l.memo((e=>{e.demos;return l.createElement(l.Fragment,null,l.createElement("div",{className:"markdown"},l.createElement("h1",{id:"971-\u7ffb\u8f6c\u4e8c\u53c9\u6811\u4ee5\u5339\u914d\u5148\u5e8f\u904d\u5386"},l.createElement(o.AnchorLink,{to:"#971-\u7ffb\u8f6c\u4e8c\u53c9\u6811\u4ee5\u5339\u914d\u5148\u5e8f\u904d\u5386","aria-hidden":"true",tabIndex:-1},l.createElement("span",{className:"icon icon-link"})),"971. \u7ffb\u8f6c\u4e8c\u53c9\u6811\u4ee5\u5339\u914d\u5148\u5e8f\u904d\u5386"),l.createElement("blockquote",null,l.createElement("p",null,"\u94fe\u63a5\uff1a",l.createElement(o.Link,{to:"https://leetcode-cn.com/problems/flip-binary-tree-to-match-preorder-traversal/"},"971. \u7ffb\u8f6c\u4e8c\u53c9\u6811\u4ee5\u5339\u914d\u5148\u5e8f\u904d\u5386"),l.createElement("br",null),"\u96be\u5ea6\uff1a\u4e2d\u7b49",l.createElement("br",null),"\u6807\u7b7e\uff1a\u6811\u3001\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u3001\u4e8c\u53c9\u6811",l.createElement("br",null),"\u7b80\u4ecb\uff1a\u8bf7\u7ffb\u8f6c \u6700\u5c11 \u7684\u6811\u4e2d\u8282\u70b9\uff0c\u4f7f\u4e8c\u53c9\u6811\u7684 \u5148\u5e8f\u904d\u5386 \u4e0e\u9884\u671f\u7684\u904d\u5386\u884c\u7a0b voyage \u76f8\u5339\u914d \u3002 \u3002")),l.createElement("h2",{id:"\u9898\u89e3-1---typescript"},l.createElement(o.AnchorLink,{to:"#\u9898\u89e3-1---typescript","aria-hidden":"true",tabIndex:-1},l.createElement("span",{className:"icon icon-link"})),"\u9898\u89e3 1 - typescript"),l.createElement("ul",null,l.createElement("li",null,"\u7f16\u8f91\u65f6\u95f4\uff1a2021.08.14"),l.createElement("li",null,"\u6267\u884c\u7528\u65f6\uff1a84ms"),l.createElement("li",null,"\u5185\u5b58\u6d88\u8017\uff1a39.5MB"),l.createElement("li",null,"\u7f16\u7a0b\u8bed\u8a00\uff1atypescript"),l.createElement("li",null,"\u89e3\u6cd5\u4ecb\u7ecd\uff1adfs\u3002")),l.createElement(r.Z,{code:"function flipMatchVoyage(root: TreeNode | null, voyage: number[]): number[] {\n  if (root === null) return [];\n  const ans: number[] = [];\n  let stop = false;\n  dfs(root, voyage);\n  return stop ? [-1] : ans;\n  function dfs(node: TreeNode, voyage: number[]) {\n    if (stop) return;\n    const val = node.val;\n    const n = voyage.length;\n    if (val !== voyage[0]) {\n      stop = true;\n      return;\n    }\n    if (node.left === null && node.right === null) {\n      if (!(n === 1 && voyage[0] === val)) stop = true;\n      return;\n    }\n    if (node.left === null) {\n      if (voyage[1] !== node.right!.val) stop = true;\n      else dfs(node.right!, voyage.slice(1));\n      return;\n    }\n    if (node.right === null) {\n      if (voyage[1] !== node.left!.val) stop = true;\n      else dfs(node.left!, voyage.slice(1));\n      return;\n    }\n    const valL = node.left!.val;\n    const valR = node.right!.val;\n    if (voyage[1] === valL) {\n      let idx = 1;\n      while (idx < n && voyage[idx] !== valR) idx++;\n      dfs(node.left!, voyage.slice(1, idx));\n      dfs(node.right!, voyage.slice(idx));\n    } else {\n      let idx = 1;\n      while (idx < n && voyage[idx] !== valL) idx++;\n      dfs(node.right!, voyage.slice(1, idx));\n      dfs(node.left!, voyage.slice(idx));\n      ans.push(val);\n    }\n  }\n}",lang:"typescript"})))}));n["default"]=e=>{var n=l.useContext(o.context),t=n.demos;return l.useEffect((()=>{var n;null!==e&&void 0!==e&&null!==(n=e.location)&&void 0!==n&&n.hash&&o.AnchorLink.scrollToAnchor(decodeURIComponent(e.location.hash.slice(1)))}),[]),l.createElement(a,{demos:t})}}}]);