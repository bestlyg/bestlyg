(self["webpackChunkblog"]=self["webpackChunkblog"]||[]).push([[12227],{83209:function(e,n,t){"use strict";t.r(n);var r=t(96832),a=t(22131),l=t(89730),m=r.memo((e=>{e.demos;return r.createElement(r.Fragment,null,r.createElement("div",{className:"markdown"},r.createElement("h1",{id:"1224-\u6700\u5927\u76f8\u7b49\u9891\u7387"},r.createElement(a.AnchorLink,{to:"#1224-\u6700\u5927\u76f8\u7b49\u9891\u7387","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"1224. \u6700\u5927\u76f8\u7b49\u9891\u7387"),r.createElement("blockquote",null,r.createElement("p",null,"\u94fe\u63a5\uff1a",r.createElement(a.Link,{to:"https://leetcode.cn/problems/maximum-equal-frequency/"},"1224. \u6700\u5927\u76f8\u7b49\u9891\u7387"),r.createElement("br",null),"\u96be\u5ea6\uff1a\u56f0\u96be",r.createElement("br",null),"\u6807\u7b7e\uff1a\u6570\u7ec4\u3001\u54c8\u5e0c\u8868",r.createElement("br",null),"\u7b80\u4ecb\uff1a\u7ed9\u4f60\u4e00\u4e2a\u6b63\u6574\u6570\u6570\u7ec4 nums\uff0c\u8bf7\u4f60\u5e2e\u5fd9\u4ece\u8be5\u6570\u7ec4\u4e2d\u627e\u51fa\u80fd\u6ee1\u8db3\u4e0b\u9762\u8981\u6c42\u7684 \u6700\u957f \u524d\u7f00\uff0c\u5e76\u8fd4\u56de\u8be5\u524d\u7f00\u7684\u957f\u5ea6\u3002")),r.createElement("h2",{id:"\u9898\u89e3-1---rust"},r.createElement(a.AnchorLink,{to:"#\u9898\u89e3-1---rust","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"\u9898\u89e3 1 - rust"),r.createElement("ul",null,r.createElement("li",null,"\u7f16\u8f91\u65f6\u95f4\uff1a2022.08.18"),r.createElement("li",null,"\u6267\u884c\u7528\u65f6\uff1a52ms"),r.createElement("li",null,"\u5185\u5b58\u6d88\u8017\uff1a3.4MB"),r.createElement("li",null,"\u7f16\u7a0b\u8bed\u8a00\uff1arust"),r.createElement("li",null,"\u89e3\u6cd5\u4ecb\u7ecd\uff1a\u53ea\u6709\u4e09\u79cd\u60c5\u51b5\u53ef\u4ee5\u6210\u7acb\uff0c1.\u6700\u5927\u9891\u7387\u53ea\u6709\u4e00\uff0c2.\u6240\u6709\u6570\u53ea\u6709\u6700\u5927\u9891\u7387\u548c\u7b2c\u4e8c\u5927\u9891\u7387\u4e14\u6700\u5927\u9891\u7387\u53ea\u6709\u4e00\u79cd\u6570\uff0c3.\u6240\u6709\u6570\u9664\u4e86\u4e00\u4e2a\u90fd\u662f\u6700\u5927\u9891\u7387\uff0c\u5269\u4e0b\u7684\u4e00\u4e2a\u6570\u9891\u7387\u662f 1\u3002")),r.createElement(l.Z,{code:"impl Solution {\n    pub fn max_equal_freq(nums: Vec<i32>) -> i32 {\n        use std::collections::HashMap;\n        let (mut freq_map, mut cnt_map) =\n            (HashMap::<usize, usize>::new(), HashMap::<i32, usize>::new());\n        let mut ans = 0;\n        let mut max_freq = 0;\n        for i in 0..nums.len() {\n            let num = nums[i];\n            let cnt = cnt_map.get(&num).unwrap_or(&0);\n            let prev_freq = freq_map.get_mut(cnt);\n            if prev_freq.is_some() {\n                *prev_freq.unwrap() -= 1;\n            }\n            let cnt = *cnt + 1;\n            cnt_map.insert(num, cnt);\n            freq_map.insert(cnt, freq_map.get(&cnt).unwrap_or(&0) + 1);\n            max_freq = max_freq.max(cnt);\n            if max_freq == 1\n                || freq_map.get(&max_freq).unwrap_or(&0) * max_freq\n                    + freq_map.get(&(max_freq - 1)).unwrap_or(&0) * (max_freq - 1)\n                    == i + 1\n                    && *freq_map.get(&max_freq).unwrap_or(&0) == 1\n                || freq_map.get(&max_freq).unwrap_or(&0) * max_freq == i\n                    && *freq_map.get(&1).unwrap_or(&0) == 1\n            {\n                ans = i + 1;\n            }\n        }\n        ans as i32\n    }\n}",lang:"rust"})))}));n["default"]=e=>{var n=r.useContext(a.context),t=n.demos;return r.useEffect((()=>{var n;null!==e&&void 0!==e&&null!==(n=e.location)&&void 0!==n&&n.hash&&a.AnchorLink.scrollToAnchor(decodeURIComponent(e.location.hash.slice(1)))}),[]),r.createElement(m,{demos:t})}}}]);