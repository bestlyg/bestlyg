(self["webpackChunkblog"]=self["webpackChunkblog"]||[]).push([[49503],{40521:function(e,n,t){"use strict";t.r(n);var r=t(96832),a=t(22131),l=t(89730),s=r.memo((e=>{e.demos;return r.createElement(r.Fragment,null,r.createElement("div",{className:"markdown"},r.createElement("h1",{id:"\u6620\u5c04map"},r.createElement(a.AnchorLink,{to:"#\u6620\u5c04map","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"\u6620\u5c04(Map)"),r.createElement("p",null,"\u4e5f\u53eb\u505a\u5b57\u5178\uff0c\u952e\u503c\u5bf9\u7684\u5339\u914d\uff0c\u4e24\u4e2a\u5143\u7d20\u7684\u96c6\u4e4b\u95f4\u5143\u7d20\u76f8\u4e92\u201c\u5bf9\u5e94\u201d\u7684\u5173\u7cfb\u3002"),r.createElement("ul",null,r.createElement("li",null,"Map \u7684\u6bcf\u4e00\u4e2a key \u662f\u552f\u4e00\u7684")),r.createElement("h2",{id:"\u5e38\u7528\u6620\u5c04"},r.createElement(a.AnchorLink,{to:"#\u5e38\u7528\u6620\u5c04","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"\u5e38\u7528\u6620\u5c04"),r.createElement("ul",null,r.createElement("li",null,"HashMap",r.createElement("ul",null,r.createElement("li",null,"\u5e95\u5c42\u4f7f\u7528\u54c8\u5e0c\u8868"))),r.createElement("li",null,"ListMap",r.createElement("ul",null,r.createElement("li",null,"\u5e95\u5c42\u4f7f\u7528\u94fe\u8868"))),r.createElement("li",null,"TreeMap",r.createElement("ul",null,r.createElement("li",null,"\u5e95\u5c42\u4f7f\u7528\u6811\u5f62\u7ed3\u6784")))),r.createElement("h2",{id:"\u6838\u5fc3\u4ee3\u7801"},r.createElement(a.AnchorLink,{to:"#\u6838\u5fc3\u4ee3\u7801","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),r.createElement(a.Link,{to:"https://gitee.com/bestlyg/bestlyg/tree/master/packages/data-structures/src/map-set/map.ts"},"\u6838\u5fc3\u4ee3\u7801")),r.createElement(l.Z,{code:"export interface Map<K, V> {\n  size: number;\n  empty: boolean;\n  clear: () => void;\n  contains: (key: K) => boolean;\n  get: (key: K) => V | undefined;\n  set: (key: K, val: V) => boolean;\n  remove: (key: K) => boolean;\n}",lang:"ts"}),r.createElement("h2",{id:"\u6838\u5fc3\u4ee3\u7801-1"},r.createElement(a.AnchorLink,{to:"#\u6838\u5fc3\u4ee3\u7801-1","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),r.createElement(a.Link,{to:"https://gitee.com/bestlyg/bestlyg/tree/master/packages/data-structures/src/map-set/treeMap.ts"},"\u6838\u5fc3\u4ee3\u7801")),r.createElement(l.Z,{code:"import { Map } from './map';\nconst RED = true;\nconst BLACK = false;\ntype Color = boolean;\nconst isRed = (node: TreeMapNode<any, any> | null) => node?.color === RED;\nconst isBlack = (node: TreeMapNode<any, any> | null) => node === null || node?.color === BLACK;\nconst setColor = (node: TreeMapNode<any, any> | null, color: Color) => {\n  /* istanbul ignore next */\n  if (node) node.color = color;\n};\nconst setRed = (node: TreeMapNode<any, any> | null) => setColor(node, RED);\nconst setBlack = (node: TreeMapNode<any, any> | null) => setColor(node, BLACK);\nexport class TreeMapNode<K, V> {\n  color = RED;\n  left: TreeMapNode<K, V> | null = null;\n  right: TreeMapNode<K, V> | null = null;\n  constructor(public key: K, public val: V, public parent: TreeMapNode<K, V> | null = null) {}\n}\nexport class TreeMap<K, V> implements Map<K, V> {\n  private _size = 0;\n  get size() {\n    return this._size;\n  }\n  get empty() {\n    return this._size === 0;\n  }\n  private root: TreeMapNode<K, V> | null = null;\n  constructor(private compare: (k1: K, k2: K) => number) {}\n  clear() {\n    this.root = null;\n    this._size = 0;\n  }\n  contains(key: K) {\n    return this.findNode(key) !== null;\n  }\n  get(key: K) {\n    return this.findNode(key)?.val ?? undefined;\n  }\n  set(key: K, val: V) {\n    let node = this.findNode(key);\n    if (node !== null) {\n      node.val = val;\n      return false;\n    }\n    if (this.root === null) {\n      this.root = node = new TreeMapNode<K, V>(key, val);\n    } else {\n      let parent = this.root;\n      let pos = 'left';\n      while (parent !== null) {\n        const compare = this.compare(parent.key, key);\n        if (compare > 0) {\n          if (parent.left === null) break;\n          parent = parent.left;\n        } else {\n          if (parent.right === null) {\n            pos = 'right';\n            break;\n          }\n          parent = parent.right;\n        }\n      }\n      parent[pos] = node = new TreeMapNode<K, V>(key, val, parent);\n    }\n    this._size++;\n    this.afterSet(node);\n    return true;\n  }\n  private afterSet(node: TreeMapNode<K, V>) {\n    let parent = node.parent;\n    if (parent === null) {\n      setBlack(node);\n      return;\n    }\n    if (isBlack(parent)) return;\n    const grand = parent.parent!;\n    const sibling = grand.left === parent ? grand.right! : grand.left!;\n    if (isRed(sibling)) {\n      setBlack(parent);\n      setBlack(sibling);\n      setRed(grand);\n      this.afterSet(grand);\n      return;\n    }\n    if (grand.left === parent) {\n      if (parent.right === node) {\n        this.rotateL(parent);\n        [parent, node] = [node, parent];\n      }\n      this.rotateR(grand);\n    } else {\n      if (parent.left === node) {\n        this.rotateR(parent);\n        [parent, node] = [node, parent];\n      }\n      this.rotateL(grand);\n    }\n    setBlack(parent);\n    setRed(node);\n    setRed(grand);\n  }\n  remove(key: K) {\n    let node = this.findNode(key);\n    if (node === null) return false;\n    if (node.left !== null && node.right !== null) {\n      const successor = this.successor(node);\n      [node.key, node.val, successor.key, successor.val] = [\n        successor.key,\n        successor.val,\n        node.key,\n        node.val,\n      ];\n      node = successor;\n    }\n    const parent = node.parent!;\n    this._size--;\n    if (node.left === null && node.right === null) {\n      if (this.root === node) {\n        this.clear();\n        return true;\n      }\n      const pos = parent.left === node ? 'left' : 'right';\n      parent[pos] = null;\n      this.afterRemove(node);\n      return true;\n    }\n    const childNode = node.left ?? node.right!;\n    if (parent === null) this.root = childNode;\n    else {\n      const pos = parent.left === node ? 'left' : 'right';\n      parent[pos] = childNode;\n    }\n    childNode.parent = parent;\n    this.afterRemove(childNode);\n    return true;\n  }\n  private afterRemove(node: TreeMapNode<K, V>) {\n    if (isRed(node)) {\n      setBlack(node);\n      return;\n    }\n    const parent = node.parent;\n    if (parent === null) return;\n    const leftChild = parent.left === null || parent.left === node;\n    let sibling = leftChild ? parent.right! : parent.left!;\n    if (leftChild) {\n      if (isRed(sibling)) {\n        this.rotateL(parent);\n        setBlack(sibling);\n        setRed(parent);\n        sibling = parent.right!;\n      }\n      if (isBlack(sibling.left) && isBlack(sibling.right)) {\n        const parentIsBlack = isBlack(parent);\n        setRed(sibling);\n        setBlack(parent);\n        parentIsBlack && this.afterRemove(parent);\n        return;\n      }\n      if (isBlack(sibling.right)) {\n        this.rotateR(sibling);\n        sibling = sibling.parent!;\n      }\n      this.rotateL(parent);\n      setColor(sibling, parent.color);\n      setBlack(parent);\n      setBlack(sibling.right);\n    } else {\n      if (isRed(sibling)) {\n        this.rotateR(parent);\n        setBlack(sibling);\n        setRed(parent);\n        sibling = parent.left!;\n      }\n      if (isBlack(sibling.left) && isBlack(sibling.right)) {\n        const parentIsBlack = isBlack(parent);\n        setRed(sibling);\n        setBlack(parent);\n        parentIsBlack && this.afterRemove(parent);\n        return;\n      }\n      if (isBlack(sibling.left)) {\n        this.rotateL(sibling);\n        sibling = sibling.parent!;\n      }\n      this.rotateR(parent);\n      setColor(sibling, parent.color);\n      setBlack(parent);\n      setBlack(sibling.left);\n    }\n  }\n  private successor(node: TreeMapNode<K, V>) {\n    let successor = node.right!;\n    while (successor.left) successor = successor.left;\n    return successor;\n  }\n  private findNode(key: K, root = this.root): TreeMapNode<K, V> | null {\n    if (root === null) return null;\n    const compare = this.compare(root.key, key);\n    if (compare > 0) return this.findNode(key, root.left);\n    if (compare < 0) return this.findNode(key, root.right);\n    return root;\n  }\n  private rotateL(grand: TreeMapNode<K, V>) {\n    const root = grand.parent;\n    const parent = grand.right!;\n    if (root === null) this.root = parent;\n    else {\n      const pos = root.left === grand ? 'left' : 'right';\n      root[pos] = parent;\n    }\n    grand.right = parent.left;\n    if (parent.left) parent.left.parent = grand;\n    parent.left = grand;\n    grand.parent = parent;\n    parent.parent = root;\n  }\n  private rotateR(grand: TreeMapNode<K, V>) {\n    const root = grand.parent;\n    const parent = grand.left!;\n    if (root === null) this.root = parent;\n    else {\n      const pos = root.left === grand ? 'left' : 'right';\n      root[pos] = parent;\n    }\n    grand.left = parent.right;\n    if (parent.right) parent.right.parent = grand;\n    parent.right = grand;\n    grand.parent = parent;\n    parent.parent = root;\n  }\n}",lang:"ts"}),r.createElement("h2",{id:"\u6838\u5fc3\u4ee3\u7801-2"},r.createElement(a.AnchorLink,{to:"#\u6838\u5fc3\u4ee3\u7801-2","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),r.createElement(a.Link,{to:"https://gitee.com/bestlyg/bestlyg/tree/master/packages/data-structures/src/map-set/hashMap.ts"},"\u6838\u5fc3\u4ee3\u7801")),r.createElement(l.Z,{code:"import { Map } from './map';\nimport { TreeMap } from './treeMap';\n\nexport function toHash(data: any, max: number) {\n  const jsonStr = JSON.stringify(data);\n  let res = 0;\n  for (let i = 0, n = jsonStr.length; i < n; i++) {\n    res = (res + jsonStr.codePointAt(i)!) % max;\n  }\n  return res;\n}\nexport class HashMap<K, V> implements Map<K, V> {\n  private list: TreeMap<K, V>[] = [];\n  private _size = 0;\n  get size() {\n    return this._size;\n  }\n  get empty() {\n    return this._size === 0;\n  }\n  constructor(private compare: (t1: K, t2: K) => number, private max = 31) {}\n  clear() {\n    this.list.length = 0;\n    this._size = 0;\n  }\n  contains(key: K) {\n    const tree = this.list[toHash(key, this.max)];\n    if (!tree) return false;\n    return tree.contains(key);\n  }\n  get(key: K) {\n    const tree = this.list[toHash(key, this.max)];\n    if (!tree) return undefined;\n    return tree.get(key);\n  }\n  set(key: K, val: V) {\n    const idx = toHash(key, this.max);\n    let tree = this.list[idx];\n    if (!tree) this.list[idx] = tree = new TreeMap(this.compare);\n    if (tree.set(key, val)) {\n      this._size++;\n      return true;\n    } else return false;\n  }\n  remove(key: K) {\n    const tree = this.list[toHash(key, this.max)];\n    if (!tree) return false;\n    if (tree.remove(key)) {\n      this._size--;\n      return true;\n    } else return false;\n  }\n}",lang:"ts"})))}));n["default"]=e=>{var n=r.useContext(a.context),t=n.demos;return r.useEffect((()=>{var n;null!==e&&void 0!==e&&null!==(n=e.location)&&void 0!==n&&n.hash&&a.AnchorLink.scrollToAnchor(decodeURIComponent(e.location.hash.slice(1)))}),[]),r.createElement(s,{demos:t})}}}]);