(self["webpackChunkblog"]=self["webpackChunkblog"]||[]).push([[32249],{27330:function(e,n,t){"use strict";t.r(n);var r=t(96832),i=t(22131),o=t(89730),l=r.memo((e=>{e.demos;return r.createElement(r.Fragment,null,r.createElement("div",{className:"markdown"},r.createElement("h1",{id:"472-\u8fde\u63a5\u8bcd"},r.createElement(i.AnchorLink,{to:"#472-\u8fde\u63a5\u8bcd","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"472. \u8fde\u63a5\u8bcd"),r.createElement("blockquote",null,r.createElement("p",null,"\u94fe\u63a5\uff1a",r.createElement(i.Link,{to:"https://leetcode-cn.com/problems/concatenated-words/"},"472. \u8fde\u63a5\u8bcd"),r.createElement("br",null),"\u96be\u5ea6\uff1a\u4e2d\u7b49",r.createElement("br",null),"\u6807\u7b7e\uff1a\u6df1\u5ea6\u4f18\u5148\u641c\u7d22\u3001\u5b57\u5178\u6811\u3001\u6570\u7ec4\u3001\u5b57\u7b26\u4e32\u3001\u52a8\u6001\u89c4\u5212",r.createElement("br",null),"\u7b80\u4ecb\uff1a\u7ed9\u4f60\u4e00\u4e2a \u4e0d\u542b\u91cd\u590d \u5355\u8bcd\u7684\u5b57\u7b26\u4e32\u6570\u7ec4 words \uff0c\u8bf7\u4f60\u627e\u51fa\u5e76\u8fd4\u56de words \u4e2d\u7684\u6240\u6709 \u8fde\u63a5\u8bcd \u3002")),r.createElement("h2",{id:"\u9898\u89e3-1---typescript"},r.createElement(i.AnchorLink,{to:"#\u9898\u89e3-1---typescript","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"\u9898\u89e3 1 - typescript"),r.createElement("ul",null,r.createElement("li",null,"\u7f16\u8f91\u65f6\u95f4\uff1a2021.12.28"),r.createElement("li",null,"\u6267\u884c\u7528\u65f6\uff1a4684ms"),r.createElement("li",null,"\u5185\u5b58\u6d88\u8017\uff1a72.9MB"),r.createElement("li",null,"\u7f16\u7a0b\u8bed\u8a00\uff1atypescript"),r.createElement("li",null,"\u89e3\u6cd5\u4ecb\u7ecd\uff1atrie\u3002")),r.createElement(o.Z,{code:"class TrieNode {\n  end = false;\n  children: TrieNode[] = [];\n  constructor(public val: string) {}\n}\nclass Trie {\n  root = new TrieNode('');\n  insert(word: string): void {\n    let node = this.root;\n    for (const ch of word) {\n      const idx = this.getIdx(ch);\n      if (!node.children[idx]) node.children[idx] = new TrieNode(ch);\n      node = node.children[idx];\n    }\n    node.end = true;\n  }\n  findNode(word: string): TrieNode | null {\n    let node = this.root;\n    for (const ch of word) {\n      const idx = this.getIdx(ch);\n      if (!node.children[idx]) return null;\n      node = node.children[idx];\n    }\n    return node;\n  }\n  search(word: string): boolean {\n    return !!this.findNode(word)?.end;\n  }\n  startsWith(prefix: string): boolean {\n    return !!this.findNode(prefix);\n  }\n  getIdx(ch: string) {\n    return ch.codePointAt(0)! - 'a'.codePointAt(0)!;\n  }\n}\n\nfunction check(trie: Trie, word: string, init = true): boolean {\n  if (!init && trie.search(word)) return true;\n  for (let i = 0, n = word.length; i < n; i++) {\n    if (trie.search(word.substring(0, i)) && check(trie, word.substring(i), false)) return true;\n  }\n  return false;\n}\nfunction findAllConcatenatedWordsInADict(words: string[]): string[] {\n  const trie = new Trie();\n  return words\n    .sort((w1, w2) => w1.length - w2.length)\n    .filter(word => {\n      if (!word) return false;\n      if (check(trie, word)) return true;\n      trie.insert(word);\n      return false;\n    });\n}",lang:"typescript"})))}));n["default"]=e=>{var n=r.useContext(i.context),t=n.demos;return r.useEffect((()=>{var n;null!==e&&void 0!==e&&null!==(n=e.location)&&void 0!==n&&n.hash&&i.AnchorLink.scrollToAnchor(decodeURIComponent(e.location.hash.slice(1)))}),[]),r.createElement(l,{demos:t})}}}]);